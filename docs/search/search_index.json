{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyield-brazilian-fixed-income-toolkit","title":"PYield: Brazilian Fixed Income Toolkit","text":"<p>PYield is a Python library designed for the analysis of Brazilian fixed income instruments. Leveraging the power of popular Python libraries like Polars, Pandas, Numpy and Requests, PYield simplifies the process of obtaining and processing data from key sources such as ANBIMA, BCB, IBGE and B3.</p> <p>Documentation: https://crdcj.github.io/PYield/</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Data Collection: Automated fetching of data from ANBIMA and B3.</li> <li>Data Processing: Efficient processing and normalization of fixed income data.</li> <li>Analysis Tools: Built-in functions for common analysis tasks in fixed income markets.</li> <li>Easy Integration: Seamless integration with pandas data analysis workflows.</li> <li>Type Hints: Full support for static type checking, enhancing development experience and code quality.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install PYield using pip: <pre><code>pip install pyield\n</code></pre></p>"},{"location":"#custom-types","title":"Custom Types","text":""},{"location":"#datescalar","title":"DateScalar","text":"<p><code>DateScalar</code> and <code>DateArray</code> are a type alias used across PYield to represent different types of date inputs. It includes several common date formats, allowing for flexible date handling within the library. </p> <p>The accepted formats in <code>DateScalar</code> are:</p> <ul> <li><code>datetime.date</code></li> <li><code>datetime.datetime</code></li> <li><code>str</code> (in the format <code>DD-MM-YYYY</code> as used in Brazil)</li> <li><code>np.datetime64</code></li> <li><code>pd.Timestamp</code></li> </ul>"},{"location":"#datearray","title":"DateArray","text":"<p>The accepted formats in <code>DateArray</code> are: - <code>pd.Series</code> - <code>pd.DatetimeIndex</code> - <code>np.ndarray</code> - <code>list[DateScalar]</code> - <code>tuple[DateScalar, ...]</code> - <code>pl.Series</code> (Polars Series)</p> <p>Referencing <code>DateScalar</code> and <code>DateArray</code> in function arguments simplifies the code by allowing any of these date formats to be used interchangeably.</p>"},{"location":"#important-note-on-date-formats","title":"Important Note on Date Formats","text":"<p>When using date strings in PYield functions, please ensure that the date format is day-first (e.g., \"31-05-2024\"). This format was chosen to be consistent with the Brazilian date convention.</p> <p>For production code, it is recommended to parse date strings with <code>pandas.to_datetime</code> using an explicit format to avoid ambiguity and ensure consistency. For example: <pre><code>import pandas as pd\n# Converting a date string to a pandas Timestamp with a specific format\ndate = pd.to_datetime(\"2024/31/05\", format=\"%Y/%d/%m\")\ndate = pd.to_datetime(\"05-31-2024\", format=\"%m-%d-%Y\")\n</code></pre></p>"},{"location":"#how-to-use-pyield","title":"How to use PYield","text":""},{"location":"#brazilian-treasury-bonds-tools","title":"Brazilian Treasury Bonds Tools","text":"<pre><code>&gt;&gt;&gt; from pyield import ntnb, ntnf, ltn\n\n# Get ANBIMA data for a given date\n&gt;&gt;&gt; ltn.data(\"23-08-2024\")\n    ReferenceDate BondType MaturityDate  IndicativeRate       Price\n0     2024-08-23      LTN   2024-10-01        0.104416  989.415342\n1     2024-08-23      LTN   2025-01-01        0.107171  964.293046\n2     2024-08-23      LTN   2025-04-01        0.110866  938.943013\n3     2024-08-23      LTN   2025-07-01        0.113032  913.849158\n4     2024-08-23      LTN   2025-10-01        0.114374  887.394285\n5     2024-08-23      LTN   2026-01-01        0.114654  863.026594\n6     2024-08-23      LTN   2026-04-01        0.114997  840.232741\n7     2024-08-23      LTN   2026-07-01        0.115265  818.020491\n8     2024-08-23      LTN   2026-10-01        0.115357  795.185488\n9     2024-08-23      LTN   2027-07-01        0.115335  733.981131\n10    2024-08-23      LTN   2028-01-01        0.115694  693.647778\n11    2024-08-23      LTN   2028-07-01        0.116417    655.6398\n12    2024-08-23      LTN   2030-01-01        0.117436  554.331151\n\n# Calculate the quotation of a NTN-B bond as per ANBIMA's rules\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n\n# Calculate the DI Spread of NTN-F and LTN bonds in a given date\n&gt;&gt;&gt; ntnf.di_spreads(\"23-08-2024\")\n    MaturityDate  DISpread\n0   2025-01-01     -5.38\n1   2027-01-01      4.39\n2   2029-01-01      7.37\n3   2031-01-01     12.58\n4   2033-01-01      7.67\n5   2035-01-01     12.76\n</code></pre>"},{"location":"#business-days-tools-brazilian-holidays-are-automatically-considered","title":"Business Days Tools (Brazilian holidays are automatically considered)","text":"<pre><code>&gt;&gt;&gt; from pyield import bday\n# Count the number of business days between two dates\n# Start date is included, end date is excluded\n&gt;&gt;&gt; bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Get the next business day after a given date (offset=1)\n&gt;&gt;&gt; bday.offset(dates=\"29-12-2023\", offset=1)\ndatetime.date(2024, 1, 2)\n\n# Get the next business day if it is not a business day (offset=0)\n&gt;&gt;&gt; bday.offset(dates=\"30-12-2023\", offset=0)\ndatetime.date(2024, 1, 2)\n\n# Since 29-12-2023 is a business day, it returns the same date (offset=0)\n&gt;&gt;&gt; bday.offset(dates=\"29-12-2023\", offset=0)\ndatetime.date(2023, 12, 29)\n\n# Generate a pandas series with the business days between two dates\n&gt;&gt;&gt; bday.generate(start='29-12-2023', end='03-01-2024')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\n</code></pre>"},{"location":"#futures-data","title":"Futures Data","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n\n# Fetch historical DI Futures data from B3\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", date='08-03-2024')\nTradeDate  TickerSymbol ExpirationDate BDaysToExp ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08       DI1J24     2024-04-01         15 ...   10.952      10.952      10.956         10.956\n2024-03-08       DI1K24     2024-05-02         37 ...   10.776      10.774      10.780         10.777\n2024-03-08       DI1M24     2024-06-03         58 ...   10.604      10.602      10.604         10.608\n       ...          ...            ...        ... ...      ...         ...         ...            ...\n2024-03-08       DI1F37     2037-01-02       3213 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.859\n2024-03-08       DI1F38     2038-01-04       3462 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.859\n2024-03-08       DI1F39     2039-01-03       3713 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.85\n\n# Fetch current DI Futures data from B3 (15 minutes delay)\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", date=\"21-03-2024\")  # when the date used is the current date and market is open\nLastUpdatee      TickerSymbol ExpirationDate BDaysToExp ... MaxRate LastAskRate LastBidRate LastRate\n2024-04-21 13:37:39       DI1K24     2024-05-02          7 ... 0.10660     0.10652     0.10660  0.10660\n2024-04-21 13:37:39       DI1M24     2024-06-03         28 ... 0.10518     0.10510     0.10516  0.10518\n2024-04-21 13:37:39       DI1N24     2024-07-01         48 ... 0.10480     0.10456     0.10462  0.10460\n                ...          ...            ...        ... ...     ...         ...         ...      ...\n2024-04-21 13:37:39       DI1F37     2037-01-02       3183 ...    &lt;NA&gt;        &lt;NA&gt;     0.11600     &lt;NA&gt;\n2024-04-21 13:37:39       DI1F38     2038-01-04       3432 ...    &lt;NA&gt;        &lt;NA&gt;     0.11600     &lt;NA&gt;\n2024-04-21 13:37:39       DI1F39     2039-01-03       3683 ...    &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;     &lt;NA&gt;\n</code></pre>"},{"location":"#indicators-data","title":"Indicators Data","text":"<pre><code>&gt;&gt;&gt; from pyield import bc\n\n# Fetch the SELIC target rates from the Central Bank of Brazil\n&gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\", \"30-01-2025\")  # No data on 26-01-2025 (sunday)\n        Date   Value\n0 2025-01-27  0.1215\n1 2025-01-28  0.1215\n2 2025-01-29  0.1215\n3 2025-01-30  0.1315\n\n# Fetch the SELIC target rate for a specific date\n&gt;&gt;&gt; bc.selic_over(\"27-01-2025\")\n        Date   Value\n0.1215  # 12.15%\n</code></pre>"},{"location":"#projections-data","title":"Projections Data","text":"<pre><code>&gt;&gt;&gt; from pyield import anbima\n# Fetch current month projection for IPCA from IBGE API\n&gt;&gt;&gt; ipca = anbima.ipca_projection()\n&gt;&gt;&gt; print(ipca)\nIndicatorProjection(\n    last_updated=Timestamp('2024-04-19 18:55:00'),    \n    reference_period='set/24',\n    projected_value=0.0035  # 0.35%\n)\n&gt;&gt;&gt; ipca.projected_value\n0.0035  # 0.35%\n</code></pre>"},{"location":"#interpolation-tools","title":"Interpolation Tools","text":"<p>Interpolate interest rates for specific business days using the Interpolator class. <pre><code>&gt;&gt;&gt; from pyield import Interpolator\n# Initialize the Interpolator with known business days and interest rates.\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n&gt;&gt;&gt; linear_interpolator = Interpolator(\"linear\", known_bdays, known_rates)\n&gt;&gt;&gt; linear_interpolator(45)  # Interpolate the interest rate for a given number of business days.\n0.0475\n\n# Use the flat forward method for interpolation.\n&gt;&gt;&gt; ff_interpolator = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; ff_interpolator(45)\n0.04833068080970859\n</code></pre></p>"},{"location":"anbima/","title":"Anbima Data","text":""},{"location":"anbima/#pyield.anbima.intraday_ettj","title":"<code>intraday_ettj()</code>","text":"<p>Retrieves and processes the intraday Brazilian yield curve data from ANBIMA.</p> <p>This function fetches the most recent intraday yield curve data published by ANBIMA, containing real rates (IPCA-indexed), nominal rates, and implied inflation at various vertices (time points). The curve is published at around 12:30 PM BRT.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the intraday ETTJ data.</p> DataFrame columns <ul> <li>date: Reference date of the yield curve</li> <li>vertex: Time point in business days</li> <li>nominal_rate: Zero-coupon nominal interest rate</li> <li>real_rate: Zero-coupon real interest rate (IPCA-indexed)</li> <li>implied_inflation: Implied inflation rate (break-even inflation)</li> </ul> Note <p>All rates are expressed in decimal format (e.g., 0.12 for 12%).</p> Source code in <code>pyield/anbima/ettj.py</code> <pre><code>def intraday_ettj() -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves and processes the intraday Brazilian yield curve data from ANBIMA.\n\n    This function fetches the most recent intraday yield curve data published by ANBIMA,\n    containing real rates (IPCA-indexed), nominal rates, and implied inflation\n    at various vertices (time points). The curve is published at around 12:30 PM BRT.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the intraday ETTJ data.\n\n    DataFrame columns:\n        - date: Reference date of the yield curve\n        - vertex: Time point in business days\n        - nominal_rate: Zero-coupon nominal interest rate\n        - real_rate: Zero-coupon real interest rate (IPCA-indexed)\n        - implied_inflation: Implied inflation rate (break-even inflation)\n\n    Note:\n        All rates are expressed in decimal format (e.g., 0.12 for 12%).\n    \"\"\"\n\n    request_payload = {\"Dt_Ref\": \"\", \"saida\": \"csv\"}\n    response = requests.post(INTRADAY_ETTJ_URL, data=request_payload)\n    texto = response.text\n\n    # --- Extra\u00e7\u00e3o da Tabela 1: PREFIXADOS ---\n    data_ref, tabela_pre, tabela_ipca = _extrair_data_e_tabelas(texto, texto)\n\n    df_pre = _ler_tabela_intradia(tabela_pre)\n    df_pre = df_pre.rename(columns={\"D0\": \"nominal_rate\"})\n\n    df_ipca = _ler_tabela_intradia(tabela_ipca)\n    df_ipca = df_ipca.rename(columns={\"D0\": \"real_rate\"})\n\n    df = pd.merge(df_pre, df_ipca, on=\"Vertices\", how=\"right\")\n    df = df.rename(columns={\"Vertices\": \"vertex\"})\n\n    # Divide float columns by 100 and round to 6 decimal places\n    df[\"real_rate\"] = (df[\"real_rate\"] / 100).round(ROUND_DIGITS)\n    df[\"nominal_rate\"] = (df[\"nominal_rate\"] / 100).round(ROUND_DIGITS)\n    df[\"implied_inflation\"] = (df[\"nominal_rate\"] + 1) / (df[\"real_rate\"] + 1) - 1\n    df[\"implied_inflation\"] = df[\"implied_inflation\"].round(ROUND_DIGITS)\n\n    df[\"date\"] = data_ref\n    df[\"date\"] = df[\"date\"].astype(\"date32[pyarrow]\")\n    column_order = [\"date\", \"vertex\", \"nominal_rate\", \"real_rate\", \"implied_inflation\"]\n    return df[column_order].copy()\n</code></pre>"},{"location":"anbima/#pyield.anbima.ipca_projection","title":"<code>ipca_projection()</code>","text":"<p>Retrieves the current IPCA projection from the ANBIMA website.</p> <p>This function makes an HTTP request to the ANBIMA website, extracts HTML tables containing economic indicators, and specifically processes the IPCA projection data.</p> Process <ol> <li>Accesses the ANBIMA indicators webpage</li> <li>Extracts the third table that contains the IPCA projection</li> <li>Locates the row labeled as \"IPCA1\"</li> <li>Extracts the projection value and converts it to decimal format</li> <li>Extracts and formats the reference month of the projection</li> <li>Extracts the date and time of the last update</li> </ol> <p>Returns:</p> Name Type Description <code>IndicatorProjection</code> <code>IndicatorProjection</code> <p>An object containing: - last_updated (pd.Timestamp): Date and time of the last data update - reference_period (str): Reference period of the projection as a string in   \"MMM/YY\" brazilian format (e.g., \"set/25\") - projected_value (float): Projected IPCA value as a decimal number</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If there are connection issues with the ANBIMA site</p> <code>ValueError</code> <p>If the expected data is not found in the page structure</p> Notes <ul> <li>The function requires internet connection to access the ANBIMA website</li> <li>The structure of the ANBIMA page may change, which could affect the function</li> </ul> Source code in <code>pyield/anbima/ipca.py</code> <pre><code>def ipca_projection() -&gt; IndicatorProjection:\n    \"\"\"\n    Retrieves the current IPCA projection from the ANBIMA website.\n\n    This function makes an HTTP request to the ANBIMA website, extracts HTML tables\n    containing economic indicators, and specifically processes the IPCA projection data.\n\n    Process:\n        1. Accesses the ANBIMA indicators webpage\n        2. Extracts the third table that contains the IPCA projection\n        3. Locates the row labeled as \"IPCA1\"\n        4. Extracts the projection value and converts it to decimal format\n        5. Extracts and formats the reference month of the projection\n        6. Extracts the date and time of the last update\n\n    Returns:\n        IndicatorProjection: An object containing:\n            - last_updated (pd.Timestamp): Date and time of the last data update\n            - reference_period (str): Reference period of the projection as a string in\n              \"MMM/YY\" brazilian format (e.g., \"set/25\")\n            - projected_value (float): Projected IPCA value as a decimal number\n\n    Raises:\n        requests.RequestException: If there are connection issues with the ANBIMA site\n        ValueError: If the expected data is not found in the page structure\n\n    Notes:\n        - The function requires internet connection to access the ANBIMA website\n        - The structure of the ANBIMA page may change, which could affect the function\n    \"\"\"\n    url = \"https://www.anbima.com.br/informacoes/indicadores/\"\n    r = requests.get(url)\n    r.encoding = \"latin1\"\n    dfs = pd.read_html(\n        io.StringIO(r.text),\n        flavor=\"html5lib\",\n        decimal=\",\",\n        thousands=\".\",\n        dtype_backend=\"numpy_nullable\",\n    )\n    # The IPCA projection is in the third table\n    df = dfs[2]\n\n    last_update_str = df.iat[0, 0].split(\"Atualiza\u00e7\u00e3o:\")[-1].strip()\n    last_update = pd.to_datetime(last_update_str, format=\"%d/%m/%Y - %H:%M h\")\n\n    ipca_row = df.loc[df[0] == \"IPCA1\"]\n    ipca_value = ipca_row.iloc[0, 2]\n    ipca_value = pd.to_numeric(ipca_value, errors=\"coerce\")\n    ipca_value = round(float(ipca_value) / 100, 4)\n\n    # Extract and format the reference month\n    ipca_date = ipca_row.iloc[0, 1]\n    ipca_date = str(ipca_date)\n    ipca_date = ipca_date.split(\"(\")[-1].split(\")\")[0]\n\n    return IndicatorProjection(\n        last_updated=last_update,\n        reference_period=ipca_date,\n        projected_value=ipca_value,\n    )\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ettj","title":"<code>last_ettj()</code>","text":"<p>Retrieves and processes the latest Brazilian yield curve data from ANBIMA.</p> <p>This function fetches the most recent yield curve data published by ANBIMA, containing real rates (IPCA-indexed), nominal rates, and implied inflation at various vertices (time points).</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the latest ETTJ data.</p> DataFrame columns <ul> <li>date: Reference date of the yield curve</li> <li>vertex: Time point in business days</li> <li>nominal_rate: Zero-coupon nominal interest rate</li> <li>real_rate: Zero-coupon real interest rate (IPCA-indexed)</li> <li>implied_inflation: Implied inflation rate (break-even inflation)</li> </ul> Note <p>All rates are expressed in decimal format (e.g., 0.12 for 12%).</p> Source code in <code>pyield/anbima/ettj.py</code> <pre><code>def last_ettj() -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves and processes the latest Brazilian yield curve data from ANBIMA.\n\n    This function fetches the most recent yield curve data published by ANBIMA,\n    containing real rates (IPCA-indexed), nominal rates, and implied inflation\n    at various vertices (time points).\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the latest ETTJ data.\n\n    DataFrame columns:\n        - date: Reference date of the yield curve\n        - vertex: Time point in business days\n        - nominal_rate: Zero-coupon nominal interest rate\n        - real_rate: Zero-coupon real interest rate (IPCA-indexed)\n        - implied_inflation: Implied inflation rate (break-even inflation)\n\n    Note:\n        All rates are expressed in decimal format (e.g., 0.12 for 12%).\n    \"\"\"\n    text = _get_last_content_text()\n    reference_date = _get_reference_date(text)\n    text = _filter_ettf_text(text)\n    df = _convert_text_to_df(text, reference_date)\n    return _process_df(df)\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ima","title":"<code>last_ima(ima_type=None)</code>","text":"<p>Fetch and process the last IMA market data available from ANBIMA.</p> <p>This function processes the data into a structured DataFrame. It handles conversion of date formats, renames columns to English, and converts certain numeric columns to integer types. In the event of an error during data fetching or processing, an empty DataFrame is returned.</p> <p>Parameters:</p> Name Type Description Default <code>ima_type</code> <code>str</code> <p>Type of IMA index to filter the data. If None, all IMA indexes are returned. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the IMA data.</p> DataFrame columns <ul> <li>Date: reference date of the data.</li> <li>IMAType: type of IMA index.</li> <li>BondType: type of bond.</li> <li>Maturity: bond maturity date.</li> <li>SelicCode: bond code in the SELIC system.</li> <li>ISIN: international Securities Identification Number.</li> <li>BDToMat: business days to maturity.</li> <li>Duration: duration of the bond in business years (252 days/year).</li> <li>IndicativeRate: indicative rate.</li> <li>Price: bond price.</li> <li>InterestPrice: interest price.</li> <li>DV01: DV01 in R$.</li> <li>PMR: average repurchase term.</li> <li>Weight: weight of the bond in the index.</li> <li>Convexity: convexity of the bond.</li> <li>TheoreticalQuantity: theoretical quantity.</li> <li>NumberOfOperations: number of operations.</li> <li>NegotiatedQuantity: negotiated quantity.</li> <li>NegotiatedValue: negotiated value.</li> <li>MarketQuantity: market quantity.</li> <li>MarketDV01: market DV01 in R$.</li> <li>MarketValue: market value in R$.</li> </ul> <p>Raises:</p> Type Description <code>Exception</code> <p>Logs error and returns an empty DataFrame if any error occurs during fetching or processing.</p> Source code in <code>pyield/anbima/ima.py</code> <pre><code>def last_ima(ima_type: ima_types | None = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch and process the last IMA market data available from ANBIMA.\n\n    This function processes the data into a structured DataFrame.\n    It handles conversion of date formats, renames columns to English, and converts\n    certain numeric columns to integer types. In the event of an error during data\n    fetching or processing, an empty DataFrame is returned.\n\n    Args:\n        ima_type (str, optional): Type of IMA index to filter the data. If None, all\n            IMA indexes are returned. Defaults to None.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the IMA data.\n\n    DataFrame columns:\n        - Date: reference date of the data.\n        - IMAType: type of IMA index.\n        - BondType: type of bond.\n        - Maturity: bond maturity date.\n        - SelicCode: bond code in the SELIC system.\n        - ISIN: international Securities Identification Number.\n        - BDToMat: business days to maturity.\n        - Duration: duration of the bond in business years (252 days/year).\n        - IndicativeRate: indicative rate.\n        - Price: bond price.\n        - InterestPrice: interest price.\n        - DV01: DV01 in R$.\n        - PMR: average repurchase term.\n        - Weight: weight of the bond in the index.\n        - Convexity: convexity of the bond.\n        - TheoreticalQuantity: theoretical quantity.\n        - NumberOfOperations: number of operations.\n        - NegotiatedQuantity: negotiated quantity.\n        - NegotiatedValue: negotiated value.\n        - MarketQuantity: market quantity.\n        - MarketDV01: market DV01 in R$.\n        - MarketValue: market value in R$.\n\n    Raises:\n        Exception: Logs error and returns an empty DataFrame if any error occurs during\n            fetching or processing.\n    \"\"\"\n    try:\n        ima_text = _fetch_last_ima_text()\n        df = _fetch_last_ima(ima_text)\n        df = _process_last_ima(df)\n        df = _reorder_last_ima(df)\n        if ima_type is not None:\n            df = df.query(\"IMAType == @ima_type\").reset_index(drop=True)\n        df = df.sort_values([\"IMAType\", \"BondType\", \"Maturity\"]).reset_index(drop=True)\n        return df\n    except Exception as e:\n        logger.exception(f\"Error fetching or processing the last IMA data: {e}\")\n        return pd.DataFrame()\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_data","title":"<code>tpf_data(date, bond_type=None, fetch_from_source=False)</code>","text":"<p>Recupera os dados do mercado secund\u00e1rio de TPF da ANBIMA.</p> <p>Esta fun\u00e7\u00e3o busca taxas indicativas e outros dados de t\u00edtulos p\u00fablicos brasileiros. A obten\u00e7\u00e3o dos dados segue uma hierarquia de fontes para otimizar o desempenho e o acesso.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>A data de refer\u00eancia para os dados (ex: '2024-06-14').</p> required <code>bond_type</code> <code>str</code> <p>Filtra os resultados por um tipo de t\u00edtulo espec\u00edfico (ex: 'LTN', 'NTN-B'). Por padr\u00e3o, retorna todos os tipos.</p> <code>None</code> <code>fetch_from_source</code> <code>bool</code> <p>Se True, for\u00e7a a fun\u00e7\u00e3o a ignorar o cache e buscar os dados diretamente da fonte (ANBIMA). Padr\u00e3o \u00e9 False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Um DataFrame contendo os dados solicitados. Retorna um</p> <code>DataFrame</code> <p>DataFrame vazio se n\u00e3o houver dados para a data especificada (ex:</p> <code>DataFrame</code> <p>finais de semana, feriados ou datas futuras).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; anbima.tpf_data(date=\"22-08-2025\")\n   ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate    DIRate\n0     2025-08-22      LFT     210100  ...    0.0001       0.000165   0.14906\n1     2025-08-22      LFT     210100  ... -0.000156      -0.000116   0.14843\n2     2025-08-22      LFT     210100  ... -0.000143      -0.000107    0.1436\n3     2025-08-22      LFT     210100  ...  0.000292       0.000302  0.138189\n...\n</code></pre> Data columns <ul> <li>BondType: Tipo do t\u00edtulo p\u00fablico (e.g., 'LTN', 'NTN-B').</li> <li>ReferenceDate: Data de refer\u00eancia dos dados.</li> <li>SelicCode: C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate: Data base ou de emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate: Data de vencimento do t\u00edtulo.</li> <li>BDToMat: N\u00famero de dias \u00fateis entre a data de refer\u00eancia e o vencimento.</li> <li>Duration: Macaulay Duration do t\u00edtulo em anos.</li> <li>DV01: Varia\u00e7\u00e3o financeira no pre\u00e7o do t\u00edtulo (em BRL) para uma     mudan\u00e7a de 1 basis point (0,01%) na taxa de juros.</li> <li>DV01USD: O mesmo que DV01, mas convertido para USD pela PTAX do dia.</li> <li>Price: Pre\u00e7o Unit\u00e1rio (PU) do t\u00edtulo na data de refer\u00eancia.</li> <li>BidRate: Taxa de compra em formato decimal (e.g., 0.10 para 10%).</li> <li>AskRate: Taxa de venda em formato decimal.</li> <li>IndicativeRate: Taxa indicativa em formato decimal.</li> <li>DIRate: Taxa DI interpolada (flatforward) no vencimento do t\u00edtulo.</li> <li>StdDev: Desvio padr\u00e3o da taxa indicativa.</li> <li>LowerBoundRateD0: Limite inferior do intervalo indicativo para D+0.</li> <li>UpperBoundRateD0: Limite superior do intervalo indicativo para D+0.</li> <li>LowerBoundRateD1: Limite inferior do intervalo indicativo para D+1.</li> <li>UpperBoundRateD1: Limite superior do intervalo indicativo para D+1.</li> <li>Criteria: Crit\u00e9rio utilizado pela ANBIMA para o c\u00e1lculo.</li> </ul> Notes <p>A fonte dos dados segue a seguinte hierarquia:</p> <ol> <li>Cache Local (Padr\u00e3o): Fornece acesso r\u00e1pido a dados hist\u00f3ricos     desde 01/01/2020. \u00c9 utilizado por padr\u00e3o (<code>fetch_from_source=False</code>).</li> <li>Site P\u00fablico da ANBIMA: Acessado quando <code>fetch_from_source=True</code>,     disponibiliza os dados dos \u00faltimos 5 dias \u00fateis.</li> <li>Rede RTM da ANBIMA: Acessada quando <code>fetch_from_source=True</code> para     datas com mais de 5 dias \u00fateis. O acesso ao hist\u00f3rico completo     requer uma conex\u00e3o \u00e0 rede RTM. Sem ela, a consulta para datas     antigas retornar\u00e1 um DataFrame vazio.</li> </ol> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_data(\n    date: DateScalar,\n    bond_type: str | None = None,\n    fetch_from_source: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Recupera os dados do mercado secund\u00e1rio de TPF da ANBIMA.\n\n    Esta fun\u00e7\u00e3o busca taxas indicativas e outros dados de t\u00edtulos p\u00fablicos\n    brasileiros. A obten\u00e7\u00e3o dos dados segue uma hierarquia de fontes para\n    otimizar o desempenho e o acesso.\n\n    Args:\n        date (DateScalar): A data de refer\u00eancia para os dados (ex: '2024-06-14').\n        bond_type (str, optional): Filtra os resultados por um tipo de t\u00edtulo\n            espec\u00edfico (ex: 'LTN', 'NTN-B'). Por padr\u00e3o, retorna todos os tipos.\n        fetch_from_source (bool, optional): Se True, for\u00e7a a fun\u00e7\u00e3o a ignorar o\n            cache e buscar os dados diretamente da fonte (ANBIMA).\n            Padr\u00e3o \u00e9 False.\n\n    Returns:\n        pd.DataFrame: Um DataFrame contendo os dados solicitados. Retorna um\n        DataFrame vazio se n\u00e3o houver dados para a data especificada (ex:\n        finais de semana, feriados ou datas futuras).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; anbima.tpf_data(date=\"22-08-2025\")\n           ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate    DIRate\n        0     2025-08-22      LFT     210100  ...    0.0001       0.000165   0.14906\n        1     2025-08-22      LFT     210100  ... -0.000156      -0.000116   0.14843\n        2     2025-08-22      LFT     210100  ... -0.000143      -0.000107    0.1436\n        3     2025-08-22      LFT     210100  ...  0.000292       0.000302  0.138189\n        ...\n\n\n    Data columns:\n        - BondType: Tipo do t\u00edtulo p\u00fablico (e.g., 'LTN', 'NTN-B').\n        - ReferenceDate: Data de refer\u00eancia dos dados.\n        - SelicCode: C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate: Data base ou de emiss\u00e3o do t\u00edtulo.\n        - MaturityDate: Data de vencimento do t\u00edtulo.\n        - BDToMat: N\u00famero de dias \u00fateis entre a data de refer\u00eancia e o vencimento.\n        - Duration: Macaulay Duration do t\u00edtulo em anos.\n        - DV01: Varia\u00e7\u00e3o financeira no pre\u00e7o do t\u00edtulo (em BRL) para uma\n            mudan\u00e7a de 1 basis point (0,01%) na taxa de juros.\n        - DV01USD: O mesmo que DV01, mas convertido para USD pela PTAX do dia.\n        - Price: Pre\u00e7o Unit\u00e1rio (PU) do t\u00edtulo na data de refer\u00eancia.\n        - BidRate: Taxa de compra em formato decimal (e.g., 0.10 para 10%).\n        - AskRate: Taxa de venda em formato decimal.\n        - IndicativeRate: Taxa indicativa em formato decimal.\n        - DIRate: Taxa DI interpolada (flatforward) no vencimento do t\u00edtulo.\n        - StdDev: Desvio padr\u00e3o da taxa indicativa.\n        - LowerBoundRateD0: Limite inferior do intervalo indicativo para D+0.\n        - UpperBoundRateD0: Limite superior do intervalo indicativo para D+0.\n        - LowerBoundRateD1: Limite inferior do intervalo indicativo para D+1.\n        - UpperBoundRateD1: Limite superior do intervalo indicativo para D+1.\n        - Criteria: Crit\u00e9rio utilizado pela ANBIMA para o c\u00e1lculo.\n\n    Notes:\n        A fonte dos dados segue a seguinte hierarquia:\n\n        1.  **Cache Local (Padr\u00e3o):** Fornece acesso r\u00e1pido a dados hist\u00f3ricos\n            desde 01/01/2020. \u00c9 utilizado por padr\u00e3o (`fetch_from_source=False`).\n        2.  **Site P\u00fablico da ANBIMA:** Acessado quando `fetch_from_source=True`,\n            disponibiliza os dados dos \u00faltimos 5 dias \u00fateis.\n        3.  **Rede RTM da ANBIMA:** Acessada quando `fetch_from_source=True` para\n            datas com mais de 5 dias \u00fateis. O acesso ao hist\u00f3rico completo\n            requer uma conex\u00e3o \u00e0 rede RTM. Sem ela, a consulta para datas\n            antigas retornar\u00e1 um DataFrame vazio.\n    \"\"\"\n    date = convert_input_dates(date)\n\n    date_log = date.strftime(\"%d/%m/%Y\")\n    today = dt.datetime.now(BZ_TIMEZONE).date()\n    if date &gt; today:\n        logger.info(\n            f\"Cannot fetch data for a future date ({date_log}). \"\n            \"Returning empty DataFrame.\"\n        )\n        return pd.DataFrame()\n\n    if fetch_from_source:\n        # Try to fetch the data from the Anbima website\n        df = _fetch_tpf_data(date)\n    else:\n        df = (\n            get_cached_dataset(\"tpf\")\n            .query(\"ReferenceDate == @date\")\n            .reset_index(drop=True)\n        )\n\n    if df.empty:\n        # If the data is still empty, return an empty DataFrame\n        return pd.DataFrame()\n\n    if bond_type:\n        norm_bond_type = _bond_type_mapping(bond_type)  # noqa\n        df = df.query(\"BondType == @norm_bond_type\").reset_index(drop=True)\n\n    return df.sort_values([\"BondType\", \"MaturityDate\"]).reset_index(drop=True)\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_fixed_rate_maturities","title":"<code>tpf_fixed_rate_maturities(date)</code>","text":"<p>Retrieve existing maturity dates for fixed-rate public bonds (LTN and NTN-F).</p> <p>This function fetches existing maturity dates for 'LTN' and 'NTN-F' bond types for a given date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for maturity dates.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing unique maturity dates for 'LTN' and 'NTN-F' bonds, sorted in ascending order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; anbima.tpf_fixed_rate_maturities(date=\"22-08-2025\")\n0     2025-10-01\n1     2026-01-01\n2     2026-04-01\n3     2026-07-01\n        ...\n14    2031-01-01\n15    2032-01-01\n16    2033-01-01\n17    2035-01-01\nName: MaturityDate, dtype: date32[day][pyarrow]\n</code></pre> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_fixed_rate_maturities(date: DateScalar) -&gt; pd.Series:\n    \"\"\"Retrieve existing maturity dates for fixed-rate public bonds (LTN and NTN-F).\n\n    This function fetches existing maturity dates for 'LTN' and\n    'NTN-F' bond types for a given date.\n\n    Args:\n        date (DateScalar): The reference date for maturity dates.\n\n    Returns:\n        pd.Series: A Series containing unique maturity dates for 'LTN' and\n            'NTN-F' bonds, sorted in ascending order.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; anbima.tpf_fixed_rate_maturities(date=\"22-08-2025\")\n        0     2025-10-01\n        1     2026-01-01\n        2     2026-04-01\n        3     2026-07-01\n                ...\n        14    2031-01-01\n        15    2032-01-01\n        16    2033-01-01\n        17    2035-01-01\n        Name: MaturityDate, dtype: date32[day][pyarrow]\n    \"\"\"\n    maturity_dates = (\n        tpf_data(date)\n        .query(\"BondType in ['LTN', 'NTN-F']\")[\"MaturityDate\"]\n        .drop_duplicates()\n        .sort_values(ignore_index=True)\n        .reset_index(drop=True)\n    )\n    return maturity_dates\n</code></pre>"},{"location":"bc/","title":"BC Data","text":""},{"location":"bc/#pyield.bc.auctions","title":"<code>auctions(start=None, end=None, auction_type=None)</code>","text":"<p>Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.</p> <p>Consultas de Per\u00edodo: - Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>.   Exemplo: <code>auctions(start='2024-10-20', end='2024-10-27')</code> - Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir   da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel.   Exemplo: <code>auctions(start='2024-10-20')</code> - Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o desde a   data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>.   Exemplo: <code>auctions(end='2024-10-27')</code></p> <p>S\u00e9rie Hist\u00f3rica Completa: - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o   \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>.   Exemplo: <code>auctions()</code></p> <p>Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas, filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado. O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros <code>start</code> e <code>end</code> segue o padr\u00e3o da API do Banco Central: - Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim. - Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>. - Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</p> <p>Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\"). Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado. Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateScalar, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateScalar, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>auction_type</code> <code>(Literal['sell', 'buy'], opcional)</code> <p>O tipo de leil\u00e3o para filtrar diretamente na API. Padr\u00e3o \u00e9 <code>None</code> (retorna todos os tipos de leil\u00e3o).</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo especificados. Em caso de erro ao buscar os dados, um DataFrame vazio \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; df = bc.auctions(start=\"19-08-2025\", end=\"19-08-2025\")\n&gt;&gt;&gt; df\n        Date Settlement AuctionType  ...     ValueFR  ValueSR       Value\n0 2025-08-19 2025-08-20       Venda  ...  2572400000        0  2572400000\n1 2025-08-19 2025-08-20       Venda  ... 12804476147 17123853 12821600000\n2 2025-08-19 2025-08-20       Venda  ...  1289936461  3263539  1293200000\n3 2025-08-19 2025-08-20       Venda  ...  2071654327  2245673  2073900000\n4 2025-08-19 2025-08-20       Venda  ...  2010700000        0  2010700000\n[5 rows x 30 columns]\n</code></pre> Notes <p>FR = First Round (Primeira Rodada) SR = Second Round (Segunda Rodada)</p> DataFrame Columns <ul> <li>Date: Data do leil\u00e3o.</li> <li>Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.</li> <li>AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").</li> <li>Ordinance: Edital normativo associado ao leil\u00e3o.</li> <li>Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").</li> <li>BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").</li> <li>SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.</li> <li>Maturity: Data de vencimento do t\u00edtulo.</li> <li>BDToMat: Dias \u00fateis entre a liquida\u00e7\u00e3o da 1R e a data de vencimento do t\u00edtulo.</li> <li>Duration: Duration (Dura\u00e7\u00e3o) calculada com base na data de     liquida\u00e7\u00e3o da 1R e na data de vencimento do t\u00edtulo.</li> <li>AvgMaturity: Maturidade m\u00e9dia do t\u00edtulo (em anos).</li> <li>AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.</li> <li>CutPrice: Pre\u00e7o de corte.</li> <li>AvgRate: Taxa de juros m\u00e9dia.</li> <li>CutRate: Taxa de corte.</li> <li>DV01FR: DV01 da Primeira Rodada (FR) em R$.</li> <li>DV01SR: DV01 da Segunda Rodada (SR) em R$.</li> <li>DV01: Valor do DV01 total do leil\u00e3o em R$.</li> <li>DV01FRUSD: DV01 da Primeira Rodada (FR) em d\u00f3lares (USD).</li> <li>DV01SRUSD: DV01 da Segunda Rodada (SR) em d\u00f3lares (USD).</li> <li>DV01USD: DV01 total do leil\u00e3o em d\u00f3lares (USD).</li> <li>OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).</li> <li>OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).</li> <li>OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).</li> <li>AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).</li> <li>AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).</li> <li>AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).</li> <li>ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.</li> <li>ValueSR: Valor da segunda rodada (SR) em R$.</li> <li>Value: Valor total do leil\u00e3o em R$ (FR + SR).</li> </ul> Source code in <code>pyield/bc/auction.py</code> <pre><code>def auctions(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n    auction_type: Literal[\"sell\", \"buy\"] | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.\n\n    **Consultas de Per\u00edodo:**\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n      Exemplo: `auctions(start='2024-10-20', end='2024-10-27')`\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir\n      da data de `start` **at\u00e9 a data mais recente dispon\u00edvel**.\n      Exemplo: `auctions(start='2024-10-20')`\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o **desde a\n      data mais antiga dispon\u00edvel at\u00e9 a data de `end`**.\n      Exemplo: `auctions(end='2024-10-27')`\n\n    **S\u00e9rie Hist\u00f3rica Completa:**\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o\n      \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n      Exemplo: `auctions()`\n\n    Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas,\n    filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado.\n    O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros `start` e `end` segue o padr\u00e3o\n    da API do Banco Central:\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\").\n    Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado.\n    Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.\n\n    Args:\n        start (DateScalar, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateScalar, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        auction_type (Literal[\"sell\", \"buy\"], opcional): O tipo de leil\u00e3o para filtrar\n            diretamente na API. Padr\u00e3o \u00e9 `None` (retorna todos os tipos de leil\u00e3o).\n\n    Returns:\n        pd.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo\n            especificados. Em caso de erro ao buscar os dados, um DataFrame vazio\n            \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; df = bc.auctions(start=\"19-08-2025\", end=\"19-08-2025\")\n        &gt;&gt;&gt; df\n                Date Settlement AuctionType  ...     ValueFR  ValueSR       Value\n        0 2025-08-19 2025-08-20       Venda  ...  2572400000        0  2572400000\n        1 2025-08-19 2025-08-20       Venda  ... 12804476147 17123853 12821600000\n        2 2025-08-19 2025-08-20       Venda  ...  1289936461  3263539  1293200000\n        3 2025-08-19 2025-08-20       Venda  ...  2071654327  2245673  2073900000\n        4 2025-08-19 2025-08-20       Venda  ...  2010700000        0  2010700000\n        [5 rows x 30 columns]\n\n    Notes:\n        FR = First Round (Primeira Rodada)\n        SR = Second Round (Segunda Rodada)\n\n    DataFrame Columns:\n        - Date: Data do leil\u00e3o.\n        - Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.\n        - AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").\n        - Ordinance: Edital normativo associado ao leil\u00e3o.\n        - Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").\n        - BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").\n        - SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.\n        - Maturity: Data de vencimento do t\u00edtulo.\n        - BDToMat: Dias \u00fateis entre a liquida\u00e7\u00e3o da 1R e a data de vencimento do t\u00edtulo.\n        - Duration: Duration (Dura\u00e7\u00e3o) calculada com base na data de\n            liquida\u00e7\u00e3o da 1R e na data de vencimento do t\u00edtulo.\n        - AvgMaturity: Maturidade m\u00e9dia do t\u00edtulo (em anos).\n        - AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.\n        - CutPrice: Pre\u00e7o de corte.\n        - AvgRate: Taxa de juros m\u00e9dia.\n        - CutRate: Taxa de corte.\n        - DV01FR: DV01 da Primeira Rodada (FR) em R$.\n        - DV01SR: DV01 da Segunda Rodada (SR) em R$.\n        - DV01: Valor do DV01 total do leil\u00e3o em R$.\n        - DV01FRUSD: DV01 da Primeira Rodada (FR) em d\u00f3lares (USD).\n        - DV01SRUSD: DV01 da Segunda Rodada (SR) em d\u00f3lares (USD).\n        - DV01USD: DV01 total do leil\u00e3o em d\u00f3lares (USD).\n        - OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).\n        - OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).\n        - OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).\n        - AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).\n        - AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).\n        - AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).\n        - ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.\n        - ValueSR: Valor da segunda rodada (SR) em R$.\n        - Value: Valor total do leil\u00e3o em R$ (FR + SR).\n    \"\"\"\n    try:\n        url = _build_url(start=start, end=end, auction_type=auction_type)\n        api_csv_text = _get_api_csv(url)\n        df = _parse_csv(api_csv_text)\n        if df.is_empty():\n            logger.warning(\"No auction data found after parsing the API response.\")\n            return pd.DataFrame()\n        df = _format_df(df)\n        df = _process_df(df)\n        df = _adjust_values_without_auction(df)\n        df = _add_duration(df)\n        df = _add_dv01(df)\n        df = _add_usd_dv01(df)\n        df = _add_avg_maturity(df)\n        df = _sort_and_reorder_columns(df)\n        return df.to_pandas(use_pyarrow_extension_array=True)\n    except Exception as e:\n        logger.exception(f\"Error fetching auction data from BC API: {e}\")\n        return pd.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.di_over","title":"<code>di_over(date, annualized=True)</code>","text":"<p>Fetches the DI Over rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the DI Over rate for.</p> required <code>annualized</code> <code>bool</code> <p>If True, returns the annualized rate (252 trading days per year), otherwise returns the daily rate.</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>The DI Over rate as a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n0.104\n</code></pre> <pre><code>&gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n0.00045513\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def di_over(date: DateScalar, annualized: bool = True) -&gt; float:\n    \"\"\"\n    Fetches the DI Over rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the DI Over rate for.\n        annualized: If True, returns the annualized rate (252 trading\n            days per year), otherwise returns the daily rate.\n\n    Returns:\n        The DI Over rate as a float.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n        0.104\n\n        &gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n        0.00045513\n    \"\"\"\n    df = di_over_series(date, date, annualized)\n    if df.empty:\n        return float(\"nan\")\n    return df.at[0, \"Value\"]\n</code></pre>"},{"location":"bc/#pyield.bc.di_over_series","title":"<code>di_over_series(start, end=None, annualized=True)</code>","text":"<p>Fetches the DI (Interbank Deposit) rate from the Brazilian Central Bank.</p> <p>The DI rate represents the average interest rate of interbank loans.</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024 https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> required <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <code>annualized</code> <code>bool</code> <p>If True, returns the annualized rate (252 trading days per year), otherwise returns the daily rate.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the DI rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.di_over_series(\"29-01-2025\")\n        Date   Value\n0  2025-01-29  0.1215\n1  2025-01-30  0.1315\n2  2025-01-31  0.1315\n3  2025-02-03  0.1315\n...\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def di_over_series(\n    start: DateScalar,\n    end: DateScalar | None = None,\n    annualized: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches the DI (Interbank Deposit) rate from the Brazilian Central Bank.\n\n    The DI rate represents the average interest rate of interbank loans.\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n        annualized: If True, returns the annualized rate (252 trading\n            days per year), otherwise returns the daily rate.\n\n    Returns:\n        DataFrame containing Date and Value columns with the DI rate,\n        or empty DataFrame if data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.di_over_series(\"29-01-2025\")\n                Date   Value\n        0  2025-01-29  0.1215\n        1  2025-01-30  0.1315\n        2  2025-01-31  0.1315\n        3  2025-02-03  0.1315\n        ...\n\n    \"\"\"\n    df = _fetch_data_from_url(BCSerie.DI_OVER, start, end)\n    if annualized:\n        df = df.with_columns(\n            (((pl.col(\"Value\") + 1).pow(252)) - 1)\n            .round(DECIMAL_PLACES_ANNUALIZED)\n            .alias(\"Value\")\n        )\n\n    else:\n        df = df.with_columns(pl.col(\"Value\").round(DECIMAL_PLACES_DAILY))\n\n    return df.to_pandas(use_pyarrow_extension_array=True)\n</code></pre>"},{"location":"bc/#pyield.bc.ptax","title":"<code>ptax(date)</code>","text":"<p>Busca a cota\u00e7\u00e3o PTAX m\u00e9dia de fechamento para uma data espec\u00edfica.</p> <p>Esta fun\u00e7\u00e3o \u00e9 um wrapper para a fun\u00e7\u00e3o <code>ptax_series</code>, otimizada para buscar o valor de um \u00fanico dia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>A data para a qual a cota\u00e7\u00e3o PTAX \u00e9 desejada. Pode ser uma string no formato \"dd-mm-aaaa\" ou um objeto date/datetime.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>O valor da PTAX (taxa m\u00e9dia) para a data especificada.    Retorna <code>np.nan</code> se n\u00e3o houver cota\u00e7\u00e3o para a data    (ex: feriado, fim de semana ou data futura).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Busca a PTAX para um dia \u00fatil\n&gt;&gt;&gt; bc.ptax(\"22-08-2025\")\n5.4389\n</code></pre> <pre><code>&gt;&gt;&gt; # Busca a PTAX para um fim de semana (sem dados)\n&gt;&gt;&gt; ptax_rate_weekend = bc.ptax(\"23-08-2025\")\n&gt;&gt;&gt; pd.isna(ptax_rate_weekend)\nTrue\n</code></pre> Source code in <code>pyield/bc/ptax_api.py</code> <pre><code>def ptax(date: DateScalar) -&gt; float:\n    \"\"\"Busca a cota\u00e7\u00e3o PTAX m\u00e9dia de fechamento para uma data espec\u00edfica.\n\n    Esta fun\u00e7\u00e3o \u00e9 um wrapper para a fun\u00e7\u00e3o `ptax_series`, otimizada para\n    buscar o valor de um \u00fanico dia.\n\n    Args:\n        date (DateScalar): A data para a qual a cota\u00e7\u00e3o PTAX \u00e9 desejada.\n            Pode ser uma string no formato \"dd-mm-aaaa\" ou um objeto date/datetime.\n\n    Returns:\n        float: O valor da PTAX (taxa m\u00e9dia) para a data especificada.\n               Retorna `np.nan` se n\u00e3o houver cota\u00e7\u00e3o para a data\n               (ex: feriado, fim de semana ou data futura).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Busca a PTAX para um dia \u00fatil\n        &gt;&gt;&gt; bc.ptax(\"22-08-2025\")\n        5.4389\n\n        &gt;&gt;&gt; # Busca a PTAX para um fim de semana (sem dados)\n        &gt;&gt;&gt; ptax_rate_weekend = bc.ptax(\"23-08-2025\")\n        &gt;&gt;&gt; pd.isna(ptax_rate_weekend)\n        True\n    \"\"\"\n    # Reutiliza a fun\u00e7\u00e3o ptax_series para buscar os dados para o dia espec\u00edfico.\n    # Definir start e end com a mesma data busca a cota\u00e7\u00e3o para aquele dia.\n    df_ptax = ptax_series(start=date, end=date)\n\n    # Se o DataFrame estiver vazio, significa que n\u00e3o h\u00e1 cota\u00e7\u00e3o para a data.\n    # Isso ocorre em fins de semana, feriados ou datas futuras.\n    if df_ptax.empty:\n        logger.warning(f\"No PTAX data found for date: {date}\")\n        return float(\"nan\")\n\n    # A API retorna uma \u00fanica linha para a cota\u00e7\u00e3o de fechamento de um dia.\n    # A coluna \"MidRate\" representa a PTAX de fechamento.\n    return df_ptax[\"MidRate\"].iloc[0]\n</code></pre>"},{"location":"bc/#pyield.bc.ptax_series","title":"<code>ptax_series(start=None, end=None)</code>","text":"<p>Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio) - Fonte: Banco Central do Brasil (BCB) - Frequ\u00eancia: Di\u00e1ria - Unidade: R$</p> <p>Documenta\u00e7\u00e3o da API do BCB:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n</code></pre> <p>Exemplo de chamada \u00e0 API:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n</code></pre> <p>Consultas de Per\u00edodo:</p> <ul> <li> <p>Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>. Exemplo:</p> <pre><code>`ptax_series(start='20-10-2024', end='27-10-2024')`\n</code></pre> </li> <li> <p>Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados a partir da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Exemplo:</p> <pre><code>`ptax_series(start='20-10-2024')`\n</code></pre> </li> <li> <p>Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Exemplo:</p> <p><code>ptax_series(end='27-10-2024')</code></p> </li> </ul> <p>S\u00e9rie Hist\u00f3rica Completa:</p> <ul> <li>Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984 at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>. Exemplo:<pre><code>`ptax_series()`\n</code></pre> </li> </ul> <p>Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:</p> <ul> <li>Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim.</li> <li>Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>.</li> <li>Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateScalar, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateScalar, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.</p> <code>DataFrame</code> <p>Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio</p> <code>DataFrame</code> <p>ser\u00e1 retornado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; df = yd.bc.ptax_series(start=\"20-04-2025\", end=\"25-04-2025\")\n&gt;&gt;&gt; df\n         Date                    DateTime  BuyRate  SellRate  MidRate\n0  2025-04-22  2025-04-22 13:09:35.629000    5.749    5.7496   5.7493\n1  2025-04-23  2025-04-23 13:06:30.443000   5.6874     5.688   5.6877\n2  2025-04-24  2025-04-24 13:04:29.639000   5.6732    5.6738   5.6735\n3  2025-04-25  2025-04-25 13:09:26.592000    5.684    5.6846   5.6843\n</code></pre> Notes <p>Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990 e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992, essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de 2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de 1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta; o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos boletins do dia.</p> <ul> <li>Primeira data dispon\u00edvel: 28.11.1984</li> <li>\u00daltima data dispon\u00edvel: data atual</li> </ul> <p>O DataFrame possui as seguintes colunas:</p> <ul> <li>Date: Data da cota\u00e7\u00e3o.</li> <li>DateTime: Data e hora da cota\u00e7\u00e3o.</li> <li>BuyRate: Taxa de compra.</li> <li>SellRate: Taxa de venda.</li> <li>MidRate: Taxa m\u00e9dia entre a taxa de compra e venda.</li> </ul> Source code in <code>pyield/bc/ptax_api.py</code> <pre><code>def ptax_series(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio)\n    - Fonte: Banco Central do Brasil (BCB)\n    - Frequ\u00eancia: Di\u00e1ria\n    - Unidade: R$\n\n    Documenta\u00e7\u00e3o da API do BCB:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n\n    Exemplo de chamada \u00e0 API:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n\n    Consultas de Per\u00edodo:\n\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n    Exemplo:\n\n            `ptax_series(start='20-10-2024', end='27-10-2024')`\n\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados a partir\n    da data de `start` at\u00e9 a data mais recente dispon\u00edvel. Exemplo:\n\n            `ptax_series(start='20-10-2024')`\n\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados desde a data mais\n    antiga dispon\u00edvel at\u00e9 a data de `end`. Exemplo:\n\n        `ptax_series(end='27-10-2024')`\n\n    S\u00e9rie Hist\u00f3rica Completa:\n\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984\n    at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n    Exemplo:\n\n            `ptax_series()`\n\n    Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:\n\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start (DateScalar, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateScalar, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n\n    Returns:\n        pd.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.\n        Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio\n        ser\u00e1 retornado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; df = yd.bc.ptax_series(start=\"20-04-2025\", end=\"25-04-2025\")\n        &gt;&gt;&gt; df\n                 Date                    DateTime  BuyRate  SellRate  MidRate\n        0  2025-04-22  2025-04-22 13:09:35.629000    5.749    5.7496   5.7493\n        1  2025-04-23  2025-04-23 13:06:30.443000   5.6874     5.688   5.6877\n        2  2025-04-24  2025-04-24 13:04:29.639000   5.6732    5.6738   5.6735\n        3  2025-04-25  2025-04-25 13:09:26.592000    5.684    5.6846   5.6843\n\n    Notes:\n        Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990\n        e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas\n        administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992,\n        essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de\n        2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no\n        mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de\n        1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder\n        \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de\n        c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta;\n        o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos\n        boletins do dia.\n\n        - Primeira data dispon\u00edvel: 28.11.1984\n        - \u00daltima data dispon\u00edvel: data atual\n\n        O DataFrame possui as seguintes colunas:\n\n        - Date: Data da cota\u00e7\u00e3o.\n        - DateTime: Data e hora da cota\u00e7\u00e3o.\n        - BuyRate: Taxa de compra.\n        - SellRate: Taxa de venda.\n        - MidRate: Taxa m\u00e9dia entre a taxa de compra e venda.\n\n\n    \"\"\"\n    if start:\n        start = dc.convert_input_dates(start)\n    else:\n        start = dt.date(1984, 11, 28)  # Primeira data dispon\u00edvel na API\n\n    if end:\n        end = dc.convert_input_dates(end)\n    else:\n        end = dt.datetime.now(TIMEZONE_BZ).date()\n\n    try:\n        url = _build_api_url(start, end)\n        text = _fetch_text_from_api(url)\n        df = _parse_csv(text)\n        if df.is_empty():\n            logging.warning(\"No data found for the specified period.\")\n            return pd.DataFrame()\n        df = _process_df(df)\n        return df.to_pandas(use_pyarrow_extension_array=True)\n    except requests.exceptions.HTTPError as http_err:\n        logger.error(f\"HTTP error occurred: {http_err}\")\n        return pd.DataFrame()\n    except Exception as e:\n        logger.exception(\"Error fetching PTAX data from BC API: %s\", e)\n        return pd.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.repos","title":"<code>repos(start=None, end=None)</code>","text":"<p>Consulta e retorna leil\u00f5es de opera\u00e7\u00f5es compromissadas (repos) do BCB.</p> <p>Sem\u00e2ntica dos par\u00e2metros de per\u00edodo (API OData):     - start somente: dados de start at\u00e9 o fim da s\u00e9rie.     - end somente: dados do in\u00edcio da s\u00e9rie at\u00e9 end.     - ambos omitidos: s\u00e9rie hist\u00f3rica completa.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | None</code> <p>Data inicial (inclusive) ou None.</p> <code>None</code> <code>end</code> <code>DateScalar | None</code> <p>Data final (inclusive) ou None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame pandas com colunas normalizadas em portugu\u00eas e tipos</p> <code>DataFrame</code> <p>enriquecidos (fra\u00e7\u00f5es decimais, inteiros, datas). Em caso de erro</p> <code>DataFrame</code> <p>retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.</p> Colunas retornadas <ul> <li>data_leilao: data de ocorr\u00eancia do leil\u00e3o.</li> <li>data_liquidacao: data de liquida\u00e7\u00e3o (in\u00edcio da opera\u00e7\u00e3o).</li> <li>data_retorno: data de recompra / t\u00e9rmino da opera\u00e7\u00e3o.</li> <li>hora_inicio: hor\u00e1rio de in\u00edcio do leil\u00e3o.</li> <li>prazo_dias_corridos: dias corridos at\u00e9 a data de retorno.</li> <li>prazo_dias_uteis: dias \u00fateis entre liquida\u00e7\u00e3o e retorno (bday.count).</li> <li>numero_comunicado: n\u00famero do comunicado/aviso do BC (pode ser nulo).</li> <li>tipo_oferta: classif. do tipo de oferta (ex: Tomador, Compromissada 1047).</li> <li>publico_permitido: escopo de participantes (SomenteDealer, TodoMercado).</li> <li>volume_aceito: volume aceito no leil\u00e3o em reais (convertido de milhares).</li> <li>taxa_corte: taxa de corte (ex. 0.1490 = 14,90%). Nula se volume_aceito = 0.</li> <li>percentual_aceito: percentual do volume ofertado efetivamente aceito (0-100).   100 = nenhuma rejei\u00e7\u00e3o. 0 indica nada aceito (volume_aceito = 0).</li> </ul> <p>Notas adicionais:     - Dados ordenados por: data_leilao, hora_inicio, tipo_oferta.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.repos(start=\"21-08-2025\", end=\"21-08-2025\")\n  data_leilao data_liquidacao data_retorno hora_inicio  ...  publico_permitido  volume_aceito  taxa_corte percentual_aceito\n0  2025-08-21      2025-08-21   2025-08-22    09:00:00  ...      SomenteDealer   647707406000       0.149             100.0\n1  2025-08-21      2025-08-22   2025-11-21    12:00:00  ...        TodoMercado     5000000000      0.9978             35.87\n[2 rows x 12 columns]\n</code></pre> Source code in <code>pyield/bc/repo.py</code> <pre><code>def repos(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Consulta e retorna leil\u00f5es de opera\u00e7\u00f5es compromissadas (repos) do BCB.\n\n    Sem\u00e2ntica dos par\u00e2metros de per\u00edodo (API OData):\n        - start somente: dados de start at\u00e9 o fim da s\u00e9rie.\n        - end somente: dados do in\u00edcio da s\u00e9rie at\u00e9 end.\n        - ambos omitidos: s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start: Data inicial (inclusive) ou None.\n        end: Data final (inclusive) ou None.\n\n    Returns:\n        DataFrame pandas com colunas normalizadas em portugu\u00eas e tipos\n        enriquecidos (fra\u00e7\u00f5es decimais, inteiros, datas). Em caso de erro\n        retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.\n\n    Colunas retornadas:\n        - data_leilao: data de ocorr\u00eancia do leil\u00e3o.\n        - data_liquidacao: data de liquida\u00e7\u00e3o (in\u00edcio da opera\u00e7\u00e3o).\n        - data_retorno: data de recompra / t\u00e9rmino da opera\u00e7\u00e3o.\n        - hora_inicio: hor\u00e1rio de in\u00edcio do leil\u00e3o.\n        - prazo_dias_corridos: dias corridos at\u00e9 a data de retorno.\n        - prazo_dias_uteis: dias \u00fateis entre liquida\u00e7\u00e3o e retorno (bday.count).\n        - numero_comunicado: n\u00famero do comunicado/aviso do BC (pode ser nulo).\n        - tipo_oferta: classif. do tipo de oferta (ex: Tomador, Compromissada 1047).\n        - publico_permitido: escopo de participantes (SomenteDealer, TodoMercado).\n        - volume_aceito: volume aceito no leil\u00e3o em reais (convertido de milhares).\n        - taxa_corte: taxa de corte (ex. 0.1490 = 14,90%). Nula se volume_aceito = 0.\n        - percentual_aceito: percentual do volume ofertado efetivamente aceito (0-100).\n          100 = nenhuma rejei\u00e7\u00e3o. 0 indica nada aceito (volume_aceito = 0).\n\n        Notas adicionais:\n            - Dados ordenados por: data_leilao, hora_inicio, tipo_oferta.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.repos(start=\"21-08-2025\", end=\"21-08-2025\")\n          data_leilao data_liquidacao data_retorno hora_inicio  ...  publico_permitido  volume_aceito  taxa_corte percentual_aceito\n        0  2025-08-21      2025-08-21   2025-08-22    09:00:00  ...      SomenteDealer   647707406000       0.149             100.0\n        1  2025-08-21      2025-08-22   2025-11-21    12:00:00  ...        TodoMercado     5000000000      0.9978             35.87\n        [2 rows x 12 columns]\n    \"\"\"  # noqa: E501\n    try:\n        url = _build_url(start=start, end=end)\n        logger.debug(f\"Consultando API do BC: {url}\")\n        api_csv = _fetch_api_csv(url)\n        df = _read_csv_data(api_csv)\n        if df.is_empty():\n            logger.warning(\"Sem dados de leil\u00f5es para o per\u00edodo especificado.\")\n            return pd.DataFrame()\n        df = _process_df(df)\n        df = _handle_zero_volume(df)\n        df = _sort_and_select_columns(df)\n        return df.to_pandas(use_pyarrow_extension_array=True)\n    except Exception as e:\n        logger.exception(f\"Erro ao buscar dados de leil\u00f5es na API do BC: {e}\")\n        return pd.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over","title":"<code>selic_over(date)</code>","text":"<p>Fetches the SELIC Over rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the SELIC Over rate for.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The SELIC Over rate as a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n0.104\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_over(date: DateScalar) -&gt; float:\n    \"\"\"\n    Fetches the SELIC Over rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the SELIC Over rate for.\n\n    Returns:\n        The SELIC Over rate as a float.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n        0.104\n    \"\"\"\n    df = selic_over_series(date, date)\n    if df.empty:\n        return float(\"nan\")\n    return df.at[0, \"Value\"]\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over_series","title":"<code>selic_over_series(start, end=None)</code>","text":"<p>Fetches the SELIC Over rate from the Brazilian Central Bank.</p> <p>The SELIC Over rate is the daily average interest rate effectively practiced between banks in the interbank market, using public securities as collateral.</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> required <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the SELIC Over rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # No data on 26-01-2025 (sunday). Rate changed due to Copom meeting.\n&gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\")  # Returns all data since 26-01-2025\n        Date   Value\n0 2025-01-27  0.1215\n1 2025-01-28  0.1215\n2 2025-01-29  0.1215\n3 2025-01-30  0.1315\n4 2025-01-31  0.1315\n...\n</code></pre> <pre><code>&gt;&gt;&gt; # Fetching data for a specific date range\n&gt;&gt;&gt; bc.selic_over_series(\"14-09-2025\", \"17-09-2025\")\n         Date  Value\n0  2025-09-15  0.149\n1  2025-09-16  0.149\n2  2025-09-17  0.149\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_over_series(\n    start: DateScalar,\n    end: DateScalar | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches the SELIC Over rate from the Brazilian Central Bank.\n\n    The SELIC Over rate is the daily average interest rate effectively practiced\n    between banks in the interbank market, using public securities as collateral.\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n\n    Returns:\n        DataFrame containing Date and Value columns with the SELIC Over rate,\n        or empty DataFrame if data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # No data on 26-01-2025 (sunday). Rate changed due to Copom meeting.\n        &gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\")  # Returns all data since 26-01-2025\n                Date   Value\n        0 2025-01-27  0.1215\n        1 2025-01-28  0.1215\n        2 2025-01-29  0.1215\n        3 2025-01-30  0.1315\n        4 2025-01-31  0.1315\n        ...\n\n        &gt;&gt;&gt; # Fetching data for a specific date range\n        &gt;&gt;&gt; bc.selic_over_series(\"14-09-2025\", \"17-09-2025\")\n                 Date  Value\n        0  2025-09-15  0.149\n        1  2025-09-16  0.149\n        2  2025-09-17  0.149\n    \"\"\"\n    df = _fetch_data_from_url(BCSerie.SELIC_OVER, start, end)\n    return df.with_columns(\n        pl.col(\"Value\").round(DECIMAL_PLACES_ANNUALIZED),\n    ).to_pandas(use_pyarrow_extension_array=True)\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target","title":"<code>selic_target(date)</code>","text":"<p>Fetches the SELIC Target rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the SELIC Target rate for.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The SELIC Target rate as a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n0.105\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_target(date: DateScalar) -&gt; float:\n    \"\"\"\n    Fetches the SELIC Target rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the SELIC Target rate for.\n\n    Returns:\n        The SELIC Target rate as a float.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n        0.105\n    \"\"\"\n    df = selic_target_series(date, date)\n    if df.empty:\n        return float(\"nan\")\n    return df.at[0, \"Value\"]\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target_series","title":"<code>selic_target_series(start, end=None)</code>","text":"<p>Fetches the SELIC Target rate from the Brazilian Central Bank.</p> <p>The SELIC Target rate is the official interest rate set by the Central Bank of Brazil's Monetary Policy Committee (COPOM).</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date for the data to fetch.</p> required <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the SELIC Target rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\n        Date  Value\n0 2024-05-31  0.105\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_target_series(\n    start: DateScalar,\n    end: DateScalar | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches the SELIC Target rate from the Brazilian Central Bank.\n\n    The SELIC Target rate is the official interest rate set by the\n    Central Bank of Brazil's Monetary Policy Committee (COPOM).\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n\n    Returns:\n        DataFrame containing Date and Value columns with the SELIC Target rate,\n        or empty DataFrame if data is not available\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\n                Date  Value\n        0 2024-05-31  0.105\n    \"\"\"\n    df = _fetch_data_from_url(BCSerie.SELIC_TARGET, start, end)\n    df = df.with_columns(pl.col(\"Value\").round(DECIMAL_PLACES_ANNUALIZED))\n    return df.to_pandas(use_pyarrow_extension_array=True)\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_intraday_trades","title":"<code>tpf_intraday_trades()</code>","text":"<p>Fetches real-time secondary trading data for domestic Federal Public Debt (TPF - t\u00edtulos p\u00fablicos federais) from the Central Bank of Brazil (BCB).</p> <p>This function checks if the SELIC market is currently open based on Brazil/Sao_Paulo timezone business days and trading hours (defined by REALTIME_START_TIME and REALTIME_END_TIME). If the market is closed, or if no data is available from the source, or if an error occurs during fetching or processing, an empty DataFrame is returned. Otherwise, it retrieves, cleans, and processes the intraday trade data provided by BCB for Brazilian government bonds.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the latest intraday trades for FPD securities. Returns an empty DataFrame if the market is closed, no data is found, or an error occurs. The DataFrame includes the following columns:</p> <ul> <li><code>SettlementDate</code>: The reference date for the spot market     trading activity reported in this dataset (the current     business day). Forward trades listed have future settlement dates     not specified here.</li> <li><code>BondType</code>: Abbreviation/ticker for the bond type (e.g., LFT,     LTN, NTN-B).</li> <li><code>SelicCode</code>: The unique SELIC code identifying the specific bond issue.</li> <li><code>MaturityDate</code>: The maturity date of the bond.</li> </ul> <p>Spot Market Data: *   <code>MinPrice</code>: Minimum traded price. *   <code>AvgPrice</code>: Average traded price. *   <code>MaxPrice</code>: Maximum traded price. *   <code>LastPrice</code>: Last traded price. *   <code>MinRate</code>: Minimum traded yield/rate (as a decimal, e.g., 0.11 for 11%). *   <code>AvgRate</code>: Average traded yield/rate (as a decimal). *   <code>MaxRate</code>: Maximum traded yield/rate (as a decimal). *   <code>LastRate</code>: Last traded yield/rate (as a decimal). *   <code>Trades</code>: Total number of trades settled. *   <code>Quantity</code>: Total number of bonds traded (quantity). *   <code>Value</code>: Total financial value traded (in BRL). *   <code>BrokeredTrades</code>: Number of brokered trades settled. *   <code>BrokeredQuantity</code>: Quantity of bonds traded via brokers.</p> <p>Forward Market Data: *   <code>ForwardMinPrice</code>: Minimum traded price. *   <code>ForwardAvgPrice</code>: Average traded price. *   <code>ForwardMaxPrice</code>: Maximum traded price. *   <code>ForwardLastPrice</code>: Last traded price. *   <code>ForwardMinRate</code>: Minimum traded yield/rate (decimal). *   <code>ForwardAvgRate</code>: Average traded yield/rate (decimal). *   <code>ForwardMaxRate</code>: Maximum traded yield/rate (decimal). *   <code>ForwardLastRate</code>: Last traded yield/rate (decimal). *   <code>ForwardTrades</code>: Total number of trades contracted. *   <code>ForwardQuantity</code>: Total number of bonds traded (quantity). *   <code>ForwardValue</code>: Total financial value traded (in BRL). *   <code>ForwardBrokeredTrades</code>: Number of brokered trades contracted. *   <code>ForwardBrokeredQuantity</code>: Quantity of bonds traded via brokers.</p>"},{"location":"bc/#pyield.bc.tpf_intraday_trades--arrow-note-usage-in-data-types","title":"Arrow note usage in data types","text":"<p>Note:     - The DataFrame returned by this function may be empty if the market is closed,       no data is found, or an error occurs.     - Arrow data types are used for better performance and compatibility with other       libraries.</p> Source code in <code>pyield/bc/trades_intraday.py</code> <pre><code>def tpf_intraday_trades() -&gt; pd.DataFrame:\n    \"\"\"Fetches real-time secondary trading data for domestic Federal Public Debt\n    (TPF - t\u00edtulos p\u00fablicos federais) from the Central Bank of Brazil (BCB).\n\n    This function checks if the SELIC market is currently open based on Brazil/Sao_Paulo\n    timezone business days and trading hours (defined by REALTIME_START_TIME and\n    REALTIME_END_TIME). If the market is closed, or if no data is available from the\n    source, or if an error occurs during fetching or processing, an empty DataFrame\n    is returned. Otherwise, it retrieves, cleans, and processes the intraday trade\n    data provided by BCB for Brazilian government bonds.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the latest intraday trades for FPD\n            securities. Returns an empty DataFrame if the market is closed, no data\n            is found, or an error occurs. The DataFrame includes the following columns:\n\n            *   `SettlementDate`: The reference date for the spot market\n                trading activity reported in this dataset (the current\n                business day). Forward trades listed have future settlement dates\n                not specified here.\n            *   `BondType`: Abbreviation/ticker for the bond type (e.g., LFT,\n                LTN, NTN-B).\n            *   `SelicCode`: The unique SELIC code identifying the specific bond issue.\n            *   `MaturityDate`: The maturity date of the bond.\n\n            **Spot Market Data:**\n            *   `MinPrice`: Minimum traded price.\n            *   `AvgPrice`: Average traded price.\n            *   `MaxPrice`: Maximum traded price.\n            *   `LastPrice`: Last traded price.\n            *   `MinRate`: Minimum traded yield/rate (as a decimal, e.g., 0.11 for 11%).\n            *   `AvgRate`: Average traded yield/rate (as a decimal).\n            *   `MaxRate`: Maximum traded yield/rate (as a decimal).\n            *   `LastRate`: Last traded yield/rate (as a decimal).\n            *   `Trades`: Total number of trades settled.\n            *   `Quantity`: Total number of bonds traded (quantity).\n            *   `Value`: Total financial value traded (in BRL).\n            *   `BrokeredTrades`: Number of brokered trades settled.\n            *   `BrokeredQuantity`: Quantity of bonds traded via brokers.\n\n            **Forward Market Data:**\n            *   `ForwardMinPrice`: Minimum traded price.\n            *   `ForwardAvgPrice`: Average traded price.\n            *   `ForwardMaxPrice`: Maximum traded price.\n            *   `ForwardLastPrice`: Last traded price.\n            *   `ForwardMinRate`: Minimum traded yield/rate (decimal).\n            *   `ForwardAvgRate`: Average traded yield/rate (decimal).\n            *   `ForwardMaxRate`: Maximum traded yield/rate (decimal).\n            *   `ForwardLastRate`: Last traded yield/rate (decimal).\n            *   `ForwardTrades`: Total number of trades contracted.\n            *   `ForwardQuantity`: Total number of bonds traded (quantity).\n            *   `ForwardValue`: Total financial value traded (in BRL).\n            *   `ForwardBrokeredTrades`: Number of brokered trades contracted.\n            *   `ForwardBrokeredQuantity`: Quantity of bonds traded via brokers.\n    # Arrow note usage in data types\n    Note:\n        - The DataFrame returned by this function may be empty if the market is closed,\n          no data is found, or an error occurs.\n        - Arrow data types are used for better performance and compatibility with other\n          libraries.\n\n    \"\"\"\n    if not is_selic_open():\n        logger.info(\"Market is closed. Returning empty DataFrame.\")\n        return pd.DataFrame()\n\n    try:\n        raw_text = _fetch_csv_from_url()\n        # raw_text = test_file.read_text(encoding=\"iso-8859-15\")\n        cleaned_text = _clean_csv(raw_text)\n        if not cleaned_text:\n            logger.warning(\"No data found in the FPD intraday trades.\")\n            return pd.DataFrame()\n        df = _convert_csv_to_df(cleaned_text)\n        df = _process_df(df)\n        df = _reorder_columns(df)\n        value = df[\"Value\"].sum() / 10**9\n        logger.info(f\"Fetched {value:,.1f} billion BRL in FPD intraday trades.\")\n        return df\n    except Exception as e:\n        logger.exception(\n            f\"Error fetching data from BCB: {e}. Returning empty DataFrame.\"\n        )\n        return pd.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_monthly_trades","title":"<code>tpf_monthly_trades(target_date, extragroup=False)</code>","text":"<p>Fetches monthly secondary trading data for the domestic 'Federal Public Debt' (TPF - t\u00edtulos p\u00fablicos federais) registered in the Brazilian Central Bank (BCB) Selic system.</p> <p>Downloads the monthly bond trading data from the Brazilian Central Bank (BCB) website for the month corresponding to the provided date. The data is downloaded as a ZIP file, extracted, and loaded into a Pandas DataFrame. The data contains all trades executed during the month, separated by each 'SettlementDate'.</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>DateScalar</code> <p>The date for which the monthly trading data will be fetched. This date can be a string, datetime, or pandas Timestamp object. It will be converted to a pandas Timestamp object. Only the year and month of this date will be used to download the corresponding monthly file. extragroup (bool): If True, fetches only the trades that are considered 'extragroup' (between different economic groups)\". If False, fetches all trades. Default is False. Extragroup trades are those where the transferring counterparty's conglomerate is different from the receiving counterparty's conglomerate, or when at least one of the counterparties does not belong to a conglomerate. In the case of funds, the conglomerate considered is that of the administrator.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the bond trading data for the specified month.</p> DataFrame columns <ul> <li>SettlementDate: Date when the trade settled</li> <li>BondType: Security type abbreviation</li> <li>SelicCode: Unique code in the SELIC system</li> <li>ISIN: International Securities Identification Number</li> <li>IssueDate: Date when the security was issued</li> <li>MaturityDate: Security's maturity date</li> <li>Trades: Number of trades executed</li> <li>Quantity: Quantity traded</li> <li>Value: Value traded</li> <li>AvgPrice: Average price</li> <li>AvgRate: Average rate And additional trading metrics like min/max prices and rates.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Fetches all trades for Jan/2025\n&gt;&gt;&gt; bc.tpf_monthly_trades(\"07-01-2025\", extragroup=True).head(5)\n  SettlementDate BondType SelicCode          ISIN  ... AvgRate MaxRate  BrokerageTrades  BrokerageQuantity\n0     2025-01-02      LFT    210100  BRSTNCLF1RC4  ...  0.0132  0.0906                2               9581\n1     2025-01-02      LFT    210100  BRSTNCLF1RD2  ...  0.0561   0.101               11              42823\n2     2025-01-02      LFT    210100  BRSTNCLF1RE0  ...  0.0191  0.0405               19              33330\n3     2025-01-02      LFT    210100  BRSTNCLF1RF7  ...  0.0304    0.05               10              14583\n4     2025-01-02      LFT    210100  BRSTNCLF1RG5  ...  0.0697  0.0935               12              51776\n...\n</code></pre> Source code in <code>pyield/bc/trades_monthly.py</code> <pre><code>def tpf_monthly_trades(\n    target_date: DateScalar, extragroup: bool = False\n) -&gt; pd.DataFrame:\n    \"\"\"Fetches monthly secondary trading data for the domestic 'Federal Public Debt'\n    (TPF - t\u00edtulos p\u00fablicos federais) registered in the Brazilian Central Bank (BCB)\n    Selic system.\n\n    Downloads the monthly bond trading data from the Brazilian Central Bank (BCB)\n    website for the month corresponding to the provided date. The data is downloaded\n    as a ZIP file, extracted, and loaded into a Pandas DataFrame. The data contains\n    all trades executed during the month, separated by each 'SettlementDate'.\n\n    Args:\n        target_date (DateScalar): The date for which the monthly trading data will be\n            fetched. This date can be a string, datetime, or pandas Timestamp object.\n            It will be converted to a pandas Timestamp object. Only the year and month\n            of this date will be used to download the corresponding monthly file.\n            extragroup (bool): If True, fetches only the trades that are considered\n            'extragroup' (between different economic groups)\".\n            If False, fetches all trades. Default is False.\n            Extragroup trades are those where the transferring counterparty's\n            conglomerate is different from the receiving counterparty's conglomerate, or\n            when at least one of the counterparties does not belong to a conglomerate.\n            In the case of funds, the conglomerate considered is that of the\n            administrator.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the bond trading data for the specified\n            month.\n\n    DataFrame columns:\n        - SettlementDate: Date when the trade settled\n        - BondType: Security type abbreviation\n        - SelicCode: Unique code in the SELIC system\n        - ISIN: International Securities Identification Number\n        - IssueDate: Date when the security was issued\n        - MaturityDate: Security's maturity date\n        - Trades: Number of trades executed\n        - Quantity: Quantity traded\n        - Value: Value traded\n        - AvgPrice: Average price\n        - AvgRate: Average rate\n        And additional trading metrics like min/max prices and rates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Fetches all trades for Jan/2025\n        &gt;&gt;&gt; bc.tpf_monthly_trades(\"07-01-2025\", extragroup=True).head(5)\n          SettlementDate BondType SelicCode          ISIN  ... AvgRate MaxRate  BrokerageTrades  BrokerageQuantity\n        0     2025-01-02      LFT    210100  BRSTNCLF1RC4  ...  0.0132  0.0906                2               9581\n        1     2025-01-02      LFT    210100  BRSTNCLF1RD2  ...  0.0561   0.101               11              42823\n        2     2025-01-02      LFT    210100  BRSTNCLF1RE0  ...  0.0191  0.0405               19              33330\n        3     2025-01-02      LFT    210100  BRSTNCLF1RF7  ...  0.0304    0.05               10              14583\n        4     2025-01-02      LFT    210100  BRSTNCLF1RG5  ...  0.0697  0.0935               12              51776\n        ...\n    \"\"\"  # noqa: E501\n    try:\n        target_date = convert_input_dates(target_date)\n        url = _build_file_url(target_date, extragroup)\n        zip_content = _fetch_zip_from_url(url)\n        extracted_file = _uncompress_zip(zip_content)\n        df = _read_dataframe_from_zip(extracted_file)\n        df = _process_df(df)\n\n    except HTTPError as e:\n        if e.code == 404:  # noqa\n            msg = f\"Resource not found (404) at {url}. Returning an empty DataFrame.\"\n            logger.warning(msg)\n            return pd.DataFrame()\n        else:\n            # Captures the full traceback for unexpected HTTP errors\n            msg = f\"Unexpected HTTP error ({e.code}) while accessing URL: {url}\"\n            logger.exception(msg)\n            raise e\n\n    except Exception:\n        # Captures the full traceback for any other errors\n        msg = f\"An unexpected error occurred while processing data from {url}.\"\n        logger.exception(msg)\n        raise\n\n    # LOG DE SUCESSO\n    msg = f\"Successfully processed data from {url}. Found {len(df)} records.\"\n    logger.info(msg)\n\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.vna_lft","title":"<code>vna_lft(date)</code>","text":"<p>Retrieves the VNA (Valor Nominal Atualizado) from the BCB for a given date.</p> <p>This function fetches daily data from the BCB website, extracts the VNA value from a specific table within the downloaded content, and returns this value.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The date for which to retrieve the VNA value. This argument accepts various date formats, including string and datetime objects, which are then standardized using the <code>convert_input_dates</code> function.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The VNA (Valor Nominal Atualizado) value for the specified date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n14903.01148\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the extracted VNA values from the BCB website are inconsistent (i.e., not all extracted values are identical), suggesting potential data discrepancies on the source website. The error message includes a link to the BCB website for manual verification.</p> <code>HTTPError</code> <p>If the HTTP request to the BCB website fails. This could be due to network issues, website unavailability, or the requested data not being found for the given date.</p> Source code in <code>pyield/bc/vna.py</code> <pre><code>def vna_lft(date: DateScalar) -&gt; float:\n    \"\"\"Retrieves the VNA (Valor Nominal Atualizado) from the BCB for a given date.\n\n    This function fetches daily data from the BCB website, extracts the\n    VNA value from a specific table within the downloaded content, and\n    returns this value.\n\n    Args:\n        date (DateScalar): The date for which to retrieve the VNA value.\n            This argument accepts various date formats, including string and\n            datetime objects, which are then standardized using the\n            `convert_input_dates` function.\n\n    Returns:\n        float: The VNA (Valor Nominal Atualizado) value for the specified date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n        14903.01148\n\n    Raises:\n        ValueError: If the extracted VNA values from the BCB website are\n            inconsistent (i.e., not all extracted values are identical),\n            suggesting potential data discrepancies on the source website.\n            The error message includes a link to the BCB website for manual\n            verification.\n        requests.exceptions.HTTPError: If the HTTP request to the BCB website\n            fails. This could be due to network issues, website unavailability,\n            or the requested data not being found for the given date.\n    \"\"\"\n    text = _get_text(date)\n    table_text = _extract_vna_table_text(text)\n    table_lines = _parse_vna_table_lines(table_text)\n    vnas = _extract_vna_values_from_lines(table_lines)\n    vna_value = _validate_vna_values(vnas)\n    return vna_value\n</code></pre>"},{"location":"bday/","title":"Business Day Tools","text":""},{"location":"bday/#pyield.bday.count","title":"<code>count(start, end)</code>","text":"<p>Counts the number of business days between a <code>start</code> date (inclusive) and an <code>end</code> date (exclusive). The function can handle single dates, arrays of dates and mixed inputs, returning either a single integer or a series of integers depending on the inputs. It accounts for specified holidays, effectively excluding them from the business day count.</p> <p>Important Note: Each date in the <code>start</code> input is evaluated individually to determine which list of holidays (old or new) applies to the calculation. The transition date is 2023-12-26, which means: - Dates before 2023-12-26 use the old holiday list. - Dates on or after 2023-12-26 use the new holiday list.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | DateArray</code> <p>The start date(s) for counting (inclusive). Transition Handling: The holiday list used for the entire counting period between <code>start</code> and <code>end</code> is determined solely by the <code>start</code> date's relation to the holiday transition date (2023-12-26). If <code>start</code> is before this date, the old holiday list is used for the whole count, even if <code>end</code> is after it. If <code>start</code> is on or after this date, new holiday list is used.</p> required <code>end</code> <code>DateScalar | DateArray</code> <p>The end date(s) for counting (exclusive).</p> required <p>Returns:</p> Type Description <code>int | Series | None</code> <p>int | pd.Series | None: Returns an integer or None if <code>start</code> and <code>end</code> are single dates, or a Series if any of them is an array of dates.</p> Notes <ul> <li>This function is a wrapper around <code>numpy.busday_count</code>, adapted to work     directly with various Pandas and Numpy date formats.</li> <li>It supports flexible date inputs, including single dates, lists, Series, and     more, for both <code>start</code> and <code>end</code> parameters.</li> <li>The return type depends on the input types: single dates return an int, while     arrays of dates return a pd.Series with the count for each date range.</li> <li>The <code>start</code> date determines the holiday list, ensuring consistency with the     applicable calendar at the time.</li> <li>See <code>numpy.busday_count</code> documentation for more details on how holidays are     handled and how business day counts are calculated:     https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n10\n</code></pre> <p>Total business days in January and February since the start of the year</p> <pre><code>&gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n0    22\n1    41\ndtype: int64[pyarrow]\n</code></pre> <p>The remaining business days in January and February to the end of the year</p> <pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n0    253\n1    231\ndtype: int64[pyarrow]\n</code></pre> <p>The total business days in January and February of 2024</p> <pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n0    22\n1    19\ndtype: int64[pyarrow]\n</code></pre> <p>Null values are propagated</p> <pre><code>&gt;&gt;&gt; bday.count(pd.NaT, \"01-01-2024\")  # NaT start\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"01-01-2024\", pd.NaT)  # NaT end\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"01-01-2024\", [\"01-02-2024\", pd.NaT])  # NaT in end array\n0    22\n1    &lt;NA&gt;\ndtype: int64[pyarrow]\n</code></pre> <p>Original pandas index is preserved</p> <pre><code>&gt;&gt;&gt; start_dates = pd.Series(\n...     [\"01-01-2024\", \"01-02-2024\", \"01-03-2024\"],\n...     index=[\"a\", \"b\", \"c\"],\n... )\n&gt;&gt;&gt; bday.count(start_dates, \"01-01-2025\")\na    253\nb    231\nc    212\ndtype: int64[pyarrow]\n</code></pre> Source code in <code>pyield/bday.py</code> <pre><code>def count(\n    start: DateScalar | DateArray,\n    end: DateScalar | DateArray,\n) -&gt; int | pd.Series | None:\n    \"\"\"\n    Counts the number of business days between a `start` date (inclusive) and an `end`\n    date (exclusive). The function can handle single dates, arrays of dates and\n    mixed inputs, returning either a single integer or a series of integers depending\n    on the inputs. It accounts for specified holidays, effectively excluding them from\n    the business day count.\n\n    **Important Note:** Each date in the `start` input is evaluated individually to\n    determine which list of holidays (old or new) applies to the calculation. The\n    transition date is 2023-12-26, which means:\n    - Dates before 2023-12-26 use the old holiday list.\n    - Dates on or after 2023-12-26 use the new holiday list.\n\n    Args:\n        start (DateScalar | DateArray): The start date(s) for counting (inclusive).\n            **Transition Handling:** The holiday list used for the *entire* counting\n            period between `start` and `end` is determined solely by the `start` date's\n            relation to the holiday transition date (2023-12-26). If `start` is before\n            this date, the old holiday list is used for the whole count, even if `end`\n            is after it. If `start` is on or after this date, new holiday list is used.\n        end (DateScalar | DateArray): The end date(s) for counting (exclusive).\n\n    Returns:\n        int | pd.Series | None: Returns an integer or None if `start` and `end` are\n            single dates, or a Series if any of them is an array of dates.\n\n    Notes:\n        - This function is a wrapper around `numpy.busday_count`, adapted to work\n            directly with various Pandas and Numpy date formats.\n        - It supports flexible date inputs, including single dates, lists, Series, and\n            more, for both `start` and `end` parameters.\n        - The return type depends on the input types: single dates return an int, while\n            arrays of dates return a pd.Series with the count for each date range.\n        - The `start` date determines the holiday list, ensuring consistency with the\n            applicable calendar at the time.\n        - See `numpy.busday_count` documentation for more details on how holidays are\n            handled and how business day counts are calculated:\n            https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n        10\n\n        Total business days in January and February since the start of the year\n        &gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n        0    22\n        1    41\n        dtype: int64[pyarrow]\n\n        The remaining business days in January and February to the end of the year\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n        0    253\n        1    231\n        dtype: int64[pyarrow]\n\n        The total business days in January and February of 2024\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n        0    22\n        1    19\n        dtype: int64[pyarrow]\n\n        Null values are propagated\n        &gt;&gt;&gt; bday.count(pd.NaT, \"01-01-2024\")  # NaT start\n\n        &gt;&gt;&gt; bday.count(\"01-01-2024\", pd.NaT)  # NaT end\n\n        &gt;&gt;&gt; bday.count(\"01-01-2024\", [\"01-02-2024\", pd.NaT])  # NaT in end array\n        0    22\n        1    &lt;NA&gt;\n        dtype: int64[pyarrow]\n\n        Original pandas index is preserved\n        &gt;&gt;&gt; start_dates = pd.Series(\n        ...     [\"01-01-2024\", \"01-02-2024\", \"01-03-2024\"],\n        ...     index=[\"a\", \"b\", \"c\"],\n        ... )\n        &gt;&gt;&gt; bday.count(start_dates, \"01-01-2025\")\n        a    253\n        b    231\n        c    212\n        dtype: int64[pyarrow]\n    \"\"\"\n    # Padroniza as entradas para objetos do Pandas\n    start_pd = dc.convert_input_dates(start)\n    end_pd = dc.convert_input_dates(end)\n\n    # 1. VALIDA\u00c7\u00c3O ESTRUTURAL\n    if isinstance(start_pd, pd.Series) and isinstance(end_pd, pd.Series):\n        if not start_pd.index.equals(end_pd.index):\n            raise ValueError(\"Input dates have different indices!\")\n\n    # 2. L\u00d3GICA PRINCIPAL\n\n    # --- CASO 1: AMBAS AS ENTRADAS S\u00c3O ESCALARES ---\n    if not isinstance(start_pd, pd.Series) and not isinstance(end_pd, pd.Series):\n        if pd.isna(start_pd) or pd.isna(end_pd):\n            return None\n\n        result = np.busday_count(\n            begindates=start_pd,\n            enddates=end_pd,\n            holidays=br_holidays.get_holiday_array(start_pd),\n        )\n        return int(result)\n\n    # --- CASO 2: PELO MENOS UMA ENTRADA \u00c9 UMA S\u00c9RIE ---\n\n    # Garante que ambas as vari\u00e1veis sejam Series para alinhamento autom\u00e1tico.\n    # O Pandas faz o \"broadcast\" do escalar para o tamanho da Series.\n    if isinstance(end_pd, pd.Series):\n        start_pd = pd.Series(start_pd, index=end_pd.index)\n    else:\n        end_pd = pd.Series(end_pd, index=start_pd.index)\n\n    # Inicializa a s\u00e9rie de resultados com o \u00edndice correto e tipo que suporta NA.\n    # Nulos nas entradas (start_pd ou end_pd) resultar\u00e3o em NA aqui.\n    result = pd.Series(index=start_pd.index, dtype=\"int64[pyarrow]\")\n\n    # Cria m\u00e1scaras para linhas n\u00e3o-nulas, divididas pelo calend\u00e1rio de feriados.\n    # A l\u00f3gica de feriados depende APENAS da data de in\u00edcio.\n    not_null_mask = start_pd.notna() &amp; end_pd.notna()\n    mask_old_holidays = not_null_mask &amp; (start_pd &lt; br_holidays.TRANSITION_DATE)\n    mask_new_holidays = not_null_mask &amp; (start_pd &gt;= br_holidays.TRANSITION_DATE)\n\n    # Calcula e atribui os resultados para o subconjunto \"OLD\"\n    if mask_old_holidays.any():\n        result.loc[mask_old_holidays] = np.busday_count(\n            begindates=dc.to_numpy_date_type(start_pd[mask_old_holidays]),\n            enddates=dc.to_numpy_date_type(end_pd[mask_old_holidays]),\n            holidays=OLD_HOLIDAYS_ARRAY,\n        )\n\n    # Calcula e atribui os resultados para o subconjunto \"NEW\"\n    if mask_new_holidays.any():\n        result.loc[mask_new_holidays] = np.busday_count(\n            begindates=dc.to_numpy_date_type(start_pd[mask_new_holidays]),\n            enddates=dc.to_numpy_date_type(end_pd[mask_new_holidays]),\n            holidays=NEW_HOLIDAYS_ARRAY,\n        )\n\n    # As linhas onde not_null_mask era False j\u00e1 cont\u00eam o valor &lt;NA&gt; default.\n    return result\n</code></pre>"},{"location":"bday/#pyield.bday.generate","title":"<code>generate(start=None, end=None, inclusive='both', holiday_option='new')</code>","text":"<p>Generates a Series of business days between a <code>start</code> and <code>end</code> date, considering the list of Brazilian holidays. It supports customization of holiday lists and inclusion options for start and end dates. It wraps <code>pandas.bdate_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | None</code> <p>The start date for generating the dates.  If None, the current date is used. Defaults to None.</p> <code>None</code> <code>end</code> <code>DateScalar | None</code> <p>The end date for generating business days. If None, the current date is used. Defaults to None.</p> <code>None</code> <code>inclusive</code> <code>Literal['both', 'neither', 'left', 'right']</code> <p>Determines which of the start and end dates are included in the result. Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.</p> <code>'both'</code> <code>holiday_option</code> <code>Literal['old', 'new', 'infer']</code> <p>Specifies the list of holidays to consider. Defaults to \"new\". - 'old': Uses the holiday list effective before the transition date of 2023-12-26. - 'new': Uses the holiday list effective on and after the transition date of 2023-12-26. - 'infer': Automatically selects the holiday list ('old' or 'new') based on the <code>start</code> date relative to the transition date (2023-12-26). If <code>start</code> is before the transition, 'old' is used; otherwise, 'new' is used.</p> <code>'new'</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series representing a range of business days between the specified start and end dates, considering the specified holidays.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n0   2023-12-22\n1   2023-12-26\n2   2023-12-27\n3   2023-12-28\n4   2023-12-29\n5   2024-01-02\ndtype: date32[day][pyarrow]\n</code></pre> Note <p>For detailed information on parameters and error handling, refer to <code>pandas.bdate_range</code> documentation: https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.</p> Source code in <code>pyield/bday.py</code> <pre><code>def generate(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n    inclusive: Literal[\"both\", \"neither\", \"left\", \"right\"] = \"both\",\n    holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"new\",\n) -&gt; pd.Series:\n    \"\"\"\n    Generates a Series of business days between a `start` and `end` date, considering\n    the list of Brazilian holidays. It supports customization of holiday lists and\n    inclusion options for start and end dates. It wraps `pandas.bdate_range`.\n\n    Args:\n        start (DateScalar | None, optional): The start date for generating the dates.\n             If None, the current date is used. Defaults to None.\n        end (DateScalar | None, optional): The end date for generating business days.\n            If None, the current date is used. Defaults to None.\n        inclusive (Literal[\"both\", \"neither\", \"left\", \"right\"], optional):\n            Determines which of the start and end dates are included in the result.\n            Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.\n        holiday_option (Literal[\"old\", \"new\", \"infer\"], optional):\n            Specifies the list of holidays to consider. Defaults to \"new\".\n            - **'old'**: Uses the holiday list effective *before* the transition date\n            of 2023-12-26.\n            - **'new'**: Uses the holiday list effective *on and after* the transition\n            date of 2023-12-26.\n            - **'infer'**: Automatically selects the holiday list ('old' or 'new') based\n            on the `start` date relative to the transition date (2023-12-26). If `start`\n            is before the transition, 'old' is used; otherwise, 'new' is used.\n\n    Returns:\n        pd.Series: A Series representing a range of business days between the specified\n            start and end dates, considering the specified holidays.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n        0   2023-12-22\n        1   2023-12-26\n        2   2023-12-27\n        3   2023-12-28\n        4   2023-12-29\n        5   2024-01-02\n        dtype: date32[day][pyarrow]\n\n    Note:\n        For detailed information on parameters and error handling, refer to\n        `pandas.bdate_range` documentation:\n        https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.\n    \"\"\"\n    if start:\n        start_pd = dc.convert_input_dates(start)\n    else:\n        start_pd = dt.datetime.now(TIMEZONE_BZ).date()\n\n    if end:\n        end_pd = dc.convert_input_dates(end)\n    else:\n        end_pd = dt.datetime.now(TIMEZONE_BZ).date()\n\n    applicable_holidays = br_holidays.get_holiday_series(\n        dates=start_pd, holiday_option=holiday_option\n    ).to_list()\n\n    # Get the result as a DatetimeIndex (dti)\n    result_dti = pd.bdate_range(\n        start=start_pd,\n        end=end_pd,\n        freq=\"C\",\n        inclusive=inclusive,\n        holidays=applicable_holidays,\n    )\n\n    return pd.Series(result_dti.values).astype(\"date32[pyarrow]\")\n</code></pre>"},{"location":"bday/#pyield.bday.is_business_day","title":"<code>is_business_day(date)</code>","text":"<p>Checks if the input date is a business day.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The date to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the input date is a business day, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas\nFalse\n</code></pre> Notes <ul> <li>This function correctly identifies business days according to the applicable Brazilian holiday list (before or after the 2023-12-26 transition), based on the input <code>date</code>.</li> </ul> Source code in <code>pyield/bday.py</code> <pre><code>def is_business_day(date: DateScalar) -&gt; bool:\n    \"\"\"\n    Checks if the input date is a business day.\n\n    Args:\n        date (DateScalar): The date to check.\n\n    Returns:\n        bool: True if the input date is a business day, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas\n        False\n\n    Notes:\n        - This function correctly identifies business days according to the applicable\n        Brazilian holiday list (before or after the 2023-12-26 transition), based\n        on the input `date`.\n    \"\"\"\n    date_pd = dc.convert_input_dates(date)\n    shifted_date = offset(date_pd, 0)  # Shift the date if it is not a business day\n    return date_pd == shifted_date\n</code></pre>"},{"location":"bday/#pyield.bday.last_business_day","title":"<code>last_business_day()</code>","text":"<p>Returns the last business day in Brazil. If the current date is a business day, it returns the current date. If it is a weekend or holiday, it returns the last business day before the current date.</p> <p>Returns:</p> Type Description <code>date</code> <p>dt.date: The last business day in Brazil.</p> Notes <ul> <li>The determination of the last business day considers the correct Brazilian holiday list (before or after the 2023-12-26 transition) applicable to the current date.</li> </ul> Source code in <code>pyield/bday.py</code> <pre><code>def last_business_day() -&gt; dt.date:\n    \"\"\"\n    Returns the last business day in Brazil. If the current date is a business day, it\n    returns the current date. If it is a weekend or holiday, it returns the last\n    business day before the current date.\n\n    Returns:\n        dt.date: The last business day in Brazil.\n\n    Notes:\n        - The determination of the last business day considers the correct Brazilian\n        holiday list (before or after the 2023-12-26 transition) applicable to\n        the current date.\n\n    \"\"\"\n    # Get the current date in Brazil without timezone information\n    bz_today = dt.datetime.now(TIMEZONE_BZ).date()\n    result = offset(bz_today, 0, roll=\"backward\")\n    assert isinstance(result, dt.date), (\n        \"Assumption violated: offset did not return a date for the current date.\"\n    )\n    return result\n</code></pre>"},{"location":"bday/#pyield.bday.offset","title":"<code>offset(dates, offset, roll='forward')</code>","text":"<p>First adjusts the date to fall on a valid day according to the roll rule, then applies offsets to the given dates to the next or previous business day, considering brazilian holidays. This function supports both single dates and collections of dates. It is a wrapper for <code>numpy.busday_offset</code> adapted for Pandas data types and brazilian holidays.</p> <p>Important Note: Each date in the <code>dates</code> input is evaluated individually to determine which list of holidays applies to the calculation. Transition date is 2023-12-26, which means: - Dates before 2023-12-26 use the old holiday list. - Dates on or after 2023-12-26 use the new holiday list.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar | DateArray</code> <p>The date(s) to offset. Can be a scalar date type or a collection of dates. Transition Handling: Due to a change in Brazilian national holidays effective from 2023-12-26 (<code>TRANSITION_DATE</code>), this function automatically selects the appropriate holiday list (old or new) based on each individual date in the <code>dates</code> input. Dates before 2023-12-26 use the old list for their offset calculation, while dates on or after 2023-12-26 use the new list.</p> required <code>offset</code> <code>int | Series | ndarray | list[int] | tuple[int]</code> <p>The number of business days to offset the dates. Positive for future dates, negative for past dates. Zero will return the same date if it's a business day, or the next business day otherwise.</p> required <code>roll</code> <code>Literal['forward', 'backward']</code> <p>Direction to roll the date if it falls on a holiday or weekend. 'forward' to the next business day, 'backward' to the previous. Defaults to 'forward'.</p> <code>'forward'</code> <p>Returns:</p> Type Description <code>date | Series | None</code> <p>dt.date | pd.Series: If a single date is provided, returns a single <code>date</code> of the offset date. If a series of dates is provided, returns a <code>Series</code> of offset dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n</code></pre> <p>Offset to the next business day if not a bday (offset=0 and roll=\"forward\")</p> <p>Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\ndatetime.date(2023, 12, 26)\n</code></pre> <p>Offset Friday before Christmas (no offset because it's a business day)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")</p> <p>No offset because it's a business day</p> <pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Offset to the first business day before \"23-12-2023\"</p> <pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Jump to the next business day (1 offset and roll=\"forward\")</p> <p>Offset Friday to the next business day (Friday is jumped -&gt; Monday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\ndatetime.date(2024, 9, 30)\n</code></pre> <p>Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\ndatetime.date(2024, 10, 1)\n</code></pre> <p>Jump to the previous business day (-1 offset and roll=\"backward\")</p> <p>Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\ndatetime.date(2024, 9, 26)\n</code></pre> <p>Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\ndatetime.date(2024, 9, 26)\n</code></pre> <p>List of dates and offsets</p> <pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)  # a list of dates\n0   2024-09-20\n1   2024-09-23\ndtype: date32[day][pyarrow]\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\n0   2024-09-20\n1   2024-09-23\ndtype: date32[day][pyarrow]\n</code></pre> <p>Scalar null values are propagated</p> <pre><code>&gt;&gt;&gt; bday.offset(pd.NaT, 1)  # NaT input\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(pd.NaT, [1, 2])  # NaT input with a list of offsets\n0   &lt;NA&gt;\n1   &lt;NA&gt;\ndtype: date32[day][pyarrow]\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", pd.NaT], 1)  # NaT in a list of dates\n0   2024-09-20\n1   &lt;NA&gt;\ndtype: date32[day][pyarrow]\n</code></pre> <p>Original pandas index is preserved</p> <pre><code>&gt;&gt;&gt; dates = pd.Series(\n...     [\"19-09-2024\", \"20-09-2024\", \"21-09-2024\"],\n...     index=[\"a\", \"b\", \"c\"],\n... )\n&gt;&gt;&gt; bday.offset(dates, 1)\na   2024-09-20\nb   2024-09-23\nc   2024-09-24\ndtype: date32[day][pyarrow]\n</code></pre> Note <p>This function uses <code>numpy.busday_offset</code> under the hood, which means it follows the same conventions and limitations for business day calculations. For detailed information on error handling and behavior, refer to the <code>numpy.busday_offset</code> documentation: https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html</p> Source code in <code>pyield/bday.py</code> <pre><code>def offset(  # noqa\n    dates: DateScalar | DateArray,\n    offset: IntegerScalar | IntegerArray,\n    roll: Literal[\"forward\", \"backward\"] = \"forward\",\n) -&gt; dt.date | pd.Series | None:\n    \"\"\"\n    First adjusts the date to fall on a valid day according to the roll rule, then\n    applies offsets to the given dates to the next or previous business day, considering\n    brazilian holidays. This function supports both single dates and collections of\n    dates. It is a wrapper for `numpy.busday_offset` adapted for Pandas data types and\n    brazilian holidays.\n\n    **Important Note:** Each date in the `dates` input is evaluated individually to\n    determine which list of holidays applies to the calculation. Transition date\n    is 2023-12-26, which means:\n    - Dates before 2023-12-26 use the old holiday list.\n    - Dates on or after 2023-12-26 use the new holiday list.\n\n    Args:\n        dates (DateScalar | DateArray): The date(s) to offset. Can be a scalar date type\n            or a collection of dates. **Transition Handling:** Due to a change in\n            Brazilian national holidays effective from 2023-12-26 (`TRANSITION_DATE`),\n            this function automatically selects the appropriate holiday list\n            (old or new) based on **each individual date** in the `dates` input.\n            Dates before 2023-12-26 use the old list for their offset calculation,\n            while dates on or after 2023-12-26 use the new list.\n        offset (int | Series | np.ndarray | list[int] | tuple[int], optional):\n            The number of business days to offset the dates. Positive for future dates,\n            negative for past dates. Zero will return the same date if it's a business\n            day, or the next business day otherwise.\n        roll (Literal[\"forward\", \"backward\"], optional): Direction to roll the date if\n            it falls on a holiday or weekend. 'forward' to the next business day,\n            'backward' to the previous. Defaults to 'forward'.\n\n    Returns:\n        dt.date | pd.Series: If a single date is provided, returns a single\n            `date` of the offset date. If a series of dates is provided, returns a\n            `Series` of offset dates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n\n        Offset to the next business day if not a bday (offset=0 and roll=\"forward\")\n\n        Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\n        datetime.date(2023, 12, 26)\n\n        Offset Friday before Christmas (no offset because it's a business day)\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\n        datetime.date(2023, 12, 22)\n\n        Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")\n\n        No offset because it's a business day\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\n        datetime.date(2023, 12, 22)\n\n        Offset to the first business day before \"23-12-2023\"\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\n        datetime.date(2023, 12, 22)\n\n        Jump to the next business day (1 offset and roll=\"forward\")\n\n        Offset Friday to the next business day (Friday is jumped -&gt; Monday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\n        datetime.date(2024, 9, 30)\n\n        Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\n        datetime.date(2024, 10, 1)\n\n        Jump to the previous business day (-1 offset and roll=\"backward\")\n\n        Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\n        datetime.date(2024, 9, 26)\n\n        Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\n        datetime.date(2024, 9, 26)\n\n        List of dates and offsets\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)  # a list of dates\n        0   2024-09-20\n        1   2024-09-23\n        dtype: date32[day][pyarrow]\n\n        &gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\n        0   2024-09-20\n        1   2024-09-23\n        dtype: date32[day][pyarrow]\n\n        Scalar null values are propagated\n        &gt;&gt;&gt; bday.offset(pd.NaT, 1)  # NaT input\n\n        &gt;&gt;&gt; bday.offset(pd.NaT, [1, 2])  # NaT input with a list of offsets\n        0   &lt;NA&gt;\n        1   &lt;NA&gt;\n        dtype: date32[day][pyarrow]\n\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", pd.NaT], 1)  # NaT in a list of dates\n        0   2024-09-20\n        1   &lt;NA&gt;\n        dtype: date32[day][pyarrow]\n\n        Original pandas index is preserved\n        &gt;&gt;&gt; dates = pd.Series(\n        ...     [\"19-09-2024\", \"20-09-2024\", \"21-09-2024\"],\n        ...     index=[\"a\", \"b\", \"c\"],\n        ... )\n        &gt;&gt;&gt; bday.offset(dates, 1)\n        a   2024-09-20\n        b   2024-09-23\n        c   2024-09-24\n        dtype: date32[day][pyarrow]\n\n    Note:\n        This function uses `numpy.busday_offset` under the hood, which means it follows\n        the same conventions and limitations for business day calculations. For detailed\n        information on error handling and behavior, refer to the `numpy.busday_offset`\n        documentation:\n        https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html\n    \"\"\"\n    # Padroniza as entradas para objetos do Pandas\n    dates_pd = dc.convert_input_dates(dates)\n    if isinstance(offset, IntegerArray):\n        offset_pd = pd.Series(offset).astype(\"int64[pyarrow]\")\n    else:\n        offset_pd = offset\n\n    # 1. VALIDA\u00c7\u00c3O ESTRUTURAL\n    if isinstance(dates_pd, pd.Series) and isinstance(offset_pd, pd.Series):\n        if not dates_pd.index.equals(offset_pd.index):\n            raise ValueError(\"Input dates have different indices!\")\n\n    # 2. L\u00d3GICA PRINCIPAL\n\n    # --- CASO 1: AMBOS OS INPUTS S\u00c3O ESCALARES ---\n    if not isinstance(dates_pd, pd.Series) and not isinstance(offset_pd, pd.Series):\n        if pd.isna(dates_pd) or pd.isna(offset_pd):\n            return None\n\n        offsetted_date_np = np.busday_offset(\n            dates=dates_pd,\n            offsets=offset_pd,\n            roll=roll,\n            holidays=br_holidays.get_holiday_array(dates_pd),\n        )\n\n        assert isinstance(offsetted_date_np, np.datetime64), (\n            \"Assumption violated: np.busday_offset did not return a scalar \"\n            f\"np.datetime64 for scalar inputs. Got: {type(offsetted_date_np)}\"\n        )\n        return offsetted_date_np.item()\n\n    # --- CASO 2: PELO MENOS UM DOS INPUTS \u00c9 UMA S\u00c9RIE ---\n    # Garante que ambas as vari\u00e1veis sejam Series para alinhamento autom\u00e1tico.\n    # O Pandas faz o \"broadcast\" do escalar para o tamanho da Series.\n    if isinstance(offset_pd, pd.Series):\n        dates_pd = pd.Series(dates_pd, index=offset_pd.index, dtype=\"date32[pyarrow]\")\n    else:\n        offset_pd = pd.Series(offset_pd, index=dates_pd.index)\n\n    # Inicializa a s\u00e9rie de resultados com o \u00edndice correto e tipo que suporta NaT.\n    result = pd.Series(index=dates_pd.index, dtype=\"date32[pyarrow]\")\n\n    # Divide the input in order to apply the correct holiday list\n    mask_not_null = dates_pd.notna() &amp; offset_pd.notna()\n    mask_old_holidays = mask_not_null &amp; (dates_pd &lt; br_holidays.TRANSITION_DATE)\n    mask_new_holidays = mask_not_null &amp; (dates_pd &gt;= br_holidays.TRANSITION_DATE)\n\n    if mask_old_holidays.any():\n        np_offset_values = np.busday_offset(\n            dates=dc.to_numpy_date_type(dates_pd[mask_old_holidays]),\n            offsets=offset_pd[mask_old_holidays],\n            roll=roll,\n            holidays=OLD_HOLIDAYS_ARRAY,\n        )\n        pd_offset_values = pd.to_datetime(np_offset_values).astype(\"date32[pyarrow]\")\n        result.loc[mask_old_holidays] = pd_offset_values\n\n    if mask_new_holidays.any():\n        np_offset_values = np.busday_offset(\n            dates=dc.to_numpy_date_type(dates_pd[mask_new_holidays]),\n            offsets=offset_pd[mask_new_holidays],\n            roll=roll,\n            holidays=NEW_HOLIDAYS_ARRAY,\n        )\n        pd_offset_values = pd.to_datetime(np_offset_values).astype(\"date32[pyarrow]\")\n        result.loc[mask_new_holidays] = pd_offset_values\n\n    return result\n</code></pre>"},{"location":"di1/","title":"DI Futures Data","text":""},{"location":"di1/#pyield.b3.di1.available_trade_dates","title":"<code>available_trade_dates()</code>","text":"<p>Returns all unique end-of-day trade dates available in the DI dataset.</p> <p>Retrieves and lists all distinct 'TradeDate' values present in the historical DI futures data cache, sorted chronologically.</p> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A sorted Series of unique trade dates (dt.date)        for which DI data is available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # DI Futures series starts from 1995-01-02\n&gt;&gt;&gt; di1.available_trade_dates().head(5)\n0   1995-01-02\n1   1995-01-03\n2   1995-01-04\n3   1995-01-05\n4   1995-01-06\ndtype: date32[day][pyarrow]\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def available_trade_dates() -&gt; pd.Series:\n    \"\"\"\n    Returns all unique end-of-day trade dates available in the DI dataset.\n\n    Retrieves and lists all distinct 'TradeDate' values present in the\n    historical DI futures data cache, sorted chronologically.\n\n    Returns:\n        pd.Series: A sorted Series of unique trade dates (dt.date)\n                   for which DI data is available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # DI Futures series starts from 1995-01-02\n        &gt;&gt;&gt; di1.available_trade_dates().head(5)\n        0   1995-01-02\n        1   1995-01-03\n        2   1995-01-04\n        3   1995-01-05\n        4   1995-01-06\n        dtype: date32[day][pyarrow]\n    \"\"\"\n    available_dates = (\n        get_cached_dataset(\"di1\")\n        .drop_duplicates(subset=[\"TradeDate\"])[\"TradeDate\"]\n        .sort_values(ascending=True)\n        .reset_index(drop=True)\n    )\n    available_dates.name = None\n    return available_dates\n</code></pre>"},{"location":"di1/#pyield.b3.di1.data","title":"<code>data(dates, month_start=False, pre_filter=False, all_columns=True)</code>","text":"<p>Retrieves DI Futures contract data for a specific trade date.</p> <p>Provides access to DI futures data, allowing adjustments to expiration dates (to month start) and optional filtering based on LTN and NTN-F bond maturities.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar</code> <p>The trade dates for which to retrieve DI contract data.</p> required <code>month_start</code> <code>bool</code> <p>If True, adjusts all expiration dates to the first day of their respective month (e.g., 2025-02-01 becomes 2025-01-01). Defaults to False.</p> <code>False</code> <code>pre_filter</code> <code>bool</code> <p>If True, filters DI contracts to include only those whose expiration dates match known prefixed Treasury bond (LTN, NTN-F) maturities from the TPF dataset nearest to the given trade date. Defaults to False.</p> <code>False</code> <code>all_columns</code> <code>bool</code> <p>If True, returns all available columns from the DI dataset. If False, returns a subset of the most common columns. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the DI futures contract data for the specified dates, sorted by trade dates and expiration dates. Returns an empty DataFrame if no data is found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; df = di1.data(dates=\"16-10-2024\", month_start=True)\n&gt;&gt;&gt; df.iloc[:5, :5]  # Show the first five rows and columns\n   TradeDate ExpirationDate TickerSymbol  BDaysToExp  OpenContracts\n0 2024-10-16     2024-11-01       DI1X24          12        1744269\n1 2024-10-16     2024-12-01       DI1Z24          31        1429375\n2 2024-10-16     2025-01-01       DI1F25          52        5423969\n3 2024-10-16     2025-02-01       DI1G25          74         279491\n4 2024-10-16     2025-03-01       DI1H25          94         344056\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def data(\n    dates: DateScalar | DateArray,\n    month_start: bool = False,\n    pre_filter: bool = False,\n    all_columns: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves DI Futures contract data for a specific trade date.\n\n    Provides access to DI futures data, allowing adjustments to expiration dates\n    (to month start) and optional filtering based on LTN and NTN-F bond maturities.\n\n    Args:\n        dates (DateScalar): The trade dates for which to retrieve DI contract data.\n        month_start (bool, optional): If True, adjusts all expiration dates to the\n            first day of their respective month (e.g., 2025-02-01 becomes\n            2025-01-01). Defaults to False.\n        pre_filter (bool, optional): If True, filters DI contracts to include only\n            those whose expiration dates match known prefixed Treasury bond (LTN, NTN-F)\n            maturities from the TPF dataset nearest to the given trade date.\n            Defaults to False.\n        all_columns (bool, optional): If True, returns all available columns from\n            the DI dataset. If False, returns a subset of the most common columns.\n            Defaults to True.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the DI futures contract data for the\n            specified dates, sorted by trade dates and expiration dates.\n            Returns an empty DataFrame if no data is found\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; df = di1.data(dates=\"16-10-2024\", month_start=True)\n        &gt;&gt;&gt; df.iloc[:5, :5]  # Show the first five rows and columns\n           TradeDate ExpirationDate TickerSymbol  BDaysToExp  OpenContracts\n        0 2024-10-16     2024-11-01       DI1X24          12        1744269\n        1 2024-10-16     2024-12-01       DI1Z24          31        1429375\n        2 2024-10-16     2025-01-01       DI1F25          52        5423969\n        3 2024-10-16     2025-02-01       DI1G25          74         279491\n        4 2024-10-16     2025-03-01       DI1H25          94         344056\n    \"\"\"\n    dates = dc.convert_input_dates(dates)\n    # Force dates to be a Series for consistency\n    if isinstance(dates, dt.date):\n        dates = pd.Series([dates]).astype(\"date32[pyarrow]\")\n\n    # Remove duplicates and sort dates\n    dates = dates.drop_duplicates().sort_values().reset_index(drop=True)\n    df = _get_data(dates)\n    if df.empty:\n        logger.warning(\"No DI1 data found for the specified dates.\")\n        logger.warning(\"Returning empty DataFrame.\")\n        return pd.DataFrame()\n\n    if \"DaysToExpiration\" in df.columns:\n        df.drop(columns=[\"DaysToExpiration\"], inplace=True)\n\n    if pre_filter:\n        df_pre = (\n            get_cached_dataset(\"tpf\")\n            .query(\"BondType in ['LTN', 'NTN-F']\")\n            .drop_duplicates(subset=[\"ReferenceDate\", \"MaturityDate\"])\n            .sort_values([\"ReferenceDate\", \"MaturityDate\"])\n            .reset_index(drop=True)[[\"ReferenceDate\", \"MaturityDate\"]]\n            .rename(  # Rename columns for merging\n                columns={\"ReferenceDate\": \"TradeDate\", \"MaturityDate\": \"ExpirationDate\"}\n            )\n        )\n\n        # Verificar se existe a data de hoje no df_pre\n        today = dt.datetime.now(TIMEZONE_BZ).date()\n        if today in dates.values and today not in df_pre[\"TradeDate\"].values:\n            df_pre_today = df_pre.query(\"TradeDate == TradeDate.max()\").reset_index(\n                drop=True\n            )\n            df_pre_today[\"TradeDate\"] = today\n            df_pre_today[\"TradeDate\"] = df_pre_today[\"TradeDate\"].astype(\n                \"date32[pyarrow]\"\n            )\n            df_pre = pd.concat([df_pre, df_pre_today]).reset_index(drop=True)\n\n        # Assure that dates in ExpirationDate (maturity date) are business days\n        df_pre[\"ExpirationDate\"] = bday.offset(df_pre[\"ExpirationDate\"], 0).astype(\n            \"date32[pyarrow]\"\n        )\n\n        df = df.merge(df_pre, how=\"inner\", on=[\"TradeDate\", \"ExpirationDate\"])\n\n        if df.empty:\n            logger.warning(\n                \"No DI Futures data found for the specified dates after pre-filtering.\"\n                \"Returning empty DataFrame.\"\n            )\n            return pd.DataFrame()\n\n    if month_start:\n        df[\"ExpirationDate\"] = df[\"ExpirationDate\"].dt.floor(\"MS\")\n\n    if not all_columns:\n        cols = [\n            \"TradeDate\",\n            \"TickerSymbol\",\n            \"ExpirationDate\",\n            \"BDaysToExp\",\n            \"OpenContracts\",\n            \"TradeVolume\",\n            \"DV01\",\n            \"SettlementPrice\",\n            \"LastPrice\",\n            \"OpenRate\",\n            \"MinRate\",\n            \"MaxRate\",\n            \"CloseRate\",\n            \"SettlementRate\",\n            \"LastRate\",\n            \"ForwardRate\",\n        ]\n        selected_cols = [col for col in cols if col in df.columns]\n        df = df[selected_cols].copy()\n\n    return df.sort_values(by=[\"TradeDate\", \"ExpirationDate\"]).reset_index(drop=True)\n</code></pre>"},{"location":"di1/#pyield.b3.di1.interpolate_rate","title":"<code>interpolate_rate(date, expiration, extrapolate=False)</code>","text":"<p>Interpolates or retrieves the DI rate for a single expiration date.</p> <p>Fetches DI contract data for the specified trade <code>date</code> and determines the settlement rate for the given <code>expiration</code>. If an exact match for the expiration date exists, its rate is returned. Otherwise, the rate is interpolated using the flat-forward method based on the rates of surrounding contracts.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The trade date for which to retrieve DI data.</p> required <code>expiration</code> <code>DateScalar</code> <p>The target expiration date for the rate.</p> required <code>extrapolate</code> <code>bool</code> <p>If True, allows extrapolation if the <code>expiration</code> date falls outside the range of available contract expirations for the given <code>date</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The exact or interpolated DI settlement rate for the specified date and expiration. Returns <code>float('NaN')</code> if:     - No DI data is found for the <code>date</code>.     - The <code>expiration</code> is outside range and <code>extrapolate</code> is False.     - An interpolation calculation fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # Get rate for an existing contract expiration\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2027\")\n0.13901\n</code></pre> <pre><code>&gt;&gt;&gt; # Get rate for a non-existing contract expiration\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-11-2027\")\n0.13576348733268917\n</code></pre> <pre><code>&gt;&gt;&gt; # Extrapolate rate for a future expiration date\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2050\", extrapolate=True)\n0.13881\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def interpolate_rate(\n    date: DateScalar,\n    expiration: DateScalar,\n    extrapolate: bool = False,\n) -&gt; float:\n    \"\"\"\n    Interpolates or retrieves the DI rate for a single expiration date.\n\n    Fetches DI contract data for the specified trade `date` and determines the\n    settlement rate for the given `expiration`. If an exact match for the\n    expiration date exists, its rate is returned. Otherwise, the rate is\n    interpolated using the flat-forward method based on the rates of surrounding\n    contracts.\n\n    Args:\n        date (DateScalar): The trade date for which to retrieve DI data.\n        expiration (DateScalar): The target expiration date for the rate.\n        extrapolate (bool, optional): If True, allows extrapolation if the\n            `expiration` date falls outside the range of available contract\n            expirations for the given `date`. Defaults to False.\n\n    Returns:\n        float: The exact or interpolated DI settlement rate for the specified\n            date and expiration. Returns `float('NaN')` if:\n                - No DI data is found for the `date`.\n                - The `expiration` is outside range and `extrapolate` is False.\n                - An interpolation calculation fails.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # Get rate for an existing contract expiration\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2027\")\n        0.13901\n\n        &gt;&gt;&gt; # Get rate for a non-existing contract expiration\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-11-2027\")\n        0.13576348733268917\n\n        &gt;&gt;&gt; # Extrapolate rate for a future expiration date\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2050\", extrapolate=True)\n        0.13881\n    \"\"\"\n    date = dc.convert_input_dates(date)\n    expiration = dc.convert_input_dates(expiration)\n    if not date or not expiration:\n        return float(\"NaN\")\n\n    # Get the DI contract DataFrame\n    df = data(dates=date)\n\n    if df.empty:\n        return float(\"NaN\")\n\n    max_exp = df[\"ExpirationDate\"].max()\n\n    if expiration &gt; max_exp and not extrapolate:\n        logger.warning(\n            f\"Expiration date ({expiration}) is greater than the maximum expiration \"\n            f\"date ({max_exp}) and extrapolation is not allowed. Returning NaN.\"\n        )\n        return float(\"NaN\")\n\n    if expiration in df[\"ExpirationDate\"]:\n        rate = df.query(\"ExpirationDate == @expiration\")[\"SettlementRate\"]\n        return float(rate.iloc[0]) if not rate.empty else float(\"NaN\")\n\n    ff_interp = interpolator.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=df[\"BDaysToExp\"],\n        known_rates=df[\"SettlementRate\"],\n        extrapolate=extrapolate,\n    )\n    bd = bday.count(date, expiration)\n    if pd.isna(bd):\n        return float(\"NaN\")\n    return ff_interp(bd)\n</code></pre>"},{"location":"di1/#pyield.b3.di1.interpolate_rates","title":"<code>interpolate_rates(dates, expirations, extrapolate=True)</code>","text":"<p>Interpolates DI rates for specified trade dates and expiration dates.</p> <p>Calculates interpolated DI rates using the flat-forward method for given sets of trade dates and expiration dates. This function is well-suited for vectorized calculations across multiple date pairs.</p> <p>If DI rates are unavailable for a given trade date, the corresponding interpolated rate(s) will be NaN.</p> <p>Handles broadcasting: If one argument is a scalar and the other is an array, the scalar value is applied to all elements of the array.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar | DateArray</code> <p>The trade date(s) for the rates.</p> required <code>expirations</code> <code>DateScalar | DateArray</code> <p>The corresponding expiration date(s). Must be compatible in length with <code>dates</code> if both are arrays.</p> required <code>extrapolate</code> <code>bool</code> <p>Whether to allow extrapolation beyond the range of known DI rates for a given trade date. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the interpolated DI rates (as floats). Values will be NaN where interpolation is not possible (e.g., no DI data for the trade date).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dates</code> and <code>expirations</code> are both array-like but have different lengths.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # Note: by default, pandas shows floats with 6 decimal places\n&gt;&gt;&gt; # Interpolate rates for multiple trade and expiration dates\n&gt;&gt;&gt; # There is a contract with expiration 01-01-2027 in 08-05-2025\n&gt;&gt;&gt; # The rate is not interpolated (settlement rate is used)\n&gt;&gt;&gt; # There is no contract with expiration 25-11-2027 in 09-05-2025\n&gt;&gt;&gt; # The rate is interpolated (flat-forward method)\n&gt;&gt;&gt; # There is no data for trade date 10-05-2025 (Saturday) -&gt; NaN\n&gt;&gt;&gt; # Note: 0.13461282461562996 is shown as 0.134613\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=[\"08-05-2025\", \"09-05-2025\", \"10-05-2025\"],\n...     expirations=[\"01-01-2027\", \"25-11-2027\", \"01-01-2030\"],\n... )\n0    0.13972\n1    0.134613\n2    &lt;NA&gt;\ndtype: double[pyarrow]\n</code></pre> <pre><code>&gt;&gt;&gt; # Interpolate rates for a single trade date and multiple expiration dates\n&gt;&gt;&gt; # There is no DI Contract in 09-05-2025 with expiration 01-01-2050\n&gt;&gt;&gt; # The longest available contract is used to extrapolate the rate\n&gt;&gt;&gt; # Note: extrapolation is allowed by default\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=\"25-04-2025\",\n...     expirations=[\"01-01-2027\", \"01-01-2050\"],\n... )\n0    0.13901\n1    0.13881\ndtype: double[pyarrow]\n</code></pre> <pre><code>&gt;&gt;&gt; # With extrapolation set to False, the second rate will be NaN\n&gt;&gt;&gt; # Note: 0.13576348733268917 is shown as 0.135763\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=\"25-04-2025\",\n...     expirations=[\"01-11-2027\", \"01-01-2050\"],\n...     extrapolate=False,\n... )\n0    0.135763\n1    &lt;NA&gt;\ndtype: double[pyarrow]\n</code></pre> Notes <ul> <li>All available settlement rates are used for the flat-forward interpolation.</li> <li>The function handles broadcasting of scalar and array-like inputs.</li> </ul> Source code in <code>pyield/b3/di1.py</code> <pre><code>def interpolate_rates(\n    dates: DateScalar | DateArray,\n    expirations: DateScalar | DateArray,\n    extrapolate: bool = True,\n) -&gt; pd.Series:\n    \"\"\"\n    Interpolates DI rates for specified trade dates and expiration dates.\n\n    Calculates interpolated DI rates using the **flat-forward** method for given\n    sets of trade dates and expiration dates. This function is well-suited\n    for vectorized calculations across multiple date pairs.\n\n    If DI rates are unavailable for a given trade date, the corresponding\n    interpolated rate(s) will be NaN.\n\n    Handles broadcasting: If one argument is a scalar and the other is an array,\n    the scalar value is applied to all elements of the array.\n\n    Args:\n        dates (DateScalar | DateArray): The trade date(s) for the rates.\n        expirations (DateScalar | DateArray): The corresponding expiration date(s).\n            Must be compatible in length with `dates` if both are arrays.\n        extrapolate (bool, optional): Whether to allow extrapolation beyond the\n            range of known DI rates for a given trade date. Defaults to True.\n\n    Returns:\n        pd.Series: A Series containing the interpolated DI rates (as floats).\n            Values will be NaN where interpolation is not possible\n            (e.g., no DI data for the trade date).\n\n    Raises:\n        ValueError: If `dates` and `expirations` are both array-like but have\n            different lengths.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # Note: by default, pandas shows floats with 6 decimal places\n        &gt;&gt;&gt; # Interpolate rates for multiple trade and expiration dates\n        &gt;&gt;&gt; # There is a contract with expiration 01-01-2027 in 08-05-2025\n        &gt;&gt;&gt; # The rate is not interpolated (settlement rate is used)\n        &gt;&gt;&gt; # There is no contract with expiration 25-11-2027 in 09-05-2025\n        &gt;&gt;&gt; # The rate is interpolated (flat-forward method)\n        &gt;&gt;&gt; # There is no data for trade date 10-05-2025 (Saturday) -&gt; NaN\n        &gt;&gt;&gt; # Note: 0.13461282461562996 is shown as 0.134613\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=[\"08-05-2025\", \"09-05-2025\", \"10-05-2025\"],\n        ...     expirations=[\"01-01-2027\", \"25-11-2027\", \"01-01-2030\"],\n        ... )\n        0    0.13972\n        1    0.134613\n        2    &lt;NA&gt;\n        dtype: double[pyarrow]\n\n        &gt;&gt;&gt; # Interpolate rates for a single trade date and multiple expiration dates\n        &gt;&gt;&gt; # There is no DI Contract in 09-05-2025 with expiration 01-01-2050\n        &gt;&gt;&gt; # The longest available contract is used to extrapolate the rate\n        &gt;&gt;&gt; # Note: extrapolation is allowed by default\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=\"25-04-2025\",\n        ...     expirations=[\"01-01-2027\", \"01-01-2050\"],\n        ... )\n        0    0.13901\n        1    0.13881\n        dtype: double[pyarrow]\n\n        &gt;&gt;&gt; # With extrapolation set to False, the second rate will be NaN\n        &gt;&gt;&gt; # Note: 0.13576348733268917 is shown as 0.135763\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=\"25-04-2025\",\n        ...     expirations=[\"01-11-2027\", \"01-01-2050\"],\n        ...     extrapolate=False,\n        ... )\n        0    0.135763\n        1    &lt;NA&gt;\n        dtype: double[pyarrow]\n\n    Notes:\n        - All available settlement rates are used for the flat-forward interpolation.\n        - The function handles broadcasting of scalar and array-like inputs.\n    \"\"\"\n    # Convert input dates to a consistent format\n    dates = dc.convert_input_dates(dates)\n    expirations = dc.convert_input_dates(expirations)\n\n    # Ensure the lengths of input arrays are consistent\n    match (dates, expirations):\n        case dt.date(), pd.Series():\n            dfi = pd.DataFrame({\"mat\": expirations})\n            dfi[\"tdate\"] = dates\n\n        case pd.Series(), dt.date():\n            dfi = pd.DataFrame({\"tdate\": dates})\n            dfi[\"mat\"] = expirations\n\n        case pd.Series(), pd.Series():\n            if len(dates) != len(expirations):\n                raise ValueError(\"Args. should have the same length.\")\n            dfi = pd.DataFrame({\"tdate\": dates, \"mat\": expirations})\n\n        case dt.date(), dt.date():\n            dfi = pd.DataFrame({\"tdate\": [dates], \"mat\": [expirations]})\n\n    # Compute business days between reference dates and maturities\n    dfi[\"bdays\"] = bday.count(dfi[\"tdate\"], dfi[\"mat\"])\n\n    # Initialize the interpolated rate column with NaN\n    dfi[\"irate\"] = pd.NA\n    dfi[\"irate\"] = dfi[\"irate\"].astype(\"float64[pyarrow]\")\n\n    # Load DI rates dataset filtered by the provided reference dates\n    dfr = data(dates=dates)\n\n    # Return an empty DataFrame if no rates are found\n    if dfr.empty:\n        return pd.Series()\n\n    # Iterate over each unique reference date\n    for date in dfi[\"tdate\"].unique():\n        # Filter DI rates for the current reference date\n        dfr_subset = dfr.query(\"TradeDate == @date\").reset_index(drop=True)\n\n        # Skip processing if no rates are available for the current date\n        if dfr_subset.empty:\n            continue\n\n        # Initialize the interpolator with known rates and business days\n        interp = interpolator.Interpolator(\n            method=\"flat_forward\",\n            known_bdays=dfr_subset[\"BDaysToExp\"],\n            known_rates=dfr_subset[\"SettlementRate\"],\n            extrapolate=extrapolate,\n        )\n\n        # Apply interpolation to rows matching the current reference date\n        mask: pd.Series = dfi[\"tdate\"] == date\n        dfi.loc[mask, \"irate\"] = dfi.loc[mask, \"bdays\"].apply(interp)\n\n    # Return the Series with interpolated rates\n    dfi[\"irate\"].name = None\n    return dfi[\"irate\"]\n</code></pre>"},{"location":"forwards/","title":"Forwards","text":""},{"location":"forwards/#pyield.fwd.forward","title":"<code>forward(bday1, bday2, rate1, rate2)</code>","text":"<p>Calcula a taxa a termo (forward rate) entre dois prazos (dias \u00fateis).</p> Utiliza a f\u00f3rmula <p>f\u2081\u2192\u2082 = ((1 + r\u2082)^(du\u2082/252) / (1 + r\u2081)^(du\u2081/252))^(252/(du\u2082 - du\u2081)) - 1</p> Onde <ul> <li>r\u2081 \u00e9 a taxa zero para o primeiro prazo (du\u2081).</li> <li>r\u2082 \u00e9 a taxa zero para o segundo prazo (du\u2082).</li> <li>du\u2081 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a primeira data.</li> <li>du\u2082 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a segunda data.</li> <li>A constante 252 representa o n\u00famero de dias \u00fateis no ano.</li> </ul> <p>Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:</p> <pre><code>f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>bday1</code> <code>int</code> <p>N\u00famero de dias \u00fateis do primeiro ponto (prazo menor).</p> required <code>bday2</code> <code>int</code> <p>N\u00famero de dias \u00fateis do segundo ponto (prazo maior).</p> required <code>rate1</code> <code>float</code> <p>Taxa zero (spot rate) para o prazo <code>bday1</code>.</p> required <code>rate2</code> <code>float</code> <p>Taxa zero (spot rate) para o prazo <code>bday2</code>.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>A taxa a termo calculada entre <code>bday1</code> e <code>bday2</code>. Retorna <code>float('nan')</code> se <code>bday2 &lt;= bday1</code> ou se qualquer um dos argumentos de entrada for NaN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Exemplo v\u00e1lido: bday2 &gt; bday1\n&gt;&gt;&gt; yd.forward(10, 20, 0.05, 0.06)\n0.0700952380952371\n&gt;&gt;&gt; # Exemplo inv\u00e1lido: bday2 &lt;= bday1\n&gt;&gt;&gt; yd.forward(20, 10, 0.06, 0.05)\nnan\n&gt;&gt;&gt; yd.forward(10, 10, 0.05, 0.05)\nnan\n&gt;&gt;&gt; # Exemplo com NaN na entrada\n&gt;&gt;&gt; yd.forward(10, 20, 0.05, pd.NA)\nnan\n</code></pre> Note <p>\u00c9 fundamental que <code>bday2</code> seja estritamente maior que <code>bday1</code> para que o c\u00e1lculo da taxa a termo seja matematicamente v\u00e1lido.</p> <p>A f\u00f3rmula utilizada \u00e9 derivada da rela\u00e7\u00e3o entre taxas zero (spot rates) \u00e9: $$ f_{1 \\rightarrow 2} = \\left( \\frac{(1 + r_2)^{t_2}}{(1 + r_1)^{t_1}} \\right)^{\\frac{1}{t_2 - t_1}} - 1 $$</p> Source code in <code>pyield/fwd.py</code> <pre><code>def forward(\n    bday1: int,\n    bday2: int,\n    rate1: float,\n    rate2: float,\n) -&gt; float:\n    r\"\"\"\n    Calcula a taxa a termo (forward rate) entre dois prazos (dias \u00fateis).\n\n    Utiliza a f\u00f3rmula:\n        f\u2081\u2192\u2082 = ((1 + r\u2082)^(du\u2082/252) / (1 + r\u2081)^(du\u2081/252))^(252/(du\u2082 - du\u2081)) - 1\n\n    Onde:\n        - r\u2081 \u00e9 a taxa zero para o primeiro prazo (du\u2081).\n        - r\u2082 \u00e9 a taxa zero para o segundo prazo (du\u2082).\n        - du\u2081 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a primeira data.\n        - du\u2082 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a segunda data.\n        - A constante 252 representa o n\u00famero de dias \u00fateis no ano.\n\n    Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:\n\n        f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n\n    Args:\n        bday1 (int): N\u00famero de dias \u00fateis do primeiro ponto (prazo menor).\n        bday2 (int): N\u00famero de dias \u00fateis do segundo ponto (prazo maior).\n        rate1 (float): Taxa zero (spot rate) para o prazo `bday1`.\n        rate2 (float): Taxa zero (spot rate) para o prazo `bday2`.\n\n    Returns:\n        float: A taxa a termo calculada entre `bday1` e `bday2`. Retorna\n            `float('nan')` se `bday2 &lt;= bday1` ou se qualquer um dos\n            argumentos de entrada for NaN.\n\n    Examples:\n        &gt;&gt;&gt; # Exemplo v\u00e1lido: bday2 &gt; bday1\n        &gt;&gt;&gt; yd.forward(10, 20, 0.05, 0.06)\n        0.0700952380952371\n        &gt;&gt;&gt; # Exemplo inv\u00e1lido: bday2 &lt;= bday1\n        &gt;&gt;&gt; yd.forward(20, 10, 0.06, 0.05)\n        nan\n        &gt;&gt;&gt; yd.forward(10, 10, 0.05, 0.05)\n        nan\n        &gt;&gt;&gt; # Exemplo com NaN na entrada\n        &gt;&gt;&gt; yd.forward(10, 20, 0.05, pd.NA)\n        nan\n\n    Note:\n        \u00c9 fundamental que `bday2` seja estritamente maior que `bday1` para que\n        o c\u00e1lculo da taxa a termo seja matematicamente v\u00e1lido.\n\n    A f\u00f3rmula utilizada \u00e9 derivada da rela\u00e7\u00e3o entre taxas zero (spot rates) \u00e9:\n    $$\n    f_{1 \\rightarrow 2} = \\left( \\frac{(1 + r_2)^{t_2}}{(1 + r_1)^{t_1}} \\right)^{\\frac{1}{t_2 - t_1}} - 1\n    $$\n    \"\"\"  # noqa: E501\n    if pd.isna(rate1) or pd.isna(rate2) or pd.isna(bday1) or pd.isna(bday2):\n        # If any of the inputs are NaN, return NaN\n        return float(\"nan\")\n\n    # Handle the case where the two dates are the same\n    if bday2 &lt;= bday1:\n        return float(\"nan\")\n\n    # Convert business days to business years\n    t1 = bday1 / 252\n    t2 = bday2 / 252\n\n    # f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n    return ((1 + rate2) ** t2 / (1 + rate1) ** t1) ** (1 / (t2 - t1)) - 1\n</code></pre>"},{"location":"forwards/#pyield.fwd.forwards","title":"<code>forwards(bdays, rates, groupby_dates=None)</code>","text":"<p>Calcula taxas a termo (forward rates) a partir de taxas zero (spot rates).</p> <p>A taxa a termo no v\u00e9rtice 'n' \u00e9 definida como:     fwd\u2096 = fwd\u2c7c\u2192\u2096 (a taxa a termo de j para k)</p> A f\u00f3rmula utilizada \u00e9 <p>fwd\u2096 = ((1 + r\u2096)^(du\u2096/252) / (1 + r\u2c7c)^(du\u2c7c/252))^(252/(du\u2096 - du\u2c7c)) - 1</p> <p>Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:</p> <pre><code>fwd\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c)^(1/(t\u2096 - t\u2c7c)) - 1\n</code></pre> <p>Em LaTeX, a f\u00f3rmula \u00e9 representada como: $$ fwd_k = \\left( \\frac{(1 + r_k)^{t_k}}{(1 + r_j)^{t_j}} \\right)^{\\frac{1}{t_k - t_j}} - 1 $$</p> Onde <ul> <li>r\u2c7c \u00e9 a taxa zero para o v\u00e9rtice anterior.</li> <li>r\u2096 \u00e9 a taxa zero para o v\u00e9rtice atual.</li> <li>t\u2c7c \u00e9 o prazo em anos para o v\u00e9rtice anterior (calculado como du\u2c7c/252).</li> <li>t\u2096 \u00e9 o prazo em anos para o v\u00e9rtice atual (calculado como du\u2096/252).</li> <li>A constante 252 representa o n\u00famero de dias \u00fateis no ano.</li> </ul> <p>A primeira taxa a termo de cada grupo \u00e9 definida como a taxa zero desse primeiro v\u00e9rtice (fwd\u2081 = r\u2081), dado que n\u00e3o existe um v\u00e9rtice anterior a r\u2081 para se calcular a taxa a termo no primeiro ponto.</p> <p>Valores nulos nas taxas ou prazos de entrada resultar\u00e3o em valores nulos nas taxas a termo calculadas. A fun\u00e7\u00e3o tamb\u00e9m lida com agrupamentos opcionais, permitindo calcular taxas a termo para diferentes grupos de datas. O agrupamento \u00e9 feito com base na coluna <code>groupby_dates</code>, que deve ser fornecida como uma s\u00e9rie de pandas. Se <code>groupby_dates</code> for None, todos os dados ser\u00e3o tratados como um \u00fanico grupo. A fun\u00e7\u00e3o calcula as taxas a termo para todos os pontos, exceto o primeiro de cada grupo, que \u00e9 tratado separadamente.</p> <p>Parameters:</p> Name Type Description Default <code>bdays</code> <code>Series</code> <p>N\u00famero de dias \u00fateis para cada taxa zero.</p> required <code>rates</code> <code>Series</code> <p>Taxas zero correspondentes aos dias \u00fateis.</p> required <code>groupby_dates</code> <code>Series | None</code> <p>Crit\u00e9rio de agrupamento opcional para segmentar os c\u00e1lculos (ex: por data de refer\u00eancia). Se None, todos os dados s\u00e3o tratados como um \u00fanico grupo. Default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: S\u00e9rie contendo as taxas a termo calculadas (tipo Float64). A primeira taxa de cada grupo corresponde \u00e0 taxa zero inicial.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os \u00edndices de <code>bdays</code> e <code>rates</code> n\u00e3o forem iguais.</p> <code>ValueError</code> <p>Se <code>groupby_dates</code> n\u00e3o for None e n\u00e3o tiver o mesmo tamanho</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bdays = [10, 20, 30]\n&gt;&gt;&gt; rates = [0.05, 0.06, 0.07]\n&gt;&gt;&gt; yd.forwards(bdays, rates)\n0        0.05\n1    0.070095\n2    0.090284\ndtype: double[pyarrow]\n</code></pre> <pre><code>&gt;&gt;&gt; # Exemplo com agrupamento (a \u00faltima est\u00e1 isolada em outro grupo)\n&gt;&gt;&gt; groupby_dates = [1, 1, 2]\n&gt;&gt;&gt; yd.forwards(bdays, rates, groupby_dates)\n0    0.05\n1    0.070095\n2    0.07\ndtype: double[pyarrow]\n</code></pre> <pre><code>&gt;&gt;&gt; # Exemplo com taxas indicativas de NTN-B em 16-09-2025\n&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; df = ntnb.data(\"16-09-2025\")\n&gt;&gt;&gt; yd.forwards(df[\"BDToMat\"], df[\"IndicativeRate\"])\n0       0.0943\n1     0.071549\n2     0.072439\n3     0.069558\n4     0.076614\n5     0.076005\n6     0.071325\n7     0.069915\n8     0.068105\n9     0.071278\n10    0.069117\n11    0.070373\n12    0.073286\ndtype: double[pyarrow]\n</code></pre> <pre><code>&gt;&gt;&gt; # Valores nulos s\u00e3o descartados no c\u00e1lculo e retornados como nulos\n&gt;&gt;&gt; du = [230, 415, 730, None, 914]\n&gt;&gt;&gt; tx = [0.0943, 0.084099, 0.079052, 0.1, 0.077134]\n&gt;&gt;&gt; yd.forwards(du, tx)\n0      0.0943\n1    0.071549\n2    0.072439\n3        &lt;NA&gt;\n4    0.069558\ndtype: double[pyarrow]\n</code></pre> <pre><code>&gt;&gt;&gt; # O algoritmo ordena os dados de entrada antes do c\u00e1lculo e retorna\n&gt;&gt;&gt; # os resultados na ordem original. Valores duplicados s\u00e3o tratados\n&gt;&gt;&gt; # como um \u00fanico ponto no c\u00e1lculo da taxa a termo (\u00faltimo valor \u00e9 mantido).\n&gt;&gt;&gt; du = [230, 730, 415, 230]\n&gt;&gt;&gt; tx = [0.1, 0.079052, 0.084099, 0.0943]\n&gt;&gt;&gt; yd.forwards(du, tx)\n0      0.0943\n1    0.072439\n2    0.071549\n3      0.0943\ndtype: double[pyarrow]\n</code></pre> Note <ul> <li>A fun\u00e7\u00e3o ordena os dados de entrada primeiro por <code>groupby_dates</code>, se for fornecido, e depois por <code>bdays</code> para garantir a ordem cronol\u00f3gica correta no c\u00e1lculo das taxas a termo.</li> <li>Os resultados s\u00e3o retornados na mesma ordem dos dados de entrada.</li> </ul> Source code in <code>pyield/fwd.py</code> <pre><code>def forwards(\n    bdays: pd.Series | pl.Series | list[int] | tuple[int],\n    rates: pd.Series | pl.Series | list[float] | tuple[float],\n    groupby_dates: pd.Series | None = None,\n) -&gt; pd.Series:\n    r\"\"\"\n    Calcula taxas a termo (forward rates) a partir de taxas zero (spot rates).\n\n    A taxa a termo no v\u00e9rtice 'n' \u00e9 definida como:\n        fwd\u2096 = fwd\u2c7c\u2192\u2096 (a taxa a termo de j para k)\n\n    A f\u00f3rmula utilizada \u00e9:\n        fwd\u2096 = ((1 + r\u2096)^(du\u2096/252) / (1 + r\u2c7c)^(du\u2c7c/252))^(252/(du\u2096 - du\u2c7c)) - 1\n\n    Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:\n\n        fwd\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c)^(1/(t\u2096 - t\u2c7c)) - 1\n\n    Em LaTeX, a f\u00f3rmula \u00e9 representada como:\n    $$\n    fwd_k = \\left( \\frac{(1 + r_k)^{t_k}}{(1 + r_j)^{t_j}} \\right)^{\\frac{1}{t_k - t_j}} - 1\n    $$\n\n    Onde:\n        - r\u2c7c \u00e9 a taxa zero para o v\u00e9rtice anterior.\n        - r\u2096 \u00e9 a taxa zero para o v\u00e9rtice atual.\n        - t\u2c7c \u00e9 o prazo em anos para o v\u00e9rtice anterior (calculado como du\u2c7c/252).\n        - t\u2096 \u00e9 o prazo em anos para o v\u00e9rtice atual (calculado como du\u2096/252).\n        - A constante 252 representa o n\u00famero de dias \u00fateis no ano.\n\n    A primeira taxa a termo de cada grupo \u00e9 definida como a\n    taxa zero desse primeiro v\u00e9rtice (fwd\u2081 = r\u2081), dado que n\u00e3o existe um v\u00e9rtice\n    anterior a r\u2081 para se calcular a taxa a termo no primeiro ponto.\n\n    Valores nulos nas taxas ou prazos de entrada resultar\u00e3o em valores nulos\n    nas taxas a termo calculadas. A fun\u00e7\u00e3o tamb\u00e9m lida com agrupamentos\n    opcionais, permitindo calcular taxas a termo para diferentes grupos de\n    datas. O agrupamento \u00e9 feito com base na coluna `groupby_dates`, que\n    deve ser fornecida como uma s\u00e9rie de pandas. Se `groupby_dates` for None,\n    todos os dados ser\u00e3o tratados como um \u00fanico grupo.\n    A fun\u00e7\u00e3o calcula as taxas a termo para todos os pontos, exceto o primeiro\n    de cada grupo, que \u00e9 tratado separadamente.\n\n    Args:\n        bdays (pd.Series): N\u00famero de dias \u00fateis para cada taxa zero.\n        rates (pd.Series): Taxas zero correspondentes aos dias \u00fateis.\n        groupby_dates (pd.Series | None, optional): Crit\u00e9rio de agrupamento\n            opcional para segmentar os c\u00e1lculos (ex: por data de refer\u00eancia).\n            Se None, todos os dados s\u00e3o tratados como um \u00fanico grupo.\n            Default None.\n\n    Returns:\n        pd.Series: S\u00e9rie contendo as taxas a termo calculadas (tipo Float64).\n            A primeira taxa de cada grupo corresponde \u00e0 taxa zero inicial.\n\n    Raises:\n        ValueError: Se os \u00edndices de `bdays` e `rates` n\u00e3o forem iguais.\n        ValueError: Se `groupby_dates` n\u00e3o for None e n\u00e3o tiver o mesmo tamanho\n\n    Examples:\n        &gt;&gt;&gt; bdays = [10, 20, 30]\n        &gt;&gt;&gt; rates = [0.05, 0.06, 0.07]\n        &gt;&gt;&gt; yd.forwards(bdays, rates)\n        0        0.05\n        1    0.070095\n        2    0.090284\n        dtype: double[pyarrow]\n\n        &gt;&gt;&gt; # Exemplo com agrupamento (a \u00faltima est\u00e1 isolada em outro grupo)\n        &gt;&gt;&gt; groupby_dates = [1, 1, 2]\n        &gt;&gt;&gt; yd.forwards(bdays, rates, groupby_dates)\n        0    0.05\n        1    0.070095\n        2    0.07\n        dtype: double[pyarrow]\n\n        &gt;&gt;&gt; # Exemplo com taxas indicativas de NTN-B em 16-09-2025\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; df = ntnb.data(\"16-09-2025\")\n        &gt;&gt;&gt; yd.forwards(df[\"BDToMat\"], df[\"IndicativeRate\"])\n        0       0.0943\n        1     0.071549\n        2     0.072439\n        3     0.069558\n        4     0.076614\n        5     0.076005\n        6     0.071325\n        7     0.069915\n        8     0.068105\n        9     0.071278\n        10    0.069117\n        11    0.070373\n        12    0.073286\n        dtype: double[pyarrow]\n\n        &gt;&gt;&gt; # Valores nulos s\u00e3o descartados no c\u00e1lculo e retornados como nulos\n        &gt;&gt;&gt; du = [230, 415, 730, None, 914]\n        &gt;&gt;&gt; tx = [0.0943, 0.084099, 0.079052, 0.1, 0.077134]\n        &gt;&gt;&gt; yd.forwards(du, tx)\n        0      0.0943\n        1    0.071549\n        2    0.072439\n        3        &lt;NA&gt;\n        4    0.069558\n        dtype: double[pyarrow]\n\n        &gt;&gt;&gt; # O algoritmo ordena os dados de entrada antes do c\u00e1lculo e retorna\n        &gt;&gt;&gt; # os resultados na ordem original. Valores duplicados s\u00e3o tratados\n        &gt;&gt;&gt; # como um \u00fanico ponto no c\u00e1lculo da taxa a termo (\u00faltimo valor \u00e9 mantido).\n        &gt;&gt;&gt; du = [230, 730, 415, 230]\n        &gt;&gt;&gt; tx = [0.1, 0.079052, 0.084099, 0.0943]\n        &gt;&gt;&gt; yd.forwards(du, tx)\n        0      0.0943\n        1    0.072439\n        2    0.071549\n        3      0.0943\n        dtype: double[pyarrow]\n\n    Note:\n        - A fun\u00e7\u00e3o ordena os dados de entrada primeiro por `groupby_dates`,\n        se for fornecido, e depois por `bdays` para garantir a ordem cronol\u00f3gica\n        correta no c\u00e1lculo das taxas a termo.\n        - Os resultados s\u00e3o retornados na mesma ordem dos dados de entrada.\n    \"\"\"  # noqa: E501\n    # 1. Montar o DataFrame\n    # Criar coluna de agrupamento dummy se n\u00e3o for fornecida\n    groupby_dates_exp = pl.Series(groupby_dates) if groupby_dates is not None else 0\n    df_orig = pl.DataFrame(\n        {\n            \"du_k\": bdays,\n            \"rate_k\": rates,\n            \"groupby_date\": groupby_dates_exp,\n        }\n    )\n\n    # 3. Definir a f\u00f3rmula da taxa a termo\n    # f\u2096 = f\u2c7c\u2192\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c) ^ (1/(t\u2096 - t\u2c7c)) - 1\n    exp1 = (1 + pl.col(\"rate_k\")) ** pl.col(\"time_k\")  # (1 + r\u2096)^t\u2096\n    exp2 = (1 + pl.col(\"rate_j\")) ** pl.col(\"time_j\")  # (1 + r\u2c7c)^t\u2c7c\n    exp3 = 1 / (pl.col(\"time_k\") - pl.col(\"time_j\"))  # 1/(t\u2096 - t\u2c7c)\n    fwd_formula = (exp1 / exp2) ** exp3 - 1\n\n    # --- In\u00edcio da L\u00f3gica com Express\u00f5es (Lazy API) ---\n    df_fwd = (\n        df_orig.drop_nans()\n        .drop_nulls()\n        .unique(subset=[\"du_k\", \"groupby_date\"], keep=\"last\")\n        .sort([\"groupby_date\", \"du_k\"])\n        .with_columns(time_k=pl.col(\"du_k\") / 252)  # Criar coluna de tempo em anos\n        .with_columns(\n            # Calcular os valores deslocados (shift) dentro de cada grupo\n            rate_j=pl.col(\"rate_k\").shift(1).over(\"groupby_date\"),\n            time_j=pl.col(\"time_k\").shift(1).over(\"groupby_date\"),\n        )\n        .with_columns(fwd=fwd_formula)\n        .with_columns(\n            # Usar a taxa spot para a primeira entrada de cada grupo\n            fwd=pl.when(pl.col(\"time_j\").is_null())\n            .then(pl.col(\"rate_k\"))\n            .otherwise(pl.col(\"fwd\"))\n        )\n    )\n    s_fwd = (\n        df_orig.join(\n            df_fwd,\n            on=[\"du_k\", \"groupby_date\"],\n            how=\"left\",\n            maintain_order=\"left\",\n        )\n        .get_column(\"fwd\")\n        .to_pandas(use_pyarrow_extension_array=True)\n    )\n\n    s_fwd.name = None  # Remover o nome da s\u00e9rie\n    return s_fwd\n</code></pre>"},{"location":"futures/","title":"Futures Data","text":""},{"location":"futures/#pyield.futures.futures","title":"<code>futures(contract_code, date)</code>","text":"<p>Fetches data for a specified futures contract based on type and reference date.</p> <p>Parameters:</p> Name Type Description Default <code>contract_code</code> <code>str</code> <p>The B3 futures contract code identifying the derivative. Supported contract codes are: - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3. - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3. - \"FRC\": Forward Rate Agreement (FRA) from B3. - \"DAP\": DI x IPCA Spread Futures. - \"DOL\": U.S. Dollar Futures from B3. - \"WDO\": Mini U.S. Dollar Futures from B3. - \"IND\": Ibovespa Futures from B3. - \"WIN\": Mini Ibovespa Futures from B3.</p> required <code>date</code> <code>DateScalar</code> <p>The date for which to fetch the data. If the reference date is a string, it should be in 'DD-MM-YYYY' format.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the fetched data for the specified futures contract.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the futures contract code is not recognized or supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n    TradeDate TickerSymbol  ... SettlementRate  ForwardRate\n0  2024-05-31       DI1M24  ...        0.10399      0.10399\n1  2024-05-31       DI1N24  ...         0.1039     0.103896\n2  2024-05-31       DI1Q24  ...         0.1037     0.103517\n3  2024-05-31       DI1U24  ...         0.1036       0.1034\n...\n</code></pre> <pre><code>&gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n    TradeDate TickerSymbol  ... SettlementRate  ForwardRate\n0  2024-05-31       DAPM24  ...         0.0555       0.0555\n1  2024-05-31       DAPN24  ...        0.07524     0.086254\n2  2024-05-31       DAPQ24  ...         0.0885     0.106631\n3  2024-05-31       DAPU24  ...         0.0855     0.078171\n...\n</code></pre> Source code in <code>pyield/b3/futures/__init__.py</code> <pre><code>def futures(\n    contract_code: ContractOptions | str,\n    date: DateScalar,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches data for a specified futures contract based on type and reference date.\n\n    Args:\n        contract_code (str): The B3 futures contract code identifying the derivative.\n            Supported contract codes are:\n            - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3.\n            - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3.\n            - \"FRC\": Forward Rate Agreement (FRA) from B3.\n            - \"DAP\": DI x IPCA Spread Futures.\n            - \"DOL\": U.S. Dollar Futures from B3.\n            - \"WDO\": Mini U.S. Dollar Futures from B3.\n            - \"IND\": Ibovespa Futures from B3.\n            - \"WIN\": Mini Ibovespa Futures from B3.\n        date (DateScalar): The date for which to fetch the data.\n            If the reference date is a string, it should be in 'DD-MM-YYYY' format.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the fetched data for the specified futures\n            contract.\n\n    Raises:\n        ValueError: If the futures contract code is not recognized or supported.\n\n    Examples:\n        &gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n            TradeDate TickerSymbol  ... SettlementRate  ForwardRate\n        0  2024-05-31       DI1M24  ...        0.10399      0.10399\n        1  2024-05-31       DI1N24  ...         0.1039     0.103896\n        2  2024-05-31       DI1Q24  ...         0.1037     0.103517\n        3  2024-05-31       DI1U24  ...         0.1036       0.1034\n        ...\n\n        &gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n            TradeDate TickerSymbol  ... SettlementRate  ForwardRate\n        0  2024-05-31       DAPM24  ...         0.0555       0.0555\n        1  2024-05-31       DAPN24  ...        0.07524     0.086254\n        2  2024-05-31       DAPQ24  ...         0.0885     0.106631\n        3  2024-05-31       DAPU24  ...         0.0855     0.078171\n        ...\n    \"\"\"\n    converted_date = dc.convert_input_dates(date)\n    selected_contract = str(contract_code).upper()\n\n    if _is_trading_day(converted_date):\n        # \u00c9 um dia de negocia\u00e7\u00e3o intraday\n        time = dt.datetime.now(BZ_TIMEZONE).time()\n        if time &lt; INTRADAY_START_TIME:  # Mercado n\u00e3o est\u00e1 aberto ainda\n            logger.warning(\"Market is not open yet. Returning an empty DataFrame. \")\n            return pd.DataFrame()\n\n        # Existe a chance de que os dados consolidados estejam dispon\u00edveis ap\u00f3s as 20h\n        if time &gt;= HISTORICAL_START_TIME:\n            df_hist = _get_historical_data(selected_contract, converted_date)\n            if not df_hist.empty:\n                logger.info(\"Consolidated data is already available and will be used.\")\n                return df_hist\n\n        # Mercado est\u00e1 aberto e n\u00e3o h\u00e1 dados consolidados dispon\u00edveis ainda\n        return fetch_intraday_df(selected_contract)\n\n    else:  # \u00c9 um dia hist\u00f3rico\n        return _get_historical_data(selected_contract, converted_date)\n</code></pre>"},{"location":"ibge/","title":"IBGE Data","text":""},{"location":"ibge/#pyield.ibge.ipca_indexes","title":"<code>ipca_indexes(start, end)</code>","text":"<p>Retrieves the IPCA index values for a specified date range.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]</p> <p>Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date of the date range</p> required <code>end</code> <code>DateScalar</code> <p>The end date of the date range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ibge\n&gt;&gt;&gt; # Get the IPCA indexes for the first quarter of 2024\n&gt;&gt;&gt; df = ibge.ipca_indexes(\"01-01-2024\", \"31-03-2024\")\n</code></pre> Source code in <code>pyield/ibge/ipca.py</code> <pre><code>def ipca_indexes(start: DateScalar, end: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves the IPCA index values for a specified date range.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]\n\n    Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]\n\n    Args:\n        start (DateScalar): The start date of the date range\n        end (DateScalar): The end date of the date range\n\n    Returns:\n        pd.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ibge\n        &gt;&gt;&gt; # Get the IPCA indexes for the first quarter of 2024\n        &gt;&gt;&gt; df = ibge.ipca_indexes(\"01-01-2024\", \"31-03-2024\")\n    \"\"\"\n    start = convert_input_dates(start)\n    end = convert_input_dates(end)\n\n    start_date = start.strftime(\"%Y%m\")\n    end_date = end.strftime(\"%Y%m\")\n    api_url = f\"{IPCA_URL}{start_date}-{end_date}/variaveis/2266?localidades=N1[all]\"\n    data_dict = _fetch_series_data(api_url)\n\n    return _process_ipca_dataframe(data_dict)\n</code></pre>"},{"location":"ibge/#pyield.ibge.ipca_last_indexes","title":"<code>ipca_last_indexes(num_months=1)</code>","text":"<p>Retrieves the last IPCA index values for a specified number of months.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]</p> <p>Example: For the last 2 months, the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>Number of months to retrieve. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If num_months is 0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ibge\n&gt;&gt;&gt; # Get the last month's IPCA index\n&gt;&gt;&gt; df = ibge.ipca_last_indexes(1)\n&gt;&gt;&gt; # Get the last 3 months' IPCA indexes\n&gt;&gt;&gt; df = ibge.ipca_last_indexes(3)\n</code></pre> Source code in <code>pyield/ibge/ipca.py</code> <pre><code>def ipca_last_indexes(num_months: int = 1) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves the last IPCA index values for a specified number of months.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]\n\n    Example: For the last 2 months, the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]\n\n    Args:\n        num_months (int, optional): Number of months to retrieve. Defaults to 1.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Raises:\n        ValueError: If num_months is 0\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ibge\n        &gt;&gt;&gt; # Get the last month's IPCA index\n        &gt;&gt;&gt; df = ibge.ipca_last_indexes(1)\n        &gt;&gt;&gt; # Get the last 3 months' IPCA indexes\n        &gt;&gt;&gt; df = ibge.ipca_last_indexes(3)\n    \"\"\"\n    num_months = abs(num_months)\n    if num_months == 0:\n        raise ValueError(\"The number of months must be greater than 0.\")\n\n    api_url = f\"{IPCA_URL}-{num_months}/variaveis/2266?localidades=N1[all]\"\n    data_dict = _fetch_series_data(api_url)\n\n    return _process_ipca_dataframe(data_dict)\n</code></pre>"},{"location":"ibge/#pyield.ibge.ipca_last_rates","title":"<code>ipca_last_rates(num_months=1)</code>","text":"<p>Retrieves the last IPCA monthly rates for a specified number of months.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]</p> <p>Example: For the last 2 months, the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>Number of months to retrieve. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If num_months is 0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ibge\n&gt;&gt;&gt; # Get the last month's IPCA rate\n&gt;&gt;&gt; df = ibge.ipca_last_rates(1)\n&gt;&gt;&gt; # Get the last 3 months' IPCA rates\n&gt;&gt;&gt; df = ibge.ipca_last_rates(3)\n</code></pre> Source code in <code>pyield/ibge/ipca.py</code> <pre><code>def ipca_last_rates(num_months: int = 1) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves the last IPCA monthly rates for a specified number of months.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]\n\n    Example: For the last 2 months, the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]\n\n    Args:\n        num_months (int, optional): Number of months to retrieve. Defaults to 1.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Raises:\n        ValueError: If num_months is 0\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ibge\n        &gt;&gt;&gt; # Get the last month's IPCA rate\n        &gt;&gt;&gt; df = ibge.ipca_last_rates(1)\n        &gt;&gt;&gt; # Get the last 3 months' IPCA rates\n        &gt;&gt;&gt; df = ibge.ipca_last_rates(3)\n    \"\"\"\n    num_months = abs(num_months)\n    if num_months == 0:\n        raise ValueError(\"The number of months must be greater than 0.\")\n\n    api_url = f\"{IPCA_URL}-{num_months}/variaveis/63?localidades=N1[all]\"\n    data_dict = _fetch_series_data(api_url)\n\n    return _process_ipca_dataframe(data_dict, is_in_pct=True)\n</code></pre>"},{"location":"ibge/#pyield.ibge.ipca_rates","title":"<code>ipca_rates(start, end)</code>","text":"<p>Retrieves the IPCA monthly rates for a specified date range.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]</p> <p>Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date of the date range</p> required <code>end</code> <code>DateScalar</code> <p>The end date of the date range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns 'Period' and 'Rate'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ibge\n&gt;&gt;&gt; # Get the IPCA rates for the first quarter of 2024\n&gt;&gt;&gt; df = ibge.ipca_rates(\"01-01-2024\", \"31-03-2024\")\n</code></pre> Source code in <code>pyield/ibge/ipca.py</code> <pre><code>def ipca_rates(start: DateScalar, end: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves the IPCA monthly rates for a specified date range.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]\n\n    Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]\n\n    Args:\n        start (DateScalar): The start date of the date range\n        end (DateScalar): The end date of the date range\n\n    Returns:\n        pd.DataFrame: DataFrame with columns 'Period' and 'Rate'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ibge\n        &gt;&gt;&gt; # Get the IPCA rates for the first quarter of 2024\n        &gt;&gt;&gt; df = ibge.ipca_rates(\"01-01-2024\", \"31-03-2024\")\n    \"\"\"\n    start = convert_input_dates(start)\n    end = convert_input_dates(end)\n\n    start_date = start.strftime(\"%Y%m\")\n    end_date = end.strftime(\"%Y%m\")\n    api_url = f\"{IPCA_URL}{start_date}-{end_date}/variaveis/63?localidades=N1[all]\"\n    data_dict = _fetch_series_data(api_url)\n\n    return _process_ipca_dataframe(data_dict, is_in_pct=True)\n</code></pre>"},{"location":"interpolator/","title":"Interpolator","text":""},{"location":"interpolator/#pyield.interpolator.Interpolator","title":"<code>Interpolator(method, known_bdays, known_rates, extrapolate=False)</code>","text":"<p>Interpolator class for interest rate interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['flat_forward', 'linear']</code> <p>The interpolation method to use.</p> required <code>known_bdays</code> <code>Series | list[int]</code> <p>The known business days sequence.</p> required <code>known_rates</code> <code>Series | list[float]</code> <p>The known interest rates sequence.</p> required <code>extrapolate</code> <code>bool</code> <p>If True, extrapolates beyond known business days using the last available rate. Defaults to False, returning NaN for out-of-range values.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If known_bdays and known_rates do not have the same length.</p> <code>ValueError</code> <p>If the interpolation method is not recognized</p> Note <ul> <li>This class uses a 252 business days per year convention.</li> <li>Instances of this class are immutable. To modify the interpolation   settings, create a new instance.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import Interpolator\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n</code></pre> <p>Linear interpolation example:</p> <pre><code>&gt;&gt;&gt; linear = Interpolator(\"linear\", known_bdays, known_rates)\n&gt;&gt;&gt; linear(45)\n0.0475\n</code></pre> <p>Flat forward interpolation example:</p> <pre><code>&gt;&gt;&gt; fforward = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; fforward(45)\n0.04833068080970859\n</code></pre> Source code in <code>pyield/interpolator.py</code> <pre><code>def __init__(\n    self,\n    method: Literal[\"flat_forward\", \"linear\"],\n    known_bdays: pd.Series | np.ndarray | tuple[int] | list[int] | pl.Series,\n    known_rates: pd.Series | np.ndarray | tuple[float] | list[float] | pl.Series,\n    extrapolate: bool = False,\n):\n    df = (\n        pl.DataFrame({\"bday\": known_bdays, \"rate\": known_rates})\n        .with_columns(pl.col(\"bday\").cast(pl.Int64))\n        .with_columns(pl.col(\"rate\").cast(pl.Float64))\n        .drop_nulls()\n        .drop_nans()\n        .unique(subset=\"bday\", keep=\"last\")\n        .sort(\"bday\")\n    )\n    self._df = df\n    self._method = str(method)\n    self._known_bdays = tuple(df.get_column(\"bday\"))\n    self._known_rates = tuple(df.get_column(\"rate\"))\n    self._extrapolate = bool(extrapolate)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__call__","title":"<code>__call__(bday)</code>","text":"<p>Allows the instance to be called as a function to perform interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interest rate interpolated by the specified method for the given number of business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __call__(self, bday: int) -&gt; float:\n    \"\"\"\n    Allows the instance to be called as a function to perform interpolation.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for the given\n            number of business days.\n    \"\"\"\n    return self.interpolate(bday)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of known business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the number of known business days.\"\"\"\n    return len(self._df)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__repr__","title":"<code>__repr__()</code>","text":"<p>Textual representation, used in terminal or scripts.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Textual representation, used in terminal or scripts.\"\"\"\n    return repr(self._df)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.flat_forward","title":"<code>flat_forward(bday, k)</code>","text":"<p>Performs the interest rate interpolation using the flat forward method.</p> <p>This method calculates the interpolated interest rate for a given number of business days (<code>bday</code>) using the flat forward methodology, based on two known points: the current point (<code>k</code>) and the previous point (<code>j</code>).</p> <p>Assuming interest rates are in decimal form, the interpolated rate is calculated. Time is measured in years based on a 252-business-day year.</p> <p>The interpolated rate is given by the formula:</p> \\[ \\left(f_j*\\left(\\frac{f_k}{f_j}\\right)^{f_t}\\right)^{\\frac{1}{time}}-1 \\] <p>Where the factors used in the formula are defined as:</p> <ul> <li><code>f\u2c7c = (1 + rate\u2c7c)^time\u2c7c</code> is the compounding factor at point <code>j</code>.</li> <li><code>f\u2096 = (1 + rate\u2096)^time\u2096</code> is the compounding factor at point <code>k</code>.</li> <li><code>f\u209c = (time - time\u2c7c)/(time\u2096 - time\u2c7c)</code> is the time factor.</li> </ul> <p>And the variables are defined as:</p> <ul> <li><code>time = bday/252</code> is the time in years for the interpolated point. <code>bday</code> is  the number of business days for the interpolated point (input to this method).</li> <li><code>k</code> is the index of the current known point.</li> <li><code>time\u2096 = bday\u2096/252</code> is the time in years of point <code>k</code>.</li> <li><code>rate\u2096</code> is the interest rate (decimal) at point <code>k</code>.</li> <li><code>j</code> is the index of the previous known point (<code>k - 1</code>).</li> <li><code>time\u2c7c = bday\u2c7c/252</code> is the time in years of point <code>j</code>.</li> <li><code>rate\u2c7c</code> is the interest rate (decimal) at point <code>j</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of bus. days for which the rate is to be interpolated.</p> required <code>k</code> <code>int</code> <p>The index in the known_bdays and known_rates arrays such that      known_bdays[k-1] &lt; bday &lt; known_bdays[k]. This <code>k</code> corresponds      to the index of the next known point after <code>bday</code>.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interpolated interest rate in decimal form.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def flat_forward(self, bday: int, k: int) -&gt; float:\n    r\"\"\"\n    Performs the interest rate interpolation using the flat forward method.\n\n    This method calculates the interpolated interest rate for a given\n    number of business days (`bday`) using the flat forward methodology,\n    based on two known points: the current point (`k`) and the previous point (`j`).\n\n    Assuming interest rates are in decimal form, the interpolated rate\n    is calculated. Time is measured in years based on a 252-business-day year.\n\n    The interpolated rate is given by the formula:\n\n    $$\n    \\left(f_j*\\left(\\frac{f_k}{f_j}\\right)^{f_t}\\right)^{\\frac{1}{time}}-1\n    $$\n\n    Where the factors used in the formula are defined as:\n\n    * `f\u2c7c = (1 + rate\u2c7c)^time\u2c7c` is the compounding factor at point `j`.\n    * `f\u2096 = (1 + rate\u2096)^time\u2096` is the compounding factor at point `k`.\n    * `f\u209c = (time - time\u2c7c)/(time\u2096 - time\u2c7c)` is the time factor.\n\n    And the variables are defined as:\n\n    * `time = bday/252` is the time in years for the interpolated point. `bday` is\n     the number of business days for the interpolated point (input to this method).\n    * `k` is the index of the current known point.\n    * `time\u2096 = bday\u2096/252` is the time in years of point `k`.\n    * `rate\u2096` is the interest rate (decimal) at point `k`.\n    * `j` is the index of the previous known point (`k - 1`).\n    * `time\u2c7c = bday\u2c7c/252` is the time in years of point `j`.\n    * `rate\u2c7c` is the interest rate (decimal) at point `j`.\n\n    Args:\n        bday (int): Number of bus. days for which the rate is to be interpolated.\n        k (int): The index in the known_bdays and known_rates arrays such that\n                 known_bdays[k-1] &lt; bday &lt; known_bdays[k]. This `k` corresponds\n                 to the index of the next known point after `bday`.\n\n    Returns:\n        float: The interpolated interest rate in decimal form.\n    \"\"\"\n    rate_j = self._known_rates[k - 1]\n    time_j = self._known_bdays[k - 1] / 252\n    rate_k = self._known_rates[k]\n    time_k = self._known_bdays[k] / 252\n    time = bday / 252\n\n    # Perform flat forward interpolation\n    f_j = (1 + rate_j) ** time_j\n    f_k = (1 + rate_k) ** time_k\n    f_t = (time - time_j) / (time_k - time_j)\n    return (f_j * (f_k / f_j) ** f_t) ** (1 / time) - 1\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.interpolate","title":"<code>interpolate(bday)</code>","text":"<p>Finds the appropriate interpolation point and returns the interest rate interpolated by the specified method from that point.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interest rate interpolated by the specified method for the given number of business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bday: int) -&gt; float:\n    \"\"\"\n    Finds the appropriate interpolation point and returns the interest rate\n    interpolated by the specified method from that point.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for the given\n            number of business days.\n    \"\"\"\n    # Create local references to facilitate code readability\n    known_bdays = self._known_bdays\n    known_rates = self._known_rates\n    extrapolate = self._extrapolate\n    method = self._method\n\n    # Lower bound extrapolation is always the first known rate\n    if bday &lt; known_bdays[0]:\n        return known_rates[0]\n    # Upper bound extrapolation depends on the extrapolate flag\n    elif bday &gt; known_bdays[-1]:\n        return known_rates[-1] if extrapolate else float(\"NaN\")\n\n    # Find k such that known_bdays[k-1] &lt; bday &lt; known_bdays[k]\n    k = bisect.bisect_left(known_bdays, bday)\n\n    # If bday is one of the known points, return its rate directly\n    if k &lt; len(known_bdays) and known_bdays[k] == bday:\n        return known_rates[k]\n\n    if method == \"linear\":\n        return self.linear(bday, k)\n    elif method == \"flat_forward\":\n        return self.flat_forward(bday, k)\n\n    raise ValueError(f\"Interpolation method '{method}' not recognized.\")\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.linear","title":"<code>linear(bday, k)</code>","text":"<p>Performs the interest rate interpolation using the linear method.</p> <p>The interpolated rate is given by the formula: y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)</p> <p>Where: - (x, y) is the point to be interpolated (bday, interpolated_rate). - (x1, y1) is the previous known point (bday_j, rate_j). - (x2, y2) is the next known point (bday_k, rate_k).</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of bus. days for which the rate is to be interpolated.</p> required <code>k</code> <code>int</code> <p>The index such that known_bdays[k-1] &lt; bday &lt; known_bdays[k].</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interpolated interest rate in decimal form.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def linear(self, bday: int, k: int) -&gt; float:\n    \"\"\"\n    Performs the interest rate interpolation using the linear method.\n\n    The interpolated rate is given by the formula:\n    y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)\n\n    Where:\n    - (x, y) is the point to be interpolated (bday, interpolated_rate).\n    - (x1, y1) is the previous known point (bday_j, rate_j).\n    - (x2, y2) is the next known point (bday_k, rate_k).\n\n    Args:\n        bday (int): Number of bus. days for which the rate is to be interpolated.\n        k (int): The index such that known_bdays[k-1] &lt; bday &lt; known_bdays[k].\n\n    Returns:\n        float: The interpolated interest rate in decimal form.\n    \"\"\"\n    # Get the bracketing points for interpolation\n    bday_j, rate_j = self._known_bdays[k - 1], self._known_rates[k - 1]\n    bday_k, rate_k = self._known_bdays[k], self._known_rates[k]\n\n    # Perform linear interpolation\n    return rate_j + (bday - bday_j) * (rate_k - rate_j) / (bday_k - bday_j)\n</code></pre>"},{"location":"lft/","title":"LFT","text":""},{"location":"lft/#pyield.tn.lft.data","title":"<code>data(date)</code>","text":"<p>Fetch the LFT indicative rates for the given reference date from ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the following columns: - ReferenceDate: The reference date for the data. - BondType: The type of bond. - MaturityDate: The maturity date of the LFT bond. - IndicativeRate: The Anbima indicative rate for the LFT bond. - Price: The price of the LFT bond.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.data(\"23-08-2024\")\n   ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate    DIRate\n0     2024-08-23      LFT     210100  ...  0.000226       0.000272   0.10408\n1     2024-08-23      LFT     210100  ... -0.000481      -0.000418   0.11082\n2     2024-08-23      LFT     210100  ... -0.000258       -0.00023  0.114315\n3     2024-08-23      LFT     210100  ...   0.00006       0.000075  0.114982\n...\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the LFT indicative rates for the given reference date from ANBIMA.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the following columns:\n            - ReferenceDate: The reference date for the data.\n            - BondType: The type of bond.\n            - MaturityDate: The maturity date of the LFT bond.\n            - IndicativeRate: The Anbima indicative rate for the LFT bond.\n            - Price: The price of the LFT bond.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.data(\"23-08-2024\")\n           ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate    DIRate\n        0     2024-08-23      LFT     210100  ...  0.000226       0.000272   0.10408\n        1     2024-08-23      LFT     210100  ... -0.000481      -0.000418   0.11082\n        2     2024-08-23      LFT     210100  ... -0.000258       -0.00023  0.114315\n        3     2024-08-23      LFT     210100  ...   0.00006       0.000075  0.114982\n        ...\n    \"\"\"\n    return anbima.tpf_data(date, \"LFT\")\n</code></pre>"},{"location":"lft/#pyield.tn.lft.premium","title":"<code>premium(lft_rate, di_rate)</code>","text":"<p>Calculate the premium of the LFT bond over the DI Futures rate.</p> <p>Parameters:</p> Name Type Description Default <code>lft_rate</code> <code>float</code> <p>The annualized trading rate over the selic rate for the bond.</p> required <code>di_rate</code> <code>float</code> <p>The DI Futures annualized yield rate (interpolated to the same maturity as the LFT).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LFT bond over the DI Futures rate.</p> <p>Examples:</p> <p>Calculate the premium of a LFT in 28/04/2025</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft_rate = 0.001124  # 0.1124%\n&gt;&gt;&gt; di_rate = 0.13967670224373396  # 13.967670224373396%\n&gt;&gt;&gt; lft.premium(lft_rate, di_rate)\n1.008594331960501\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def premium(lft_rate: float, di_rate: float) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LFT bond over the DI Futures rate.\n\n    Args:\n        lft_rate (float): The annualized trading rate over the selic rate for the bond.\n        di_rate (float): The DI Futures annualized yield rate (interpolated to the same\n            maturity as the LFT).\n\n    Returns:\n        float: The premium of the LFT bond over the DI Futures rate.\n\n    Examples:\n        Calculate the premium of a LFT in 28/04/2025\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft_rate = 0.001124  # 0.1124%\n        &gt;&gt;&gt; di_rate = 0.13967670224373396  # 13.967670224373396%\n        &gt;&gt;&gt; lft.premium(lft_rate, di_rate)\n        1.008594331960501\n    \"\"\"\n    # daily rate\n    ltt_factor = (lft_rate + 1) ** (1 / 252)\n    di_factor = (di_rate + 1) ** (1 / 252)\n    return (ltt_factor * di_factor - 1) / (di_factor - 1)\n</code></pre>"},{"location":"lft/#pyield.tn.lft.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the quotation of a LFT bond using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the bond.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The annualized yield rate of the bond</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The quotation of the bond.</p> <p>Examples:</p> <p>Calculate the quotation of a LFT bond with a 0.02 yield rate:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.quotation(\n...     settlement=\"24-07-2024\",\n...     maturity=\"01-09-2030\",\n...     rate=0.001717,  # 0.1717%\n... )\n98.9645\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def quotation(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the quotation of a LFT bond using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date of the bond.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The annualized yield rate of the bond\n\n    Returns:\n        float: The quotation of the bond.\n\n    Examples:\n        Calculate the quotation of a LFT bond with a 0.02 yield rate:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.quotation(\n        ...     settlement=\"24-07-2024\",\n        ...     maturity=\"01-09-2030\",\n        ...     rate=0.001717,  # 0.1717%\n        ... )\n        98.9645\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # The number of bdays between settlement (inclusive) and the maturity (exclusive)\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = tools.truncate(bdays / 252, 14)\n\n    discount_factor = 1 / (1 + rate) ** num_of_years\n\n    return tools.truncate(100 * discount_factor, 4)\n</code></pre>"},{"location":"ltn/","title":"LTN","text":""},{"location":"ltn/#pyield.tn.ltn.data","title":"<code>data(date)</code>","text":"<p>Fetch the LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.data(\"23-08-2024\")\n  ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate   DIRate\n0    2024-08-23      LTN     100000  ...  0.104252       0.104416  0.10472\n1    2024-08-23      LTN     100000  ...  0.107016       0.107171  0.10823\n2    2024-08-23      LTN     100000  ...  0.110746       0.110866  0.11179\n3    2024-08-23      LTN     100000  ...  0.112947       0.113032  0.11365\n...\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.data(\"23-08-2024\")\n          ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate   DIRate\n        0    2024-08-23      LTN     100000  ...  0.104252       0.104416  0.10472\n        1    2024-08-23      LTN     100000  ...  0.107016       0.107171  0.10823\n        2    2024-08-23      LTN     100000  ...  0.110746       0.110866  0.11179\n        3    2024-08-23      LTN     100000  ...  0.112947       0.113032  0.11365\n        ...\n\n    \"\"\"\n    return anbima.tpf_data(date, \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.di_spreads","title":"<code>di_spreads(date)</code>","text":"<p>Calculates the DI spread for the LTN based on ANBIMA's indicative rates.</p> <p>This function fetches the indicative rates for the NTN-F bonds and the DI futures rates and calculates the spread between these rates in basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for the spread calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with the columns \"MaturityDate\" and \"DISpread\" (in bps).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; spreads = ltn.di_spreads(\"22-08-2024\")\n&gt;&gt;&gt; spreads[\"DISpread\"] = spreads[\"DISpread\"] * 10000  # Convert to bps\n&gt;&gt;&gt; spreads\n   MaturityDate  DISpread\n0    2024-10-01     -3.06\n1    2025-01-01     -9.95\n2    2025-04-01     -8.28\n3    2025-07-01      -6.1\n4    2025-10-01     -2.57\n5    2026-01-01     -1.57\n6    2026-04-01     -0.86\n7    2026-07-01      2.83\n8    2026-10-01      4.17\n9    2027-07-01      3.72\n10   2028-01-01      6.19\n11   2028-07-01      8.68\n12   2030-01-01     14.96\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def di_spreads(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the DI spread for the LTN based on ANBIMA's indicative rates.\n\n    This function fetches the indicative rates for the NTN-F bonds and the DI futures\n    rates and calculates the spread between these rates in basis points.\n\n    Parameters:\n        date (DateScalar, optional): The reference date for the\n            spread calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame with the columns \"MaturityDate\" and \"DISpread\" (in bps).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; spreads = ltn.di_spreads(\"22-08-2024\")\n        &gt;&gt;&gt; spreads[\"DISpread\"] = spreads[\"DISpread\"] * 10000  # Convert to bps\n        &gt;&gt;&gt; spreads\n           MaturityDate  DISpread\n        0    2024-10-01     -3.06\n        1    2025-01-01     -9.95\n        2    2025-04-01     -8.28\n        3    2025-07-01      -6.1\n        4    2025-10-01     -2.57\n        5    2026-01-01     -1.57\n        6    2026-04-01     -0.86\n        7    2026-07-01      2.83\n        8    2026-10-01      4.17\n        9    2027-07-01      3.72\n        10   2028-01-01      6.19\n        11   2028-07-01      8.68\n        12   2030-01-01     14.96\n    \"\"\"\n    # Fetch DI Spreads for the reference date\n    df = tools.pre_spreads(date)\n    df.query(\"BondType == 'LTN'\", inplace=True)\n    df.sort_values([\"MaturityDate\"], ignore_index=True, inplace=True)\n    return df[[\"MaturityDate\", \"DISpread\"]]\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.dv01","title":"<code>dv01(settlement, maturity, rate)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an LTN in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the LTN.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.dv01(\"26-03-2025\", \"01-01-2032\", 0.150970)\n0.2269059999999854\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def dv01(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an LTN in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a date-like object.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a date-like object.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the LTN.\n\n    Returns:\n        float: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.dv01(\"26-03-2025\", \"01-01-2032\", 0.150970)\n        0.2269059999999854\n    \"\"\"\n    price1 = price(settlement, maturity, rate)\n    price2 = price(settlement, maturity, rate + 0.0001)\n    return price1 - price2\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.historical_premium","title":"<code>historical_premium(date, maturity)</code>","text":"<p>Calculate the premium of the LTN bond over the DI Future rate for a given date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the rates.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the LTN bond.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LTN bond over the DI Future rate for the given date.    If the data is not available, returns NaN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.historical_premium(\"22-08-2024\", \"01-01-2030\")\n1.0120718007994287\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def historical_premium(\n    date: DateScalar,\n    maturity: DateScalar,\n) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LTN bond over the DI Future rate for a given date.\n\n    Args:\n        date (DateScalar): The reference date to fetch the rates.\n        maturity (DateScalar): The maturity date of the LTN bond.\n\n    Returns:\n        float: The premium of the LTN bond over the DI Future rate for the given date.\n               If the data is not available, returns NaN.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.historical_premium(\"22-08-2024\", \"01-01-2030\")\n        1.0120718007994287\n\n    \"\"\"\n    # Convert input dates to a consistent format\n    date = dc.convert_input_dates(date)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Retrieve LTN rates for the reference date\n    df_anbima = data(date)\n    if df_anbima.empty:\n        return float(\"NaN\")\n\n    # Extract the LTN rate for the specified maturity date\n    ltn_rates = df_anbima.query(\"MaturityDate == @maturity\")[\"IndicativeRate\"]\n    if ltn_rates.empty:\n        return float(\"NaN\")\n    ltn_rate = float(ltn_rates.iloc[0])\n\n    # Retrieve DI rate for the reference date and maturity\n    di_rate = di1.interpolate_rate(date=date, expiration=maturity, extrapolate=True)\n    if pd.isnull(di_rate):  # Check if the DI rate is NaN\n        return float(\"NaN\")\n\n    # Calculate and return the premium using the extracted rates\n    return premium(ltn_rate, di_rate)\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.maturities(\"22-08-2024\")\n0    2024-10-01\n1    2025-01-01\n2    2025-04-01\n3    2025-07-01\n4    2025-10-01\n5    2026-01-01\n6    2026-04-01\n7    2026-07-01\n8    2026-10-01\n9    2027-07-01\n10   2028-01-01\n11   2028-07-01\n12   2030-01-01\ndtype: date32[day][pyarrow]\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pd.Series:\n    \"\"\"\n    Fetch the bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series of bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.maturities(\"22-08-2024\")\n        0    2024-10-01\n        1    2025-01-01\n        2    2025-04-01\n        3    2025-07-01\n        4    2025-10-01\n        5    2026-01-01\n        6    2026-04-01\n        7    2026-07-01\n        8    2026-10-01\n        9    2027-07-01\n        10   2028-01-01\n        11   2028-07-01\n        12   2030-01-01\n        dtype: date32[day][pyarrow]\n\n    \"\"\"\n    df_rates = data(date)\n    s_maturities = df_rates[\"MaturityDate\"]\n    s_maturities.name = None\n    return s_maturities\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.premium","title":"<code>premium(ltn_rate, di_rate)</code>","text":"<p>Calculate the premium of the LTN bond over the DI Future rate using provided rates.</p> <p>Parameters:</p> Name Type Description Default <code>ltn_rate</code> <code>float</code> <p>The annualized LTN rate.</p> required <code>di_rate</code> <code>float</code> <p>The annualized DI Future rate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LTN bond over the DI Future rate.</p> <p>Examples:</p> <p>Reference date: 22-08-2024 LTN rate for 01-01-2030: 0.118746 DI (JAN30) Settlement rate: 0.11725</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.premium(0.118746, 0.11725)\n1.0120718007994287\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def premium(ltn_rate: float, di_rate: float) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LTN bond over the DI Future rate using provided rates.\n\n    Args:\n        ltn_rate (float): The annualized LTN rate.\n        di_rate (float): The annualized DI Future rate.\n\n    Returns:\n        float: The premium of the LTN bond over the DI Future rate.\n\n    Examples:\n        Reference date: 22-08-2024\n        LTN rate for 01-01-2030: 0.118746\n        DI (JAN30) Settlement rate: 0.11725\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.premium(0.118746, 0.11725)\n        1.0120718007994287\n    \"\"\"\n    # C\u00e1lculo das taxas di\u00e1rias\n    ltn_daily_rate = (1 + ltn_rate) ** (1 / 252) - 1\n    di_daily_rate = (1 + di_rate) ** (1 / 252) - 1\n\n    # Retorno do c\u00e1lculo do pr\u00eamio\n    return ltn_daily_rate / di_daily_rate\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the LTN price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-F.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The LTN price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n535.279902\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def price(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the LTN price using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a date-like object.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a date-like object.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-F.\n\n    Returns:\n        float: The LTN price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n        535.279902\n    \"\"\"\n\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rule\n    num_of_years = tools.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Truncate the price to 6 decimal places as per Anbima rules\n    return tools.truncate(FACE_VALUE / discount_factor, 6)\n</code></pre>"},{"location":"ntnb/","title":"NTN-B","text":""},{"location":"ntnb/#pyield.tn.ntnb.bei_rates","title":"<code>bei_rates(settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates)</code>","text":"<p>Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real interest rates. The BEI represents the inflation rate that equalizes the real and nominal yields. The calculation is based on the spot rates for NTN-B bonds.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>ntnb_maturities</code> <code>Series</code> <p>The maturity dates for the NTN-B bonds.</p> required <code>ntnb_rates</code> <code>Series</code> <p>The real interest rates (Yield to Maturity - YTM) corresponding to the given NTN-B maturities.</p> required <code>nominal_maturities</code> <code>Series</code> <p>The maturity dates to be used as reference for nominal rates.</p> required <code>nominal_rates</code> <code>Series</code> <p>The nominal interest rates (e.g. DI Futures or  zero prefixed bonds rates) used as reference for the calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the calculated breakeven inflation rates.</p> Returned columns <ul> <li>MaturityDate: The maturity date of the bonds.</li> <li>BDToMat: The number of business days from the settlement to the maturity.</li> <li>RIR: The calculated Real Interest Rates based on the spot rates.</li> <li>NIR: The Nominal Interest Rates interpolated for the maturity date.</li> <li>BEI: The calculated Breakeven Inflation Rates.</li> </ul> Notes <p>The BEI is calculated by comparing the nominal and real interest rates, indicating the market's inflation expectations over the period from the settlement date to the bond's maturity.</p> <p>Examples:</p> <p>Get the NTN-B rates for a specific reference date. These are YTM rates and the spot rates are calculated based on them</p> <pre><code>&gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n</code></pre> <p>Get the DI Futures settlement rates for the same reference date to be used as reference for the nominal rates:</p> <pre><code>&gt;&gt;&gt; df_di = yd.di1.data(\"05-09-2024\")\n</code></pre> <p>Calculate the BEI rates considering the settlement at the reference date:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.bei_rates(\n...     settlement=\"05-09-2024\",\n...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n...     nominal_maturities=df_di[\"ExpirationDate\"],\n...     nominal_rates=df_di[\"SettlementRate\"],\n... )\n   MaturityDate  BDToMat       RIR       NIR       BEI\n0    2025-05-15      171  0.061749  0.113836  0.049058\n1    2026-08-15      488  0.066133  0.117126   0.04783\n2    2027-05-15      673  0.063816  0.117169  0.050152\n3    2028-08-15      988  0.063635   0.11828  0.051376\n4    2029-05-15     1172  0.062532   0.11838  0.052561\n5    2030-08-15     1486  0.061809  0.118499   0.05339\n6    2032-08-15     1990  0.062135  0.118084  0.052676\n7    2033-05-15     2177  0.061897   0.11787   0.05271\n8    2035-05-15     2676  0.061711  0.117713  0.052747\n9    2040-08-15     3995  0.060468   0.11759  0.053865\n10   2045-05-15     5182    0.0625   0.11759   0.05185\n11   2050-08-15     6497  0.063016   0.11759  0.051339\n12   2055-05-15     7686  0.062252   0.11759  0.052095\n13   2060-08-15     9003  0.063001   0.11759  0.051354\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def bei_rates(\n    settlement: DateScalar,\n    ntnb_maturities: pd.Series,\n    ntnb_rates: pd.Series,\n    nominal_maturities: pd.Series,\n    nominal_rates: pd.Series,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real\n    interest rates. The BEI represents the inflation rate that equalizes the real and\n    nominal yields. The calculation is based on the spot rates for NTN-B bonds.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        ntnb_maturities (pd.Series): The maturity dates for the NTN-B bonds.\n        ntnb_rates (pd.Series): The real interest rates (Yield to Maturity - YTM)\n            corresponding to the given NTN-B maturities.\n        nominal_maturities (pd.Series): The maturity dates to be used as reference for\n            nominal rates.\n        nominal_rates (pd.Series): The nominal interest rates (e.g. DI Futures or\n             zero prefixed bonds rates) used as reference for the calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the calculated breakeven inflation rates.\n\n    Returned columns:\n        - MaturityDate: The maturity date of the bonds.\n        - BDToMat: The number of business days from the settlement to the maturity.\n        - RIR: The calculated Real Interest Rates based on the spot rates.\n        - NIR: The Nominal Interest Rates interpolated for the maturity date.\n        - BEI: The calculated Breakeven Inflation Rates.\n\n    Notes:\n        The BEI is calculated by comparing the nominal and real interest rates,\n        indicating the market's inflation expectations over the period from the\n        settlement date to the bond's maturity.\n\n    Examples:\n        Get the NTN-B rates for a specific reference date.\n        These are YTM rates and the spot rates are calculated based on them\n        &gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n\n        Get the DI Futures settlement rates for the same reference date to be used as\n        reference for the nominal rates:\n        &gt;&gt;&gt; df_di = yd.di1.data(\"05-09-2024\")\n\n        Calculate the BEI rates considering the settlement at the reference date:\n        &gt;&gt;&gt; yd.ntnb.bei_rates(\n        ...     settlement=\"05-09-2024\",\n        ...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n        ...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n        ...     nominal_maturities=df_di[\"ExpirationDate\"],\n        ...     nominal_rates=df_di[\"SettlementRate\"],\n        ... )\n           MaturityDate  BDToMat       RIR       NIR       BEI\n        0    2025-05-15      171  0.061749  0.113836  0.049058\n        1    2026-08-15      488  0.066133  0.117126   0.04783\n        2    2027-05-15      673  0.063816  0.117169  0.050152\n        3    2028-08-15      988  0.063635   0.11828  0.051376\n        4    2029-05-15     1172  0.062532   0.11838  0.052561\n        5    2030-08-15     1486  0.061809  0.118499   0.05339\n        6    2032-08-15     1990  0.062135  0.118084  0.052676\n        7    2033-05-15     2177  0.061897   0.11787   0.05271\n        8    2035-05-15     2676  0.061711  0.117713  0.052747\n        9    2040-08-15     3995  0.060468   0.11759  0.053865\n        10   2045-05-15     5182    0.0625   0.11759   0.05185\n        11   2050-08-15     6497  0.063016   0.11759  0.051339\n        12   2055-05-15     7686  0.062252   0.11759  0.052095\n        13   2060-08-15     9003  0.063001   0.11759  0.051354\n\n    \"\"\"\n    # Normalize input dates\n    settlement = dc.convert_input_dates(settlement)\n    ntnb_maturities = pd.to_datetime(ntnb_maturities, errors=\"coerce\", dayfirst=True)\n\n    # Calculate Real Interest Rate (RIR)\n    df = spot_rates(settlement, ntnb_maturities, ntnb_rates)\n    df[\"BDToMat\"] = bday.count(settlement, df[\"MaturityDate\"])\n    df = df.rename(columns={\"SpotRate\": \"RIR\"})\n\n    nir_interplator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, nominal_maturities),\n        known_rates=nominal_rates,\n        extrapolate=True,\n    )\n\n    df[\"NIR\"] = df[\"BDToMat\"].apply(nir_interplator).astype(\"float64[pyarrow]\")\n    # Calculate Breakeven Inflation Rate (BEI)\n    df[\"BEI\"] = ((df[\"NIR\"] + 1) / (df[\"RIR\"] + 1)) - 1\n\n    cols_reordered = [\n        \"MaturityDate\",\n        \"BDToMat\",\n        \"RIR\",\n        \"NIR\",\n        \"BEI\",\n    ]\n    return df[cols_reordered].copy()\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Generate the cash flows for NTN-B bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exclusive) to start generating the cash flows.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n  PaymentDate    CashFlow\n0  2024-05-15    2.956301\n1  2024-11-15    2.956301\n2  2025-05-15  102.956301\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def cash_flows(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-B bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (DateScalar): The settlement date (exclusive) to start generating\n            the cash flows.\n        maturity (DateScalar): The maturity date of the bond.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n          PaymentDate    CashFlow\n        0  2024-05-15    2.956301\n        1  2024-11-15    2.956301\n        2  2025-05-15  102.956301\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Get the coupon dates between the settlement and maturity dates\n    p_dates = payment_dates(settlement, maturity)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cfs = np.where(p_dates == maturity, FINAL_PMT, COUPON_PMT).tolist()\n\n    # Return a dataframe with the payment dates and cash flows\n    return pd.DataFrame(data={\"PaymentDate\": p_dates, \"CashFlow\": cfs})\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.data","title":"<code>data(date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> Returned columns <ul> <li>MaturityDate: The maturity date of the bond.</li> <li>IndicativeRate: The indicative rate for the bond.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.data(\"23-08-2024\")\n   ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate    DIRate\n0     2024-08-23    NTN-B     760199  ...  0.063667       0.063804  0.112749\n1     2024-08-23    NTN-B     760199  ...  0.065635       0.065795  0.114963\n2     2024-08-23    NTN-B     760199  ...  0.063601       0.063794  0.114888\n3     2024-08-23    NTN-B     760199  ...  0.062905       0.063094  0.115595\n...\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Returned columns:\n        - MaturityDate: The maturity date of the bond.\n        - IndicativeRate: The indicative rate for the bond.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.data(\"23-08-2024\")\n           ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate    DIRate\n        0     2024-08-23    NTN-B     760199  ...  0.063667       0.063804  0.112749\n        1     2024-08-23    NTN-B     760199  ...  0.065635       0.065795  0.114963\n        2     2024-08-23    NTN-B     760199  ...  0.063601       0.063794  0.114888\n        3     2024-08-23    NTN-B     760199  ...  0.062905       0.063094  0.115595\n        ...\n    \"\"\"\n    return anbima.tpf_data(date, \"NTN-B\")\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration of the NTN-B bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the duration.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration of the NTN-B bond in business years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.duration(\"23-08-2024\", \"15-08-2060\", 0.061005)\n15.083054313130464\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def duration(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration of the NTN-B bond in business years.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-B bond.\n        rate (float): The discount rate used to calculate the duration.\n\n    Returns:\n        float: The Macaulay duration of the NTN-B bond in business years.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.duration(\"23-08-2024\", \"15-08-2060\", 0.061005)\n        15.083054313130464\n    \"\"\"\n    # Return NaN if any input is NaN\n    if any(pd.isna(x) for x in [settlement, maturity, rate]):\n        return float(\"NaN\")\n\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    df = cash_flows(settlement, maturity)\n    df[\"BY\"] = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    df[\"DCF\"] = df[\"CashFlow\"] / (1 + rate) ** df[\"BY\"]\n    duration = (df[\"DCF\"] * df[\"BY\"]).sum() / df[\"DCF\"].sum()\n    # Return the duration as native float\n    return float(duration)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.dv01","title":"<code>dv01(settlement, maturity, rate, vna)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an NTN-B in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.dv01(\"26-03-2025\", \"15-08-2060\", 0.074358, 4470.979474)\n4.640875999999935\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def dv01(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n    vna: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an NTN-B in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a date-like object.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a date-like object.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n\n    Returns:\n        float: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.dv01(\"26-03-2025\", \"15-08-2060\", 0.074358, 4470.979474)\n        4.640875999999935\n    \"\"\"\n    quotation1 = quotation(settlement, maturity, rate)\n    quotation2 = quotation(settlement, maturity, rate + 0.0001)\n    price1 = price(vna, quotation1)\n    price2 = price(vna, quotation2)\n    return price1 - price2\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.maturities","title":"<code>maturities(date)</code>","text":"<p>Get the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series containing the maturity dates for the NTN-B bonds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.maturities(\"16-08-2024\")\n0    2025-05-15\n1    2026-08-15\n2    2027-05-15\n3    2028-08-15\n4    2029-05-15\n5    2030-08-15\n6    2032-08-15\n7    2033-05-15\n8    2035-05-15\n9    2040-08-15\n10   2045-05-15\n11   2050-08-15\n12   2055-05-15\n13   2060-08-15\ndtype: date32[day][pyarrow]\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pd.Series:\n    \"\"\"\n    Get the bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: Series containing the maturity dates for the NTN-B bonds.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.maturities(\"16-08-2024\")\n        0    2025-05-15\n        1    2026-08-15\n        2    2027-05-15\n        3    2028-08-15\n        4    2029-05-15\n        5    2030-08-15\n        6    2032-08-15\n        7    2033-05-15\n        8    2035-05-15\n        9    2040-08-15\n        10   2045-05-15\n        11   2050-08-15\n        12   2055-05-15\n        13   2060-08-15\n        dtype: date32[day][pyarrow]\n    \"\"\"\n    df_rates = data(date)\n    s_maturities = df_rates[\"MaturityDate\"]\n    s_maturities.name = None\n    return s_maturities\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. Coupon payments are made on the 15th of February, May, August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exlusive) to start generating the coupon dates.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series of coupon dates within the specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n0   2024-05-15\n1   2024-11-15\n2   2025-05-15\ndtype: date32[day][pyarrow]\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def payment_dates(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. Coupon payments are made on the 15th of February, May,\n    August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B\n    bond is determined by its maturity date.\n\n    Args:\n        settlement (DateScalar): The settlement date (exlusive) to start generating\n            the coupon dates.\n        maturity (DateScalar): The maturity date.\n\n    Returns:\n        pd.Series: Series of coupon dates within the specified range.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n        0   2024-05-15\n        1   2024-11-15\n        2   2025-05-15\n        dtype: date32[day][pyarrow]\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt; settlement:\n        raise ValueError(\"Maturity date must be after the start date.\")\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= pd.DateOffset(months=6)\n        coupon_date = coupon_date.date()  # DateOffset returns a Timestamp\n\n    coupon_dates = pd.Series(coupon_dates).astype(\"date32[pyarrow]\")\n    return coupon_dates.sort_values().reset_index(drop=True)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-B price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-B bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-B quotation in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n4271.864805\n&gt;&gt;&gt; ntnb.price(4315.498383, 100.6409)\n4343.156412\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B price using Anbima rules.\n\n    Args:\n        vna (float): The nominal value of the NTN-B bond.\n        quotation (float): The NTN-B quotation in base 100.\n\n    Returns:\n        float: The NTN-B price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n        4271.864805\n        &gt;&gt;&gt; ntnb.price(4315.498383, 100.6409)\n        4343.156412\n    \"\"\"\n    return bt.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-B quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B quotation truncated to 4 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n&gt;&gt;&gt; ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n100.6409\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def quotation(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-B bond.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n\n    Returns:\n        float: The NTN-B quotation truncated to 4 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n        99.3651\n        &gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n        99.5341\n        &gt;&gt;&gt; ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n        100.6409\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    cf_df = cash_flows(settlement, maturity)\n    cf_dates = cf_df[\"PaymentDate\"]\n    cf_values = cf_df[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = bt.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return bt.truncate(cf_present_value.sum(), 4)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.spot_rates","title":"<code>spot_rates(settlement, maturities, rates, show_coupons=False)</code>","text":"<p>Calculate the spot rates for NTN-B bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The reference date for settlement.</p> required <code>maturities</code> <code>Series</code> <p>Series of maturity dates for the bonds.</p> required <code>rates</code> <code>Series</code> <p>Series of yield to maturity rates.</p> required <code>show_coupons</code> <code>bool</code> <p>If True, the result will include the intermediate coupon dates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; # Get the NTN-B rates for a specific reference date\n&gt;&gt;&gt; df = ntnb.data(\"16-08-2024\")\n&gt;&gt;&gt; # Calculate the spot rates considering the settlement at the reference date\n&gt;&gt;&gt; ntnb.spot_rates(\n...     settlement=\"16-08-2024\",\n...     maturities=df[\"MaturityDate\"],\n...     rates=df[\"IndicativeRate\"],\n... )\n   MaturityDate  BDToMat  SpotRate\n0    2025-05-15      185  0.063894\n1    2026-08-15      502  0.066141\n2    2027-05-15      687  0.064087\n3    2028-08-15     1002  0.063057\n4    2029-05-15     1186  0.061458\n5    2030-08-15     1500  0.059491\n6    2032-08-15     2004  0.059652\n7    2033-05-15     2191  0.059497\n8    2035-05-15     2690  0.059151\n9    2040-08-15     4009  0.058326\n10   2045-05-15     5196  0.060371\n11   2050-08-15     6511  0.060772\n12   2055-05-15     7700  0.059909\n13   2060-08-15     9017  0.060652\n</code></pre> Notes <p>The calculation of the spot rates for NTN-B bonds considers the following steps:     - Map all all possible payment dates up to the longest maturity date.     - Interpolate the YTM rates in the intermediate payment dates.     - Calculate the NTN-B quotation for each maturity date.     - Calculate the real spot rates for each maturity date.     - Columns in the returned DataFrame:         - MaturityDate: The maturity date of the bond.         - BDToMat: The number of business days from settlement to maturities.         - SpotRate: The real spot rate for the bond.</p> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def spot_rates(\n    settlement: DateScalar,\n    maturities: pd.Series,\n    rates: pd.Series,\n    show_coupons: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the spot rates for NTN-B bonds using the bootstrap method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price.\n\n    Args:\n        settlement (DateScalar): The reference date for settlement.\n        maturities (pd.Series): Series of maturity dates for the bonds.\n        rates (pd.Series): Series of yield to maturity rates.\n        show_coupons (bool, optional): If True, the result will include the\n            intermediate coupon dates. Defaults to False.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; # Get the NTN-B rates for a specific reference date\n        &gt;&gt;&gt; df = ntnb.data(\"16-08-2024\")\n        &gt;&gt;&gt; # Calculate the spot rates considering the settlement at the reference date\n        &gt;&gt;&gt; ntnb.spot_rates(\n        ...     settlement=\"16-08-2024\",\n        ...     maturities=df[\"MaturityDate\"],\n        ...     rates=df[\"IndicativeRate\"],\n        ... )\n           MaturityDate  BDToMat  SpotRate\n        0    2025-05-15      185  0.063894\n        1    2026-08-15      502  0.066141\n        2    2027-05-15      687  0.064087\n        3    2028-08-15     1002  0.063057\n        4    2029-05-15     1186  0.061458\n        5    2030-08-15     1500  0.059491\n        6    2032-08-15     2004  0.059652\n        7    2033-05-15     2191  0.059497\n        8    2035-05-15     2690  0.059151\n        9    2040-08-15     4009  0.058326\n        10   2045-05-15     5196  0.060371\n        11   2050-08-15     6511  0.060772\n        12   2055-05-15     7700  0.059909\n        13   2060-08-15     9017  0.060652\n\n    Notes:\n        The calculation of the spot rates for NTN-B bonds considers the following steps:\n            - Map all all possible payment dates up to the longest maturity date.\n            - Interpolate the YTM rates in the intermediate payment dates.\n            - Calculate the NTN-B quotation for each maturity date.\n            - Calculate the real spot rates for each maturity date.\n            - Columns in the returned DataFrame:\n                - MaturityDate: The maturity date of the bond.\n                - BDToMat: The number of business days from settlement to maturities.\n                - SpotRate: The real spot rate for the bond.\n    \"\"\"\n    # Process and validate the input data\n    settlement = dc.convert_input_dates(settlement)\n    maturities = dc.convert_input_dates(maturities)\n\n    # Create the interpolator to calculate the YTM rates for intermediate dates\n    ff_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, maturities),\n        known_rates=rates,\n    )\n\n    # Generate coupon dates up to the longest maturity date\n    all_coupon_dates = _generate_all_coupon_dates(\n        start=settlement, end=maturities.max()\n    )\n\n    # Create a DataFrame with all coupon dates and the corresponding YTM\n    df = pd.DataFrame(data=all_coupon_dates, columns=[\"MaturityDate\"])\n    df[\"BDToMat\"] = bday.count(settlement, df[\"MaturityDate\"])\n    df[\"BYears\"] = df[\"BDToMat\"] / 252\n    df[\"YTM\"] = df[\"BDToMat\"].apply(ff_interpolator)\n    df[\"Coupon\"] = COUPON_PMT\n    df[\"SpotRate\"] = np.nan\n\n    # The Bootstrap loop to calculate spot rates\n    for index, row in df.iterrows():\n        # Get the cash flow dates for the bond\n        cf_dates = payment_dates(settlement, row[\"MaturityDate\"])\n\n        # If there is only one cash flow date, it means the bond is a single payment\n        # bond, so the spot rate is equal to the YTM rate\n        if len(cf_dates) == 1:\n            df.at[index, \"SpotRate\"] = row[\"YTM\"]\n            continue\n\n        # Calculate the present value of the cash flows without last payment\n        cf_dates = cf_dates[:-1]\n        cf_df = df.query(\"MaturityDate in @cf_dates\").reset_index(drop=True)\n        cf_present_value = bt.calculate_present_value(\n            cash_flows=cf_df[\"Coupon\"],\n            rates=cf_df[\"SpotRate\"],\n            periods=cf_df[\"BYears\"],\n        )\n\n        # Calculate the Spot Rate for the bond\n        bond_price = quotation(settlement, row[\"MaturityDate\"], row[\"YTM\"])\n        price_factor = FINAL_PMT / (bond_price - cf_present_value)\n        df.at[index, \"SpotRate\"] = price_factor ** (1 / row[\"BYears\"]) - 1\n\n    df = df[[\"MaturityDate\", \"BDToMat\", \"SpotRate\"]].copy()\n    # Force float64 type in float columns to standardize the output\n    df[\"SpotRate\"] = df[\"SpotRate\"].astype(\"float64[pyarrow]\")\n\n    # Filter the result without the intermediate coupon dates (virtual bonds)\n    if not show_coupons:\n        df = df.query(\"MaturityDate in @maturities\").reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"ntnc/","title":"NTN-C","text":""},{"location":"ntnc/#pyield.tn.ntnc.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Generate the cash flows for NTN-C bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exclusive) to start generating the cash flows.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.cash_flows(\"21-03-2025\", \"01-01-2031\")\n   PaymentDate    CashFlow\n0   2025-07-01    5.830052\n1   2026-01-01    5.830052\n2   2026-07-01    5.830052\n3   2027-01-01    5.830052\n4   2027-07-01    5.830052\n5   2028-01-01    5.830052\n6   2028-07-01    5.830052\n7   2029-01-01    5.830052\n8   2029-07-01    5.830052\n9   2030-01-01    5.830052\n10  2030-07-01    5.830052\n11  2031-01-01  105.830052\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def cash_flows(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-C bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (DateScalar): The settlement date (exclusive) to start generating\n            the cash flows.\n        maturity (DateScalar): The maturity date of the bond.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.cash_flows(\"21-03-2025\", \"01-01-2031\")\n           PaymentDate    CashFlow\n        0   2025-07-01    5.830052\n        1   2026-01-01    5.830052\n        2   2026-07-01    5.830052\n        3   2027-01-01    5.830052\n        4   2027-07-01    5.830052\n        5   2028-01-01    5.830052\n        6   2028-07-01    5.830052\n        7   2029-01-01    5.830052\n        8   2029-07-01    5.830052\n        9   2030-01-01    5.830052\n        10  2030-07-01    5.830052\n        11  2031-01-01  105.830052\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Get the coupon dates between the settlement and maturity dates\n    p_dates = payment_dates(settlement, maturity)\n\n    # Get the right coupon payment and final payment values\n    coupon_pmt = _get_coupon_pmt(maturity)\n    final_pmt = _get_final_pmt(maturity)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cfs = np.where(p_dates == maturity, final_pmt, coupon_pmt).tolist()\n\n    # Return a dataframe with the payment dates and cash flows\n    return pd.DataFrame(data={\"PaymentDate\": p_dates, \"CashFlow\": cfs})\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.data","title":"<code>data(date)</code>","text":"<p>Fetch the LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.data(\"23-08-2024\")\n  ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate   DIRate\n0    2024-08-23    NTN-C     770100  ...  0.057587       0.059617  0.11575\n...\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.data(\"23-08-2024\")\n          ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate   DIRate\n        0    2024-08-23    NTN-C     770100  ...  0.057587       0.059617  0.11575\n        ...\n    \"\"\"\n    return anbima.tpf_data(date, \"NTN-C\")\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration of the NTN-C bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-C bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the duration.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration of the NTN-C bond in business years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.duration(\"21-03-2025\", \"01-01-2031\", 0.067626)\n4.405363320448003\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def duration(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration of the NTN-C bond in business years.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-C bond.\n        rate (float): The discount rate used to calculate the duration.\n\n    Returns:\n        float: The Macaulay duration of the NTN-C bond in business years.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.duration(\"21-03-2025\", \"01-01-2031\", 0.067626)\n        4.405363320448003\n    \"\"\"\n    # Return NaN if any input is NaN\n    if any(pd.isna(x) for x in [settlement, maturity, rate]):\n        return float(\"NaN\")\n\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    df = cash_flows(settlement, maturity)\n    df[\"BY\"] = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    df[\"DCF\"] = df[\"CashFlow\"] / (1 + rate) ** df[\"BY\"]\n    duration = (df[\"DCF\"] * df[\"BY\"]).sum() / df[\"DCF\"].sum()\n    # Return the duration as native float\n    return float(duration)\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. The NTN-C bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exlusive) to start generating the coupon dates.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series of coupon dates within the specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.payment_dates(\"21-03-2025\", \"01-01-2031\")\n0    2025-07-01\n1    2026-01-01\n2    2026-07-01\n3    2027-01-01\n4    2027-07-01\n5    2028-01-01\n6    2028-07-01\n7    2029-01-01\n8    2029-07-01\n9    2030-01-01\n10   2030-07-01\n11   2031-01-01\ndtype: date32[day][pyarrow]\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def payment_dates(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. The NTN-C bond is determined by its maturity date.\n\n    Args:\n        settlement (DateScalar): The settlement date (exlusive) to start generating\n            the coupon dates.\n        maturity (DateScalar): The maturity date.\n\n    Returns:\n        pd.Series: Series of coupon dates within the specified range.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.payment_dates(\"21-03-2025\", \"01-01-2031\")\n        0    2025-07-01\n        1    2026-01-01\n        2    2026-07-01\n        3    2027-01-01\n        4    2027-07-01\n        5    2028-01-01\n        6    2028-07-01\n        7    2029-01-01\n        8    2029-07-01\n        9    2030-01-01\n        10   2030-07-01\n        11   2031-01-01\n        dtype: date32[day][pyarrow]\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt; settlement:\n        raise ValueError(\"Maturity date must be after the start date.\")\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= pd.DateOffset(months=6)\n        coupon_date = coupon_date.date()  # DateOffset returns a Timestamp\n\n    coupon_dates = pd.Series(coupon_dates).astype(\"date32[pyarrow]\")\n    return coupon_dates.sort_values().reset_index(drop=True)\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-C price using Anbima rules.</p> <p>price = VNA * quotation / 100</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-C bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-C quotation in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-C price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.price(6598.913723, 126.4958)\n8347.348705\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-C price using Anbima rules.\n\n    price = VNA * quotation / 100\n\n    Args:\n        vna (float): The nominal value of the NTN-C bond.\n        quotation (float): The NTN-C quotation in base 100.\n\n    Returns:\n        float: The NTN-C price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.price(6598.913723, 126.4958)\n        8347.348705\n    \"\"\"\n    return bt.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-C quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-C bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-C.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-C quotation truncated to 4 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.quotation(\"21-03-2025\", \"01-01-2031\", 0.067626)\n126.4958\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def quotation(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-C quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-C bond.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-C.\n\n    Returns:\n        float: The NTN-C quotation truncated to 4 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.quotation(\"21-03-2025\", \"01-01-2031\", 0.067626)\n        126.4958\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    cf_df = cash_flows(settlement, maturity)\n    cf_dates = cf_df[\"PaymentDate\"]\n    cf_values = cf_df[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = bt.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return bt.truncate(cf_present_value.sum(), 4)\n</code></pre>"},{"location":"ntnf/","title":"NTN-F","text":""},{"location":"ntnf/#pyield.tn.ntnf.cash_flows","title":"<code>cash_flows(settlement, maturity, adj_payment_dates=False)</code>","text":"<p>Generate the cash flows for the NTN-F bond between the settlement (exclusive) and maturity dates (inclusive). The cash flows are the coupon payments and the final payment at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The date (exclusive) for starting the cash flows.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>adj_payment_dates</code> <code>bool</code> <p>If True, adjust the payment dates to the next business day.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.cash_flows(\"15-05-2024\", \"01-01-2025\")\n  PaymentDate    CashFlow\n0  2024-07-01    48.80885\n1  2025-01-01  1048.80885\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def cash_flows(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    adj_payment_dates: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate the cash flows for the NTN-F bond between the settlement (exclusive) and\n    maturity dates (inclusive). The cash flows are the coupon payments and the final\n    payment at maturity.\n\n    Args:\n        settlement (DateScalar): The date (exclusive) for starting the cash flows.\n        maturity (DateScalar): The maturity date of the bond.\n        adj_payment_dates (bool): If True, adjust the payment dates to the next\n            business day.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.cash_flows(\"15-05-2024\", \"01-01-2025\")\n          PaymentDate    CashFlow\n        0  2024-07-01    48.80885\n        1  2025-01-01  1048.80885\n    \"\"\"\n    # Validate input dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n    _check_maturity_date(maturity)\n\n    # Get the coupon payment dates between the settlement and maturity dates\n    pay_dates = payment_dates(settlement, maturity)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cf_values = np.where(pay_dates == maturity, FINAL_PMT, COUPON_PMT)\n\n    df = pd.DataFrame(data={\"PaymentDate\": pay_dates, \"CashFlow\": cf_values})\n\n    if adj_payment_dates:\n        df[\"PaymentDate\"] = bday.offset(df[\"PaymentDate\"], 0)\n\n    return df\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.data","title":"<code>data(date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.data(\"23-08-2024\")\n  ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate   DIRate\n0    2024-08-23    NTN-F     950199  ...  0.107524       0.107692  0.10823\n1    2024-08-23    NTN-F     950199  ...  0.114948       0.115109  0.11467\n2    2024-08-23    NTN-F     950199  ...   0.11621       0.116337   0.1156\n3    2024-08-23    NTN-F     950199  ...  0.116958       0.117008  0.11575\n...\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.data(\"23-08-2024\")\n          ReferenceDate BondType  SelicCode  ...   AskRate IndicativeRate   DIRate\n        0    2024-08-23    NTN-F     950199  ...  0.107524       0.107692  0.10823\n        1    2024-08-23    NTN-F     950199  ...  0.114948       0.115109  0.11467\n        2    2024-08-23    NTN-F     950199  ...   0.11621       0.116337   0.1156\n        3    2024-08-23    NTN-F     950199  ...  0.116958       0.117008  0.11575\n        ...\n    \"\"\"\n    return anbima.tpf_data(date, \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.di_net_spread","title":"<code>di_net_spread(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates, initial_guess=None)</code>","text":"<p>Calculate the net DI spread for a bond given the YTM and the DI rates.</p> <p>This function determines the spread over the DI curve that equates the present value of the bond's cash flows to its market price. It interpolates the DI rates to match the bond's cash flow payment dates and uses the Brent method to find the spread (in bps) that zeroes the difference between the bond's market price and its discounted cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the spread.</p> required <code>ntnf_maturity</code> <code>DateScalar</code> <p>The bond maturity date.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the bond.</p> required <code>di_rates</code> <code>Series</code> <p>A Series of DI rates.</p> required <code>di_expirations</code> <code>Series</code> <p>A list or Series of DI expiration dates.</p> required <code>initial_guess</code> <code>float</code> <p>An initial guess for the spread. Defaults to None. A good initial guess is the DI gross spread for the bond.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The net DI spread in decimal format (e.g., 0.0012 for 12 bps).</p> <p>Examples:</p>"},{"location":"ntnf/#pyield.tn.ntnf.di_net_spread--obs-only-some-of-the-di-rates-will-be-used-in-the-example","title":"Obs: only some of the DI rates will be used in the example.","text":"<pre><code>&gt;&gt;&gt; exp_dates = pd.to_datetime([\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"])\n&gt;&gt;&gt; di_rates = pd.Series([0.10823, 0.11594, 0.11531])\n&gt;&gt;&gt; spread = di_net_spread(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n&gt;&gt;&gt; round(spread * 10_000, 2)  # Convert to bps for display\n12.13\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def di_net_spread(  # noqa\n    settlement: DateScalar,\n    ntnf_maturity: DateScalar,\n    ntnf_rate: float,\n    di_expirations: pd.Series,\n    di_rates: pd.Series,\n    initial_guess: float | None = None,\n) -&gt; float:\n    \"\"\"\n    Calculate the net DI spread for a bond given the YTM and the DI rates.\n\n    This function determines the spread over the DI curve that equates the present value\n    of the bond's cash flows to its market price. It interpolates the DI rates to match\n    the bond's cash flow payment dates and uses the Brent method to find the spread\n    (in bps) that zeroes the difference between the bond's market price and its\n    discounted cash flows.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the spread.\n        ntnf_maturity (DateScalar): The bond maturity date.\n        ntnf_rate (float): The yield to maturity (YTM) of the bond.\n        di_rates (pd.Series): A Series of DI rates.\n        di_expirations (pd.Series): A list or Series of DI expiration dates.\n        initial_guess (float, optional): An initial guess for the spread. Defaults to\n            None. A good initial guess is the DI gross spread for the bond.\n\n    Returns:\n        float: The net DI spread in decimal format (e.g., 0.0012 for 12 bps).\n\n    Examples:\n        # Obs: only some of the DI rates will be used in the example.\n        &gt;&gt;&gt; exp_dates = pd.to_datetime([\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"])\n        &gt;&gt;&gt; di_rates = pd.Series([0.10823, 0.11594, 0.11531])\n        &gt;&gt;&gt; spread = di_net_spread(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        &gt;&gt;&gt; round(spread * 10_000, 2)  # Convert to bps for display\n        12.13\n    \"\"\"\n    # Create an interpolator for the DI rates using the flat-forward method\n    settlement = dc.convert_input_dates(settlement)\n    ntnf_maturity = dc.convert_input_dates(ntnf_maturity)\n\n    ff_interpolator = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    # Ensure the DI data is valid\n    if len(di_rates) != len(di_expirations):\n        raise ValueError(\"di_rates and di_expirations must have the same length.\")\n    if len(di_rates) == 0:\n        return float(\"NaN\")\n\n    # Calculate cash flows and business days between settlement and payment dates\n    df = cash_flows(settlement, ntnf_maturity).reset_index()\n    df[\"BDToMat\"] = bday.count(settlement, df[\"PaymentDate\"])\n\n    byears = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    di_interp = df[\"BDToMat\"].apply(ff_interpolator)\n    bond_price = price(settlement, ntnf_maturity, ntnf_rate)\n    bond_cash_flows = df[\"CashFlow\"]\n\n    def price_difference(p):\n        # Difference between the bond's price and its discounted cash flows\n        return (bond_cash_flows / (1 + di_interp + p) ** byears).sum() - bond_price\n\n    # Solve for the spread that zeroes the price difference using the bisection method\n    return _solve_spread(price_difference, initial_guess)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.di_spreads","title":"<code>di_spreads(date)</code>","text":"<p>Calculates the DI spread for the NTN-F based on ANBIMA's indicative rates.</p> <p>This function fetches the indicative rates for the NTN-F bonds and the DI futures rates and calculates the spread between these rates in basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for the spread calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\", \"DISpread\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; df_spreads = ntnf.di_spreads(\"23-08-2024\")\n&gt;&gt;&gt; df_spreads[\"DISpread\"] = df_spreads[\"DISpread\"] * 10_000  # Convert to bps\n&gt;&gt;&gt; df_spreads\n  MaturityDate  DISpread\n0   2025-01-01     -5.38\n1   2027-01-01      4.39\n2   2029-01-01      7.37\n3   2031-01-01     12.58\n4   2033-01-01      7.67\n5   2035-01-01     12.76\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def di_spreads(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the DI spread for the NTN-F based on ANBIMA's indicative rates.\n\n    This function fetches the indicative rates for the NTN-F bonds and the DI futures\n    rates and calculates the spread between these rates in basis points.\n\n    Parameters:\n        date (DateScalar): The reference date for the spread calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\", \"DISpread\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; df_spreads = ntnf.di_spreads(\"23-08-2024\")\n        &gt;&gt;&gt; df_spreads[\"DISpread\"] = df_spreads[\"DISpread\"] * 10_000  # Convert to bps\n        &gt;&gt;&gt; df_spreads\n          MaturityDate  DISpread\n        0   2025-01-01     -5.38\n        1   2027-01-01      4.39\n        2   2029-01-01      7.37\n        3   2031-01-01     12.58\n        4   2033-01-01      7.67\n        5   2035-01-01     12.76\n\n    \"\"\"\n    # Fetch DI Spreads for the reference date\n    df = tools.pre_spreads(date)\n    df = (\n        df.query(\"BondType == 'NTN-F'\")\n        .sort_values([\"MaturityDate\"])\n        .reset_index(drop=True)\n    )\n    return df[[\"MaturityDate\", \"DISpread\"]]\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration for an NTN-F bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the duration.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The yield to maturity (YTM) used to discount the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration in business business years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n6.32854218039796\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def duration(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration for an NTN-F bond in business years.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the duration.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The yield to maturity (YTM) used to discount the cash flows.\n\n    Returns:\n        float: The Macaulay duration in business business years.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n        6.32854218039796\n    \"\"\"\n    # Return NaN if any input is NaN\n    if any(pd.isna(x) for x in [settlement, maturity, rate]):\n        return float(\"NaN\")\n\n    # Validate and normalize input dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    df = cash_flows(settlement, maturity)\n    df[\"BY\"] = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    df[\"DCF\"] = df[\"CashFlow\"] / (1 + rate) ** df[\"BY\"]\n    duration = (df[\"DCF\"] * df[\"BY\"]).sum() / df[\"DCF\"].sum()\n    # Return the duration as native float\n    return float(duration)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.dv01","title":"<code>dv01(settlement, maturity, rate)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an NTN-F in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-F.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.dv01(\"26-03-2025\", \"01-01-2035\", 0.151375)\n0.39025200000003224\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def dv01(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an NTN-F in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a date-like object.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a date-like object.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-F.\n\n    Returns:\n        float: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.dv01(\"26-03-2025\", \"01-01-2035\", 0.151375)\n        0.39025200000003224\n    \"\"\"\n    price1 = price(settlement, maturity, rate)\n    price2 = price(settlement, maturity, rate + 0.0001)\n    return price1 - price2\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the NTN-F bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of NTN-F bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.maturities(\"23-08-2024\")\n0   2025-01-01\n1   2027-01-01\n2   2029-01-01\n3   2031-01-01\n4   2033-01-01\n5   2035-01-01\ndtype: date32[day][pyarrow]\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pd.Series:\n    \"\"\"\n    Fetch the NTN-F bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series of NTN-F bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.maturities(\"23-08-2024\")\n        0   2025-01-01\n        1   2027-01-01\n        2   2029-01-01\n        3   2031-01-01\n        4   2033-01-01\n        5   2035-01-01\n        dtype: date32[day][pyarrow]\n    \"\"\"\n    df_rates = data(date)\n    s_maturities = df_rates[\"MaturityDate\"]\n    s_maturities.name = None\n    return s_maturities\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a settlement date and a maturity date. The dates are exclusive for the settlement date and inclusive for the maturity date. Coupon payments are made on the 1st of January and July. The NTN-F bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the coupon dates between the settlement (exclusive) and maturity (inclusive) dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.payment_dates(\"15-05-2024\", \"01-01-2025\")\n0   2024-07-01\n1   2025-01-01\ndtype: date32[day][pyarrow]\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def payment_dates(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a settlement date and a maturity date.\n    The dates are exclusive for the settlement date and inclusive for the maturity date.\n    Coupon payments are made on the 1st of January and July.\n    The NTN-F bond is determined by its maturity date.\n\n    Args:\n        settlement (DateScalar): The settlement date.\n        maturity (DateScalar): The maturity date.\n\n    Returns:\n        pd.Series: A Series containing the coupon dates between the settlement\n            (exclusive) and maturity (inclusive) dates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.payment_dates(\"15-05-2024\", \"01-01-2025\")\n        0   2024-07-01\n        1   2025-01-01\n        dtype: date32[day][pyarrow]\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Check if the maturity date is valid\n    _check_maturity_date(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt;= settlement:\n        raise ValueError(\"Maturity date must be after the settlement date.\")\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= pd.DateOffset(months=6)\n        coupon_date = coupon_date.date()  # DateOffset returns a Timestamp\n\n    # Return the coupon dates as a sorted Series\n    coupon_dates = pd.Series(coupon_dates).astype(\"date32[pyarrow]\")\n    return coupon_dates.sort_values().reset_index(drop=True)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.premium","title":"<code>premium(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates)</code>","text":"<p>Calculate the premium of an NTN-F bond over DI rates.</p> <p>This function computes the premium of an NTN-F bond by comparing its implied discount factor with that of the DI curve. It determines the net premium based on the difference between the discount factors of the bond's yield-to-maturity (YTM) and the interpolated DI rates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the premium.</p> required <code>ntnf_maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-F bond.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the NTN-F bond.</p> required <code>di_expirations</code> <code>Series</code> <p>Series containing the expiration dates for DI rates.</p> required <code>di_rates</code> <code>Series</code> <p>Series containing the DI rates corresponding to the expiration dates.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the NTN-F bond over the DI curve, expressed as a</p> <code>float</code> <p>factor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Obs: only some of the DI rates will be used in the example.\n&gt;&gt;&gt; exp_dates = pd.to_datetime([\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"])\n&gt;&gt;&gt; di_rates = pd.Series([0.10823, 0.11594, 0.11531])\n&gt;&gt;&gt; premium(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n1.0099602136954626\n</code></pre> Notes <ul> <li>The function adjusts coupon payment dates to business days and calculates   the present value of cash flows for the NTN-F bond using DI rates.</li> </ul> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def premium(\n    settlement: DateScalar,\n    ntnf_maturity: DateScalar,\n    ntnf_rate: float,\n    di_expirations: pd.Series,\n    di_rates: pd.Series,\n) -&gt; float:\n    \"\"\"\n    Calculate the premium of an NTN-F bond over DI rates.\n\n    This function computes the premium of an NTN-F bond by comparing its implied\n    discount factor with that of the DI curve. It determines the net premium based\n    on the difference between the discount factors of the bond's yield-to-maturity\n    (YTM) and the interpolated DI rates.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the premium.\n        ntnf_maturity (DateScalar): The maturity date of the NTN-F bond.\n        ntnf_rate (float): The yield to maturity (YTM) of the NTN-F bond.\n        di_expirations (pd.Series): Series containing the expiration dates for DI rates.\n        di_rates (pd.Series): Series containing the DI rates corresponding to\n            the expiration dates.\n\n    Returns:\n        float: The premium of the NTN-F bond over the DI curve, expressed as a\n        factor.\n\n    Examples:\n        &gt;&gt;&gt; # Obs: only some of the DI rates will be used in the example.\n        &gt;&gt;&gt; exp_dates = pd.to_datetime([\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"])\n        &gt;&gt;&gt; di_rates = pd.Series([0.10823, 0.11594, 0.11531])\n        &gt;&gt;&gt; premium(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        1.0099602136954626\n\n    Notes:\n        - The function adjusts coupon payment dates to business days and calculates\n          the present value of cash flows for the NTN-F bond using DI rates.\n\n    \"\"\"\n    ntnf_maturity = dc.convert_input_dates(ntnf_maturity)\n    settlement = dc.convert_input_dates(settlement)\n\n    df = cash_flows(settlement, ntnf_maturity, adj_payment_dates=True)\n    df[\"BDToMat\"] = bday.count(settlement, df[\"PaymentDate\"])\n    df[\"BYears\"] = df[\"BDToMat\"] / 252\n\n    ff_interpolator = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    df[\"DIRate\"] = df[\"BDToMat\"].apply(ff_interpolator)\n\n    # Calculate the present value of the cash flows using the DI rate\n    bond_price = tools.calculate_present_value(\n        cash_flows=df[\"CashFlow\"],\n        rates=df[\"DIRate\"],\n        periods=df[\"BDToMat\"] / 252,\n    )\n\n    # Calculate the rate corresponding to this price\n    def price_difference(ytm):\n        # The ytm that zeroes the price difference\n        return (df[\"CashFlow\"] / (1 + ytm) ** df[\"BYears\"]).sum() - bond_price\n\n    # Solve for the YTM that zeroes the price difference\n    di_ytm = _solve_spread(price_difference, ntnf_rate)\n\n    factor_ntnf = (1 + ntnf_rate) ** (1 / 252)\n    factor_di = (1 + di_ytm) ** (1 / 252)\n    premium_np = (factor_ntnf - 1) / (factor_di - 1)\n    return float(premium_np)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-F price using Anbima rules, which corresponds to the present     value of the cash flows discounted at the given yield to maturity rate (YTM).</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the price.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) used to calculate the present value of the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-F price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 48.81, which represents a 10% annual   coupon rate compounded semi-annually and rounded to 5 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n895.359254\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def price(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-F price using Anbima rules, which corresponds to the present\n        value of the cash flows discounted at the given yield to maturity rate (YTM).\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the price.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The discount rate (yield to maturity) used to calculate the\n            present value of the cash flows.\n\n    Returns:\n        float: The NTN-F price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 48.81, which represents a 10% annual\n          coupon rate compounded semi-annually and rounded to 5 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n        895.359254\n    \"\"\"\n    cf_df = cash_flows(settlement, maturity)\n    cf_values = cf_df[\"CashFlow\"]\n    bdays = bday.count(settlement, cf_df[\"PaymentDate\"])\n    byears = tools.truncate(bdays / 252, 14)\n    discount_factors = (1 + rate) ** byears\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    dcf = (cf_values / discount_factors).round(9)\n    # Return the sum of the discounted cash flows truncated as per Anbima rules\n    return tools.truncate(dcf.sum(), 6)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.spot_rates","title":"<code>spot_rates(settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates, show_coupons=False)</code>","text":"<p>Calculate the spot rates (zero coupon rates) for NTN-F bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price. It uses the LTN rates, which are zero coupon bonds, up to the last LTN maturity available. For maturities after the last LTN maturity, it calculates the spot rates using the bootstrap method.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date for the spot rates calculation.</p> required <code>ltn_maturities</code> <code>Series</code> <p>The LTN known maturities.</p> required <code>ltn_rates</code> <code>Series</code> <p>The LTN known rates.</p> required <code>ntnf_maturities</code> <code>Series</code> <p>The NTN-F known maturities.</p> required <code>ntnf_rates</code> <code>Series</code> <p>The NTN-F known rates.</p> required <code>show_coupons</code> <code>bool</code> <p>If True, show also July rates corresponding to the coupon payments. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"BDToMat\", \"MaturityDate\" and \"SpotRate\". \"BDToMat\" is the business days from the settlement date to the maturities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf, ltn\n&gt;&gt;&gt; df_ltn = ltn.data(\"03-09-2024\")\n&gt;&gt;&gt; df_ntnf = ntnf.data(\"03-09-2024\")\n&gt;&gt;&gt; ntnf.spot_rates(\n...     settlement=\"03-09-2024\",\n...     ltn_maturities=df_ltn[\"MaturityDate\"],\n...     ltn_rates=df_ltn[\"IndicativeRate\"],\n...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n... )\n  MaturityDate  BDToMat  SpotRate\n0   2025-01-01       83  0.108837\n1   2027-01-01      584  0.119981\n2   2029-01-01     1083  0.122113\n3   2031-01-01     1584  0.122231\n4   2033-01-01     2088  0.121355\n5   2035-01-01     2587  0.121398\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def spot_rates(  # noqa\n    settlement: DateScalar,\n    ltn_maturities: pd.Series,\n    ltn_rates: pd.Series,\n    ntnf_maturities: pd.Series,\n    ntnf_rates: pd.Series,\n    show_coupons: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the spot rates (zero coupon rates) for NTN-F bonds using the bootstrap\n    method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price. It uses the LTN rates, which are zero coupon bonds, up to the\n    last LTN maturity available. For maturities after the last LTN maturity,\n    it calculates the spot rates using the bootstrap method.\n\n\n    Args:\n        settlement (DateScalar): The settlement date for the spot rates calculation.\n        ltn_maturities (pd.Series): The LTN known maturities.\n        ltn_rates (pd.Series): The LTN known rates.\n        ntnf_maturities (pd.Series): The NTN-F known maturities.\n        ntnf_rates (pd.Series): The NTN-F known rates.\n        show_coupons (bool): If True, show also July rates corresponding to the\n            coupon payments. Defaults to False.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"BDToMat\", \"MaturityDate\" and \"SpotRate\".\n            \"BDToMat\" is the business days from the settlement date to the maturities.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf, ltn\n        &gt;&gt;&gt; df_ltn = ltn.data(\"03-09-2024\")\n        &gt;&gt;&gt; df_ntnf = ntnf.data(\"03-09-2024\")\n        &gt;&gt;&gt; ntnf.spot_rates(\n        ...     settlement=\"03-09-2024\",\n        ...     ltn_maturities=df_ltn[\"MaturityDate\"],\n        ...     ltn_rates=df_ltn[\"IndicativeRate\"],\n        ...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n        ...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n        ... )\n          MaturityDate  BDToMat  SpotRate\n        0   2025-01-01       83  0.108837\n        1   2027-01-01      584  0.119981\n        2   2029-01-01     1083  0.122113\n        3   2031-01-01     1584  0.122231\n        4   2033-01-01     2088  0.121355\n        5   2035-01-01     2587  0.121398\n    \"\"\"\n    # Process and validate the input data\n    settlement = dc.convert_input_dates(settlement)\n\n    # Create flat forward interpolators for LTN and NTN-F rates\n    ltn_rate_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ltn_maturities),\n        known_rates=ltn_rates,\n    )\n    ntnf_rate_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ntnf_maturities),\n        known_rates=ntnf_rates,\n    )\n\n    # Generate all coupon dates up to the last NTN-F maturity date\n    all_coupon_dates = payment_dates(settlement, ntnf_maturities.max())\n\n    # Create a DataFrame with all coupon dates and the corresponding YTM\n    df = pd.DataFrame(data=all_coupon_dates, columns=[\"MaturityDate\"])\n    df[\"BDToMat\"] = bday.count(start=settlement, end=df[\"MaturityDate\"])\n    df[\"BYears\"] = df[\"BDToMat\"] / 252\n    df[\"Coupon\"] = COUPON_PMT\n    df[\"YTM\"] = df[\"BDToMat\"].apply(ntnf_rate_interpolator)\n\n    # The Bootstrap loop to calculate spot rates\n    for index, row in df.iterrows():\n        if row[\"MaturityDate\"] &lt;= ltn_maturities.max():\n            # Use LTN rates for maturities before the last LTN maturity date\n            df.at[index, \"SpotRate\"] = ltn_rate_interpolator(row[\"BDToMat\"])\n            continue\n\n        # Calculate the present value of the coupon payments\n        cf_dates = payment_dates(settlement, row[\"MaturityDate\"])[:-1]  # noqa\n        cf_df = df.query(\"MaturityDate in @cf_dates\").reset_index(drop=True)\n        cf_present_value = tools.calculate_present_value(\n            cash_flows=cf_df[\"Coupon\"],\n            rates=cf_df[\"SpotRate\"],\n            periods=cf_df[\"BDToMat\"] / 252,\n        )\n\n        bond_price = price(settlement, row[\"MaturityDate\"], row[\"YTM\"])\n        price_factor = FINAL_PMT / (bond_price - cf_present_value)\n        df.at[index, \"SpotRate\"] = price_factor ** (1 / row[\"BYears\"]) - 1\n\n    df = df[[\"MaturityDate\", \"BDToMat\", \"SpotRate\"]].copy()\n    df[\"SpotRate\"] = df[\"SpotRate\"].astype(\"float64[pyarrow]\")\n\n    if not show_coupons:\n        df = df.query(\"MaturityDate in @ntnf_maturities\").reset_index(drop=True)\n\n    return df\n</code></pre>"},{"location":"pre/","title":"PRE","text":""},{"location":"pre/#pyield.tn.pre.spot_rates","title":"<code>spot_rates(date)</code>","text":"<p>Create the PRE curve (zero coupon rates) for Brazilian fixed rate bonds.</p> <p>This function combines LTN rates (which are already zero coupon) with spot rates derived from NTN-F bonds using the bootstrap method.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\", and \"SpotRate\".          Contains zero coupon rates for all available maturities.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any maturity date cannot be processed or business days cannot be calculated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.spot_rates(\"18-06-2025\")\n   MaturityDate  BDToMat  SpotRate\n0    2025-07-01        8   0.14835\n1    2025-10-01       74  0.147463\n2    2026-01-01      138  0.147752\n3    2026-04-01      199  0.147947\n4    2026-07-01      260  0.147069\n5    2026-10-01      325  0.144733\n6    2027-01-01      387  0.142496\n7    2027-04-01      447  0.140924\n8    2027-07-01      510  0.139024\n9    2028-01-01      638  0.136595\n10   2028-07-01      762  0.135664\n11   2029-01-01      886  0.136484\n12   2030-01-01     1135  0.137279\n13   2031-01-01     1387  0.138154\n14   2032-01-01     1639   0.13876\n15   2033-01-01     1891    0.1393\n16   2035-01-01     2390  0.141068\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def spot_rates(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Create the PRE curve (zero coupon rates) for Brazilian fixed rate bonds.\n\n    This function combines LTN rates (which are already zero coupon) with\n    spot rates derived from NTN-F bonds using the bootstrap method.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\", and \"SpotRate\".\n                     Contains zero coupon rates for all available maturities.\n\n    Raises:\n        ValueError: If any maturity date cannot be processed or business days cannot be\n            calculated.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.spot_rates(\"18-06-2025\")\n           MaturityDate  BDToMat  SpotRate\n        0    2025-07-01        8   0.14835\n        1    2025-10-01       74  0.147463\n        2    2026-01-01      138  0.147752\n        3    2026-04-01      199  0.147947\n        4    2026-07-01      260  0.147069\n        5    2026-10-01      325  0.144733\n        6    2027-01-01      387  0.142496\n        7    2027-04-01      447  0.140924\n        8    2027-07-01      510  0.139024\n        9    2028-01-01      638  0.136595\n        10   2028-07-01      762  0.135664\n        11   2029-01-01      886  0.136484\n        12   2030-01-01     1135  0.137279\n        13   2031-01-01     1387  0.138154\n        14   2032-01-01     1639   0.13876\n        15   2033-01-01     1891    0.1393\n        16   2035-01-01     2390  0.141068\n    \"\"\"\n    # Fetch LTN data (zero coupon bonds)\n    df_ltn = anbima.tpf_data(date, \"LTN\")\n\n    # Fetch NTN-F data (coupon bonds)\n    df_ntnf = anbima.tpf_data(date, \"NTN-F\")\n\n    # Check if we have data for both bond types\n    if df_ltn.empty and df_ntnf.empty:\n        return pd.DataFrame(columns=[\"MaturityDate\", \"BDToMat\", \"SpotRate\"])\n\n    # If we only have LTN data, return it directly\n    if df_ntnf.empty:\n        pass\n        # return _process_ltn_only(date, df_ltn)\n\n    # If we only have NTN-F data, we can't bootstrap without LTN rates\n    if df_ltn.empty:\n        raise ValueError(\n            \"Cannot construct PRE curve without LTN rates for bootstrapping\"\n        )\n\n    # Use the existing spot_rates function to calculate zero coupon rates\n    df_spots = ntnf.spot_rates(\n        settlement=date,\n        ltn_maturities=df_ltn[\"MaturityDate\"],\n        ltn_rates=df_ltn[\"IndicativeRate\"],\n        ntnf_maturities=df_ntnf[\"MaturityDate\"],\n        ntnf_rates=df_ntnf[\"IndicativeRate\"],\n        show_coupons=False,\n    )\n\n    # Find LTN maturities that are not in the NTN-F result\n    ltn_mask = ~df_ltn[\"MaturityDate\"].isin(df_spots[\"MaturityDate\"])\n    ltn_not_in_ntnf = df_ltn.loc[\n        ltn_mask\n    ].copy()  # Use .loc and .copy() to avoid warning\n\n    if not ltn_not_in_ntnf.empty:\n        # Process additional LTN maturities\n        ltn_subset = _process_additional_ltn(date, ltn_not_in_ntnf)\n\n        # Ensure consistent data types\n        ltn_subset[\"BDToMat\"] = ltn_subset[\"BDToMat\"].astype(\"int64[pyarrow]\")\n        df_spots[\"BDToMat\"] = df_spots[\"BDToMat\"].astype(\"int64[pyarrow]\")\n\n        # Combine LTN and NTN-F derived spot rates\n        df_combined = pd.concat([df_spots, ltn_subset], ignore_index=True)\n    else:\n        df_combined = df_spots.copy()\n        df_combined[\"BDToMat\"] = df_combined[\"BDToMat\"].astype(\"int64[pyarrow]\")\n\n    # Final validation - ensure no NaN values in the result\n    _validate_final_result(df_combined)\n\n    # Sort by maturity date and return\n    return df_combined.sort_values(\"MaturityDate\").reset_index(drop=True)\n</code></pre>"},{"location":"tn/","title":"Tesouro Data","text":""},{"location":"tn/#pyield.tn.benchmarks","title":"<code>benchmarks(bond_type=None, include_history=False)</code>","text":"<p>Fetches benchmark data for Brazilian Treasury Bonds from the TN API.</p> <p>This function retrieves current or historical benchmark data for various Brazilian Treasury bond types (e.g., LTN, LFT, NTN-B). The data is sourced directly from the official Tesouro Nacional API.</p> <p>Parameters:</p> Name Type Description Default <code>include_history</code> <code>bool</code> <p>If <code>True</code>, includes historical benchmark data. If <code>False</code> (default), only current benchmarks are returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A pandas DataFrame containing the benchmark data. The DataFrame includes the following columns:</p> <ul> <li><code>Benchmark</code> (str): The name or identifier of the benchmark     (e.g., 'LFT 3 anos').</li> <li><code>MaturityDate</code> (datetime.date): The maturity date of the benchmark.</li> <li><code>BondType</code> (str): The type of the bond (e.g., 'LTN', 'LFT', 'NTN-B').</li> <li><code>StartDate</code> (datetime.date): The start date for the benchmark's period.</li> <li><code>EndDate</code> (datetime.date): The end date for the benchmark's period.</li> </ul> Notes <ul> <li>Data is sourced from the official Tesouro Nacional (Brazilian Treasury) API.</li> <li>An retry mechanism is implemented for SSL certificate verification errors.</li> <li>The API documentation can be found at:     https://portal-conhecimento.tesouro.gov.br/catalogo-componentes/api-leil%C3%B5es</li> <li>Rows with any <code>NaN</code> values are dropped before returning the DataFrame.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import tn\n&gt;&gt;&gt; df_current = tn.benchmarks()\n&gt;&gt;&gt; # Get historical benchmarks\n&gt;&gt;&gt; df_history = tn.benchmarks(bond_type=\"LFT\", include_history=True)\n&gt;&gt;&gt; df_history.head()\n      StartDate     EndDate BondType MaturityDate      Benchmark\n0    2014-01-01  2014-06-30      LFT   2020-03-01     LFT 6 anos\n1    2014-07-01  2014-12-31      LFT   2020-09-01     LFT 6 anos\n2    2015-01-01  2015-04-30      LFT   2021-03-01     LFT 6 anos\n3    2015-05-01  2015-12-31      LFT   2021-09-01     LFT 6 anos\n4    2016-01-01  2016-06-30      LFT   2022-03-01     LFT 6 anos\n</code></pre> Source code in <code>pyield/tn/benchmark.py</code> <pre><code>def benchmarks(bond_type: str = None, include_history: bool = False) -&gt; pd.DataFrame:\n    \"\"\"Fetches benchmark data for Brazilian Treasury Bonds from the TN API.\n\n    This function retrieves current or historical benchmark data for various Brazilian\n    Treasury bond types (e.g., LTN, LFT, NTN-B). The data is sourced directly from the\n    official Tesouro Nacional API.\n\n    Args:\n        include_history (bool, optional): If `True`, includes historical benchmark data.\n            If `False` (default), only current benchmarks are returned.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the benchmark data.\n            The DataFrame includes the following columns:\n\n            *   `Benchmark` (str): The name or identifier of the benchmark\n                (e.g., 'LFT 3 anos').\n            *   `MaturityDate` (datetime.date): The maturity date of the benchmark.\n            *   `BondType` (str): The type of the bond (e.g., 'LTN', 'LFT', 'NTN-B').\n            *   `StartDate` (datetime.date): The start date for the benchmark's period.\n            *   `EndDate` (datetime.date): The end date for the benchmark's period.\n\n    Notes:\n        *   Data is sourced from the official Tesouro Nacional (Brazilian Treasury) API.\n        *   An retry mechanism is implemented for SSL certificate verification errors.\n        *   The API documentation can be found at:\n            https://portal-conhecimento.tesouro.gov.br/catalogo-componentes/api-leil%C3%B5es\n        *   Rows with any `NaN` values are dropped before returning the DataFrame.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import tn\n        &gt;&gt;&gt; df_current = tn.benchmarks()\n        &gt;&gt;&gt; # Get historical benchmarks\n        &gt;&gt;&gt; df_history = tn.benchmarks(bond_type=\"LFT\", include_history=True)\n        &gt;&gt;&gt; df_history.head()\n              StartDate     EndDate BondType MaturityDate      Benchmark\n        0    2014-01-01  2014-06-30      LFT   2020-03-01     LFT 6 anos\n        1    2014-07-01  2014-12-31      LFT   2020-09-01     LFT 6 anos\n        2    2015-01-01  2015-04-30      LFT   2021-03-01     LFT 6 anos\n        3    2015-05-01  2015-12-31      LFT   2021-09-01     LFT 6 anos\n        4    2016-01-01  2016-06-30      LFT   2022-03-01     LFT 6 anos\n    \"\"\"\n    # Passo 1: Buscar os dados brutos\n    raw_data = _fetch_raw_benchmarks(include_history=include_history)\n    if not raw_data:\n        return pd.DataFrame()  # Retorna DF vazio se a busca falhou\n\n    # Passo 2: Processar os dados em um DataFrame limpo\n    df = _process_benchmark_data(raw_data)\n    if df.empty:\n        return pd.DataFrame()  # Retorna DF vazio se o processamento resultou em nada\n\n    # Passo 3: Aplicar filtros espec\u00edficos da chamada\n    if not include_history:\n        today = dt.now(TIMEZONE_BZ).date()  # noqa\n        df = df.query(\"IN\u00cdCIO &lt;= @today &lt;= TERMINO\").reset_index(drop=True)\n        if df.empty:\n            logger.warning(\n                \"No current benchmark data found after filtering by active period.\"\n            )\n\n    if bond_type:\n        df = df.query(\"T\u00cdTULO == @bond_type\").reset_index(drop=True)\n\n    if df.empty:\n        return pd.DataFrame()  # Retorna DF vazio se os filtros removeram tudo\n\n    # Passo 4: Formatar a sa\u00edda final\n    column_order = [c for c in COLUMN_MAPPING if c in df.columns]\n    return (\n        df[column_order]\n        .rename(columns=COLUMN_MAPPING)\n        .sort_values([\"BondType\", \"MaturityDate\"])\n        .reset_index(drop=True)\n    )\n</code></pre>"},{"location":"articles/pyield_intro/","title":"Introdu\u00e7\u00e3o a PYield","text":""},{"location":"articles/pyield_intro/#uma-biblioteca-em-python-para-obtecao-de-dados-de-instrumentos-de-renda-fixa-brasileira","title":"Uma biblioteca em Python para obte\u00e7\u00e3o de dados de instrumentos de Renda Fixa brasileira","text":"<p>Se voc\u00ea \u00e9 um entusiasta de VBA e Excel, pode pular esse artigo que aqui n\u00e3o \u00e9 lugar para voc\u00ea! Brincadeira, voc\u00ea \u00e9 bem-vindo tamb\u00e9m. Afinal, essa pode ser uma \u00f3tima desculpa para voc\u00ea finalmente aprender Python \ud83d\ude02</p> <p>Brincadeiras \u00e0 parte, qualquer um que trabalhe com an\u00e1lise de renda fixa no sabe que a obten\u00e7\u00e3o de dados de fontes como ANBIMA e B3 pode ser uma tarefa complicada. Outro ponto refere-se ao tratamento dos feriados e dias \u00fateis, um verdadeiro pesadelo para quem precisa calcular prazos e vencimentos, ainda mais depois que criaram um novo feriado nacional no final do ano passado. Sim, agora temos que considerar duas listas de feriados nacionais, uma para dados ateriores a 26-12-2023 e outra para depois.</p> <p>Claro que para os afortunados com acesso a servi\u00e7os pagos como Bloomberg, a obten\u00e7\u00e3o desse tipo de dados j\u00e1 \u00e9 bem f\u00e1cil. Mas para a maioria dos analistas financeiros, pesquisadores e entusiastas do mercado, a obten\u00e7\u00e3o e processamento desses dados pode ser um desafio. Afinal, voc\u00ea ter\u00e1 que lidar com chamadas para diversas APIs como a do IBGE, do BACEN, da ANBIMA, da B3, e por a\u00ed vai. Em alguns casos, o dado tem que ser extra\u00eddo diretamente de sites, o que pode ser ainda mais complicado.</p>"},{"location":"articles/pyield_intro/#o-que-e-pyield","title":"O que \u00e9 PYield?","text":"<p>A biblioteca Python foi projetada especificamente para a obten\u00e7\u00e3o e tratamento de dados de instrumentos de renda fixa. Ou seja, \u00e9 uma tentativa de  simplificar a obten\u00e7\u00e3o e processamento de dados de fontes prim\u00e1rias como ANBIMA e B3, fornecendo uma API de f\u00e1cil utiliza\u00e7\u00e3o.</p> <p>Utilizando a robustez de bibliotecas populares de Python, como Pandas, Requests e Numpy, PYield pode ser usada como backend de aplica\u00e7\u00f5es mais complexas, removendo a parte pesada relacionada a obten\u00e7\u00e3o e processamento de dados de fontes e formatos diversos.</p>"},{"location":"articles/pyield_intro/#caracteristicas-principais","title":"Caracter\u00edsticas Principais","text":"<ul> <li>Coleta de Dados: Obtenha dados diretamente de fontes prim\u00e1rias como ANBIMA e B3 de forma simples e r\u00e1pida.</li> <li>Processamento de Dados: Os dados s\u00e3o processados e entregues em formatos f\u00e1ceis de usar, como DataFrames do Pandas.</li> <li>Ferramentas de An\u00e1lise: Acesse fun\u00e7\u00f5es para tarefas comuns de an\u00e1lise do mercado de renda fixa, como c\u00e1lculos de dias \u00fateis e feriados.</li> </ul>"},{"location":"articles/pyield_intro/#como-instalar-o-pyield","title":"Como Instalar o PYield","text":"<p>A instala\u00e7\u00e3o do PYield \u00e9 r\u00e1pida e f\u00e1cil atrav\u00e9s do pip, o gerenciador de pacotes do Python. Basta abrir o terminal e executar o seguinte comando no seu ambiente virtual:</p> <p><pre><code>pip install pyield\n</code></pre> Este comando instala a \u00faltima vers\u00e3o do PYield, deixando voc\u00ea pronto para come\u00e7ar a utilizar a biblioteca em seus projetos.</p> <p>Exemplos Pr\u00e1ticos de Uso:</p>"},{"location":"articles/pyield_intro/#ferramentas-de-dias-uteis-feriados-brasileiros-sao-automaticamente-considerados","title":"Ferramentas de Dias \u00dateis (Feriados brasileiros s\u00e3o automaticamente considerados)","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n\n# Contar o n\u00famero de dias \u00fateis entre duas datas.\n# A data de in\u00edcio \u00e9 inclusiva, a data de t\u00e9rmino \u00e9 exclusiva.\n&gt;&gt;&gt; yd.bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Obtenha o pr\u00f3ximo dia \u00fatil ap\u00f3s uma determinada data (offset=1).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=1)\nTimestamp('2024-01-02 00:00:00')\n\n# Obtenha o pr\u00f3ximo dia \u00fatil se n\u00e3o for um dia \u00fatil (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"30-12-2023\", offset=0)\nTimestamp('2024-01-02 00:00:00')\n\n# Como 2023-12-29 j\u00e1 \u00e9 um dia \u00fatil, a fun\u00e7\u00e3o retorna a mesma data (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=0)\nTimestamp('2023-12-29 00:00:00')\n\n# Gerar uma s\u00e9rie de dias \u00fateis entre duas datas.\n&gt;&gt;&gt; yd.bday.generate(start='2023-12-29', end='2024-01-03')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\ndtype: datetime64[ns]\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-futuro-de-di","title":"Dados de Futuro de DI","text":"<pre><code># Obtenha um DataFrame com os dados dos Futuros de DI da B3 de uma data espec\u00edfica.\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", date='2024-03-08')\n\nTradeDate  ExpirationCode ExpirationDate BDaysToExp  ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08 J24            2024-04-01     15              ... 10.952   10.952      10.956      10.956\n2024-03-08 K24            2024-05-02     37              ... 10.776   10.774      10.780      10.777\n2024-03-08 M24            2024-06-03     58              ... 10.604   10.602      10.604      10.608\n...        ...            ...            ...             ... ...      ...         ...         ...\n2024-03-08 F37            2037-01-02     3213            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F38            2038-01-04     3462            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F39            2039-01-03     3713            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.85\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-titulos-do-tesouro","title":"Dados de T\u00edtulos do Tesouro","text":"<pre><code># Obtenha um DataFrame com os dados dos t\u00edtulos NTN-B da ANBIMA.\n# Os dados da Anbima est\u00e3o dispon\u00edveis para os \u00faltimos 5 dias \u00fateis.\n# Obs: Para quem \u00e9 membro da Anbima, o acesso ao hist\u00f3rico \u00e9 liberado automaticamente pela biblioteca.\n&gt;&gt;&gt; yd.anbima(bond_type=\"NTN-B\", date='2024-04-12')\n\nBondType ReferenceDate MaturityDate BidRate AskRate IndicativeRate Price\nNTN-B    2024-04-12    2024-08-15   0.07540 0.07504 0.07523        4,271.43565\nNTN-B    2024-04-12    2025-05-15   0.05945 0.05913 0.05930        4,361.34391\nNTN-B    2024-04-12    2026-08-15   0.05927 0.05897 0.05910        4,301.40082\n...      ...           ...          ...     ...     ...            ...\nNTN-B    2024-04-12    2050-08-15   0.06039 0.06006 0.06023        4,299.28233\nNTN-B    2024-04-12    2055-05-15   0.06035 0.05998 0.06017        4,367.13360\nNTN-B    2024-04-12    2060-08-15   0.06057 0.06016 0.06036        4,292.26323\n</code></pre>"},{"location":"articles/pyield_intro/#calculo-de-spreads","title":"C\u00e1lculo de spreads","text":"<pre><code># Calcule o spread entre o futuro de DI e os t\u00edtulos pr\u00e9-fixados do Tesouro.\n&gt;&gt;&gt; yd.spreads(spread_type=\"DI_PRE\", date=\"2024-4-11\")\n\nBondType ReferenceDate MaturityDate  DISpread\nLTN      2024-04-11    2024-07-01    -20.28\nLTN      2024-04-11    2024-10-01    -10.19\nLTN      2024-04-11    2025-01-01    -15.05\n...      ...           ...           ...\nNTN-F    2024-04-11    2031-01-01    -0.66\nNTN-F    2024-04-11    2033-01-01    -5.69\nNTN-F    2024-04-11    2035-01-01    -1.27\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-indicadores","title":"Dados de Indicadores","text":"<pre><code># Obtenha a taxa SELIC meta do BCB em um determinado dia.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"SELIC\", date='2024-04-12')\n0.1075  # 10.75%\n\n# Obtenha a taxa mensal (Monthly Rate) do IPCA do IBGE com base no m\u00eas de refer\u00eancia da data.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", date='2024-03-18')\n0.0016  # 0.16%\n\n# Se o indicador n\u00e3o estiver dispon\u00edvel para a data de refer\u00eancia, o retorno ser\u00e1 nulo (None).\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", date='2030-04-10')\nNone\n</code></pre>"},{"location":"articles/pyield_intro/#conclusao","title":"Conclus\u00e3o","text":"<p>Se voc\u00ea precisa obter e tratar dados de renda fixa, PYield pode ser uma ferramenta valiosa nesse processo. Com uma API simples, o seu c\u00f3digo pode se tornar mais limpo e eficiente, permitindo que voc\u00ea se concentre na an\u00e1lise dos dados em vez de se preocupar com a obten\u00e7\u00e3o e processamento deles.</p> <p>O c\u00f3digo da biblioteca pode ser acessado em: PYield</p> <p>Quem quiser contribuir com o desenvolvimento da ferramenta entre em contato comigo: cr.cj@outlook.com</p>"}]}