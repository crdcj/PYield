{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyield-brazilian-fixed-income-toolkit","title":"PYield: Brazilian Fixed Income Toolkit","text":"<p>PYield is a Python library designed for the analysis of Brazilian fixed income instruments. Leveraging the power of popular Python libraries like Pandas and Requests, PYield simplifies the process of obtaining and processing data from key sources such as ANBIMA, BCB, IBGE and B3.</p> <p>Documentation: https://crdcj.github.io/PYield/</p> <p>Source Code: https://github.com/crdcj/PYield</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Data Collection: Automated fetching of data from ANBIMA and B3.</li> <li>Data Processing: Efficient processing and normalization of fixed income data.</li> <li>Analysis Tools: Built-in functions for common analysis tasks in fixed income markets.</li> <li>Easy Integration: Seamless integration with pandas data analysis workflows.</li> <li>Type Hints: Full support for static type checking, enhancing development experience and code quality.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install PYield using pip: <pre><code>pip install pyield\n</code></pre></p>"},{"location":"#how-to-use-pyield","title":"How to use PYield","text":""},{"location":"#important-note-on-date-formats","title":"Important Note on Date Formats","text":"<p>When using date strings in PYield functions, please ensure that the date format is day-first (e.g., \"31-05-2024\"). This format was chosen to be consistent with the Brazilian date convention.</p> <p>For production code, it is recommended to parse date strings with <code>pandas.to_datetime</code> using an explicit format to avoid ambiguity and ensure consistency.</p> <p>For example: <pre><code>import pandas as pd\n# Converting a date string to a pandas Timestamp with a specific format\ndate = pd.to_datetime(\"2024/31/05\", format=\"%Y/%d/%m\")\ndate = pd.to_datetime(\"05-31-2024\", format=\"%m-%d-%Y\")\n</code></pre></p>"},{"location":"#brazilian-treasury-bonds-tools","title":"Brazilian Treasury Bonds Tools","text":"<pre><code>&gt;&gt;&gt; from pyield import ntnb, ntnf, ltn\n\n# Calculate the quote of a NTN-B bond as per ANBIMA's rules\n&gt;&gt;&gt; ntnb.quote(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quote(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n\n# Calculate the DI Spread of NTN-F bonds in a given date\n&gt;&gt;&gt; ntnf.di_spreads(\"17-07-2024\")\n2025-01-01   -2.31\n2027-01-01   -1.88\n2029-01-01   -3.26\n2031-01-01    3.61\n2033-01-01   -3.12\n2035-01-01   -1.00\nName: DISpread, dtype: Float64\n\n# Get ANBIMA's indicative rates for LTN bonds\n&gt;&gt;&gt; ltn.anbima_rates(\"17-07-2024\")\n2024-10-01    0.104236\n2025-01-01    0.105400\n2025-04-01    0.107454\n2025-07-01    0.108924\n2025-10-01    0.110751\n2026-01-01    0.111753\n2026-04-01    0.112980\n2026-07-01    0.113870\n2026-10-01    0.114592\n2027-07-01    0.116090\n2028-01-01    0.117160\n2028-07-01    0.118335\n2030-01-01    0.120090\nName: IndicativeRate, dtype: Float64\n</code></pre>"},{"location":"#business-days-tools-brazilian-holidays-are-automatically-considered","title":"Business Days Tools (Brazilian holidays are automatically considered)","text":"<pre><code>&gt;&gt;&gt; from pyield import bday\n# Count the number of business days between two dates\n# Start date is included, end date is excluded\n&gt;&gt;&gt; bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Get the next business day after a given date (offset=1)\n&gt;&gt;&gt; bday.offset(dates=\"29-12-2023\", offset=1)\nTimestamp('2024-01-02 00:00:00')\n\n# Get the next business day if it is not a business day (offset=0)\n&gt;&gt;&gt; bday.offset(dates=\"30-12-2023\", offset=0)\nTimestamp('2024-01-02 00:00:00')\n\n# Since 29-12-2023 is a business day, it returns the same date (offset=0)\n&gt;&gt;&gt; bday.offset(dates=\"29-12-2023\", offset=0)\nTimestamp('2023-12-29 00:00:00')\n\n# Generate a pandas series with the business days between two dates\n&gt;&gt;&gt; bday.generate(start='29-12-2023', end='03-01-2024')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\ndtype: datetime64[ns]\n</code></pre>"},{"location":"#futures-data","title":"Futures Data","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n# Fetch current DI Futures data from B3 (15 minutes delay)\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\")\nTradeTime      TickerSymbol ExpirationDate BDaysToExp ... MaxRate LastAskRate LastBidRate CurrentRate\n2024-04-21 13:37:39       DI1K24     2024-05-02          7 ... 0.10660     0.10652     0.10660  0.10660\n2024-04-21 13:37:39       DI1M24     2024-06-03         28 ... 0.10518     0.10510     0.10516  0.10518\n2024-04-21 13:37:39       DI1N24     2024-07-01         48 ... 0.10480     0.10456     0.10462  0.10460\n                ...          ...            ...        ... ...     ...         ...         ...      ...\n2024-04-21 13:37:39       DI1F37     2037-01-02       3183 ...    &lt;NA&gt;        &lt;NA&gt;     0.11600     &lt;NA&gt;\n2024-04-21 13:37:39       DI1F38     2038-01-04       3432 ...    &lt;NA&gt;        &lt;NA&gt;     0.11600     &lt;NA&gt;\n2024-04-21 13:37:39       DI1F39     2039-01-03       3683 ...    &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;     &lt;NA&gt;\n\n# Fetch historical DI Futures data from B3\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", reference_date='08-03-2024')\nTradeDate  TickerSymbol ExpirationDate BDaysToExp ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08       DI1J24     2024-04-01         15 ...   10.952      10.952      10.956         10.956\n2024-03-08       DI1K24     2024-05-02         37 ...   10.776      10.774      10.780         10.777\n2024-03-08       DI1M24     2024-06-03         58 ...   10.604      10.602      10.604         10.608\n       ...          ...            ...        ... ...      ...         ...         ...            ...\n2024-03-08       DI1F37     2037-01-02       3213 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.859\n2024-03-08       DI1F38     2038-01-04       3462 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.859\n2024-03-08       DI1F39     2039-01-03       3713 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.85\n</code></pre>"},{"location":"#indicators-data","title":"Indicators Data","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n# Fetch the SELIC target rate from the Central Bank of Brazil\n&gt;&gt;&gt; yd.indicator(indicator_code=\"SELIC\", reference_date='12-04-2024')\n0.1075  # 10.75%\n\n# Fetch the IPCA monthly inflation rate from IBGE\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA\", reference_date='18-03-2024')\n0.16  # 0.16%\n\n# If no data is yet available for the indicator, the function returns None\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA\", reference_date='10-04-2024')\nNone\n</code></pre>"},{"location":"#projections-data","title":"Projections Data","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n# Fetch current month projection for IPCA from IBGE API\n&gt;&gt;&gt; ipca = yd.projection(projection_code=\"IPCA_CM\")\n&gt;&gt;&gt; print(ipca)\nIndicatorProjection(\n    last_updated=Timestamp('2024-04-19 18:55:00'),\n    reference_month_ts=Timestamp('2024-04-01 00:00:00'),\n    reference_month_br='ABR/2024',\n    projected_value=0.0035  # 0.35%\n)\n&gt;&gt;&gt; ipca.projected_value\n0.0035  # 0.35%\n</code></pre>"},{"location":"#interpolation-tools","title":"Interpolation Tools","text":"<pre><code>&gt;&gt;&gt; from pyield import Interpolator\n# Interpolate interest rates for specific business days using the Interpolator class.\n\n# Initialize the Interpolator with known business days and interest rates.\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n&gt;&gt;&gt; linear_interpolator = Interpolator(\"linear\", known_bdays, known_rates)\n\n# Interpolate the interest rate for a given number of business days.\n&gt;&gt;&gt; linear_interpolator(45)\n0.0475\n\n# Use the flat forward method for interpolation.\n&gt;&gt;&gt; ff_interpolator = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; ff_interpolator(45)\n0.04833068080970859\n</code></pre>"},{"location":"anbima/","title":"Anbima Data (anbima)","text":""},{"location":"anbima/#pyield.fetchers.anbima.anbima_data","title":"<code>anbima_data(reference_date, bond_type=None)</code>","text":"<p>Fetches indicative treasury rates from ANBIMA for a specified reference date.</p> <p>This function retrieves the indicative rates for Brazilian treasury securities from ANBIMA, processing them into a structured pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The date for which to fetch the indicative rates. If a string is provided, it should be in the format 'dd-mm-yyyy'.</p> required <code>bond_type</code> <code>str</code> <p>The type of bond to filter by. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the processed ANBIMA data for the given reference date.</p> <p>Examples:</p>"},{"location":"anbima/#pyield.fetchers.anbima.anbima_data--fetch-anbima-data-for-all-bonds-in-a-specific-reference-date","title":"Fetch ANBIMA data for all bonds in a specific reference date","text":"<pre><code>&gt;&gt;&gt; anbima_data(\"18-06-2024\")\n# Fetch ANBIMA data for NTN-B bonds in a specific reference date\n&gt;&gt;&gt; anbima_data(\"18-06-2024\", \"NTN-B\")\n</code></pre> Source code in <code>pyield/fetchers/anbima.py</code> <pre><code>def anbima_data(\n    reference_date: str | pd.Timestamp,\n    bond_type: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches indicative treasury rates from ANBIMA for a specified reference date.\n\n    This function retrieves the indicative rates for Brazilian treasury securities from\n    ANBIMA, processing them into a structured pandas DataFrame.\n\n    Args:\n        reference_date (str | pd.Timestamp): The date for which to fetch the indicative\n            rates. If a string is provided, it should be in the format 'dd-mm-yyyy'.\n        bond_type (str, optional): The type of bond to filter by. Defaults to None.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the processed ANBIMA data for the\n            given reference date.\n\n    Examples:\n        # Fetch ANBIMA data for all bonds in a specific reference date\n        &gt;&gt;&gt; anbima_data(\"18-06-2024\")\n        # Fetch ANBIMA data for NTN-B bonds in a specific reference date\n        &gt;&gt;&gt; anbima_data(\"18-06-2024\", \"NTN-B\")\n    \"\"\"\n    # Normalize the reference date\n    normalized_date = dc.convert_date(reference_date)\n    file_content = _get_file_content(normalized_date)\n\n    if not file_content:\n        date_str = normalized_date.strftime(\"%d-%m-%Y\")\n        raise ValueError(f\"Could not fetch ANBIMA data for {date_str}.\")\n\n    df = _read_raw_df(file_content)\n\n    df = _process_raw_df(df)\n\n    if bond_type is None:\n        return df\n    else:\n        df.query(\"BondType == @bond_type\", inplace=True)\n        return df.reset_index(drop=True)\n</code></pre>"},{"location":"anbima/#pyield.fetchers.anbima.anbima_rates","title":"<code>anbima_rates(reference_date=None, bond_type=None)</code>","text":"<p>Gets ANBIMA indicative rates for a specified reference date and bond type.</p> <p>This function retrieves the ANBIMA indicative rates for Brazilian treasury securities, processing them into a structured pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The date for which to filter the indicative rates. If a string is provided, it should be in the format 'dd-mm-yyyy'. If None, the function returns all available rates. Defaults to None.</p> <code>None</code> <code>bond_type</code> <code>str</code> <p>The type of bond to filter by. If None, the function returns all bond types available. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the processed indicative rates for the given reference date.</p> <p>Examples:</p>"},{"location":"anbima/#pyield.fetchers.anbima.anbima_rates--fetch-anbima-rates-for-all-bonds-in-a-specific-reference-date","title":"Fetch ANBIMA rates for all bonds in a specific reference date","text":"<pre><code>&gt;&gt;&gt; yd.anbima(\"18-06-2024\")\n# Fetch ANBIMA data for NTN-B bonds in a specific reference date\n&gt;&gt;&gt; yd.anbima(\"NTN-B\", \"18-06-2024\")\n</code></pre> Source code in <code>pyield/fetchers/anbima.py</code> <pre><code>def anbima_rates(\n    reference_date: str | pd.Timestamp | None = None,\n    bond_type: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Gets ANBIMA indicative rates for a specified reference date and bond type.\n\n    This function retrieves the ANBIMA indicative rates for Brazilian treasury\n    securities, processing them into a structured pandas DataFrame.\n\n    Args:\n        reference_date (str | pd.Timestamp): The date for which to filter the indicative\n            rates. If a string is provided, it should be in the format 'dd-mm-yyyy'.\n            If None, the function returns all available rates. Defaults to None.\n        bond_type (str, optional): The type of bond to filter by. If None, the function\n            returns all bond types available. Defaults to None.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the processed indicative rates for the\n            given reference date.\n\n    Examples:\n        # Fetch ANBIMA rates for all bonds in a specific reference date\n        &gt;&gt;&gt; yd.anbima(\"18-06-2024\")\n        # Fetch ANBIMA data for NTN-B bonds in a specific reference date\n        &gt;&gt;&gt; yd.anbima(\"NTN-B\", \"18-06-2024\")\n    \"\"\"\n    if reference_date is not None:\n        reference_date = dc.convert_date(reference_date)\n    return RatesData.rates(reference_date, bond_type)\n</code></pre>"},{"location":"bday/","title":"Business Day Tool (bday)","text":""},{"location":"bday/#pyield.bday.count","title":"<code>count(start=None, end=None, holiday_list='infer')</code>","text":"<p>Counts the number of business days between a <code>start</code> and <code>end</code> date(s), inclusively for the start date and exclusively for the end date. The function can handle single dates, arrays of dates, and mixed inputs, returning either a single integer or a Series depending on the inputs. It accounts for specified holidays, effectively excluding them from the business day count.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>SingleDateTypes | SeriesDateTypes | None</code> <p>The start date(s) for counting. If None, the current date is used.</p> <code>None</code> <code>end</code> <code>SingleDateTypes | SeriesDateTypes | None</code> <p>The end date(s) for counting, which are excluded from the count themselves. If None, the current date is used.</p> <code>None</code> <code>holiday_list</code> <code>Literal['old', 'new', 'infer']</code> <p>Specifies which set of holidays to consider in the count. 'old' or 'new' refer to predefined holiday lists, while 'infer' automatically selects the list based on the most recent date in the input. Defaults to \"infer\".</p> <code>'infer'</code> <p>Returns:</p> Type Description <code>int | Series</code> <p>int | pd.Series: Returns an integer if <code>start</code> and <code>end</code> are single dates, or a Series if any of them is an array of dates.</p> Notes <ul> <li>This function is a wrapper around <code>numpy.busday_count</code>, adapted to work   directly with various Pandas and Numpy date formats.</li> <li>It supports flexible date inputs, including single dates, lists, Series, and   more, for both <code>start</code> and <code>end</code> parameters.</li> <li>The return type depends on the input types: single dates return an int, while   arrays of dates return a pd.Series with the count for each date range.</li> <li>See <code>numpy.busday_count</code> documentation for more details on how holidays are   handled and how business day counts are calculated:   https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bday.count(\"2023-12-15\", \"2024-01-01\")\n10\n&gt;&gt;&gt; bday.count(start=\"01-01-2023\", end=[\"31-01-2023\", \"01-03-2023\"])\npd.Series([22, 40], dtype='int64')\n</code></pre> Source code in <code>pyield/bday.py</code> <pre><code>def count(\n    start: SingleDateTypes | SeriesDateTypes | None = None,\n    end: SingleDateTypes | SeriesDateTypes | None = None,\n    holiday_list: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n) -&gt; int | pd.Series:\n    \"\"\"\n    Counts the number of business days between a `start` and `end` date(s), inclusively\n    for the start date and exclusively for the end date. The function can handle single\n    dates, arrays of dates, and mixed inputs, returning either a single integer or a\n    Series depending on the inputs. It accounts for specified holidays, effectively\n    excluding them from the business day count.\n\n    Args:\n        start (SingleDateTypes | SeriesDateTypes | None, optional): The start date(s)\n            for counting. If None, the current date is used.\n        end (SingleDateTypes | SeriesDateTypes| None, optional): The end date(s) for\n            counting, which are excluded from the count themselves. If None, the current\n            date is used.\n        holiday_list (Literal[\"old\", \"new\", \"infer\"], optional):\n            Specifies which set of holidays to consider in the count. 'old' or 'new'\n            refer to predefined holiday lists, while 'infer' automatically selects the\n            list based on the most recent date in the input. Defaults to \"infer\".\n\n    Returns:\n        int | pd.Series: Returns an integer if `start` and `end` are single dates,\n            or a Series if any of them is an array of dates.\n\n    Notes:\n        - This function is a wrapper around `numpy.busday_count`, adapted to work\n          directly with various Pandas and Numpy date formats.\n        - It supports flexible date inputs, including single dates, lists, Series, and\n          more, for both `start` and `end` parameters.\n        - The return type depends on the input types: single dates return an int, while\n          arrays of dates return a pd.Series with the count for each date range.\n        - See `numpy.busday_count` documentation for more details on how holidays are\n          handled and how business day counts are calculated:\n          https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.\n\n    Examples:\n        &gt;&gt;&gt; bday.count(\"2023-12-15\", \"2024-01-01\")\n        10\n        &gt;&gt;&gt; bday.count(start=\"01-01-2023\", end=[\"31-01-2023\", \"01-03-2023\"])\n        pd.Series([22, 40], dtype='int64')\n    \"\"\"\n    normalized_start = _normalize_input_dates(start)\n    normalized_end = _normalize_input_dates(end)\n\n    # Determine which list of holidays to use\n    selected_holidays = br_holidays.get_applicable_holidays(\n        normalized_start, holiday_list\n    )\n    selected_holidays_np = _convert_to_numpy_date(selected_holidays)\n\n    # Convert inputs to numpy datetime64[D] before calling numpy.busday_count\n    start_np = _convert_to_numpy_date(normalized_start)\n    end_np = _convert_to_numpy_date(normalized_end)\n\n    result_np = np.busday_count(start_np, end_np, holidays=selected_holidays_np)\n    if isinstance(result_np, np.int64):\n        return int(result_np)\n    else:\n        return pd.Series(result_np, dtype=\"Int64\")\n</code></pre>"},{"location":"bday/#pyield.bday.generate","title":"<code>generate(start=None, end=None, inclusive='both', holiday_list='infer')</code>","text":"<p>Generates a Series of business days between a <code>start</code> and <code>end</code> date, considering the list of Brazilian holidays. It supports customization of holiday lists and inclusion options for start and end dates. It wraps <code>pandas.bdate_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>SingleDateTypes | None</code> <p>The start date for generating business days. If None, the current date is used. Defaults to None.</p> <code>None</code> <code>end</code> <code>SingleDateTypes | None</code> <p>The end date for generating business days. If None, the current date is used. Defaults to None.</p> <code>None</code> <code>inclusive</code> <code>Literal['both', 'neither', 'left', 'right']</code> <p>Determines which of the start and end dates are included in the result. Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.</p> <code>'both'</code> <code>holiday_list</code> <code>Literal['old', 'new', 'infer']</code> <p>Specifies the list of holidays to consider. 'old' or 'new' refer to predefined lists, 'infer' selects the list based on the most recent date in the range. Defaults to \"infer\".</p> <code>'infer'</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series representing a range of business days between the specified start and end dates, considering the specified holidays.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\npd.Series(['2023-12-22', '2023-12-26', '2023-12-27', '2023-12-28', '2023-12-29',\n    '2024-01-02'], dtype='datetime64[ns]')\n</code></pre> Note <p>For detailed information on parameters and error handling, refer to <code>pandas.bdate_range</code> documentation: https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.</p> Source code in <code>pyield/bday.py</code> <pre><code>def generate(\n    start: SingleDateTypes | None = None,\n    end: SingleDateTypes | None = None,\n    inclusive: Literal[\"both\", \"neither\", \"left\", \"right\"] = \"both\",\n    holiday_list: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n) -&gt; pd.Series:\n    \"\"\"\n    Generates a Series of business days between a `start` and `end` date, considering\n    the list of Brazilian holidays. It supports customization of holiday lists and\n    inclusion options for start and end dates. It wraps `pandas.bdate_range`.\n\n    Args:\n        start (SingleDateTypes | None, optional):\n            The start date for generating business days. If None, the current date is\n            used. Defaults to None.\n        end (SingleDateTypes | None, optional):\n            The end date for generating business days. If None, the current date is\n            used. Defaults to None.\n        inclusive (Literal[\"both\", \"neither\", \"left\", \"right\"], optional):\n            Determines which of the start and end dates are included in the result.\n            Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.\n        holiday_list (Literal[\"old\", \"new\", \"infer\"], optional):\n            Specifies the list of holidays to consider. 'old' or 'new' refer to\n            predefined lists, 'infer' selects the list based on the most recent date in\n            the range. Defaults to \"infer\".\n\n    Returns:\n        pd.Series: A Series representing a range of business days between the specified\n            start and end dates, considering the specified holidays.\n\n    Examples:\n        &gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n        pd.Series(['2023-12-22', '2023-12-26', '2023-12-27', '2023-12-28', '2023-12-29',\n            '2024-01-02'], dtype='datetime64[ns]')\n\n    Note:\n        For detailed information on parameters and error handling, refer to\n        `pandas.bdate_range` documentation:\n        https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.\n    \"\"\"\n    normalized_start = _normalize_input_dates(start)\n    normalized_end = _normalize_input_dates(end)\n\n    selected_holidays = br_holidays.get_applicable_holidays(\n        normalized_start, holiday_list\n    )\n    selected_holidays_list = selected_holidays.to_list()\n\n    # Get the result as a DatetimeIndex (dti)\n    result_dti = pd.bdate_range(\n        start=normalized_start,\n        end=normalized_end,\n        freq=\"C\",\n        inclusive=inclusive,\n        holidays=selected_holidays_list,\n    )\n    return pd.Series(result_dti.values)\n</code></pre>"},{"location":"bday/#pyield.bday.is_business_day","title":"<code>is_business_day(date=None)</code>","text":"<p>Checks if the input date is a business day.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>SingleDateTypes | None</code> <p>The date to check. If None, the current date is used. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the input date is a business day, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas\nFalse\n&gt;&gt;&gt; bday.is_business_day()  # Check if today is a business day\nTrue\n</code></pre> Source code in <code>pyield/bday.py</code> <pre><code>def is_business_day(date: SingleDateTypes | None = None) -&gt; bool:\n    \"\"\"\n    Checks if the input date is a business day.\n\n    Args:\n        date (SingleDateTypes | None, optional): The date to check.\n            If None, the current date is used. Defaults to None.\n\n    Returns:\n        bool: True if the input date is a business day, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas\n        False\n        &gt;&gt;&gt; bday.is_business_day()  # Check if today is a business day\n        True\n    \"\"\"\n    normalized_date = _normalize_input_dates(date)\n    # Shift the date if it is not a business day\n    adjusted_date = offset(normalized_date, 0)\n    return normalized_date == adjusted_date\n</code></pre>"},{"location":"bday/#pyield.bday.offset","title":"<code>offset(dates=None, offset=0, roll='forward', holiday_list='infer')</code>","text":"<p>Offsets the dates to the next or previous business day, considering brazilian holidays. This function supports both single dates and collections of dates, handling them intelligently to return either a single offset date or a series of offset dates. It is a wrapper for <code>numpy.busday_offset</code> adapted for Pandas data types and holiday adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>SingleDateTypes | SeriesDateTypes | None</code> <p>The date(s) to offset. Can be a single date in various formats (string, <code>datetime</code>, <code>Timestamp</code>, etc.) or a collection of dates (list, tuple, <code>Series</code>, etc.). If None, the current date is used.</p> <code>None</code> <code>offset</code> <code>int</code> <p>The number of business days to offset the dates. Positive for future dates, negative for past dates. Zero will return the same date if it's a business day, or the next business day otherwise.</p> <code>0</code> <code>roll</code> <code>Literal['forward', 'backward']</code> <p>Direction to roll the date if it falls on a holiday or weekend. 'forward' to the next business day, 'backward' to the previous. Defaults to 'forward'.</p> <code>'forward'</code> <code>holiday_list</code> <code>Literal['old', 'new', 'infer']</code> <p>The list of holidays to consider. 'old' or 'new' use predefined lists, while 'infer' determines the most appropriate list based on the input dates. Defaults to \"infer\".</p> <code>'infer'</code> <p>Returns:</p> Type Description <code>Timestamp | Series</code> <p>pd.Timestamp | pd.Series: If a single date is provided, returns a single <code>Timestamp</code> of the offset date. If a series of dates is provided, returns a <code>Series</code> of offset dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; date = \"2023-12-23\"  # Saturday before Christmas\n&gt;&gt;&gt; bday.offset(date, 0)\nTimestamp('2023-12-26')\n</code></pre> <pre><code>&gt;&gt;&gt; date = \"2023-12-22\"  # Friday before Christmas\n&gt;&gt;&gt; bday.offset(date, 0)\nTimestamp('2023-12-22') # No offset because it's a business day\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(date, 1)\nTimestamp('2023-12-26') # Offset to the next business day\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(date, -1)\nTimestamp('2023-12-21') # Offset to the previous business day\n</code></pre> Note <p>This function uses <code>numpy.busday_offset</code> under the hood, which means it follows the same conventions and limitations for business day calculations. For detailed information on error handling and behavior, refer to the <code>numpy.busday_offset</code> documentation: https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html</p> Source code in <code>pyield/bday.py</code> <pre><code>def offset(\n    dates: SingleDateTypes | SeriesDateTypes | None = None,\n    offset: int = 0,\n    roll: Literal[\"forward\", \"backward\"] = \"forward\",\n    holiday_list: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n) -&gt; pd.Timestamp | pd.Series:\n    \"\"\"\n    Offsets the dates to the next or previous business day, considering brazilian\n    holidays. This function supports both single dates and collections of dates,\n    handling them intelligently to return either a single offset date or a series of\n    offset dates. It is a wrapper for `numpy.busday_offset` adapted for Pandas data\n    types and holiday adjustments.\n\n    Args:\n        dates (SingleDateTypes | SeriesDateTypes | None, optional):\n            The date(s) to offset. Can be a single date in various formats (string,\n            `datetime`, `Timestamp`, etc.) or a collection of dates (list, tuple,\n            `Series`, etc.). If None, the current date is used.\n        offset (int): The number of business days to offset the dates. Positive for\n            future dates, negative for past dates. Zero will return the same date if\n            it's a business day, or the next business day otherwise.\n        roll (Literal[\"forward\", \"backward\"], optional): Direction to roll the date if\n            it falls on a holiday or weekend. 'forward' to the next business day,\n            'backward' to the previous. Defaults to 'forward'.\n        holiday_list (Literal[\"old\", \"new\", \"infer\"], optional):\n            The list of holidays to consider. 'old' or 'new' use predefined lists, while\n            'infer' determines the most appropriate list based on the input dates.\n            Defaults to \"infer\".\n\n    Returns:\n        pd.Timestamp | pd.Series: If a single date is provided, returns a single\n            `Timestamp` of the offset date. If a series of dates is provided, returns a\n            `Series` of offset dates.\n\n    Examples:\n        &gt;&gt;&gt; date = \"2023-12-23\"  # Saturday before Christmas\n        &gt;&gt;&gt; bday.offset(date, 0)\n        Timestamp('2023-12-26')\n\n        &gt;&gt;&gt; date = \"2023-12-22\"  # Friday before Christmas\n        &gt;&gt;&gt; bday.offset(date, 0)\n        Timestamp('2023-12-22') # No offset because it's a business day\n\n        &gt;&gt;&gt; bday.offset(date, 1)\n        Timestamp('2023-12-26') # Offset to the next business day\n\n        &gt;&gt;&gt; bday.offset(date, -1)\n        Timestamp('2023-12-21') # Offset to the previous business day\n\n    Note:\n        This function uses `numpy.busday_offset` under the hood, which means it follows\n        the same conventions and limitations for business day calculations. For detailed\n        information on error handling and behavior, refer to the `numpy.busday_offset`\n        documentation: https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html\n    \"\"\"\n    normalized_dates = _normalize_input_dates(dates)\n\n    selected_holidays = br_holidays.get_applicable_holidays(\n        normalized_dates, holiday_list\n    )\n    selected_holidays_np = _convert_to_numpy_date(selected_holidays)\n\n    dates_np = _convert_to_numpy_date(normalized_dates)\n    offsetted_dates_np = np.busday_offset(\n        dates_np, offsets=offset, roll=roll, holidays=selected_holidays_np\n    )\n    if isinstance(offsetted_dates_np, np.datetime64):\n        result = pd.Timestamp(offsetted_dates_np)\n        # Force to datetime[ns] if the input was a single date\n        result = result.as_unit(\"ns\")\n    else:\n        result_dti = pd.to_datetime(offsetted_dates_np)\n        # Force the result to be a Series if the input was not a single date\n        result = pd.Series(result_dti).astype(\"datetime64[ns]\")\n\n    return result\n</code></pre>"},{"location":"futures/","title":"Futures Data (futures)","text":"<p>Fetches data for a specified futures contract based on type and reference date.</p> <p>Parameters:</p> Name Type Description Default <code>contract_code</code> <code>str</code> <p>The B3 futures contract code identifying the derivative. Supported contract codes are: - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3. - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3. - \"FRC\": Forward Rate Agreement (FRA) from B3. - \"DAP\": DI x IPCA Spread Futures. - \"DOL\": U.S. Dollar Futures from B3. - \"WDO\": Mini U.S. Dollar Futures from B3. - \"IND\": Ibovespa Futures from B3. - \"WIN\": Mini Ibovespa Futures from B3.</p> required <code>reference_date</code> <code>str | Timestamp</code> <p>The date for which to fetch the data. If the reference date is a string, it should be in 'DD-MM-YYYY' format.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the fetched data for the specified futures contract.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the futures contract code is not recognized or supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n&gt;&gt;&gt; futures(\"DDI\", \"31-05-2024\")\n</code></pre> Source code in <code>pyield/fetchers/futures_data/__init__.py</code> <pre><code>def futures(\n    contract_code: str,\n    reference_date: str | pd.Timestamp,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches data for a specified futures contract based on type and reference date.\n\n    Args:\n        contract_code (str): The B3 futures contract code identifying the derivative.\n            Supported contract codes are:\n            - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3.\n            - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3.\n            - \"FRC\": Forward Rate Agreement (FRA) from B3.\n            - \"DAP\": DI x IPCA Spread Futures.\n            - \"DOL\": U.S. Dollar Futures from B3.\n            - \"WDO\": Mini U.S. Dollar Futures from B3.\n            - \"IND\": Ibovespa Futures from B3.\n            - \"WIN\": Mini Ibovespa Futures from B3.\n        reference_date (str | pd.Timestamp): The date for which to fetch the data.\n            If the reference date is a string, it should be in 'DD-MM-YYYY' format.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the fetched data for the specified futures\n            contract.\n\n    Raises:\n        ValueError: If the futures contract code is not recognized or supported.\n\n    Examples:\n        &gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n        &gt;&gt;&gt; futures(\"DDI\", \"31-05-2024\")\n    \"\"\"\n    contract_code = contract_code.upper()\n    if contract_code not in SUPPORTED_FUTURES:\n        raise ValueError(\"Futures contract not supported.\")\n\n    normalized_date = dc.convert_date(reference_date)\n\n    today = pd.Timestamp.today().normalize()\n    if normalized_date == today:\n        df = fetch_intraday_df(contract_code)\n    else:\n        df = fetch_historical_df(contract_code, normalized_date)\n\n    return df\n</code></pre>"},{"location":"indicators/","title":"Indicators (indicator)","text":""},{"location":"indicators/#pyield.fetchers.indicators.di","title":"<code>di(reference_date)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; di(\"31-05-2024\")\n0.00040168  # Indicates a DI daily rate of 0.02% p.d.\n</code></pre> Source code in <code>pyield/fetchers/indicators.py</code> <pre><code>def di(reference_date: pd.Timestamp) -&gt; float | None:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; di(\"31-05-2024\")\n        0.00040168  # Indicates a DI daily rate of 0.02% p.d.\n    \"\"\"\n    # https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n    di_date = reference_date.strftime(\"%d/%m/%Y\")\n    api_url = f\"https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial={di_date}&amp;dataFinal={di_date}\"\n    response = requests.get(api_url, timeout=10)\n    response.raise_for_status()\n\n    if di_date in response.text:\n        data = response.json()\n        return round(float(data[0][\"valor\"]) / 100, 8)\n    else:\n        return None\n</code></pre>"},{"location":"indicators/#pyield.fetchers.indicators.ipca_monthly_rate","title":"<code>ipca_monthly_rate(reference_date)</code>","text":"<p>Fetches the IPCA (\u00cdndice Nacional de Pre\u00e7os ao Consumidor Amplo) monthly rate from the IBGE (Instituto Brasileiro de Geografia e Estat\u00edstica) for a given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for which data is fetched. If a string is passed, it should be in 'DD-MM-YYYY' format.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The IPCA monthly rate for the specified date as a float.</p> <code>float | None</code> <p>Returns None if data is not found or in case of an error.</p> Notes <p>The function makes an API call to the IBGE's data portal to retrieve the information. An example of the API call: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202403/variaveis/63?localidades=N1[all] where '202403' is the reference date in 'YYYYMM' format. The API URL is constructed dynamically based on the reference date provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ipca_monthly_rate(\"01-04-2024\")\n0.0038  # Indicates an IPCA monthly rate of 0.38% p.m.\n</code></pre> Source code in <code>pyield/fetchers/indicators.py</code> <pre><code>def ipca_monthly_rate(reference_date: pd.Timestamp) -&gt; float | None:\n    \"\"\"\n    Fetches the IPCA (\u00cdndice Nacional de Pre\u00e7os ao Consumidor Amplo) monthly rate\n    from the IBGE (Instituto Brasileiro de Geografia e Estat\u00edstica) for a given\n    reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for which data\n            is fetched. If a string is passed, it should be in 'DD-MM-YYYY' format.\n\n    Returns:\n        float | None: The IPCA monthly rate for the specified date as a float.\n        Returns None if data is not found or in case of an error.\n\n    Notes:\n        The function makes an API call to the IBGE's data portal to retrieve the\n        information. An example of the API call:\n        https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202403/variaveis/63?localidades=N1[all]\n        where '202403' is the reference date in 'YYYYMM' format.\n        The API URL is constructed dynamically based on the reference date provided.\n\n    Examples:\n        &gt;&gt;&gt; ipca_monthly_rate(\"01-04-2024\")\n        0.0038  # Indicates an IPCA monthly rate of 0.38% p.m.\n\n    \"\"\"\n    # Format the date as 'YYYYMM' for the API endpoint\n    ipca_date = reference_date.strftime(\"%Y%m\")\n\n    # Construct the API URL using the formatted date\n    api_url = f\"https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/{ipca_date}/variaveis/63?localidades=N1[all]\"\n\n    # Send a GET request to the API\n    response = requests.get(api_url, timeout=10)\n\n    # Raises HTTPError, if one occurred\n    response.raise_for_status()\n\n    # Parse the JSON response\n    data = response.json()\n\n    # Extract and return the IPCA monthly growth rate if data is available\n    if data:\n        ipca_str = data[0][\"resultados\"][0][\"series\"][0][\"serie\"][ipca_date]\n        return round(float(ipca_str) / 100, 4)\n    else:\n        return None\n</code></pre>"},{"location":"indicators/#pyield.fetchers.indicators.selic_target","title":"<code>selic_target(reference_date)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; selic_taget(\"31-05-2024\")\n0.1075  # Indicates a SELIC target rate of 10.75% p.a.\n</code></pre> Source code in <code>pyield/fetchers/indicators.py</code> <pre><code>def selic_target(reference_date: pd.Timestamp) -&gt; float | None:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; selic_taget(\"31-05-2024\")\n        0.1075  # Indicates a SELIC target rate of 10.75% p.a.\n    \"\"\"\n    # https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n    selic_date = reference_date.strftime(\"%d/%m/%Y\")\n    api_url = f\"https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial={selic_date}&amp;dataFinal={selic_date}\"\n    response = requests.get(api_url, timeout=10)\n    response.raise_for_status()\n\n    if selic_date in response.text:\n        data = response.json()\n        return round(float(data[0][\"valor\"]) / 100, 4)\n    else:\n        return None\n</code></pre>"},{"location":"interpolator/","title":"Interpolator (intepolator)","text":""},{"location":"interpolator/#pyield.interpolator.Interpolator","title":"<code>Interpolator</code>","text":"Source code in <code>pyield/interpolator.py</code> <pre><code>class Interpolator:\n    def __init__(\n        self,\n        method: Literal[\"flat_forward\", \"linear\"],\n        known_bdays: pd.Series | list,\n        known_rates: pd.Series | list,\n    ):\n        \"\"\"\n        Initialize the Interpolator with given atributes.\n\n        Args:\n            method (Literal[\"flat_forward\", \"linear\"]): Interpolation method.\n            known_bdays (pd.Series | pd.Index | list): Series of known business days.\n            known_rates (pd.Series | pd.Index | list): Series of known interest rates.\n\n        Raises:\n            ValueError: If known_bdays and known_rates do not have the same length.\n            ValueError: If the interpolation method is not recognized\n\n        Returns:\n            Interpolator: An instance of the Interpolator\n\n        Note:\n            This class uses a 252 business days per year convention.\n        Examples:\n            &gt;&gt;&gt; known_bdays = [30, 60, 90]\n            &gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n            &gt;&gt;&gt; interpolator = Interpolator(\"linear\", known_bdays, known_rates)\n        \"\"\"\n        self.method = method\n        self.known_bdays = known_bdays\n        self.known_rates = known_rates\n        self._set_known_bdays_and_rates()\n\n    def _set_known_bdays_and_rates(self) -&gt; None:\n        \"\"\"Validate and process the inputs of the Interpolator.\"\"\"\n        if self.method not in {\"flat_forward\", \"linear\"}:\n            raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n\n        known_bdays = self.known_bdays\n        known_rates = self.known_rates\n        if isinstance(known_bdays, pd.Series):\n            known_bdays = known_bdays.to_list()\n        if isinstance(known_rates, pd.Series):\n            known_rates = known_rates.to_list()\n\n        if len(known_bdays) != len(known_rates):\n            raise ValueError(\"known_bdays and known_rates must have the same length.\")\n\n        df = pd.DataFrame({\"bday\": known_bdays, \"rate\": known_rates})\n        df = df.dropna().drop_duplicates(subset=\"bday\").sort_values(\"bday\")\n\n        self._known_bdays = df[\"bday\"].to_list()\n        self._known_rates = df[\"rate\"].to_list()\n\n    def _flat_forward(self, bday: int) -&gt; float:\n        \"\"\"Performs the interest rate interpolation using the flat forward method.\"\"\"\n\n        # Find i such that known_bdays[i-1] &lt; bday &lt; known_bdays[i]\n        i = bisect.bisect_left(self._known_bdays, bday)\n\n        # Get previous and next known rates and business days\n        prev_rate = self._known_rates[i - 1]\n        prev_bday = self._known_bdays[i - 1]\n        next_rate = self._known_rates[i]\n        next_bday = self._known_bdays[i]\n\n        # Perform flat forward interpolation\n        a = (1 + prev_rate) ** (prev_bday / 252)\n        b = (1 + next_rate) ** (next_bday / 252)\n        c = (bday - prev_bday) / (next_bday - prev_bday)\n        return (a * (b / a) ** c) ** (252 / bday) - 1\n\n    def _linear(self, bday: int) -&gt; float:\n        \"\"\"Performs linear interpolation.\"\"\"\n        np_float = np.interp(bday, self._known_bdays, self._known_rates)\n        return float(np_float)\n\n    def interpolate(self, bday: int) -&gt; float:\n        \"\"\"\n        Finds the appropriate interpolation point and returns the interest rate\n        interpolated by the specified method from that point.\n\n        Args:\n            bday (int): Number of business days for which the interest rate is to be\n                calculated.\n\n        Returns:\n            float: The interest rate interpolated by the specified method for the given\n                number of business days.\n\n        Examples:\n                &gt;&gt;&gt; known_bdays = [30, 60, 90]\n                &gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n                &gt;&gt;&gt; linear = Interpolator(\"linear\", known_bdays, known_rates)\n                &gt;&gt;&gt; linear.interpolate(45)\n                0.0475\n                &gt;&gt;&gt; fforward = Interpolator(\"flat_forward\", known_bdays, known_rates)\n                &gt;&gt;&gt; fforward.interpolate(45)\n                0.04833068080970859\n        \"\"\"\n        # Check for edge cases\n        if bday &lt; self._known_bdays[0]:\n            return self._known_rates[0]\n        elif bday &gt; self._known_bdays[-1]:\n            return self._known_rates[-1]\n        elif bday in self._known_bdays:\n            return self._known_rates[self._known_bdays.index(bday)]\n\n        if self.method == \"flat_forward\":\n            return self._flat_forward(bday)\n        elif self.method == \"linear\":\n            return self._linear(bday)\n        else:\n            raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n\n    def __call__(self, bday: int) -&gt; float:\n        \"\"\"\n        Allows the instance to be called as a function to perform interpolation.\n\n        Args:\n            bday (int): Number of business days for which the interest rate is to be\n                calculated.\n\n        Returns:\n            float: The interest rate interpolated by the specified method for the given\n                number of business days.\n        \"\"\"\n        return self.interpolate(bday)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.interpolate","title":"<code>interpolate(bday)</code>","text":"<p>Finds the appropriate interpolation point and returns the interest rate interpolated by the specified method from that point.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interest rate interpolated by the specified method for the given number of business days.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n&gt;&gt;&gt; linear = Interpolator(\"linear\", known_bdays, known_rates)\n&gt;&gt;&gt; linear.interpolate(45)\n0.0475\n&gt;&gt;&gt; fforward = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; fforward.interpolate(45)\n0.04833068080970859\n</code></pre> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bday: int) -&gt; float:\n    \"\"\"\n    Finds the appropriate interpolation point and returns the interest rate\n    interpolated by the specified method from that point.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for the given\n            number of business days.\n\n    Examples:\n            &gt;&gt;&gt; known_bdays = [30, 60, 90]\n            &gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n            &gt;&gt;&gt; linear = Interpolator(\"linear\", known_bdays, known_rates)\n            &gt;&gt;&gt; linear.interpolate(45)\n            0.0475\n            &gt;&gt;&gt; fforward = Interpolator(\"flat_forward\", known_bdays, known_rates)\n            &gt;&gt;&gt; fforward.interpolate(45)\n            0.04833068080970859\n    \"\"\"\n    # Check for edge cases\n    if bday &lt; self._known_bdays[0]:\n        return self._known_rates[0]\n    elif bday &gt; self._known_bdays[-1]:\n        return self._known_rates[-1]\n    elif bday in self._known_bdays:\n        return self._known_rates[self._known_bdays.index(bday)]\n\n    if self.method == \"flat_forward\":\n        return self._flat_forward(bday)\n    elif self.method == \"linear\":\n        return self._linear(bday)\n    else:\n        raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n</code></pre>"},{"location":"lft/","title":"LFT (lft)","text":""},{"location":"lft/#pyield.bonds.lft.anbima_data","title":"<code>anbima_data(reference_date)</code>","text":"<p>Fetch LFT Anbima data for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the Anbima data for the reference date.</p> Source code in <code>pyield/bonds/lft.py</code> <pre><code>def anbima_data(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch LFT Anbima data for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the Anbima data for the reference date.\n    \"\"\"\n    return ft.anbima_data(reference_date, \"LFT\")\n</code></pre>"},{"location":"lft/#pyield.bonds.lft.anbima_historical_rates","title":"<code>anbima_historical_rates(maturity_date)</code>","text":"<p>Fetch historical LFT Anbima indicative rates for the given maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the rates indexed by reference date.</p> Source code in <code>pyield/bonds/lft.py</code> <pre><code>def anbima_historical_rates(maturity_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch historical LFT Anbima indicative rates for the given maturity date.\n\n    Args:\n        maturity_date (str | pd.Timestamp): The maturity date of the bond.\n\n    Returns:\n        pd.Series: A Series containing the rates indexed by reference date.\n    \"\"\"\n    return ut.get_anbima_historical_rates(\"LFT\", maturity_date)\n</code></pre>"},{"location":"lft/#pyield.bonds.lft.anbima_rates","title":"<code>anbima_rates(reference_date)</code>","text":"<p>Fetch LFT Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the rates indexed by maturity date.</p> Source code in <code>pyield/bonds/lft.py</code> <pre><code>def anbima_rates(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch LFT Anbima indicative rates for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series containing the rates indexed by maturity date.\n    \"\"\"\n    return ut.get_anbima_rates(reference_date, \"LFT\")\n</code></pre>"},{"location":"lft/#pyield.bonds.lft.quote","title":"<code>quote(settlement_date, maturity_date, yield_rate)</code>","text":"<p>Calculate the quote of a LFT bond using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement_date</code> <code>str | Timestamp</code> <p>The settlement date of the bond.</p> required <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date of the bond.</p> required <code>yield_rate</code> <code>float</code> <p>The annualized yield of the bond</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The quote of the bond.</p> <p>Examples:</p> <p>Calculate the quote of a LFT bond with a 0.02 yield rate:</p> <pre><code>&gt;&gt;&gt; lft.quote(\n...     settlement_date=\"24-07-2024\",\n...     maturity_date=\"01-09-2030\",\n...     yield_rate=0.001717,  # 0.1717%\n... )\n98.9645\n</code></pre> Source code in <code>pyield/bonds/lft.py</code> <pre><code>def quote(\n    settlement_date: str | pd.Timestamp,\n    maturity_date: str | pd.Timestamp,\n    yield_rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the quote of a LFT bond using Anbima rules.\n\n    Args:\n        settlement_date (str | pd.Timestamp): The settlement date of the bond.\n        maturity_date (str | pd.Timestamp): The maturity date of the bond.\n        yield_rate (float): The annualized yield of the bond\n\n    Returns:\n        float: The quote of the bond.\n\n    Examples:\n        Calculate the quote of a LFT bond with a 0.02 yield rate:\n        &gt;&gt;&gt; lft.quote(\n        ...     settlement_date=\"24-07-2024\",\n        ...     maturity_date=\"01-09-2030\",\n        ...     yield_rate=0.001717,  # 0.1717%\n        ... )\n        98.9645\n    \"\"\"\n    # Validate and normalize dates\n    settlement_date = dc.convert_date(settlement_date)\n    maturity_date = dc.convert_date(maturity_date)\n\n    # The number of bdays between settlement (inclusive) and the maturity (exclusive)\n    bdays = bday.count(settlement_date, maturity_date)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = ut.truncate(bdays / 252, 14)\n\n    discount_factor = 1 / (1 + yield_rate) ** num_of_years\n\n    return ut.truncate(100 * discount_factor, 4)\n</code></pre>"},{"location":"ltn/","title":"LTN (ltn)","text":""},{"location":"ltn/#pyield.bonds.ltn.anbima_data","title":"<code>anbima_data(reference_date)</code>","text":"<p>Fetch LTN Anbima data for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the Anbima data for the reference date.</p> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def anbima_data(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch LTN Anbima data for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the Anbima data for the reference date.\n    \"\"\"\n    return ft.anbima_data(reference_date, \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.anbima_historical_rates","title":"<code>anbima_historical_rates(maturity_date)</code>","text":"<p>Fetch historical LTN Anbima indicative rates for the given maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the rates for the given maturity date.</p> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def anbima_historical_rates(maturity_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch historical LTN Anbima indicative rates for the given maturity date.\n\n    Args:\n        maturity_date (str | pd.Timestamp): The maturity date of the bond.\n\n    Returns:\n        pd.Series: A Series containing the rates for the given maturity date.\n    \"\"\"\n    return ut.get_anbima_historical_rates(\"LTN\", maturity_date)\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.anbima_rates","title":"<code>anbima_rates(reference_date)</code>","text":"<p>Fetch LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the rates indexed by maturity date.</p> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def anbima_rates(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series containing the rates indexed by maturity date.\n    \"\"\"\n    return ut.get_anbima_rates(reference_date, \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.di_spreads","title":"<code>di_spreads(reference_date)</code>","text":"<p>Calculates the DI spread for the LTN based on ANBIMA's indicative rates.</p> <p>This function fetches the indicative rates for the NTN-F bonds and the DI futures rates and calculates the spread between these rates in basis points.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for the spread calculation. If None or not provided, defaults to the previous business day according to the Brazilian calendar.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A pandas series containing the calculated spreads in basis points indexed by maturity dates.</p> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def di_spreads(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Calculates the DI spread for the LTN based on ANBIMA's indicative rates.\n\n    This function fetches the indicative rates for the NTN-F bonds and the DI futures\n    rates and calculates the spread between these rates in basis points.\n\n    Parameters:\n        reference_date (str | pd.Timestamp, optional): The reference date for the\n            spread calculation. If None or not provided, defaults to the previous\n            business day according to the Brazilian calendar.\n\n    Returns:\n        pd.Series: A pandas series containing the calculated spreads in basis points\n            indexed by maturity dates.\n    \"\"\"\n    reference_date = dc.convert_date(reference_date)\n    # Fetch DI Spreads for the reference date\n    df = ut.di_spreads(reference_date)\n    df.query(\"BondType == 'LTN'\", inplace=True)\n    df.sort_values([\"MaturityDate\"], ignore_index=True, inplace=True)\n    df.set_index(\"MaturityDate\", inplace=True)\n    return df[\"DISpread\"]\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.price","title":"<code>price(settlement_date, maturity_date, discount_rate)</code>","text":"<p>Calculate the LTN price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement_date</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>discount_rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-F.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The LTN price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n535.279902\n</code></pre> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def price(\n    settlement_date: str | pd.Timestamp,\n    maturity_date: str | pd.Timestamp,\n    discount_rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the LTN price using Anbima rules.\n\n    Args:\n        settlement_date (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity_date (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n        discount_rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-F.\n\n    Returns:\n        float: The LTN price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n        535.279902\n    \"\"\"\n\n    # Validate and normalize dates\n    settlement_date = dc.convert_date(settlement_date)\n    maturity_date = dc.convert_date(maturity_date)\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement_date, maturity_date)\n\n    # Calculate the number of periods truncated as per Anbima rule\n    num_of_years = ut.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + discount_rate) ** num_of_years\n\n    # Truncate the price to 6 decimal places as per Anbima rules\n    return ut.truncate(FACE_VALUE / discount_factor, 6)\n</code></pre>"},{"location":"ntnb/","title":"NTN-B (ntnb)","text":""},{"location":"ntnb/#pyield.bonds.ntnb.anbima_data","title":"<code>anbima_data(reference_date)</code>","text":"<p>Fetch NTN-B Anbima data for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the Anbima data for the reference date.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def anbima_data(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch NTN-B Anbima data for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the Anbima data for the reference date.\n    \"\"\"\n    return ft.anbima_data(reference_date, \"NTN-B\")\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.anbima_historical_rates","title":"<code>anbima_historical_rates(maturity_date)</code>","text":"<p>Fetch historical NTN-B Anbima indicative rates for the given maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the rates for the given maturity date.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def anbima_historical_rates(maturity_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch historical NTN-B Anbima indicative rates for the given maturity date.\n\n    Args:\n        maturity_date (str | pd.Timestamp): The maturity date of the bond.\n\n    Returns:\n        pd.Series: A Series containing the rates for the given maturity date.\n    \"\"\"\n    return ut.get_anbima_historical_rates(\"NTN-B\", maturity_date)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.anbima_rates","title":"<code>anbima_rates(reference_date)</code>","text":"<p>Fetch NTN-B Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the rates indexed by maturity date.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def anbima_rates(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch NTN-B Anbima indicative rates for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series containing the rates indexed by maturity date.\n    \"\"\"\n    return ut.get_anbima_rates(reference_date, \"NTN-B\")\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.anbima_spot_rates","title":"<code>anbima_spot_rates(reference_date, settlement_date)</code>","text":"<p>Fetch the NTN-B Anbima indicative rates and calculate the spot rates for the bonds.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <code>settlement_date</code> <code>str | Timestamp</code> <p>The reference date for settlement.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the maturity dates and corresponding real spot rates.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def anbima_spot_rates(\n    reference_date: str | pd.Timestamp,\n    settlement_date: str | pd.Timestamp,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the NTN-B Anbima indicative rates and calculate the spot rates for the bonds.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n        settlement_date (str | pd.Timestamp): The reference date for settlement.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the maturity dates and corresponding real\n            spot rates.\n    \"\"\"\n    ytm_rates = anbima_rates(reference_date)\n    return spot_rates(settlement_date, ytm_rates)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.bei_rates","title":"<code>bei_rates(reference_date, settlement_date, ytm_rates)</code>","text":"<p>Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real interest rates.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str or Timestamp</code> <p>The reference date for fetching data and performing calculations.</p> required <code>settlement_date</code> <code>str or Timestamp</code> <p>The settlement date for the bonds.</p> required <code>ytm_rates</code> <code>Series</code> <p>A series of Yield to Maturity (YTM) rates corresponding to the maturity dates of the bonds indexed by the maturity dates.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the breakeven inflation rates.</p> Returned columns <ul> <li>MaturityDate: Maturity date of the bond.</li> <li>BDays: Number of business days from the settlement date to the maturity.</li> <li>YTM: Yield to Maturity rate for the bond.</li> <li>RIR: Real Interest Rate for the bond.</li> <li>NIR_DI: Nominal Interest Rate for the bond.</li> <li>NIR_PRE: Nominal Interest Rate for the bond with DI spread.</li> <li>BEI_DI: Breakeven Inflation Rate for the bond.</li> <li>BEI_PRE: Breakeven Inflation Rate for the bond adjusted for DI spread.</li> </ul> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def bei_rates(\n    reference_date: str | pd.Timestamp,\n    settlement_date: str | pd.Timestamp,\n    ytm_rates: pd.Series,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real\n    interest rates.\n\n    Args:\n        reference_date (str or pd.Timestamp): The reference date for fetching data and\n            performing calculations.\n        settlement_date (str or pd.Timestamp): The settlement date for the bonds.\n        ytm_rates (pd.Series): A series of Yield to Maturity (YTM) rates corresponding\n            to the maturity dates of the bonds indexed by the maturity dates.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the breakeven inflation rates.\n\n    Returned columns:\n        - MaturityDate: Maturity date of the bond.\n        - BDays: Number of business days from the settlement date to the maturity.\n        - YTM: Yield to Maturity rate for the bond.\n        - RIR: Real Interest Rate for the bond.\n        - NIR_DI: Nominal Interest Rate for the bond.\n        - NIR_PRE: Nominal Interest Rate for the bond with DI spread.\n        - BEI_DI: Breakeven Inflation Rate for the bond.\n        - BEI_PRE: Breakeven Inflation Rate for the bond adjusted for DI spread.\n    \"\"\"\n    # Normalize input dates\n    reference_date = dc.convert_date(reference_date)\n    settlement_date = dc.convert_date(settlement_date)\n\n    # Fetch Nominal Interest Rate (NIR) data\n    df_nir = _get_nir_df(reference_date)\n\n    ytm_interplator = it.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=df_nir[\"BDaysToExp\"],\n        known_rates=df_nir[\"NIR_DI\"],\n    )\n    # Calculate Real Interest Rate (RIR)\n    df = spot_rates(settlement_date, ytm_rates)\n    df = df.rename(columns={\"SpotRate\": \"RIR\"})\n    df[\"BDays\"] = bday.count(reference_date, df[\"MaturityDate\"])\n    df[\"NIR_DI\"] = df[\"BDays\"].apply(ytm_interplator)\n\n    # Calculate Breakeven Inflation Rate (BEI)\n    df[\"BEI_DI\"] = ((df[\"NIR_DI\"] + 1) / (df[\"RIR\"] + 1)) - 1\n\n    # Adjust BEI for DI spread in prefixed bonds\n    ytm_interplator = it.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=df_nir[\"BDaysToExp\"],\n        known_rates=df_nir[\"NIR_PRE\"],\n    )\n    df[\"NIR_PRE\"] = df[\"BDays\"].apply(ytm_interplator)\n    df[\"BEI_PRE\"] = ((df[\"NIR_PRE\"] + 1) / (df[\"RIR\"] + 1)) - 1\n\n    cols_reordered = [\n        \"MaturityDate\",\n        \"BDays\",\n        \"YTM\",\n        \"RIR\",\n        \"NIR_DI\",\n        \"NIR_PRE\",\n        \"BEI_DI\",\n        \"BEI_PRE\",\n    ]\n    return df[cols_reordered].copy()\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.coupon_dates","title":"<code>coupon_dates(start_date, maturity_date)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. Coupon payments are made on the 15th of February, May, August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str | Timestamp</code> <p>The date to start generating coupon dates.</p> required <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>list[pd.Timestamp]: List of coupon dates between start and maturity dates.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def coupon_dates(\n    start_date: str | pd.Timestamp,\n    maturity_date: str | pd.Timestamp,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. Coupon payments are made on the 15th of February, May,\n    August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B\n    bond is determined by its maturity date.\n\n    Args:\n        start_date (str | pd.Timestamp): The date to start generating coupon dates.\n        maturity_date (str | pd.Timestamp): The maturity date.\n\n    Returns:\n        list[pd.Timestamp]: List of coupon dates between start and maturity dates.\n    \"\"\"\n    # Validate and normalize dates\n    start_date = dc.convert_date(start_date)\n    maturity_date = dc.convert_date(maturity_date)\n\n    # Check if maturity date is after the start date\n    if maturity_date &lt; start_date:\n        raise ValueError(\"Maturity date must be after the start date.\")\n\n    # Check if the maturity date is a valid NTN-B maturity date\n    if maturity_date.day != COUPON_DAY or maturity_date.month not in COUPON_MONTHS:\n        raise ValueError(\"NTN-B maturity must be 15/02, 15/05, 15/08, or 15/11.\")\n\n    # Initialize loop variables\n    cp_date = maturity_date\n    cp_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while cp_date &gt;= start_date:\n        cp_dates.append(cp_date)\n        # Move the coupon date back 6 months\n        cp_date -= pd.DateOffset(months=6)\n\n    return pd.Series(cp_dates).sort_values(ignore_index=True)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.price","title":"<code>price(vna, quote)</code>","text":"<p>Calculate the NTN-B price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-B bond.</p> required <code>quote</code> <code>float</code> <p>The NTN-B quote in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n4271.864805\n</code></pre> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def price(\n    vna: float,\n    quote: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B price using Anbima rules.\n\n    Args:\n        vna (float): The nominal value of the NTN-B bond.\n        quote (float): The NTN-B quote in base 100.\n\n    Returns:\n        float: The NTN-B price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n        4271.864805\n    \"\"\"\n    return ut.truncate(vna * quote / 100, 6)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.quote","title":"<code>quote(settlement_date, maturity_date, discount_rate)</code>","text":"<p>Calculate the NTN-B quote in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement_date</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>discount_rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B quote truncated to 4 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ntnb.quote(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quote(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n</code></pre> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def quote(\n    settlement_date: str | pd.Timestamp,\n    maturity_date: str | pd.Timestamp,\n    discount_rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B quote in base 100 using Anbima rules.\n\n    Args:\n        settlement_date (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity_date (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n        discount_rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n\n    Returns:\n        float: The NTN-B quote truncated to 4 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; ntnb.quote(\"31-05-2024\", \"15-05-2035\", 0.061490)\n        99.3651\n        &gt;&gt;&gt; ntnb.quote(\"31-05-2024\", \"15-08-2060\", 0.061878)\n        99.5341\n    \"\"\"\n    # Validate and normalize dates\n    settlement_date = dc.convert_date(settlement_date)\n    maturity_date = dc.convert_date(maturity_date)\n\n    # Get the coupon dates between the settlement and maturity dates\n    payment_dates = coupon_dates(settlement_date, maturity_date)\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement_date, payment_dates)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cash_flows = np.where(payment_dates == maturity_date, FINAL_PMT, COUPON_PMT)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = ut.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + discount_rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    discounted_cash_flows = (cash_flows / discount_factor).round(10)\n\n    # Return the quote (the dcf sum) truncated as per Anbima rules\n    return ut.truncate(discounted_cash_flows.sum(), 4)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.spot_rates","title":"<code>spot_rates(settlement_date, ytm_rates)</code>","text":"<p>Calculate the spot rates for NTN-B bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price.</p> <p>Parameters:</p> Name Type Description Default <code>settlement_date</code> <code>str | Timestamp</code> <p>The reference date for settlement.</p> required <code>ytm_rates</code> <code>Series</code> <p>Series of yield to maturity rates indexed by the maturity dates of the bonds.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the maturity dates and corresponding real spot rates.</p> Notes <p>The calculation of the spot rates for NTN-B bonds considers the following steps:     - Map all all possible payment dates up to the longest maturity date.     - Interpolate the YTM rates in the intermediate payment dates.     - Calculate the NTN-B quote for each maturity date.     - Calculate the real spot rates for each maturity date.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def spot_rates(\n    settlement_date: str | pd.Timestamp,\n    ytm_rates: pd.Series,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the spot rates for NTN-B bonds using the bootstrap method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price.\n\n\n    Args:\n        settlement_date (str | pd.Timestamp): The reference date for settlement.\n        ytm_rates (pd.Series): Series of yield to maturity rates indexed by the\n            maturity dates of the bonds.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the maturity dates and corresponding real\n            spot rates.\n\n    Notes:\n        The calculation of the spot rates for NTN-B bonds considers the following steps:\n            - Map all all possible payment dates up to the longest maturity date.\n            - Interpolate the YTM rates in the intermediate payment dates.\n            - Calculate the NTN-B quote for each maturity date.\n            - Calculate the real spot rates for each maturity date.\n    \"\"\"\n    # Process and validate the input data\n    settlement_date = dc.convert_date(settlement_date)\n    ytm_rates = ut.standardize_rates(ytm_rates)\n\n    # Create the interpolator object\n    ytm_rate_interpolator = it.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement_date, ytm_rates.index),\n        known_rates=ytm_rates,\n    )\n\n    last_ntnb = ytm_rates.index.max()\n\n    # Generate coupon dates up to the longest maturity date\n    all_coupon_dates = _coupon_dates_map(start=settlement_date, end=last_ntnb)\n\n    # Create a DataFrame with all coupon dates and the corresponding YTM\n    df_spot = pd.DataFrame(data=all_coupon_dates, columns=[\"MaturityDate\"])\n    df_spot[\"BDays\"] = bday.count(settlement_date, df_spot[\"MaturityDate\"])\n    df_spot[\"YTM\"] = df_spot[\"BDays\"].apply(ytm_rate_interpolator)\n\n    # The Bootstrap loop to calculate spot rates\n    for index in df_spot.index:\n        # Get the row values using the index\n        maturity = df_spot.at[index, \"MaturityDate\"]\n        bdays = df_spot.at[index, \"BDays\"]\n        ytm = df_spot.at[index, \"YTM\"]\n\n        # Get the coupon dates for the bond without the last one (principal + coupon)\n        cp_dates = coupon_dates(settlement_date, maturity)\n\n        # If there is only one coupon date and this date is the first maturity date\n        # of an existing bond, the ytm rate is also a spot rate.\n        if len(cp_dates) == 1 and cp_dates[0] == ytm_rates.index[0]:\n            df_spot.at[index, \"SpotRate\"] = ytm\n            continue\n\n        # Calculate the real spot rate for the bond\n        coupons_pv = _calculate_coupons_pv(df_spot, settlement_date, maturity)\n        bond_price = quote(settlement_date, maturity, ytm)\n        spot_rate = (FINAL_PMT / (bond_price - coupons_pv)) ** (252 / bdays) - 1\n        df_spot.at[index, \"SpotRate\"] = spot_rate\n\n    df_spot.drop(columns=[\"BDays\"], inplace=True)\n    # Return the result without the intermediate coupon dates (virtual bonds)\n    existing_maturities = ytm_rates.index  # noqa\n    return df_spot.query(\"MaturityDate in @existing_maturities\").reset_index(drop=True)\n</code></pre>"},{"location":"ntnf/","title":"NTN-F (ntnf)","text":""},{"location":"ntnf/#pyield.bonds.ntnf.anbima_data","title":"<code>anbima_data(reference_date)</code>","text":"<p>Fetch NTN-F Anbima data for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the Anbima data for the reference date.</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def anbima_data(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch NTN-F Anbima data for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the Anbima data for the reference date.\n    \"\"\"\n    return ft.anbima_data(reference_date, \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.anbima_historical_rates","title":"<code>anbima_historical_rates(maturity_date)</code>","text":"<p>Fetch historical NTN-F Anbima indicative rates for the given maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the rates for the given maturity date.</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def anbima_historical_rates(maturity_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch historical NTN-F Anbima indicative rates for the given maturity date.\n\n    Args:\n        maturity_date (str | pd.Timestamp): The maturity date of the bond.\n\n    Returns:\n        pd.Series: A Series containing the rates for the given maturity date.\n    \"\"\"\n    return ut.get_anbima_historical_rates(\"NTN-F\", maturity_date)\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.anbima_rates","title":"<code>anbima_rates(reference_date)</code>","text":"<p>Fetch NTN-F Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the rates indexed by maturity date.</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def anbima_rates(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch NTN-F Anbima indicative rates for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series containing the rates indexed by maturity date.\n    \"\"\"\n    return ut.get_anbima_rates(reference_date, \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.coupon_dates","title":"<code>coupon_dates(start_date, maturity_date)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. Coupon payments are made on the 1st of January and July. The NTN-F bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str | Timestamp</code> <p>The date to start generating coupon dates.</p> required <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series of coupon dates within the specified range.</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def coupon_dates(\n    start_date: str | pd.Timestamp,\n    maturity_date: str | pd.Timestamp,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. Coupon payments are made on the 1st of January and July.\n    The NTN-F bond is determined by its maturity date.\n\n    Args:\n        start_date (str | pd.Timestamp): The date to start generating coupon dates.\n        maturity_date (str | pd.Timestamp): The maturity date.\n\n    Returns:\n        pd.Series: Series of coupon dates within the specified range.\n    \"\"\"\n    # Validate and normalize dates\n    start_date = dc.convert_date(start_date)\n    maturity_date = dc.convert_date(maturity_date)\n\n    # Check if maturity date is after the start date\n    if maturity_date &lt; start_date:\n        raise ValueError(\"Maturity date must be after the start date.\")\n\n    # Check if the maturity date is a valid NTN-F maturity date\n    if maturity_date.day != COUPON_DAY or maturity_date.month not in COUPON_MONTHS:\n        raise ValueError(\"NTN-F maturity date must be the 1st of January or July.\")\n\n    # Initialize loop variables\n    coupon_date = maturity_date\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt;= start_date:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= pd.DateOffset(months=6)\n\n    # Return the coupon dates as a sorted Series\n    return pd.Series(coupon_dates).sort_values(ignore_index=True)\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.di_spreads","title":"<code>di_spreads(reference_date)</code>","text":"<p>Calculates the DI spread for the NTN-F based on ANBIMA's indicative rates.</p> <p>This function fetches the indicative rates for the NTN-F bonds and the DI futures rates and calculates the spread between these rates in basis points.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for the spread calculation.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A pandas series containing the calculated spreads in basis points indexed by maturity dates.</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def di_spreads(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Calculates the DI spread for the NTN-F based on ANBIMA's indicative rates.\n\n    This function fetches the indicative rates for the NTN-F bonds and the DI futures\n    rates and calculates the spread between these rates in basis points.\n\n    Parameters:\n        reference_date (str | pd.Timestamp, optional): The reference date for the\n            spread calculation.\n\n    Returns:\n        pd.Series: A pandas series containing the calculated spreads in basis points\n            indexed by maturity dates.\n    \"\"\"\n    reference_date = dc.convert_date(reference_date)\n    # Fetch DI Spreads for the reference date\n    df = ut.di_spreads(reference_date)\n    df.query(\"BondType == 'NTN-F'\", inplace=True)\n    df.sort_values([\"MaturityDate\"], ignore_index=True, inplace=True)\n    df.set_index(\"MaturityDate\", inplace=True)\n    return df[\"DISpread\"]\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.price","title":"<code>price(settlement_date, maturity_date, discount_rate)</code>","text":"<p>Calculate the NTN-F price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement_date</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity_date</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>discount_rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-F.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-F price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 48.81, which represents a 10% annual   coupon rate compounded semi-annually and rounded to 5 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n895.359254\n</code></pre> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def price(\n    settlement_date: str | pd.Timestamp,\n    maturity_date: str | pd.Timestamp,\n    discount_rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-F price using Anbima rules.\n\n    Args:\n        settlement_date (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity_date (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n        discount_rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-F.\n\n    Returns:\n        float: The NTN-F price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 48.81, which represents a 10% annual\n          coupon rate compounded semi-annually and rounded to 5 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n        895.359254\n    \"\"\"\n\n    # Validate and normalize dates\n    settlement_date = dc.convert_date(settlement_date)\n    maturity_date = dc.convert_date(maturity_date)\n\n    # Create a Series with the coupon dates\n    payment_dates = pd.Series(coupon_dates(settlement_date, maturity_date))\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement_date, payment_dates)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cash_flows = np.where(payment_dates == maturity_date, FINAL_PMT, COUPON_PMT)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = ut.truncate(bdays / 252, 14)\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    discount_factor = (1 + discount_rate) ** num_of_years\n    discounted_cash_flows = (cash_flows / discount_factor).round(9)\n\n    # Return the sum of the discounted cash flows truncated as per Anbima rules\n    return ut.truncate(discounted_cash_flows.sum(), 6)\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.spot_rates","title":"<code>spot_rates(settlement_date, ltn_rates, ntnf_rates)</code>","text":"<p>Calculate the spot rates for NTN-F bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price.</p> <p>Parameters:</p> Name Type Description Default <code>settlement_date</code> <code>str | Timestamp</code> <p>The settlement date in as a pandas Timestamp or a string in 'DD-MM-YYYY' format.</p> required <code>ltn_rates</code> <code>Series</code> <p>The LTN known rates, indexed by maturity date.</p> required <code>ntnf_rates</code> <code>Series</code> <p>The NTN-F known rates, indexed by maturity date.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the maturity dates and the corresponding spot rates.</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def spot_rates(\n    settlement_date: str | pd.Timestamp,\n    ltn_rates: pd.Series,\n    ntnf_rates: pd.Series,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the spot rates for NTN-F bonds using the bootstrap method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price.\n\n    Args:\n        settlement_date (str | pd.Timestamp): The settlement date in as\n            a pandas Timestamp or a string in 'DD-MM-YYYY' format.\n        ltn_rates (pd.Series): The LTN known rates, indexed by maturity date.\n        ntnf_rates (pd.Series): The NTN-F known rates, indexed by maturity\n            date.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the maturity dates and\n            the corresponding spot rates.\n    \"\"\"\n    # Process and validate the input data\n    settlement_date = dc.convert_date(settlement_date)\n    ltn_rates = ut.standardize_rates(ltn_rates)\n    ntnf_rates = ut.standardize_rates(ntnf_rates)\n\n    # Create flat forward interpolators for LTN and NTN-F rates\n    ltn_rate_interpolator = it.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement_date, ltn_rates.index),\n        known_rates=ltn_rates,\n    )\n    ntnf_rate_interpolator = it.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement_date, ntnf_rates.index),\n        known_rates=ntnf_rates,\n    )\n\n    # Determine the last maturity dates for LTN and NTN-F rates\n    last_ltn = ltn_rates.index.max()\n    last_ntnf = ntnf_rates.index.max()\n\n    # Generate all coupon dates up to the last NTN-F maturity date\n    all_coupon_dates = _coupon_dates_map(settlement_date, last_ntnf)\n\n    # Create a DataFrame with all coupon dates and the corresponding YTM\n    df_spot = pd.DataFrame(data=all_coupon_dates, columns=[\"MaturityDate\"])\n    df_spot[\"BDays\"] = bday.count(start=settlement_date, end=df_spot[\"MaturityDate\"])\n    df_spot[\"YTM\"] = df_spot[\"BDays\"].apply(ntnf_rate_interpolator)\n\n    # The Bootstrap loop to calculate spot rates\n    for index in df_spot.index:\n        maturity = df_spot.at[index, \"MaturityDate\"]\n        bdays = df_spot.at[index, \"BDays\"]\n\n        if maturity &lt;= last_ltn:\n            # Use LTN rates for maturities before the last LTN maturity date\n            df_spot.at[index, \"SpotRate\"] = ltn_rate_interpolator(bdays)\n            continue\n\n        # Calculate the spot rate for the bond\n        coupons_pv = _calculate_coupons_pv(df_spot, settlement_date, maturity)\n        ytm = df_spot.at[index, \"YTM\"]\n        bond_price = price(settlement_date, maturity, ytm)\n        spot_rate = (FINAL_PMT / (bond_price - coupons_pv)) ** (252 / bdays) - 1\n        df_spot.at[index, \"SpotRate\"] = spot_rate\n\n    return df_spot\n</code></pre>"},{"location":"articles/pyield_intro/","title":"Introdu\u00e7\u00e3o a PYield","text":""},{"location":"articles/pyield_intro/#uma-biblioteca-em-python-para-obtecao-de-dados-de-instrumentos-de-renda-fixa-brasileira","title":"Uma biblioteca em Python para obte\u00e7\u00e3o de dados de instrumentos de Renda Fixa brasileira","text":"<p>Se voc\u00ea \u00e9 um entusiasta de VBA e Excel, pode pular esse artigo que aqui n\u00e3o \u00e9 lugar para voc\u00ea! Brincadeira, voc\u00ea \u00e9 bem-vindo tamb\u00e9m. Afinal, essa pode ser uma \u00f3tima desculpa para voc\u00ea finalmente aprender Python \ud83d\ude02</p> <p>Brincadeiras \u00e0 parte, qualquer um que trabalhe com an\u00e1lise de renda fixa no sabe que a obten\u00e7\u00e3o de dados de fontes como ANBIMA e B3 pode ser uma tarefa complicada. Outro ponto refere-se ao tratamento dos feriados e dias \u00fateis, um verdadeiro pesadelo para quem precisa calcular prazos e vencimentos, ainda mais depois que criaram um novo feriado nacional no final do ano passado. Sim, agora temos que considerar duas listas de feriados nacionais, uma para dados ateriores a 26-12-2023 e outra para depois.</p> <p>Claro que para os afortunados com acesso a servi\u00e7os pagos como Bloomberg, a obten\u00e7\u00e3o desse tipo de dados j\u00e1 \u00e9 bem f\u00e1cil. Mas para a maioria dos analistas financeiros, pesquisadores e entusiastas do mercado, a obten\u00e7\u00e3o e processamento desses dados pode ser um desafio. Afinal, voc\u00ea ter\u00e1 que lidar com chamadas para diversas APIs como a do IBGE, do BACEN, da ANBIMA, da B3, e por a\u00ed vai. Em alguns casos, o dado tem que ser extra\u00eddo diretamente de sites, o que pode ser ainda mais complicado.</p>"},{"location":"articles/pyield_intro/#o-que-e-pyield","title":"O que \u00e9 PYield?","text":"<p>A biblioteca Python foi projetada especificamente para a obten\u00e7\u00e3o e tratamento de dados de instrumentos de renda fixa. Ou seja, \u00e9 uma tentativa de  simplificar a obten\u00e7\u00e3o e processamento de dados de fontes prim\u00e1rias como ANBIMA e B3, fornecendo uma API de f\u00e1cil utiliza\u00e7\u00e3o.</p> <p>Utilizando a robustez de bibliotecas populares de Python, como Pandas, Requests e Numpy, PYield pode ser usada como backend de aplica\u00e7\u00f5es mais complexas, removendo a parte pesada relacionada a obten\u00e7\u00e3o e processamento de dados de fontes e formatos diversos.</p>"},{"location":"articles/pyield_intro/#caracteristicas-principais","title":"Caracter\u00edsticas Principais","text":"<ul> <li>Coleta de Dados: Obtenha dados diretamente de fontes prim\u00e1rias como ANBIMA e B3 de forma simples e r\u00e1pida.</li> <li>Processamento de Dados: Os dados s\u00e3o processados e entregues em formatos f\u00e1ceis de usar, como DataFrames do Pandas.</li> <li>Ferramentas de An\u00e1lise: Acesse fun\u00e7\u00f5es para tarefas comuns de an\u00e1lise do mercado de renda fixa, como c\u00e1lculos de dias \u00fateis e feriados.</li> </ul>"},{"location":"articles/pyield_intro/#como-instalar-o-pyield","title":"Como Instalar o PYield","text":"<p>A instala\u00e7\u00e3o do PYield \u00e9 r\u00e1pida e f\u00e1cil atrav\u00e9s do pip, o gerenciador de pacotes do Python. Basta abrir o terminal e executar o seguinte comando no seu ambiente virtual:</p> <p><pre><code>pip install pyield\n</code></pre> Este comando instala a \u00faltima vers\u00e3o do PYield, deixando voc\u00ea pronto para come\u00e7ar a utilizar a biblioteca em seus projetos.</p> <p>Exemplos Pr\u00e1ticos de Uso:</p>"},{"location":"articles/pyield_intro/#ferramentas-de-dias-uteis-feriados-brasileiros-sao-automaticamente-considerados","title":"Ferramentas de Dias \u00dateis (Feriados brasileiros s\u00e3o automaticamente considerados)","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n\n# Contar o n\u00famero de dias \u00fateis entre duas datas.\n# A data de in\u00edcio \u00e9 inclusiva, a data de t\u00e9rmino \u00e9 exclusiva.\n&gt;&gt;&gt; yd.bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Obtenha o pr\u00f3ximo dia \u00fatil ap\u00f3s uma determinada data (offset=1).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=1)\nTimestamp('2024-01-02 00:00:00')\n\n# Obtenha o pr\u00f3ximo dia \u00fatil se n\u00e3o for um dia \u00fatil (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"30-12-2023\", offset=0)\nTimestamp('2024-01-02 00:00:00')\n\n# Como 2023-12-29 j\u00e1 \u00e9 um dia \u00fatil, a fun\u00e7\u00e3o retorna a mesma data (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=0)\nTimestamp('2023-12-29 00:00:00')\n\n# Gerar uma s\u00e9rie de dias \u00fateis entre duas datas.\n&gt;&gt;&gt; yd.bday.generate(start='2023-12-29', end='2024-01-03')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\ndtype: datetime64[ns]\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-futuro-de-di","title":"Dados de Futuro de DI","text":"<pre><code># Obtenha um DataFrame com os dados dos Futuros de DI da B3 de uma data espec\u00edfica.\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", reference_date='2024-03-08')\n\nTradeDate  ExpirationCode ExpirationDate BDaysToExp  ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08 J24            2024-04-01     15              ... 10.952   10.952      10.956      10.956\n2024-03-08 K24            2024-05-02     37              ... 10.776   10.774      10.780      10.777\n2024-03-08 M24            2024-06-03     58              ... 10.604   10.602      10.604      10.608\n...        ...            ...            ...             ... ...      ...         ...         ...\n2024-03-08 F37            2037-01-02     3213            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F38            2038-01-04     3462            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F39            2039-01-03     3713            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.85\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-titulos-do-tesouro","title":"Dados de T\u00edtulos do Tesouro","text":"<pre><code># Obtenha um DataFrame com os dados dos t\u00edtulos NTN-B da ANBIMA.\n# Os dados da Anbima est\u00e3o dispon\u00edveis para os \u00faltimos 5 dias \u00fateis.\n# Obs: Para quem \u00e9 membro da Anbima, o acesso ao hist\u00f3rico \u00e9 liberado automaticamente pela biblioteca.\n&gt;&gt;&gt; yd.anbima(bond_type=\"NTN-B\", reference_date='2024-04-12')\n\nBondType ReferenceDate MaturityDate BidRate AskRate IndicativeRate Price\nNTN-B    2024-04-12    2024-08-15   0.07540 0.07504 0.07523        4,271.43565\nNTN-B    2024-04-12    2025-05-15   0.05945 0.05913 0.05930        4,361.34391\nNTN-B    2024-04-12    2026-08-15   0.05927 0.05897 0.05910        4,301.40082\n...      ...           ...          ...     ...     ...            ...\nNTN-B    2024-04-12    2050-08-15   0.06039 0.06006 0.06023        4,299.28233\nNTN-B    2024-04-12    2055-05-15   0.06035 0.05998 0.06017        4,367.13360\nNTN-B    2024-04-12    2060-08-15   0.06057 0.06016 0.06036        4,292.26323\n</code></pre>"},{"location":"articles/pyield_intro/#calculo-de-spreads","title":"C\u00e1lculo de spreads","text":"<pre><code># Calcule o spread entre o futuro de DI e os t\u00edtulos pr\u00e9-fixados do Tesouro.\n&gt;&gt;&gt; yd.spreads(spread_type=\"DI_PRE\", reference_date=\"2024-4-11\")\n\nBondType ReferenceDate MaturityDate  DISpread\nLTN      2024-04-11    2024-07-01    -20.28\nLTN      2024-04-11    2024-10-01    -10.19\nLTN      2024-04-11    2025-01-01    -15.05\n...      ...           ...           ...\nNTN-F    2024-04-11    2031-01-01    -0.66\nNTN-F    2024-04-11    2033-01-01    -5.69\nNTN-F    2024-04-11    2035-01-01    -1.27\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-indicadores","title":"Dados de Indicadores","text":"<pre><code># Obtenha a taxa SELIC meta do BCB em um determinado dia.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"SELIC\", reference_date='2024-04-12')\n0.1075  # 10.75%\n\n# Obtenha a taxa mensal (Monthly Rate) do IPCA do IBGE com base no m\u00eas de refer\u00eancia da data.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", reference_date='2024-03-18')\n0.0016  # 0.16%\n\n# Se o indicador n\u00e3o estiver dispon\u00edvel para a data de refer\u00eancia, o retorno ser\u00e1 nulo (None).\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", reference_date='2030-04-10')\nNone\n</code></pre>"},{"location":"articles/pyield_intro/#conclusao","title":"Conclus\u00e3o","text":"<p>Se voc\u00ea precisa obter e tratar dados de renda fixa, PYield pode ser uma ferramenta valiosa nesse processo. Com uma API simples, o seu c\u00f3digo pode se tornar mais limpo e eficiente, permitindo que voc\u00ea se concentre na an\u00e1lise dos dados em vez de se preocupar com a obten\u00e7\u00e3o e processamento deles.</p> <p>O c\u00f3digo da biblioteca pode ser acessado em: PYield</p> <p>Quem quiser contribuir com o desenvolvimento da ferramenta entre em contato comigo: cr.cj@outlook.com</p>"}]}