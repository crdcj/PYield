{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyield-brazilian-fixed-income-toolkit","title":"PYield: Brazilian Fixed Income Toolkit","text":"<p>PYield is a Python library for analyzing Brazilian fixed income instruments. It fetches and processes data from ANBIMA, BCB, IBGE and B3, returning Polars DataFrames for fast, type-safe data pipelines.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyield\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import pyield as yd\n\n# Business days (foundation of all calculations)\nyd.bday.count(\"02-01-2025\", \"15-01-2025\")  # -&gt; 9\nyd.bday.offset(\"29-12-2023\", 1)            # -&gt; datetime.date(2024, 1, 2)\n\n# DI Futures curve\ndf = yd.futures(\"31-05-2024\", \"DI1\")\n# Columns: TradeDate, TickerSymbol, ExpirationDate, BDaysToExp, SettlementRate, ...\n\n# Rate interpolation (flat forward, 252 bdays/year convention)\ninterp = yd.Interpolator(\"flat_forward\", df[\"BDaysToExp\"], df[\"SettlementRate\"])\ninterp(45)       # -&gt; 0.04833...\ninterp([30, 60]) # -&gt; pl.Series with interpolated rates\n\n# Treasury bond pricing\nyd.ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)  # -&gt; 99.3651\n\n# BCB indicators\nyd.bc.selic_over(\"31-05-2024\")  # -&gt; 0.000414...\n</code></pre> <p>A Colab notebook with more examples is available:</p> <p></p>"},{"location":"#core-building-blocks","title":"Core Building Blocks","text":""},{"location":"#business-days-bday","title":"Business Days (<code>bday</code>)","text":"<p>The <code>bday</code> module is the foundation of PYield. All date calculations (pricing, duration, forward rates) depend on accurate business day counting with Brazilian holidays.</p> <pre><code>from pyield import bday\n\n# Count business days (start inclusive, end exclusive)\nbday.count(\"29-12-2023\", \"02-01-2024\")  # -&gt; 1\n\n# Offset by N business days\nbday.offset(\"29-12-2023\", 1)  # -&gt; datetime.date(2024, 1, 2)\n\n# Adjust non-business day to next business day\nbday.offset(\"30-12-2023\", 0)  # -&gt; datetime.date(2024, 1, 2)\n\n# Generate business day range\nbday.generate(\"22-12-2023\", \"02-01-2024\")\n# -&gt; Series: [2023-12-22, 2023-12-26, 2023-12-27, 2023-12-28, 2023-12-29, 2024-01-02]\n\n# Check if date is business day\nbday.is_business_day(\"25-12-2023\")  # -&gt; False (Christmas)\n</code></pre> <p>All functions support vectorized operations with lists, Series, or arrays.</p>"},{"location":"#rate-interpolation-interpolator","title":"Rate Interpolation (<code>Interpolator</code>)","text":"<p>The <code>Interpolator</code> class interpolates interest rates using the 252 business days/year convention standard in Brazil.</p> <pre><code>from pyield import Interpolator\n\nknown_bdays = [30, 60, 90]\nknown_rates = [0.045, 0.05, 0.055]\n\n# Flat forward interpolation (market standard)\ninterp = Interpolator(\"flat_forward\", known_bdays, known_rates)\ninterp(45)  # -&gt; 0.04833...\n\n# Linear interpolation\nlinear = Interpolator(\"linear\", known_bdays, known_rates)\nlinear(45)  # -&gt; 0.0475\n\n# Vectorized\ninterp([15, 45, 75])  # -&gt; pl.Series with 3 rates\n\n# Extrapolation (disabled by default, returns NaN)\ninterp(100)  # -&gt; nan\nInterpolator(\"flat_forward\", known_bdays, known_rates, extrapolate=True)(100)  # -&gt; 0.055\n</code></pre>"},{"location":"#forward-rates-forward-forwards","title":"Forward Rates (<code>forward</code>, <code>forwards</code>)","text":"<p>Calculate forward rates from spot curves:</p> <pre><code>from pyield import forward, forwards\n\n# Single forward rate between two points\nforward(bday1=10, bday2=20, rate1=0.05, rate2=0.06)  # -&gt; 0.0700952...\n\n# Vectorized forward curve from spot rates\nbdays = [10, 20, 30]\nrates = [0.05, 0.06, 0.07]\nforwards(bdays, rates)  # -&gt; Series: [0.05, 0.070095, 0.090284]\n</code></pre>"},{"location":"#modules-overview","title":"Modules Overview","text":"Module Purpose <code>bday</code> Business day calendar with Brazilian holidays <code>futures</code> B3 futures data (DI1, DDI, FRC, DAP, DOL, WDO, IND, WIN) <code>Interpolator</code> Rate interpolation (flat_forward, linear) <code>forward</code> / <code>forwards</code> Forward rate calculation <code>ltn</code>, <code>ntnb</code>, <code>ntnf</code>, <code>lft</code>, <code>ntnc</code> Treasury bond pricing and analytics <code>anbima</code> ANBIMA data (TPF prices, yield curves, IMA indices) <code>bc</code> BCB indicators (SELIC, PTAX, repo rates, VNA) <code>ipca</code> Inflation data (historical and projections) <code>today</code> / <code>now</code> Current date/time in Brazil (America/Sao_Paulo)"},{"location":"#treasury-bonds","title":"Treasury Bonds","text":"<pre><code>from pyield import ltn, ntnb, ntnf\n\n# Fetch ANBIMA indicative rates\nltn.data(\"23-08-2024\")   # -&gt; DataFrame with LTN bonds\nntnb.data(\"23-08-2024\")  # -&gt; DataFrame with NTN-B bonds\n\n# Calculate bond quotation (base 100)\nntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)  # -&gt; 99.3651\nntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)  # -&gt; 99.5341\n\n# DI spreads (bps=True multiplies by 10,000)\nntnf.di_spreads(\"30-05-2025\", bps=True)\n# -&gt; DataFrame: BondType, MaturityDate, DISpread\n</code></pre>"},{"location":"#futures-data","title":"Futures Data","text":"<pre><code>from pyield import futures\n\n# DI1 (Interbank Deposit Futures)\nfutures(\"31-05-2024\", \"DI1\")\n\n# Other contracts: DDI, FRC, DAP, DOL, WDO, IND, WIN\nfutures(\"31-05-2024\", \"DAP\")\n\n# Intraday data (when market is open)\nfutures(\"16-01-2025\", \"DI1\")  # Returns live data if called during trading hours\n</code></pre>"},{"location":"#date-handling","title":"Date Handling","text":"<p>PYield accepts flexible date inputs (<code>DateLike</code>): - Strings: <code>\"31-05-2024\"</code>, <code>\"31/05/2024\"</code>, <code>\"2024-05-31\"</code> - <code>datetime.date</code>, <code>datetime.datetime</code> - <code>pandas.Timestamp</code>, <code>numpy.datetime64</code></p> <p>Scalar functions return <code>datetime.date</code>. Vectorized functions return <code>polars.Series</code>.</p> <p>Null handling: scalar functions return <code>float('nan')</code> for missing inputs (propagates through calculations). Vectorized functions propagate <code>null</code> element-wise.</p> <pre><code>from pyield import ntnb, bday\n\nntnb.quotation(None, \"15-05-2035\", 0.06149)  # -&gt; nan\nbday.count([\"01-01-2024\", None], \"01-02-2024\")  # -&gt; Series: [22, null]\n</code></pre>"},{"location":"#polars-migration-v0400","title":"Polars Migration (v0.40.0+)","text":"<p>All functions return Polars DataFrames/Series. To convert to Pandas:</p> <pre><code>df_pandas = df.to_pandas(use_pyarrow_extension_array=True)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation: crdcj.github.io/PYield</p>"},{"location":"#tests","title":"Tests","text":"<pre><code>pytest pyield --doctest-modules\n</code></pre>"},{"location":"anbima/","title":"Anbima","text":""},{"location":"anbima/#pyield.anbima.intraday_ettj","title":"<code>intraday_ettj()</code>","text":"<p>Retrieves and processes the intraday Brazilian yield curve data from ANBIMA.</p> <p>This function fetches the most recent intraday yield curve data published by ANBIMA, containing real rates (IPCA-indexed), nominal rates, and implied inflation at various vertices (time points). The curve is published at around 12:30 PM BRT.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the intraday ETTJ data.</p> DataFrame columns <ul> <li>date: Reference date of the yield curve</li> <li>vertex: Time point in business days</li> <li>nominal_rate: Zero-coupon nominal interest rate</li> <li>real_rate: Zero-coupon real interest rate (IPCA-indexed)</li> <li>implied_inflation: Implied inflation rate (break-even inflation)</li> </ul> Note <p>All rates are expressed in decimal format (e.g., 0.12 for 12%).</p> Source code in <code>pyield/anbima/ettj_intraday.py</code> <pre><code>def intraday_ettj() -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves and processes the intraday Brazilian yield curve data from ANBIMA.\n\n    This function fetches the most recent intraday yield curve data published by ANBIMA,\n    containing real rates (IPCA-indexed), nominal rates, and implied inflation\n    at various vertices (time points). The curve is published at around 12:30 PM BRT.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the intraday ETTJ data.\n\n    DataFrame columns:\n        - date: Reference date of the yield curve\n        - vertex: Time point in business days\n        - nominal_rate: Zero-coupon nominal interest rate\n        - real_rate: Zero-coupon real interest rate (IPCA-indexed)\n        - implied_inflation: Implied inflation rate (break-even inflation)\n\n    Note:\n        All rates are expressed in decimal format (e.g., 0.12 for 12%).\n    \"\"\"\n    api_text = _fetch_intraday_text()\n\n    # --- Extra\u00e7\u00e3o da Tabela 1: PREFIXADOS ---\n    data_ref, tabela_pre, tabela_ipca = _extract_date_and_tables(api_text)\n\n    df_pre = _parse_intraday_table(tabela_pre)\n    df_pre = df_pre.rename({\"D0\": \"nominal_rate\"})\n\n    df_ipca = _parse_intraday_table(tabela_ipca)\n    df_ipca = df_ipca.rename({\"D0\": \"real_rate\"})\n\n    df = df_pre.join(df_ipca, on=\"Vertices\", how=\"right\")\n    df = df.rename({\"Vertices\": \"vertex\"})\n\n    df = df.with_columns(\n        # convertendo de % para decimal e arredondando\n        (pl.col(\"real_rate\") / 100).round(ROUND_DIGITS),\n        (pl.col(\"nominal_rate\") / 100).round(ROUND_DIGITS),\n        pl.lit(data_ref).alias(\"date\"),\n    ).with_columns(\n        ((pl.col(\"nominal_rate\") + 1) / (pl.col(\"real_rate\") + 1) - 1)\n        .round(ROUND_DIGITS)\n        .alias(\"implied_inflation\"),\n    )\n    column_order = [\"date\", \"vertex\", \"nominal_rate\", \"real_rate\", \"implied_inflation\"]\n    return df.select(column_order)\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ettj","title":"<code>last_ettj()</code>","text":"<p>Retrieves and processes the latest Brazilian yield curve data from ANBIMA.</p> <p>This function fetches the most recent yield curve data published by ANBIMA, containing real rates (IPCA-indexed), nominal rates, and implied inflation at various vertices (time points).</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the latest ETTJ data.</p> DataFrame columns <ul> <li>date: Reference date of the yield curve</li> <li>vertex: Time point in business days</li> <li>nominal_rate: Zero-coupon nominal interest rate</li> <li>real_rate: Zero-coupon real interest rate (IPCA-indexed)</li> <li>implied_inflation: Implied inflation rate (break-even inflation)</li> </ul> Note <p>All rates are expressed in decimal format (e.g., 0.12 for 12%).</p> Source code in <code>pyield/anbima/ettj_last.py</code> <pre><code>def last_ettj() -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves and processes the latest Brazilian yield curve data from ANBIMA.\n\n    This function fetches the most recent yield curve data published by ANBIMA,\n    containing real rates (IPCA-indexed), nominal rates, and implied inflation\n    at various vertices (time points).\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the latest ETTJ data.\n\n    DataFrame columns:\n        - date: Reference date of the yield curve\n        - vertex: Time point in business days\n        - nominal_rate: Zero-coupon nominal interest rate\n        - real_rate: Zero-coupon real interest rate (IPCA-indexed)\n        - implied_inflation: Implied inflation rate (break-even inflation)\n\n    Note:\n        All rates are expressed in decimal format (e.g., 0.12 for 12%).\n    \"\"\"\n    text = _get_last_content_text()\n    reference_date = _get_reference_date(text)\n    text = _filter_ettf_text(text)\n    df = _convert_text_to_df(text, reference_date)\n    df = _process_df(df)\n    return df\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ima","title":"<code>last_ima(ima_type=None)</code>","text":"<p>Fetch and process the last IMA market data available from ANBIMA.</p> <p>This function processes the data into a structured DataFrame. It handles conversion of date formats, renames columns to English, and converts certain numeric columns to integer types. In the event of an error during data fetching or processing, an empty DataFrame is returned.</p> <p>Parameters:</p> Name Type Description Default <code>ima_type</code> <code>str</code> <p>Type of IMA index to filter the data. If None, all IMA indexes are returned. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the IMA data.</p> DataFrame columns <ul> <li>Date: reference date of the data.</li> <li>IMAType: type of IMA index.</li> <li>BondType: type of bond.</li> <li>Maturity: bond maturity date.</li> <li>SelicCode: bond code in the SELIC system.</li> <li>ISIN: international Securities Identification Number.</li> <li>BDToMat: business days to maturity.</li> <li>Duration: duration of the bond in business years (252 days/year).</li> <li>IndicativeRate: indicative rate.</li> <li>Price: bond price.</li> <li>InterestPrice: interest price.</li> <li>DV01: DV01 in R$.</li> <li>PMR: average repurchase term.</li> <li>Weight: weight of the bond in the index.</li> <li>Convexity: convexity of the bond.</li> <li>TheoreticalQuantity: theoretical quantity.</li> <li>NumberOfOperations: number of operations.</li> <li>NegotiatedQuantity: negotiated quantity.</li> <li>NegotiatedValue: negotiated value.</li> <li>MarketQuantity: market quantity.</li> <li>MarketDV01: market DV01 in R$.</li> <li>MarketValue: market value in R$.</li> </ul> <p>Raises:</p> Type Description <code>Exception</code> <p>Logs error and returns an empty DataFrame if any error occurs during fetching or processing.</p> Source code in <code>pyield/anbima/ima.py</code> <pre><code>def last_ima(ima_type: ima_types | None = None) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch and process the last IMA market data available from ANBIMA.\n\n    This function processes the data into a structured DataFrame.\n    It handles conversion of date formats, renames columns to English, and converts\n    certain numeric columns to integer types. In the event of an error during data\n    fetching or processing, an empty DataFrame is returned.\n\n    Args:\n        ima_type (str, optional): Type of IMA index to filter the data. If None, all\n            IMA indexes are returned. Defaults to None.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the IMA data.\n\n    DataFrame columns:\n        - Date: reference date of the data.\n        - IMAType: type of IMA index.\n        - BondType: type of bond.\n        - Maturity: bond maturity date.\n        - SelicCode: bond code in the SELIC system.\n        - ISIN: international Securities Identification Number.\n        - BDToMat: business days to maturity.\n        - Duration: duration of the bond in business years (252 days/year).\n        - IndicativeRate: indicative rate.\n        - Price: bond price.\n        - InterestPrice: interest price.\n        - DV01: DV01 in R$.\n        - PMR: average repurchase term.\n        - Weight: weight of the bond in the index.\n        - Convexity: convexity of the bond.\n        - TheoreticalQuantity: theoretical quantity.\n        - NumberOfOperations: number of operations.\n        - NegotiatedQuantity: negotiated quantity.\n        - NegotiatedValue: negotiated value.\n        - MarketQuantity: market quantity.\n        - MarketDV01: market DV01 in R$.\n        - MarketValue: market value in R$.\n\n    Raises:\n        Exception: Logs error and returns an empty DataFrame if any error occurs during\n            fetching or processing.\n    \"\"\"\n    try:\n        ima_text = _fetch_last_ima_text()\n        df = _parse_df(ima_text)\n        df = _process_df(df)\n        df = _reorder_columns(df)\n        if ima_type:\n            df = df.filter(pl.col(\"IMAType\") == ima_type)\n        df = df.sort(\"IMAType\", \"BondType\", \"Maturity\")\n        return df\n    except Exception as e:\n        logger.exception(f\"Error fetching or processing the last IMA data: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_data","title":"<code>tpf_data(date, bond_type=None, fetch_from_source=False)</code>","text":"<p>Recupera os dados do mercado secund\u00e1rio de TPF da ANBIMA.</p> <p>Esta fun\u00e7\u00e3o busca taxas indicativas e outros dados de t\u00edtulos p\u00fablicos brasileiros. A obten\u00e7\u00e3o dos dados segue uma hierarquia de fontes para otimizar o desempenho e o acesso.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>A data de refer\u00eancia para os dados (ex: '2024-06-14').</p> required <code>bond_type</code> <code>str</code> <p>Filtra os resultados por um tipo de t\u00edtulo espec\u00edfico (ex: 'LTN', 'NTN-B'). Por padr\u00e3o, retorna todos os tipos.</p> <code>None</code> <code>fetch_from_source</code> <code>bool</code> <p>Se True, for\u00e7a a fun\u00e7\u00e3o a ignorar o cache e buscar os dados diretamente da fonte (ANBIMA). Padr\u00e3o \u00e9 False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo os dados solicitados. Retorna um DataFrame vazio se n\u00e3o houver dados para a data especificada (ex: finais de semana, feriados ou datas futuras).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; anbima.tpf_data(date=\"22-08-2025\")\nshape: (49, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000198  \u2506 0.0001    \u2506 0.000165       \u2506 0.14906  \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000156 \u2506 -0.000116      \u2506 0.14843  \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000143 \u2506 -0.000107      \u2506 0.1436   \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000309  \u2506 0.000292  \u2506 0.000302       \u2506 0.138189 \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000421  \u2506 0.000399  \u2506 0.000411       \u2506 0.134548 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.139379  \u2506 0.139163  \u2506 0.139268       \u2506 0.13959  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.134252  \u2506 0.134018  \u2506 0.13414        \u2506 0.1327   \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.13846   \u2506 0.138355  \u2506 0.13841        \u2506 0.13626  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.139503  \u2506 0.139321  \u2506 0.139398       \u2506 0.13807  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.140673  \u2506 0.140566  \u2506 0.140633       \u2506 0.13845  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Data columns <ul> <li>BondType: Tipo do t\u00edtulo p\u00fablico (e.g., 'LTN', 'NTN-B').</li> <li>ReferenceDate: Data de refer\u00eancia dos dados.</li> <li>SelicCode: C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate: Data base ou de emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate: Data de vencimento do t\u00edtulo.</li> <li>BDToMat: N\u00famero de dias \u00fateis entre a data de refer\u00eancia e o vencimento.</li> <li>Duration: Macaulay Duration do t\u00edtulo em anos.</li> <li>DV01: Varia\u00e7\u00e3o financeira no pre\u00e7o do t\u00edtulo (em BRL) para uma     mudan\u00e7a de 1 basis point (0,01%) na taxa de juros.</li> <li>DV01USD: O mesmo que DV01, mas convertido para USD pela PTAX do dia.</li> <li>Price: Pre\u00e7o Unit\u00e1rio (PU) do t\u00edtulo na data de refer\u00eancia.</li> <li>BidRate: Taxa de compra em formato decimal (e.g., 0.10 para 10%).</li> <li>AskRate: Taxa de venda em formato decimal.</li> <li>IndicativeRate: Taxa indicativa em formato decimal.</li> <li>DIRate: Taxa DI interpolada (flatforward) no vencimento do t\u00edtulo.</li> <li>StdDev: Desvio padr\u00e3o da taxa indicativa.</li> <li>LowerBoundRateD0: Limite inferior do intervalo indicativo para D+0.</li> <li>UpperBoundRateD0: Limite superior do intervalo indicativo para D+0.</li> <li>LowerBoundRateD1: Limite inferior do intervalo indicativo para D+1.</li> <li>UpperBoundRateD1: Limite superior do intervalo indicativo para D+1.</li> <li>Criteria: Crit\u00e9rio utilizado pela ANBIMA para o c\u00e1lculo.</li> </ul> Notes <p>A fonte dos dados segue a seguinte hierarquia:</p> <ol> <li>Cache Local (Padr\u00e3o): Fornece acesso r\u00e1pido a dados hist\u00f3ricos     desde 01/01/2020. \u00c9 utilizado por padr\u00e3o (<code>fetch_from_source=False</code>).</li> <li>Site P\u00fablico da ANBIMA: Acessado quando <code>fetch_from_source=True</code>,     disponibiliza os dados dos \u00faltimos 5 dias \u00fateis.</li> <li>Rede RTM da ANBIMA: Acessada quando <code>fetch_from_source=True</code> para     datas com mais de 5 dias \u00fateis. O acesso ao hist\u00f3rico completo     requer uma conex\u00e3o \u00e0 rede RTM. Sem ela, a consulta para datas     antigas retornar\u00e1 um DataFrame vazio.</li> </ol> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_data(\n    date: DateLike,\n    bond_type: BOND_TYPES | None = None,\n    fetch_from_source: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"Recupera os dados do mercado secund\u00e1rio de TPF da ANBIMA.\n\n    Esta fun\u00e7\u00e3o busca taxas indicativas e outros dados de t\u00edtulos p\u00fablicos\n    brasileiros. A obten\u00e7\u00e3o dos dados segue uma hierarquia de fontes para\n    otimizar o desempenho e o acesso.\n\n    Args:\n        date (DateLike): A data de refer\u00eancia para os dados (ex: '2024-06-14').\n        bond_type (str, optional): Filtra os resultados por um tipo de t\u00edtulo\n            espec\u00edfico (ex: 'LTN', 'NTN-B'). Por padr\u00e3o, retorna todos os tipos.\n        fetch_from_source (bool, optional): Se True, for\u00e7a a fun\u00e7\u00e3o a ignorar o\n            cache e buscar os dados diretamente da fonte (ANBIMA).\n            Padr\u00e3o \u00e9 False.\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo os dados solicitados.\n            Retorna um DataFrame vazio se n\u00e3o houver dados para a data especificada (ex:\n            finais de semana, feriados ou datas futuras).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; anbima.tpf_data(date=\"22-08-2025\")\n        shape: (49, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000198  \u2506 0.0001    \u2506 0.000165       \u2506 0.14906  \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000156 \u2506 -0.000116      \u2506 0.14843  \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000143 \u2506 -0.000107      \u2506 0.1436   \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000309  \u2506 0.000292  \u2506 0.000302       \u2506 0.138189 \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000421  \u2506 0.000399  \u2506 0.000411       \u2506 0.134548 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.139379  \u2506 0.139163  \u2506 0.139268       \u2506 0.13959  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.134252  \u2506 0.134018  \u2506 0.13414        \u2506 0.1327   \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.13846   \u2506 0.138355  \u2506 0.13841        \u2506 0.13626  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.139503  \u2506 0.139321  \u2506 0.139398       \u2506 0.13807  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.140673  \u2506 0.140566  \u2506 0.140633       \u2506 0.13845  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Data columns:\n        - BondType: Tipo do t\u00edtulo p\u00fablico (e.g., 'LTN', 'NTN-B').\n        - ReferenceDate: Data de refer\u00eancia dos dados.\n        - SelicCode: C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate: Data base ou de emiss\u00e3o do t\u00edtulo.\n        - MaturityDate: Data de vencimento do t\u00edtulo.\n        - BDToMat: N\u00famero de dias \u00fateis entre a data de refer\u00eancia e o vencimento.\n        - Duration: Macaulay Duration do t\u00edtulo em anos.\n        - DV01: Varia\u00e7\u00e3o financeira no pre\u00e7o do t\u00edtulo (em BRL) para uma\n            mudan\u00e7a de 1 basis point (0,01%) na taxa de juros.\n        - DV01USD: O mesmo que DV01, mas convertido para USD pela PTAX do dia.\n        - Price: Pre\u00e7o Unit\u00e1rio (PU) do t\u00edtulo na data de refer\u00eancia.\n        - BidRate: Taxa de compra em formato decimal (e.g., 0.10 para 10%).\n        - AskRate: Taxa de venda em formato decimal.\n        - IndicativeRate: Taxa indicativa em formato decimal.\n        - DIRate: Taxa DI interpolada (flatforward) no vencimento do t\u00edtulo.\n        - StdDev: Desvio padr\u00e3o da taxa indicativa.\n        - LowerBoundRateD0: Limite inferior do intervalo indicativo para D+0.\n        - UpperBoundRateD0: Limite superior do intervalo indicativo para D+0.\n        - LowerBoundRateD1: Limite inferior do intervalo indicativo para D+1.\n        - UpperBoundRateD1: Limite superior do intervalo indicativo para D+1.\n        - Criteria: Crit\u00e9rio utilizado pela ANBIMA para o c\u00e1lculo.\n\n    Notes:\n        A fonte dos dados segue a seguinte hierarquia:\n\n        1.  **Cache Local (Padr\u00e3o):** Fornece acesso r\u00e1pido a dados hist\u00f3ricos\n            desde 01/01/2020. \u00c9 utilizado por padr\u00e3o (`fetch_from_source=False`).\n        2.  **Site P\u00fablico da ANBIMA:** Acessado quando `fetch_from_source=True`,\n            disponibiliza os dados dos \u00faltimos 5 dias \u00fateis.\n        3.  **Rede RTM da ANBIMA:** Acessada quando `fetch_from_source=True` para\n            datas com mais de 5 dias \u00fateis. O acesso ao hist\u00f3rico completo\n            requer uma conex\u00e3o \u00e0 rede RTM. Sem ela, a consulta para datas\n            antigas retornar\u00e1 um DataFrame vazio.\n    \"\"\"  # noqa\n    if has_nullable_args(date):\n        return pl.DataFrame()\n    date = convert_dates(date)\n    _validate_not_future_date(date)\n\n    if fetch_from_source:\n        # Tenta buscar os dados diretamente da fonte (ANBIMA)\n        df = _fetch_tpf_data(date)\n    else:\n        # Caso contr\u00e1rio, obt\u00e9m os dados do cache local\n        df = get_cached_dataset(\"tpf\").filter(pl.col(\"ReferenceDate\") == date)\n\n    if df.is_empty():\n        return pl.DataFrame()\n\n    if bond_type:\n        norm_bond_type = _bond_type_mapping(bond_type)\n        df = df.filter(pl.col(\"BondType\").is_in(norm_bond_type))\n\n    return df.sort(\"ReferenceDate\", \"BondType\", \"MaturityDate\")\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_difusao","title":"<code>tpf_difusao(data_referencia)</code>","text":"<p>Obt\u00e9m a TPF Difus\u00e3o da Anbima para uma data de refer\u00eancia espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>data_referencia</code> <code>str | date | datetime</code> <p>Data de refer\u00eancia (ex: \"DD/MM/AAAA\").</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com os dados. Retorna um DataFrame vazio se n\u00e3o houver dados ou em caso de erro.</p> Output Columns <ul> <li>data_hora_referencia (datetime): Data e hora de refer\u00eancia da taxa.</li> <li>provedor (string): Provedor dos dados.</li> <li>titulo (string): Nome do t\u00edtulo (ex: LFT, LTN).</li> <li>data_vencimento (date): Data de vencimento do t\u00edtulo.</li> <li>codigo_isin (string): C\u00f3digo ISIN do t\u00edtulo.</li> <li>dias_uteis (int): Dias \u00fateis entre a data de refer\u00eancia e o vencimento.</li> <li>taxa_indicativa_anterior (float): Taxa indicativa de fechamento D-1 (decimal).</li> <li>taxa_venda (float): Taxa de oferta de venda (Ask rate) (decimal).</li> <li>taxa_compra (float): Taxa de oferta de compra (Bid rate) (decimal).</li> <li>taxa_media (float): M\u00e9dia entre a taxa de compra e venda (decimal).</li> <li>taxa_ultima (float): \u00daltima taxa negociada (decimal).</li> </ul> Source code in <code>pyield/anbima/difusao.py</code> <pre><code>def tpf_difusao(data_referencia: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Obt\u00e9m a TPF Difus\u00e3o da Anbima para uma data de refer\u00eancia espec\u00edfica.\n\n    Args:\n        data_referencia (str | dt.date | dt.datetime):\n            Data de refer\u00eancia (ex: \"DD/MM/AAAA\").\n\n    Returns:\n        pl.DataFrame: DataFrame com os dados. Retorna um DataFrame vazio se\n            n\u00e3o houver dados ou em caso de erro.\n\n    Output Columns:\n        * data_hora_referencia (datetime): Data e hora de refer\u00eancia da taxa.\n        * provedor (string): Provedor dos dados.\n        * titulo (string): Nome do t\u00edtulo (ex: LFT, LTN).\n        * data_vencimento (date): Data de vencimento do t\u00edtulo.\n        * codigo_isin (string): C\u00f3digo ISIN do t\u00edtulo.\n        * dias_uteis (int): Dias \u00fateis entre a data de refer\u00eancia e o vencimento.\n        * taxa_indicativa_anterior (float): Taxa indicativa de fechamento D-1 (decimal).\n        * taxa_venda (float): Taxa de oferta de venda (Ask rate) (decimal).\n        * taxa_compra (float): Taxa de oferta de compra (Bid rate) (decimal).\n        * taxa_media (float): M\u00e9dia entre a taxa de compra e venda (decimal).\n        * taxa_ultima (float): \u00daltima taxa negociada (decimal).\n    \"\"\"\n    if has_nullable_args(data_referencia):\n        logger.warning(\"Nenhuma data fornecida. Retornando DataFrame vazio.\")\n        return pl.DataFrame()\n    data = cv.convert_dates(data_referencia)\n    data_str = data.strftime(\"%d/%m/%Y\")\n    csv_data = _fetch_url_data(data_str)\n\n    if not csv_data:\n        logger.warning(\"Nenhum dado foi retornado para a data '%s'.\", data_str)\n        return pl.DataFrame()\n\n    try:\n        df = _process_csv_data(csv_data)\n        return df\n    except Exception as e:\n        logger.error(\"Falha ao processar o CSV para a data '%s': %s\", data_str, e)\n        return pl.DataFrame()\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_maturities","title":"<code>tpf_maturities(date, bond_type)</code>","text":"<p>Recupera os vencimentos existentes para um tipo de t\u00edtulo na data especificada.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>A data de refer\u00eancia para os vencimentos.</p> required <code>bond_type</code> <code>BOND_TYPES</code> <p>O tipo de t\u00edtulo para filtrar (ex: 'PRE' para 'LTN' e 'NTN-F', ou especifique 'LTN' ou 'NTN-F' diretamente).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Uma Series contendo as datas de vencimento \u00fanicas para o(s) tipo(s) de t\u00edtulo especificado(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; anbima.tpf_maturities(date=\"22-08-2025\", bond_type=\"PRE\")\nshape: (18,)\nSeries: 'MaturityDate' [date]\n[\n    2025-10-01\n    2026-01-01\n    2026-04-01\n    2026-07-01\n    2026-10-01\n    \u2026\n    2030-01-01\n    2031-01-01\n    2032-01-01\n    2033-01-01\n    2035-01-01\n]\n</code></pre> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_maturities(\n    date: DateLike,\n    bond_type: BOND_TYPES,\n) -&gt; pl.Series:\n    \"\"\"Recupera os vencimentos existentes para um tipo de t\u00edtulo na data especificada.\n\n    Args:\n        date (DateLike): A data de refer\u00eancia para os vencimentos.\n        bond_type (BOND_TYPES): O tipo de t\u00edtulo para filtrar (ex: 'PRE' para 'LTN'\n            e 'NTN-F', ou especifique 'LTN' ou 'NTN-F' diretamente).\n\n    Returns:\n        pl.Series: Uma Series contendo as datas de vencimento \u00fanicas para o(s)\n            tipo(s) de t\u00edtulo especificado(s).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; anbima.tpf_maturities(date=\"22-08-2025\", bond_type=\"PRE\")\n        shape: (18,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-10-01\n            2026-01-01\n            2026-04-01\n            2026-07-01\n            2026-10-01\n            \u2026\n            2030-01-01\n            2031-01-01\n            2032-01-01\n            2033-01-01\n            2035-01-01\n        ]\n\n    \"\"\"\n    return tpf_data(date, bond_type)[\"MaturityDate\"].unique().sort()\n</code></pre>"},{"location":"b3/","title":"B3 - Bolsa de Valores do Brasil","text":"<p>Este m\u00f3dulo cont\u00e9m fun\u00e7\u00f5es para acessar dados de mercado da B3 (Brasil, Bolsa, Balc\u00e3o).</p>"},{"location":"b3/#pyield.b3.fetch_price_report","title":"<code>fetch_price_report(date, contract_code, source_type='SPR')</code>","text":"<p>Fetches and processes an XML report from B3's website.</p> <p>Downloads a zipped XML report for a specific date and asset code from B3's website, extracts the relevant data, and returns it as a Pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The date of the report to fetch.</p> required <code>contract_code</code> <code>str</code> <p>The contract code to filter the report for (e.g., 'DI1').</p> required <code>source_type</code> <code>Literal['PR', 'SPR']</code> <p>The type of report to fetch, either 'PR' (Full Price Report) or 'SPR' (Simplified Price Report). Defaults to 'SPR'.</p> <code>'SPR'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the processed data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>source_type</code> is invalid or if no data is available for the given date.</p> Source code in <code>pyield/b3/price_report.py</code> <pre><code>def fetch_price_report(\n    date: DateLike, contract_code: str, source_type: Literal[\"PR\", \"SPR\"] = \"SPR\"\n) -&gt; pl.DataFrame:\n    \"\"\"Fetches and processes an XML report from B3's website.\n\n    Downloads a zipped XML report for a specific date and asset code\n    from B3's website, extracts the relevant data, and returns it as a\n    Pandas DataFrame.\n\n    Args:\n        date: The date of the report to fetch.\n        contract_code: The contract code to filter the report for (e.g., 'DI1').\n        source_type: The type of report to fetch, either 'PR' (Full Price\n            Report) or 'SPR' (Simplified Price Report). Defaults to 'SPR'.\n\n    Returns:\n        A DataFrame containing the processed data.\n\n    Raises:\n        ValueError: If the `source_type` is invalid or if no data is\n            available for the given date.\n    \"\"\"\n    if has_nullable_args(date):\n        logger.warning(\"No date provided. Returning empty DataFrame.\")\n        return pl.DataFrame()\n    try:\n        date = cv.convert_dates(date)\n        zip_data = _get_zip_data_from_url(date, source_type)\n        df = process_zip_file(zip_data, contract_code)\n        return df\n    except Exception as e:\n        logger.warning(f\"Error fetching XML data: {e}. Returning empty DataFrame.\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"b3/#pyield.b3.read_price_report","title":"<code>read_price_report(file_path, contract_code)</code>","text":"<p>Reads and processes an XML report from a local file.</p> <p>Reads a zipped XML report from the specified file path, extracts the relevant data, and returns it as a Pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the zipped XML report file.</p> required <code>contract_code</code> <code>str</code> <p>The contract code to filter the report for (e.g., 'DI1').</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A Pandas DataFrame containing the processed data.</p> <code>DataFrame</code> <p>For 'DI1' contract codes, an additional 'DV01' column is calculated.</p> <p>Raises:     ValueError: If the provided <code>file_path</code> is not a Path object.     FileNotFoundError: If no file is found at the specified <code>file_path</code>.</p> Source code in <code>pyield/b3/price_report.py</code> <pre><code>def read_price_report(file_path: Path, contract_code: str) -&gt; pl.DataFrame:\n    \"\"\"Reads and processes an XML report from a local file.\n\n    Reads a zipped XML report from the specified file path, extracts the\n    relevant data, and returns it as a Pandas DataFrame.\n\n    Args:\n        file_path: The path to the zipped XML report file.\n        contract_code: The contract code to filter the report for (e.g., 'DI1').\n\n    Returns:\n        A Pandas DataFrame containing the processed data.\n        For 'DI1' contract codes, an additional 'DV01' column is calculated.\n    Raises:\n        ValueError: If the provided `file_path` is not a Path object.\n        FileNotFoundError: If no file is found at the specified `file_path`.\n    \"\"\"\n    zip_file = _get_file_from_path(file_path)\n    df = process_zip_file(zip_file, contract_code)\n    return df\n</code></pre>"},{"location":"bc/","title":"Banco Central (BC)","text":""},{"location":"bc/#pyield.bc.auctions","title":"<code>auctions(start=None, end=None, auction_type=None)</code>","text":"<p>Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.</p> <p>Consultas de Per\u00edodo: - Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>.   Exemplo: <code>auctions(start='2024-10-20', end='2024-10-27')</code> - Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir   da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel.   Exemplo: <code>auctions(start='2024-10-20')</code> - Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o desde a   data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>.   Exemplo: <code>auctions(end='2024-10-27')</code></p> <p>S\u00e9rie Hist\u00f3rica Completa: - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o   \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>.   Exemplo: <code>auctions()</code></p> <p>Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas, filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado. O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros <code>start</code> e <code>end</code> segue o padr\u00e3o da API do Banco Central: - Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim. - Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>. - Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</p> <p>Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\"). Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado. Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateLike, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateLike, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>auction_type</code> <code>(Literal['sell', 'buy'], opcional)</code> <p>O tipo de leil\u00e3o para filtrar diretamente na API. Padr\u00e3o \u00e9 <code>None</code> (retorna todos os tipos de leil\u00e3o).</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo especificados. Em caso de erro ao buscar os dados, um DataFrame vazio \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.auctions(start=\"19-08-2025\", end=\"19-08-2025\")\nshape: (5, 33)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Settlement \u2506 AuctionType \u2506 Ordinance \u2506 \u2026 \u2506 AcceptedQuantity \u2506 ValueFR     \u2506 ValueSR  \u2506 Value       \u2502\n\u2502 ---        \u2506 ---        \u2506 ---         \u2506 ---       \u2506   \u2506 ---              \u2506 ---         \u2506 ---      \u2506 ---         \u2502\n\u2502 date       \u2506 date       \u2506 str         \u2506 i64       \u2506   \u2506 i64              \u2506 i64         \u2506 i64      \u2506 i64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 150000           \u2506 2572400000  \u2506 0        \u2506 2572400000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 751003           \u2506 12804476147 \u2506 17123853 \u2506 12821600000 \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 193       \u2506 \u2026 \u2506 300759           \u2506 1289936461  \u2506 3263539  \u2506 1293200000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500542           \u2506 2071654327  \u2506 2245673  \u2506 2073900000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500000           \u2506 2010700000  \u2506 0        \u2506 2010700000  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>FR = First Round (Primeira Rodada) SR = Second Round (Segunda Rodada)</p> DataFrame Columns <ul> <li>Date: Data do leil\u00e3o.</li> <li>Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.</li> <li>AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").</li> <li>Ordinance: Edital normativo associado ao leil\u00e3o.</li> <li>Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").</li> <li>BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").</li> <li>SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.</li> <li>Maturity: Data de vencimento do t\u00edtulo.</li> <li>BDToMat: Dias \u00fateis entre a liquida\u00e7\u00e3o da 1R e a data de vencimento do t\u00edtulo.</li> <li>Duration: Duration (Dura\u00e7\u00e3o) calculada com base na data de     liquida\u00e7\u00e3o da 1R e na data de vencimento do t\u00edtulo.</li> <li>AvgMaturity: Maturidade m\u00e9dia do t\u00edtulo (em anos).</li> <li>AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.</li> <li>CutPrice: Pre\u00e7o de corte.</li> <li>AvgRate: Taxa de juros m\u00e9dia.</li> <li>CutRate: Taxa de corte.</li> <li>DV01FR: DV01 da Primeira Rodada (FR) em R$.</li> <li>DV01SR: DV01 da Segunda Rodada (SR) em R$.</li> <li>DV01: Valor do DV01 total do leil\u00e3o em R$.</li> <li>DV01FRUSD: DV01 da Primeira Rodada (FR) em d\u00f3lares (USD).</li> <li>DV01SRUSD: DV01 da Segunda Rodada (SR) em d\u00f3lares (USD).</li> <li>DV01USD: DV01 total do leil\u00e3o em d\u00f3lares (USD).</li> <li>OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).</li> <li>OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).</li> <li>OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).</li> <li>AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).</li> <li>AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).</li> <li>AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).</li> <li>SettledQuantityFR: Quantidade liquidada na primeira rodada (FR).</li> <li>SettledQuantitySR: Quantidade liquidada na segunda rodada (SR).</li> <li>SettledQuantity: Quantidade total liquidada no leil\u00e3o (FR + SR</li> <li>ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.</li> <li>ValueSR: Valor da segunda rodada (SR) em R$.</li> <li>Value: Valor total do leil\u00e3o em R$ (FR + SR).</li> </ul> Source code in <code>pyield/bc/auction.py</code> <pre><code>def auctions(\n    start: DateLike | None = None,\n    end: DateLike | None = None,\n    auction_type: Literal[\"sell\", \"buy\"] | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.\n\n    **Consultas de Per\u00edodo:**\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n      Exemplo: `auctions(start='2024-10-20', end='2024-10-27')`\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir\n      da data de `start` **at\u00e9 a data mais recente dispon\u00edvel**.\n      Exemplo: `auctions(start='2024-10-20')`\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o **desde a\n      data mais antiga dispon\u00edvel at\u00e9 a data de `end`**.\n      Exemplo: `auctions(end='2024-10-27')`\n\n    **S\u00e9rie Hist\u00f3rica Completa:**\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o\n      \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n      Exemplo: `auctions()`\n\n    Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas,\n    filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado.\n    O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros `start` e `end` segue o padr\u00e3o\n    da API do Banco Central:\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\").\n    Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado.\n    Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.\n\n    Args:\n        start (DateLike, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateLike, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        auction_type (Literal[\"sell\", \"buy\"], opcional): O tipo de leil\u00e3o para filtrar\n            diretamente na API. Padr\u00e3o \u00e9 `None` (retorna todos os tipos de leil\u00e3o).\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo\n            especificados. Em caso de erro ao buscar os dados, um DataFrame vazio\n            \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.auctions(start=\"19-08-2025\", end=\"19-08-2025\")\n        shape: (5, 33)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Settlement \u2506 AuctionType \u2506 Ordinance \u2506 \u2026 \u2506 AcceptedQuantity \u2506 ValueFR     \u2506 ValueSR  \u2506 Value       \u2502\n        \u2502 ---        \u2506 ---        \u2506 ---         \u2506 ---       \u2506   \u2506 ---              \u2506 ---         \u2506 ---      \u2506 ---         \u2502\n        \u2502 date       \u2506 date       \u2506 str         \u2506 i64       \u2506   \u2506 i64              \u2506 i64         \u2506 i64      \u2506 i64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 150000           \u2506 2572400000  \u2506 0        \u2506 2572400000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 751003           \u2506 12804476147 \u2506 17123853 \u2506 12821600000 \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 193       \u2506 \u2026 \u2506 300759           \u2506 1289936461  \u2506 3263539  \u2506 1293200000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500542           \u2506 2071654327  \u2506 2245673  \u2506 2073900000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500000           \u2506 2010700000  \u2506 0        \u2506 2010700000  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        FR = First Round (Primeira Rodada)\n        SR = Second Round (Segunda Rodada)\n\n    DataFrame Columns:\n        - Date: Data do leil\u00e3o.\n        - Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.\n        - AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").\n        - Ordinance: Edital normativo associado ao leil\u00e3o.\n        - Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").\n        - BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").\n        - SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.\n        - Maturity: Data de vencimento do t\u00edtulo.\n        - BDToMat: Dias \u00fateis entre a liquida\u00e7\u00e3o da 1R e a data de vencimento do t\u00edtulo.\n        - Duration: Duration (Dura\u00e7\u00e3o) calculada com base na data de\n            liquida\u00e7\u00e3o da 1R e na data de vencimento do t\u00edtulo.\n        - AvgMaturity: Maturidade m\u00e9dia do t\u00edtulo (em anos).\n        - AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.\n        - CutPrice: Pre\u00e7o de corte.\n        - AvgRate: Taxa de juros m\u00e9dia.\n        - CutRate: Taxa de corte.\n        - DV01FR: DV01 da Primeira Rodada (FR) em R$.\n        - DV01SR: DV01 da Segunda Rodada (SR) em R$.\n        - DV01: Valor do DV01 total do leil\u00e3o em R$.\n        - DV01FRUSD: DV01 da Primeira Rodada (FR) em d\u00f3lares (USD).\n        - DV01SRUSD: DV01 da Segunda Rodada (SR) em d\u00f3lares (USD).\n        - DV01USD: DV01 total do leil\u00e3o em d\u00f3lares (USD).\n        - OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).\n        - OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).\n        - OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).\n        - AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).\n        - AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).\n        - AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).\n        - SettledQuantityFR: Quantidade liquidada na primeira rodada (FR).\n        - SettledQuantitySR: Quantidade liquidada na segunda rodada (SR).\n        - SettledQuantity: Quantidade total liquidada no leil\u00e3o (FR + SR\n        - ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.\n        - ValueSR: Valor da segunda rodada (SR) em R$.\n        - Value: Valor total do leil\u00e3o em R$ (FR + SR).\n    \"\"\"  # noqa: E501\n    try:\n        url = _build_url(start=start, end=end, auction_type=auction_type)\n        api_csv_text = _get_api_csv(url)\n        df = _parse_csv(api_csv_text)\n        if df.is_empty():\n            logger.warning(\"No auction data found after parsing the API response.\")\n            return pl.DataFrame()\n        df = _format_df(df)\n        df = _process_df(df)\n        df = _adjust_values_without_auction(df)\n        df = _add_duration(df)\n        df = _add_dv01(df)\n        df = _add_usd_dv01(df)\n        df = _add_avg_maturity(df)\n        df = _sort_and_reorder_columns(df)\n        # Substituir eventuais NaNs por None para compatibilidade com bancos de dados\n        df = df.with_columns(cs.float().fill_nan(None))\n\n        return df\n    except Exception as e:\n        logger.exception(f\"Error fetching auction data from BC API: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.di_over","title":"<code>di_over(date, annualized=True)</code>","text":"<p>Fetches the DI Over rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date to fetch the DI Over rate for.</p> required <code>annualized</code> <code>bool</code> <p>If True, returns the annualized rate (252 trading days per year), otherwise returns the daily rate.</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>The DI Over rate as a float or float(\"nan\") if not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n0.104\n</code></pre> <pre><code>&gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n0.00045513\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def di_over(date: DateLike, annualized: bool = True) -&gt; float:\n    \"\"\"\n    Fetches the DI Over rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the DI Over rate for.\n        annualized: If True, returns the annualized rate (252 trading\n            days per year), otherwise returns the daily rate.\n\n    Returns:\n        The DI Over rate as a float or float(\"nan\") if not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n        0.104\n\n        &gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n        0.00045513\n    \"\"\"\n    if has_nullable_args(date):\n        return float(\"nan\")\n    df = di_over_series(date, date, annualized)\n    if df.is_empty():\n        return float(\"nan\")\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.di_over_series","title":"<code>di_over_series(start, end=None, annualized=True)</code>","text":"<p>Fetches the DI (Interbank Deposit) rate from the Brazilian Central Bank.</p> <p>The DI rate represents the average interest rate of interbank loans.</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024 https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> required <code>end</code> <code>DateLike | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <code>annualized</code> <code>bool</code> <p>If True, returns the annualized rate (252 trading days per year), otherwise returns the daily rate.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the DI rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Returns all data since 29-01-2025\n&gt;&gt;&gt; bc.di_over_series(\"29-01-2025\").head(5)  # Showing only first 5 rows\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value  \u2502\n\u2502 ---        \u2506 ---    \u2502\n\u2502 date       \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-29 \u2506 0.1215 \u2502\n\u2502 2025-01-30 \u2506 0.1315 \u2502\n\u2502 2025-01-31 \u2506 0.1315 \u2502\n\u2502 2025-02-03 \u2506 0.1315 \u2502\n\u2502 2025-02-04 \u2506 0.1315 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def di_over_series(\n    start: DateLike,\n    end: DateLike | None = None,\n    annualized: bool = True,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches the DI (Interbank Deposit) rate from the Brazilian Central Bank.\n\n    The DI rate represents the average interest rate of interbank loans.\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n        annualized: If True, returns the annualized rate (252 trading\n            days per year), otherwise returns the daily rate.\n\n    Returns:\n        DataFrame containing Date and Value columns with the DI rate,\n        or empty DataFrame if data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Returns all data since 29-01-2025\n        &gt;&gt;&gt; bc.di_over_series(\"29-01-2025\").head(5)  # Showing only first 5 rows\n        shape: (5, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value  \u2502\n        \u2502 ---        \u2506 ---    \u2502\n        \u2502 date       \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-29 \u2506 0.1215 \u2502\n        \u2502 2025-01-30 \u2506 0.1315 \u2502\n        \u2502 2025-01-31 \u2506 0.1315 \u2502\n        \u2502 2025-02-03 \u2506 0.1315 \u2502\n        \u2502 2025-02-04 \u2506 0.1315 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(start):\n        return pl.DataFrame()\n    df = _fetch_data_from_url(BCSerie.DI_OVER, start, end)\n    if annualized:\n        df = df.with_columns(\n            (((pl.col(\"Value\") + 1).pow(252)) - 1)\n            .round(DECIMAL_PLACES_ANNUALIZED)\n            .alias(\"Value\")\n        )\n\n    else:\n        df = df.with_columns(pl.col(\"Value\").round(DECIMAL_PLACES_DAILY))\n\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.ptax","title":"<code>ptax(date)</code>","text":"<p>Busca a cota\u00e7\u00e3o PTAX m\u00e9dia de fechamento para uma data espec\u00edfica.</p> <p>Esta fun\u00e7\u00e3o \u00e9 um wrapper para a fun\u00e7\u00e3o <code>ptax_series</code>, otimizada para buscar o valor de um \u00fanico dia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>A data para a qual a cota\u00e7\u00e3o PTAX \u00e9 desejada. Pode ser uma string no formato \"dd-mm-aaaa\" ou um objeto date/datetime.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>O valor da PTAX (taxa m\u00e9dia) para a data especificada.    Retorna None se n\u00e3o houver cota\u00e7\u00e3o para a data    (ex: feriado, fim de semana ou data futura).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Busca a PTAX para um dia \u00fatil\n&gt;&gt;&gt; bc.ptax(\"22-08-2025\")\n5.4389\n</code></pre> <pre><code>&gt;&gt;&gt; # Busca a PTAX para um fim de semana (sem dados)\n&gt;&gt;&gt; bc.ptax(\"23-08-2025\")\nnan\n</code></pre> Source code in <code>pyield/bc/ptax_api.py</code> <pre><code>def ptax(date: DateLike) -&gt; float:\n    \"\"\"Busca a cota\u00e7\u00e3o PTAX m\u00e9dia de fechamento para uma data espec\u00edfica.\n\n    Esta fun\u00e7\u00e3o \u00e9 um wrapper para a fun\u00e7\u00e3o `ptax_series`, otimizada para\n    buscar o valor de um \u00fanico dia.\n\n    Args:\n        date (DateLike): A data para a qual a cota\u00e7\u00e3o PTAX \u00e9 desejada.\n            Pode ser uma string no formato \"dd-mm-aaaa\" ou um objeto date/datetime.\n\n    Returns:\n        float: O valor da PTAX (taxa m\u00e9dia) para a data especificada.\n               Retorna None se n\u00e3o houver cota\u00e7\u00e3o para a data\n               (ex: feriado, fim de semana ou data futura).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Busca a PTAX para um dia \u00fatil\n        &gt;&gt;&gt; bc.ptax(\"22-08-2025\")\n        5.4389\n\n        &gt;&gt;&gt; # Busca a PTAX para um fim de semana (sem dados)\n        &gt;&gt;&gt; bc.ptax(\"23-08-2025\")\n        nan\n    \"\"\"\n    # Reutiliza a fun\u00e7\u00e3o ptax_series para buscar os dados para o dia espec\u00edfico.\n    # Definir start e end com a mesma data busca a cota\u00e7\u00e3o para aquele dia.\n    df_ptax = ptax_series(start=date, end=date)\n\n    # Se o DataFrame estiver vazio, significa que n\u00e3o h\u00e1 cota\u00e7\u00e3o para a data.\n    # Isso ocorre em fins de semana, feriados ou datas futuras.\n    if df_ptax.is_empty():\n        logger.warning(f\"No PTAX data found for date: {date}\")\n        return float(\"nan\")\n\n    # A API retorna uma \u00fanica linha para a cota\u00e7\u00e3o de fechamento de um dia.\n    # A coluna \"MidRate\" representa a PTAX de fechamento.\n    return df_ptax[\"MidRate\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.ptax_series","title":"<code>ptax_series(start=None, end=None)</code>","text":"<p>Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio) - Fonte: Banco Central do Brasil (BCB) - Frequ\u00eancia: Di\u00e1ria - Unidade: R$</p> <p>Documenta\u00e7\u00e3o da API do BCB:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n</code></pre> <p>Exemplo de chamada \u00e0 API:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n</code></pre> <p>Consultas de Per\u00edodo:</p> <ul> <li> <p>Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>. Exemplo:</p> <pre><code>`ptax_series(start='20-10-2024', end='27-10-2024')`\n</code></pre> </li> <li> <p>Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados a partir da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Exemplo:</p> <pre><code>`ptax_series(start='20-10-2024')`\n</code></pre> </li> <li> <p>Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Exemplo:</p> <p><code>ptax_series(end='27-10-2024')</code></p> </li> </ul> <p>S\u00e9rie Hist\u00f3rica Completa:</p> <ul> <li>Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984 at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>. Exemplo:<pre><code>`ptax_series()`\n</code></pre> </li> </ul> <p>Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:</p> <ul> <li>Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim.</li> <li>Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>.</li> <li>Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateLike, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateLike, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.</p> <code>DataFrame</code> <p>Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio</p> <code>DataFrame</code> <p>ser\u00e1 retornado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.ptax_series(start=\"20-04-2025\", end=\"25-04-2025\")\nshape: (4, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 DateTime                \u2506 BuyRate \u2506 SellRate \u2506 MidRate \u2502\n\u2502 ---        \u2506 ---                     \u2506 ---     \u2506 ---      \u2506 ---     \u2502\n\u2502 date       \u2506 datetime[ms]            \u2506 f64     \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-04-22 \u2506 2025-04-22 13:09:35.629 \u2506 5.749   \u2506 5.7496   \u2506 5.7493  \u2502\n\u2502 2025-04-23 \u2506 2025-04-23 13:06:30.443 \u2506 5.6874  \u2506 5.688    \u2506 5.6877  \u2502\n\u2502 2025-04-24 \u2506 2025-04-24 13:04:29.639 \u2506 5.6732  \u2506 5.6738   \u2506 5.6735  \u2502\n\u2502 2025-04-25 \u2506 2025-04-25 13:09:26.592 \u2506 5.684   \u2506 5.6846   \u2506 5.6843  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990 e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992, essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de 2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de 1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta; o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos boletins do dia.</p> <ul> <li>Primeira data dispon\u00edvel: 28.11.1984</li> <li>\u00daltima data dispon\u00edvel: data atual</li> </ul> <p>O DataFrame possui as seguintes colunas:</p> <ul> <li>Date: Data da cota\u00e7\u00e3o.</li> <li>DateTime: Data e hora da cota\u00e7\u00e3o.</li> <li>BuyRate: Taxa de compra.</li> <li>SellRate: Taxa de venda.</li> <li>MidRate: Taxa m\u00e9dia entre a compra/venda arredondada para 5 casas decimais.</li> </ul> Source code in <code>pyield/bc/ptax_api.py</code> <pre><code>def ptax_series(\n    start: DateLike | None = None,\n    end: DateLike | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio)\n    - Fonte: Banco Central do Brasil (BCB)\n    - Frequ\u00eancia: Di\u00e1ria\n    - Unidade: R$\n\n    Documenta\u00e7\u00e3o da API do BCB:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n\n    Exemplo de chamada \u00e0 API:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n\n    Consultas de Per\u00edodo:\n\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n    Exemplo:\n\n            `ptax_series(start='20-10-2024', end='27-10-2024')`\n\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados a partir\n    da data de `start` at\u00e9 a data mais recente dispon\u00edvel. Exemplo:\n\n            `ptax_series(start='20-10-2024')`\n\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados desde a data mais\n    antiga dispon\u00edvel at\u00e9 a data de `end`. Exemplo:\n\n        `ptax_series(end='27-10-2024')`\n\n    S\u00e9rie Hist\u00f3rica Completa:\n\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984\n    at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n    Exemplo:\n\n            `ptax_series()`\n\n    Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:\n\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start (DateLike, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateLike, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.\n        Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio\n        ser\u00e1 retornado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.ptax_series(start=\"20-04-2025\", end=\"25-04-2025\")\n        shape: (4, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 DateTime                \u2506 BuyRate \u2506 SellRate \u2506 MidRate \u2502\n        \u2502 ---        \u2506 ---                     \u2506 ---     \u2506 ---      \u2506 ---     \u2502\n        \u2502 date       \u2506 datetime[ms]            \u2506 f64     \u2506 f64      \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-04-22 \u2506 2025-04-22 13:09:35.629 \u2506 5.749   \u2506 5.7496   \u2506 5.7493  \u2502\n        \u2502 2025-04-23 \u2506 2025-04-23 13:06:30.443 \u2506 5.6874  \u2506 5.688    \u2506 5.6877  \u2502\n        \u2502 2025-04-24 \u2506 2025-04-24 13:04:29.639 \u2506 5.6732  \u2506 5.6738   \u2506 5.6735  \u2502\n        \u2502 2025-04-25 \u2506 2025-04-25 13:09:26.592 \u2506 5.684   \u2506 5.6846   \u2506 5.6843  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990\n        e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas\n        administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992,\n        essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de\n        2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no\n        mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de\n        1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder\n        \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de\n        c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta;\n        o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos\n        boletins do dia.\n\n        - Primeira data dispon\u00edvel: 28.11.1984\n        - \u00daltima data dispon\u00edvel: data atual\n\n        O DataFrame possui as seguintes colunas:\n\n        - Date: Data da cota\u00e7\u00e3o.\n        - DateTime: Data e hora da cota\u00e7\u00e3o.\n        - BuyRate: Taxa de compra.\n        - SellRate: Taxa de venda.\n        - MidRate: Taxa m\u00e9dia entre a compra/venda arredondada para 5 casas decimais.\n    \"\"\"\n    if start:\n        start = cv.convert_dates(start)\n    else:\n        start = dt.date(1984, 11, 28)  # Primeira data dispon\u00edvel na API\n\n    if end:\n        end = cv.convert_dates(end)\n    else:\n        end = clock.today()\n\n    try:\n        url = _build_api_url(start, end)\n        text = _fetch_text_from_api(url)\n        df = _parse_csv(text)\n        if df.is_empty():\n            logging.warning(\"No data found for the specified period.\")\n            return pl.DataFrame()\n        df = _process_df(df)\n        return df\n    except requests.exceptions.HTTPError as http_err:\n        logger.error(f\"HTTP error occurred: {http_err}\")\n        return pl.DataFrame()\n    except Exception as e:\n        logger.exception(\"Error fetching PTAX data from BC API: %s\", e)\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.repos","title":"<code>repos(start=None, end=None)</code>","text":"<p>Consulta e retorna leil\u00f5es de opera\u00e7\u00f5es compromissadas (repos) do BCB.</p> <p>Sem\u00e2ntica dos par\u00e2metros de per\u00edodo (API OData):     - start somente: dados de start at\u00e9 o fim da s\u00e9rie.     - end somente: dados do in\u00edcio da s\u00e9rie at\u00e9 end.     - ambos omitidos: s\u00e9rie hist\u00f3rica completa.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike | None</code> <p>Data inicial (inclusive) ou None.</p> <code>None</code> <code>end</code> <code>DateLike | None</code> <p>Data final (inclusive) ou None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame com colunas normalizadas em portugu\u00eas e tipos</p> <code>DataFrame</code> <p>enriquecidos (fra\u00e7\u00f5es decimais, inteiros, datas). Em caso de erro</p> <code>DataFrame</code> <p>retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.</p> DataFrame columns <ul> <li>data_leilao: data de ocorr\u00eancia do leil\u00e3o.</li> <li>data_liquidacao: data de liquida\u00e7\u00e3o (in\u00edcio da opera\u00e7\u00e3o).</li> <li>data_retorno: data de recompra / t\u00e9rmino da opera\u00e7\u00e3o.</li> <li>hora_inicio: hor\u00e1rio de in\u00edcio do leil\u00e3o.</li> <li>prazo_dias_corridos: dias corridos at\u00e9 a data de retorno.</li> <li>prazo_dias_uteis: dias \u00fateis entre liquida\u00e7\u00e3o e retorno (bday.count).</li> <li>numero_comunicado: n\u00famero do comunicado/aviso do BC (pode ser nulo).</li> <li>tipo_oferta: classif. do tipo de oferta (ex: Tomador, Compromissada 1047).</li> <li>publico_permitido: escopo de participantes (SomenteDealer, TodoMercado).</li> <li>volume_aceito: volume aceito no leil\u00e3o em reais (convertido de milhares).</li> <li>taxa_corte: taxa de corte (ex. 0.1490 = 14,90%). Nula se volume_aceito = 0.</li> <li>percentual_aceito: percentual do volume ofertado efetivamente aceito (0-100).   100 = nenhuma rejei\u00e7\u00e3o. 0 indica nada aceito (volume_aceito = 0).</li> </ul> Notes <ul> <li>Dados ordenados por: data_leilao, hora_inicio, tipo_oferta.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.repos(start=\"21-08-2025\", end=\"21-08-2025\")\nshape: (2, 12)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 data_leilao \u2506 data_liquidacao \u2506 data_retorno \u2506 hora_inicio \u2506 \u2026 \u2506 publico_permitido \u2506 volume_aceito \u2506 taxa_corte \u2506 percentual_aceito \u2502\n\u2502 ---         \u2506 ---             \u2506 ---          \u2506 ---         \u2506   \u2506 ---               \u2506 ---           \u2506 ---        \u2506 ---               \u2502\n\u2502 date        \u2506 date            \u2506 date         \u2506 time        \u2506   \u2506 str               \u2506 i64           \u2506 f64        \u2506 f64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-21  \u2506 2025-08-21      \u2506 2025-08-22   \u2506 09:00:00    \u2506 \u2026 \u2506 SomenteDealer     \u2506 647707406000  \u2506 0.149      \u2506 100.0             \u2502\n\u2502 2025-08-21  \u2506 2025-08-22      \u2506 2025-11-21   \u2506 12:00:00    \u2506 \u2026 \u2506 TodoMercado       \u2506 5000000000    \u2506 0.9978     \u2506 35.87             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/repo.py</code> <pre><code>def repos(\n    start: DateLike | None = None,\n    end: DateLike | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"Consulta e retorna leil\u00f5es de opera\u00e7\u00f5es compromissadas (repos) do BCB.\n\n    Sem\u00e2ntica dos par\u00e2metros de per\u00edodo (API OData):\n        - start somente: dados de start at\u00e9 o fim da s\u00e9rie.\n        - end somente: dados do in\u00edcio da s\u00e9rie at\u00e9 end.\n        - ambos omitidos: s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start: Data inicial (inclusive) ou None.\n        end: Data final (inclusive) ou None.\n\n    Returns:\n        DataFrame com colunas normalizadas em portugu\u00eas e tipos\n        enriquecidos (fra\u00e7\u00f5es decimais, inteiros, datas). Em caso de erro\n        retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.\n\n    DataFrame columns:\n        - data_leilao: data de ocorr\u00eancia do leil\u00e3o.\n        - data_liquidacao: data de liquida\u00e7\u00e3o (in\u00edcio da opera\u00e7\u00e3o).\n        - data_retorno: data de recompra / t\u00e9rmino da opera\u00e7\u00e3o.\n        - hora_inicio: hor\u00e1rio de in\u00edcio do leil\u00e3o.\n        - prazo_dias_corridos: dias corridos at\u00e9 a data de retorno.\n        - prazo_dias_uteis: dias \u00fateis entre liquida\u00e7\u00e3o e retorno (bday.count).\n        - numero_comunicado: n\u00famero do comunicado/aviso do BC (pode ser nulo).\n        - tipo_oferta: classif. do tipo de oferta (ex: Tomador, Compromissada 1047).\n        - publico_permitido: escopo de participantes (SomenteDealer, TodoMercado).\n        - volume_aceito: volume aceito no leil\u00e3o em reais (convertido de milhares).\n        - taxa_corte: taxa de corte (ex. 0.1490 = 14,90%). Nula se volume_aceito = 0.\n        - percentual_aceito: percentual do volume ofertado efetivamente aceito (0-100).\n          100 = nenhuma rejei\u00e7\u00e3o. 0 indica nada aceito (volume_aceito = 0).\n\n    Notes:\n        - Dados ordenados por: data_leilao, hora_inicio, tipo_oferta.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.repos(start=\"21-08-2025\", end=\"21-08-2025\")\n        shape: (2, 12)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 data_leilao \u2506 data_liquidacao \u2506 data_retorno \u2506 hora_inicio \u2506 \u2026 \u2506 publico_permitido \u2506 volume_aceito \u2506 taxa_corte \u2506 percentual_aceito \u2502\n        \u2502 ---         \u2506 ---             \u2506 ---          \u2506 ---         \u2506   \u2506 ---               \u2506 ---           \u2506 ---        \u2506 ---               \u2502\n        \u2502 date        \u2506 date            \u2506 date         \u2506 time        \u2506   \u2506 str               \u2506 i64           \u2506 f64        \u2506 f64               \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-21  \u2506 2025-08-21      \u2506 2025-08-22   \u2506 09:00:00    \u2506 \u2026 \u2506 SomenteDealer     \u2506 647707406000  \u2506 0.149      \u2506 100.0             \u2502\n        \u2502 2025-08-21  \u2506 2025-08-22      \u2506 2025-11-21   \u2506 12:00:00    \u2506 \u2026 \u2506 TodoMercado       \u2506 5000000000    \u2506 0.9978     \u2506 35.87             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    try:\n        url = _build_url(start=start, end=end)\n        logger.debug(f\"Consultando API do BC: {url}\")\n        api_csv = _fetch_api_csv(url)\n        df = _read_csv_data(api_csv)\n        if df.is_empty():\n            logger.warning(\"Sem dados de leil\u00f5es para o per\u00edodo especificado.\")\n            return pl.DataFrame()\n        df = _process_df(df)\n        df = _handle_zero_volume(df)\n        df = _sort_and_select_columns(df)\n        return df\n    except Exception as e:\n        logger.exception(f\"Erro ao buscar dados de leil\u00f5es na API do BC: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over","title":"<code>selic_over(date)</code>","text":"<p>Fetches the SELIC Over rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date to fetch the SELIC Over rate for.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The SELIC Over rate as a float or None if not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n0.104\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_over(date: DateLike) -&gt; float:\n    \"\"\"\n    Fetches the SELIC Over rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the SELIC Over rate for.\n\n    Returns:\n        The SELIC Over rate as a float or None if not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n        0.104\n    \"\"\"\n    if has_nullable_args(date):\n        return float(\"nan\")\n    df = selic_over_series(date, date)\n    if df.is_empty():\n        return float(\"nan\")\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over_series","title":"<code>selic_over_series(start, end=None)</code>","text":"<p>Fetches the SELIC Over rate from the Brazilian Central Bank.</p> <p>The SELIC Over rate is the daily average interest rate effectively practiced between banks in the interbank market, using public securities as collateral.</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> required <code>end</code> <code>DateLike | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the SELIC Over rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # No data on 26-01-2025 (sunday). Selic changed due to Copom meeting.\n&gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\").head(5)  # Showing first 5 rows\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value  \u2502\n\u2502 ---        \u2506 ---    \u2502\n\u2502 date       \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-27 \u2506 0.1215 \u2502\n\u2502 2025-01-28 \u2506 0.1215 \u2502\n\u2502 2025-01-29 \u2506 0.1215 \u2502\n\u2502 2025-01-30 \u2506 0.1315 \u2502\n\u2502 2025-01-31 \u2506 0.1315 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; # Fetching data for a specific date range\n&gt;&gt;&gt; bc.selic_over_series(\"14-09-2025\", \"17-09-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value \u2502\n\u2502 ---        \u2506 ---   \u2502\n\u2502 date       \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-09-15 \u2506 0.149 \u2502\n\u2502 2025-09-16 \u2506 0.149 \u2502\n\u2502 2025-09-17 \u2506 0.149 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_over_series(\n    start: DateLike,\n    end: DateLike | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches the SELIC Over rate from the Brazilian Central Bank.\n\n    The SELIC Over rate is the daily average interest rate effectively practiced\n    between banks in the interbank market, using public securities as collateral.\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n\n    Returns:\n        DataFrame containing Date and Value columns with the SELIC Over rate,\n        or empty DataFrame if data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # No data on 26-01-2025 (sunday). Selic changed due to Copom meeting.\n        &gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\").head(5)  # Showing first 5 rows\n        shape: (5, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value  \u2502\n        \u2502 ---        \u2506 ---    \u2502\n        \u2502 date       \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-27 \u2506 0.1215 \u2502\n        \u2502 2025-01-28 \u2506 0.1215 \u2502\n        \u2502 2025-01-29 \u2506 0.1215 \u2502\n        \u2502 2025-01-30 \u2506 0.1315 \u2502\n        \u2502 2025-01-31 \u2506 0.1315 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; # Fetching data for a specific date range\n        &gt;&gt;&gt; bc.selic_over_series(\"14-09-2025\", \"17-09-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value \u2502\n        \u2502 ---        \u2506 ---   \u2502\n        \u2502 date       \u2506 f64   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-09-15 \u2506 0.149 \u2502\n        \u2502 2025-09-16 \u2506 0.149 \u2502\n        \u2502 2025-09-17 \u2506 0.149 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(start):  # Start must be provided\n        return pl.DataFrame()\n    df = _fetch_data_from_url(BCSerie.SELIC_OVER, start, end)\n    return df.with_columns(pl.col(\"Value\").round(DECIMAL_PLACES_ANNUALIZED))\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target","title":"<code>selic_target(date)</code>","text":"<p>Fetches the SELIC Target rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date to fetch the SELIC Target rate for.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The SELIC Target rate as a float or None if not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n0.105\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_target(date: DateLike) -&gt; float:\n    \"\"\"\n    Fetches the SELIC Target rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the SELIC Target rate for.\n\n    Returns:\n        The SELIC Target rate as a float or None if not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n        0.105\n    \"\"\"\n    if has_nullable_args(date):\n        return float(\"nan\")\n    df = selic_target_series(date, date)\n    if df.is_empty():\n        return float(\"nan\")\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target_series","title":"<code>selic_target_series(start, end=None)</code>","text":"<p>Fetches the SELIC Target rate from the Brazilian Central Bank.</p> <p>The SELIC Target rate is the official interest rate set by the Central Bank of Brazil's Monetary Policy Committee (COPOM).</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>The start date for the data to fetch.</p> required <code>end</code> <code>DateLike | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the SELIC Target rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value \u2502\n\u2502 ---        \u2506 ---   \u2502\n\u2502 date       \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 0.105 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_target_series(\n    start: DateLike,\n    end: DateLike | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches the SELIC Target rate from the Brazilian Central Bank.\n\n    The SELIC Target rate is the official interest rate set by the\n    Central Bank of Brazil's Monetary Policy Committee (COPOM).\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n\n    Returns:\n        DataFrame containing Date and Value columns with the SELIC Target rate,\n        or empty DataFrame if data is not available\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\n        shape: (1, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value \u2502\n        \u2502 ---        \u2506 ---   \u2502\n        \u2502 date       \u2506 f64   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 0.105 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(start):  # Start must be provided\n        return pl.DataFrame()\n    df = _fetch_data_from_url(BCSerie.SELIC_TARGET, start, end)\n    df = df.with_columns(pl.col(\"Value\").round(DECIMAL_PLACES_ANNUALIZED))\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_intraday_trades","title":"<code>tpf_intraday_trades()</code>","text":"<p>Fetches real-time secondary trading data for domestic Federal Public Debt (TPF - t\u00edtulos p\u00fablicos federais) from the Central Bank of Brazil (BCB).</p> <p>This function checks if the SELIC market is currently open based on Brazil/Sao_Paulo timezone business days and trading hours (defined by REALTIME_START_TIME and REALTIME_END_TIME). If the market is closed, or if no data is available from the source, or if an error occurs during fetching or processing, an empty DataFrame is returned. Otherwise, it retrieves, cleans, and processes the intraday trade data provided by BCB for Brazilian government bonds.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the latest intraday trades for FPD securities. Returns an empty DataFrame if the market is closed, no data is found, or an error occurs. The DataFrame includes the following columns:</p> DataFrame Columns <ul> <li><code>CollectedAt</code>: Timestamp indicating when the data was collected     (in Brazil/Sao_Paulo timezone).</li> <li><code>SettlementDate</code>: The reference date for the spot market     trading activity reported in this dataset (the current     business day). Forward trades listed have future settlement dates     not specified here.</li> <li><code>BondType</code>: Abbreviation/ticker for the bond type (e.g., LFT,     LTN, NTN-B).</li> <li><code>SelicCode</code>: The unique SELIC code identifying the specific bond issue.</li> <li><code>MaturityDate</code>: The maturity date of the bond.</li> <li><code>MinPrice</code>: Minimum traded price.</li> <li><code>AvgPrice</code>: Average traded price.</li> <li><code>MaxPrice</code>: Maximum traded price.</li> <li><code>LastPrice</code>: Last traded price.</li> <li><code>MinRate</code>: Minimum traded yield/rate (as a decimal, e.g., 0.11 for 11%).</li> <li><code>AvgRate</code>: Average traded yield/rate (as a decimal).</li> <li><code>MaxRate</code>: Maximum traded yield/rate (as a decimal).</li> <li><code>LastRate</code>: Last traded yield/rate (as a decimal).</li> <li><code>Trades</code>: Total number of trades settled.</li> <li><code>Quantity</code>: Total number of bonds traded (quantity).</li> <li><code>Value</code>: Total financial value traded (in BRL).</li> <li><code>BrokeredTrades</code>: Number of brokered trades settled.</li> <li><code>BrokeredQuantity</code>: Quantity of bonds traded via brokers.</li> <li><code>FwdMinPrice</code>: Forward minimum traded price.</li> <li><code>FwdAvgPrice</code>: Forward average traded price.</li> <li><code>FwdMaxPrice</code>: Forward maximum traded price.</li> <li><code>FwdLastPrice</code>: Forward last traded price.</li> <li><code>FwdMinRate</code>: Forward minimum traded yield/rate (decimal).</li> <li><code>FwdAvgRate</code>: Forward average traded yield/rate (decimal).</li> <li><code>FwdMaxRate</code>: Forward maximum traded yield/rate (decimal).</li> <li><code>FwdLastRate</code>: Forward last traded yield/rate (decimal).</li> <li><code>FwdTrades</code>: Forward total number of trades contracted.</li> <li><code>FwdQuantity</code>: Forward total number of bonds traded (quantity).</li> <li><code>FwdValue</code>: Forward total financial value traded (in BRL).</li> <li><code>FwdBrokeredTrades</code>: Forward number of brokered trades contracted.</li> <li><code>FwdBrokeredQuantity</code>: Forward quantity of bonds traded via brokers.</li> </ul> Notes <ul> <li>The DataFrame returned by this function may be empty if the market is closed,   no data is found, or an error occurs.</li> <li>Arrow data types are used for better performance and compatibility with other   libraries.</li> </ul> Source code in <code>pyield/bc/trades_intraday.py</code> <pre><code>def tpf_intraday_trades() -&gt; pl.DataFrame:\n    \"\"\"Fetches real-time secondary trading data for domestic Federal Public Debt\n    (TPF - t\u00edtulos p\u00fablicos federais) from the Central Bank of Brazil (BCB).\n\n    This function checks if the SELIC market is currently open based on Brazil/Sao_Paulo\n    timezone business days and trading hours (defined by REALTIME_START_TIME and\n    REALTIME_END_TIME). If the market is closed, or if no data is available from the\n    source, or if an error occurs during fetching or processing, an empty DataFrame\n    is returned. Otherwise, it retrieves, cleans, and processes the intraday trade\n    data provided by BCB for Brazilian government bonds.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the latest intraday trades for FPD\n            securities. Returns an empty DataFrame if the market is closed, no data\n            is found, or an error occurs. The DataFrame includes the following columns:\n\n    DataFrame Columns:\n        - `CollectedAt`: Timestamp indicating when the data was collected\n            (in Brazil/Sao_Paulo timezone).\n        - `SettlementDate`: The reference date for the spot market\n            trading activity reported in this dataset (the current\n            business day). Forward trades listed have future settlement dates\n            not specified here.\n        - `BondType`: Abbreviation/ticker for the bond type (e.g., LFT,\n            LTN, NTN-B).\n        - `SelicCode`: The unique SELIC code identifying the specific bond issue.\n        - `MaturityDate`: The maturity date of the bond.\n        - `MinPrice`: Minimum traded price.\n        - `AvgPrice`: Average traded price.\n        - `MaxPrice`: Maximum traded price.\n        - `LastPrice`: Last traded price.\n        - `MinRate`: Minimum traded yield/rate (as a decimal, e.g., 0.11 for 11%).\n        - `AvgRate`: Average traded yield/rate (as a decimal).\n        - `MaxRate`: Maximum traded yield/rate (as a decimal).\n        - `LastRate`: Last traded yield/rate (as a decimal).\n        - `Trades`: Total number of trades settled.\n        - `Quantity`: Total number of bonds traded (quantity).\n        - `Value`: Total financial value traded (in BRL).\n        - `BrokeredTrades`: Number of brokered trades settled.\n        - `BrokeredQuantity`: Quantity of bonds traded via brokers.\n        - `FwdMinPrice`: Forward minimum traded price.\n        - `FwdAvgPrice`: Forward average traded price.\n        - `FwdMaxPrice`: Forward maximum traded price.\n        - `FwdLastPrice`: Forward last traded price.\n        - `FwdMinRate`: Forward minimum traded yield/rate (decimal).\n        - `FwdAvgRate`: Forward average traded yield/rate (decimal).\n        - `FwdMaxRate`: Forward maximum traded yield/rate (decimal).\n        - `FwdLastRate`: Forward last traded yield/rate (decimal).\n        - `FwdTrades`: Forward total number of trades contracted.\n        - `FwdQuantity`: Forward total number of bonds traded (quantity).\n        - `FwdValue`: Forward total financial value traded (in BRL).\n        - `FwdBrokeredTrades`: Forward number of brokered trades contracted.\n        - `FwdBrokeredQuantity`: Forward quantity of bonds traded via brokers.\n\n    Notes:\n        - The DataFrame returned by this function may be empty if the market is closed,\n          no data is found, or an error occurs.\n        - Arrow data types are used for better performance and compatibility with other\n          libraries.\n    \"\"\"\n    if not is_selic_open():\n        logger.info(\"Market is closed. Returning empty DataFrame.\")\n        return pl.DataFrame()\n\n    try:\n        raw_text = _fetch_csv_from_url()\n        cleaned_text = _clean_csv(raw_text)\n        if not cleaned_text:\n            logger.warning(\"No data found in the FPD intraday trades.\")\n            return pl.DataFrame()\n\n        df = _convert_csv_to_df(cleaned_text)\n        df = _process_df(df)\n\n        value = df[\"Value\"].sum() / 10**9\n        logger.info(f\"Fetched {value:,.1f} billion BRL in FPD intraday trades.\")\n        return df\n    except Exception as e:\n        logger.exception(\n            f\"Error fetching data from BCB: {e}. Returning empty DataFrame.\"\n        )\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_monthly_trades","title":"<code>tpf_monthly_trades(target_date, extragroup=False)</code>","text":"<p>Fetches monthly secondary trading data for the domestic 'Federal Public Debt' (TPF - t\u00edtulos p\u00fablicos federais) registered in the Brazilian Central Bank (BCB) Selic system.</p> <p>Downloads the monthly bond trading data from the Brazilian Central Bank (BCB) website for the month corresponding to the provided date. The data is downloaded as a ZIP file, extracted, and loaded into a Pandas DataFrame. The data contains all trades executed during the month, separated by each 'SettlementDate'.</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>DateLike</code> <p>The reference date for fetching the monthly trading data. Only the year and month are used to download the corresponding file.</p> required <code>extragroup</code> <code>bool</code> <p>If True, fetches only the trades that are considered 'extragroup' (between different economic groups)\". If False, fetches all trades. Default is False. Extragroup trades are those where the transferring counterparty's conglomerate is different from the receiving counterparty's conglomerate, or when at least one of the counterparties does not belong to a conglomerate. In the case of funds, the conglomerate considered is that of the administrator.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the bond trading data for the specified month.</p> DataFrame columns <ul> <li>SettlementDate: Date when the trade settled</li> <li>BondType: Security type abbreviation</li> <li>SelicCode: Unique code in the SELIC system</li> <li>ISIN: International Securities Identification Number</li> <li>IssueDate: Date when the security was issued</li> <li>MaturityDate: Security's maturity date</li> <li>Trades: Number of trades executed</li> <li>Quantity: Quantity traded</li> <li>Value: Value traded</li> <li>AvgPrice: Average price</li> <li>AvgRate: Average rate And additional trading metrics like min/max prices and rates.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Fetches all trades for Jan/2025\n&gt;&gt;&gt; bc.tpf_monthly_trades(\"07-01-2025\", extragroup=True)\nshape: (1_019, 19)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SettlementDate \u2506 BondType \u2506 SelicCode \u2506 ISIN         \u2506 \u2026 \u2506 AvgRate \u2506 MaxRate \u2506 BrokerageTrades \u2506 BrokerageQuantity \u2502\n\u2502 ---            \u2506 ---      \u2506 ---       \u2506 ---          \u2506   \u2506 ---     \u2506 ---     \u2506 ---             \u2506 ---               \u2502\n\u2502 date           \u2506 str      \u2506 i64       \u2506 str          \u2506   \u2506 f64     \u2506 f64     \u2506 i64             \u2506 i64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RC4 \u2506 \u2026 \u2506 0.0132  \u2506 0.0906  \u2506 2               \u2506 9581              \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RD2 \u2506 \u2026 \u2506 0.0561  \u2506 0.101   \u2506 11              \u2506 42823             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RE0 \u2506 \u2026 \u2506 0.0191  \u2506 0.0405  \u2506 19              \u2506 33330             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RF7 \u2506 \u2026 \u2506 0.0304  \u2506 0.05    \u2506 10              \u2506 14583             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RG5 \u2506 \u2026 \u2506 0.0697  \u2506 0.0935  \u2506 12              \u2506 51776             \u2502\n\u2502 \u2026              \u2506 \u2026        \u2506 \u2026         \u2506 \u2026            \u2506 \u2026 \u2506 \u2026       \u2506 \u2026       \u2506 \u2026               \u2506 \u2026                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1P8 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1Q6 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF204 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 12              \u2506 570000            \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF212 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF238 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 4               \u2506 115000            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/trades_monthly.py</code> <pre><code>def tpf_monthly_trades(target_date: DateLike, extragroup: bool = False) -&gt; pl.DataFrame:\n    \"\"\"Fetches monthly secondary trading data for the domestic 'Federal Public Debt'\n    (TPF - t\u00edtulos p\u00fablicos federais) registered in the Brazilian Central Bank (BCB)\n    Selic system.\n\n    Downloads the monthly bond trading data from the Brazilian Central Bank (BCB)\n    website for the month corresponding to the provided date. The data is downloaded\n    as a ZIP file, extracted, and loaded into a Pandas DataFrame. The data contains\n    all trades executed during the month, separated by each 'SettlementDate'.\n\n    Args:\n        target_date (DateLike): The reference date for fetching the monthly trading\n            data. Only the year and month are used to download the corresponding file.\n        extragroup (bool): If True, fetches only the trades that are considered\n            'extragroup' (between different economic groups)\".\n            If False, fetches all trades. Default is False.\n            Extragroup trades are those where the transferring counterparty's\n            conglomerate is different from the receiving counterparty's conglomerate, or\n            when at least one of the counterparties does not belong to a conglomerate.\n            In the case of funds, the conglomerate considered is that of the\n            administrator.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the bond trading data for the specified\n            month.\n\n    DataFrame columns:\n        - SettlementDate: Date when the trade settled\n        - BondType: Security type abbreviation\n        - SelicCode: Unique code in the SELIC system\n        - ISIN: International Securities Identification Number\n        - IssueDate: Date when the security was issued\n        - MaturityDate: Security's maturity date\n        - Trades: Number of trades executed\n        - Quantity: Quantity traded\n        - Value: Value traded\n        - AvgPrice: Average price\n        - AvgRate: Average rate\n        And additional trading metrics like min/max prices and rates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Fetches all trades for Jan/2025\n        &gt;&gt;&gt; bc.tpf_monthly_trades(\"07-01-2025\", extragroup=True)\n        shape: (1_019, 19)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 SettlementDate \u2506 BondType \u2506 SelicCode \u2506 ISIN         \u2506 \u2026 \u2506 AvgRate \u2506 MaxRate \u2506 BrokerageTrades \u2506 BrokerageQuantity \u2502\n        \u2502 ---            \u2506 ---      \u2506 ---       \u2506 ---          \u2506   \u2506 ---     \u2506 ---     \u2506 ---             \u2506 ---               \u2502\n        \u2502 date           \u2506 str      \u2506 i64       \u2506 str          \u2506   \u2506 f64     \u2506 f64     \u2506 i64             \u2506 i64               \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RC4 \u2506 \u2026 \u2506 0.0132  \u2506 0.0906  \u2506 2               \u2506 9581              \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RD2 \u2506 \u2026 \u2506 0.0561  \u2506 0.101   \u2506 11              \u2506 42823             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RE0 \u2506 \u2026 \u2506 0.0191  \u2506 0.0405  \u2506 19              \u2506 33330             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RF7 \u2506 \u2026 \u2506 0.0304  \u2506 0.05    \u2506 10              \u2506 14583             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RG5 \u2506 \u2026 \u2506 0.0697  \u2506 0.0935  \u2506 12              \u2506 51776             \u2502\n        \u2502 \u2026              \u2506 \u2026        \u2506 \u2026         \u2506 \u2026            \u2506 \u2026 \u2506 \u2026       \u2506 \u2026       \u2506 \u2026               \u2506 \u2026                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1P8 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1Q6 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF204 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 12              \u2506 570000            \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF212 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF238 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 4               \u2506 115000            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if has_nullable_args(target_date):\n        logger.warning(\"No target_date provided. Returning an empty DataFrame.\")\n        return pl.DataFrame()\n    try:\n        target_date = convert_dates(target_date)\n        url = _build_file_url(target_date, extragroup)\n        zip_content = _fetch_zip_from_url(url)\n        extracted_file = _uncompress_zip(zip_content)\n        df = _read_dataframe_from_zip(extracted_file)\n        df = _process_df(df)\n\n    except HTTPError as e:\n        if e.response.status_code == 404:  # noqa\n            msg = f\"Resource not found (404) at {url}. Returning an empty DataFrame.\"\n            logger.warning(msg)\n            return pl.DataFrame()\n        else:\n            # Captures the full traceback for unexpected HTTP errors\n            msg = f\"Unexpected HTTP error ({e.code}) while accessing URL: {url}\"\n            logger.exception(msg)\n            raise e\n\n    except Exception:\n        # Captures the full traceback for any other errors\n        msg = f\"An unexpected error occurred while processing data from {url}.\"\n        logger.exception(msg)\n        raise\n\n    # LOG DE SUCESSO\n    msg = f\"Successfully processed data from {url}. Found {len(df)} records.\"\n    logger.info(msg)\n\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.vna_lft","title":"<code>vna_lft(date)</code>","text":"<p>Retrieves the VNA (Valor Nominal Atualizado) from the BCB for a given date.</p> <p>This function fetches daily data from the BCB website, extracts the VNA value from a specific table within the downloaded content, and returns this value.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The date for which to retrieve the VNA value. This argument accepts various date formats, including string and datetime objects, which are then standardized using the <code>convert_input_dates</code> function.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The VNA (Valor Nominal Atualizado) value for the specified date, or None if the date is invalid or data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n14903.01148\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the extracted VNA values from the BCB website are inconsistent (i.e., not all extracted values are identical), suggesting potential data discrepancies on the source website. The error message includes a link to the BCB website for manual verification.</p> <code>HTTPError</code> <p>If the HTTP request to the BCB website fails. This could be due to network issues, website unavailability, or the requested data not being found for the given date.</p> Source code in <code>pyield/bc/vna.py</code> <pre><code>def vna_lft(date: DateLike) -&gt; float:\n    \"\"\"Retrieves the VNA (Valor Nominal Atualizado) from the BCB for a given date.\n\n    This function fetches daily data from the BCB website, extracts the\n    VNA value from a specific table within the downloaded content, and\n    returns this value.\n\n    Args:\n        date (DateLike): The date for which to retrieve the VNA value.\n            This argument accepts various date formats, including string and\n            datetime objects, which are then standardized using the\n            `convert_input_dates` function.\n\n    Returns:\n        float: The VNA (Valor Nominal Atualizado) value for the specified date,\n            or None if the date is invalid or data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n        14903.01148\n\n    Raises:\n        ValueError: If the extracted VNA values from the BCB website are\n            inconsistent (i.e., not all extracted values are identical),\n            suggesting potential data discrepancies on the source website.\n            The error message includes a link to the BCB website for manual\n            verification.\n        requests.exceptions.HTTPError: If the HTTP request to the BCB website\n            fails. This could be due to network issues, website unavailability,\n            or the requested data not being found for the given date.\n    \"\"\"\n    if has_nullable_args(date):\n        logger.warning(\"No valid date provided. Returning NaN.\")\n        return float(\"nan\")\n    text = _get_text(date)\n    table_text = _extract_vna_table_text(text)\n    table_lines = _parse_vna_table_lines(table_text)\n    vnas = _extract_vna_values_from_lines(table_lines)\n    vna_value = _validate_vna_values(vnas)\n    return vna_value\n</code></pre>"},{"location":"bday/","title":"Business Day Tools","text":""},{"location":"bday/#pyield.bday.count","title":"<code>count(start, end)</code>","text":"<p>Count business days between <code>start</code> (inclusive) and <code>end</code> (exclusive) with Brazilian holiday adjustment and per-row holiday regime selection.</p> <p>ORDER PRESERVATION (critical): The output order ALWAYS matches the element-wise order of the original inputs. No sorting, deduplication, alignment or reshaping is performed. If you pass arrays, the i-th result corresponds to the i-th pair of (<code>start</code>, <code>end</code>) after broadcasting. This guarantees safe assignment back to the originating DataFrame.</p> <p>Holiday regime: For each <code>start</code> value, the holiday list (old vs. new) is chosen based on the transition date 2023-12-26 (<code>TRANSITION_DATE</code>). Starts before the transition use the old list for that row's count; starts on/after use the new list.</p> <p>Null propagation: If any scalar argument is null, returns <code>None</code>. Nulls inside array inputs yield nulls in corresponding result positions.</p> <p>Return type: If both inputs are scalars (non-null) an <code>int</code> is returned; otherwise a <code>polars.Series</code> of int counts (name: 'bday_count'). If a null scalar short-circuits, <code>None</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>None | DateLike | ArrayLike</code> <p>Single date or collection (inclusive boundary).</p> required <code>end</code> <code>None | DateLike | ArrayLike</code> <p>Single date or collection (exclusive boundary).</p> required <p>Returns:</p> Type Description <code>None | int | Series</code> <p>int | pl.Series | None: Returns an integer or None if <code>start</code> and <code>end</code> are single dates, or a Series if any of them is an array of dates.</p> Notes <ul> <li>This function is a wrapper around <code>polars.business_day_count</code>.</li> <li>The holiday list is determined per-row based on the <code>start</code> date.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n10\n</code></pre> <p>Total business days in January and February since the start of the year</p> <pre><code>&gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\nshape: (2,)\nSeries: 'bday_count' [i64]\n[\n    22\n    41\n]\n</code></pre> <p>The remaining business days from January/February until the end of the year</p> <pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\nshape: (2,)\nSeries: 'bday_count' [i64]\n[\n    253\n    231\n]\n</code></pre> <p>The total business days in January and February of 2024</p> <pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\nshape: (2,)\nSeries: 'bday_count' [i64]\n[\n    22\n    19\n]\n</code></pre> <p>Null values are propagated</p> <pre><code>&gt;&gt;&gt; bday.count(None, \"01-01-2024\")  # None start\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"01-01-2024\", None)  # None end\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"01-01-2024\", [\"01-02-2024\", None])  # None in end array\nshape: (2,)\nSeries: 'bday_count' [i64]\n[\n    22\n    null\n]\n</code></pre> <pre><code>&gt;&gt;&gt; start_dates = [\"01-01-2024\", \"01-02-2024\", \"01-03-2024\"]\n&gt;&gt;&gt; bday.count(start_dates, \"01-01-2025\")\nshape: (3,)\nSeries: 'bday_count' [i64]\n[\n    253\n    231\n    212\n]\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def count(\n    start: None | DateLike | ArrayLike,\n    end: None | DateLike | ArrayLike,\n) -&gt; None | int | pl.Series:\n    \"\"\"\n    Count business days between `start` (inclusive) and `end` (exclusive) with\n    Brazilian holiday adjustment and per-row holiday regime selection.\n\n    ORDER PRESERVATION (critical): The output order ALWAYS matches the element-wise\n    order of the original inputs. No sorting, deduplication, alignment or reshaping is\n    performed. If you pass arrays, the i-th result corresponds to the i-th pair of\n    (`start`, `end`) after broadcasting. This guarantees safe assignment back to the\n    originating DataFrame.\n\n    Holiday regime: For each `start` value, the holiday list (old vs. new) is chosen\n    based on the transition date 2023-12-26 (`TRANSITION_DATE`). Starts before the\n    transition use the old list for that row's count; starts on/after use the new list.\n\n    Null propagation: If any scalar argument is null, returns `None`. Nulls inside\n    array inputs yield nulls in corresponding result positions.\n\n    Return type: If both inputs are scalars (non-null) an `int` is returned; otherwise\n    a `polars.Series` of int counts (name: 'bday_count').\n    If a null scalar short-circuits, `None` is returned.\n\n    Args:\n        start: Single date or collection (inclusive boundary).\n        end: Single date or collection (exclusive boundary).\n\n    Returns:\n        int | pl.Series | None: Returns an integer or None if `start` and `end` are\n            single dates, or a Series if any of them is an array of dates.\n\n    Notes:\n        - This function is a wrapper around `polars.business_day_count`.\n        - The holiday list is determined per-row based on the `start` date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n        10\n\n        Total business days in January and February since the start of the year\n        &gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n        shape: (2,)\n        Series: 'bday_count' [i64]\n        [\n            22\n            41\n        ]\n\n        The remaining business days from January/February until the end of the year\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n        shape: (2,)\n        Series: 'bday_count' [i64]\n        [\n            253\n            231\n        ]\n\n        The total business days in January and February of 2024\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n        shape: (2,)\n        Series: 'bday_count' [i64]\n        [\n            22\n            19\n        ]\n\n        Null values are propagated\n        &gt;&gt;&gt; bday.count(None, \"01-01-2024\")  # None start\n\n        &gt;&gt;&gt; bday.count(\"01-01-2024\", None)  # None end\n\n        &gt;&gt;&gt; bday.count(\"01-01-2024\", [\"01-02-2024\", None])  # None in end array\n        shape: (2,)\n        Series: 'bday_count' [i64]\n        [\n            22\n            null\n        ]\n\n        &gt;&gt;&gt; start_dates = [\"01-01-2024\", \"01-02-2024\", \"01-03-2024\"]\n        &gt;&gt;&gt; bday.count(start_dates, \"01-01-2025\")\n        shape: (3,)\n        Series: 'bday_count' [i64]\n        [\n            253\n            231\n            212\n        ]\n    \"\"\"\n    # Coloca as s\u00e9ries em um DataFrame para trabalhar com express\u00f5es em colunas\n    df = pl.DataFrame(\n        data={\"start\": cv.convert_dates(start), \"end\": cv.convert_dates(end)},\n        schema={\"start\": pl.Date, \"end\": pl.Date},\n        nan_to_null=True,\n    )\n\n    count_expr = (\n        pl.when(pl.col(\"start\") &lt; TRANSITION_DATE)\n        .then(\n            pl.business_day_count(\n                start=pl.col(\"start\"), end=pl.col(\"end\"), holidays=OLD_HOLIDAYS_ARRAY\n            ),\n        )\n        .otherwise(\n            pl.business_day_count(\n                start=pl.col(\"start\"), end=pl.col(\"end\"), holidays=NEW_HOLIDAYS_ARRAY\n            )\n        )\n        .cast(pl.Int64)\n        .alias(\"bday_count\")\n    )\n\n    s = df.select(count_expr)[\"bday_count\"]\n\n    if not tp.has_array_like_args(start, end):\n        return s.first()  # type: ignore[return-value]\n\n    return s\n</code></pre>"},{"location":"bday/#pyield.bday.generate","title":"<code>generate(start=None, end=None, closed='both', holiday_option='new')</code>","text":"<p>Generates a Series of business days between a <code>start</code> and <code>end</code> date, considering the list of Brazilian holidays.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike | None</code> <p>The start date. If None, the current date is used.</p> <code>None</code> <code>end</code> <code>DateLike | None</code> <p>The end date. If None, the current date is used.</p> <code>None</code> <code>closed</code> <code>Literal['both', 'left', 'right', 'none']</code> <p>Define which sides of the range are closed (inclusive). Valid options are 'both', 'left', 'right', 'none'. Defaults to 'both'.</p> <code>'both'</code> <code>holiday_option</code> <code>Literal['old', 'new', 'infer']</code> <p>Specifies the list of holidays to consider. Defaults to \"new\". - 'old': Uses the holiday list effective before 2023-12-26. - 'new': Uses the holiday list effective on and after 2023-12-26. - 'infer': Selects based on <code>start</code> date relative to the transition.</p> <code>'new'</code> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series of business days (name: 'bday').</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\nshape: (6,)\nSeries: 'bday' [date]\n[\n    2023-12-22\n    2023-12-26\n    2023-12-27\n    2023-12-28\n    2023-12-29\n    2024-01-02\n]\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def generate(\n    start: DateLike | None = None,\n    end: DateLike | None = None,\n    closed: Literal[\"both\", \"left\", \"right\", \"none\"] = \"both\",\n    holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"new\",\n) -&gt; pl.Series:\n    \"\"\"\n    Generates a Series of business days between a `start` and `end` date, considering\n    the list of Brazilian holidays.\n\n    Args:\n        start: The start date. If None, the current date is used.\n        end: The end date. If None, the current date is used.\n        closed: Define which sides of the range are closed (inclusive).\n            Valid options are 'both', 'left', 'right', 'none'. Defaults to 'both'.\n        holiday_option: Specifies the list of holidays to consider. Defaults to \"new\".\n            - 'old': Uses the holiday list effective before 2023-12-26.\n            - 'new': Uses the holiday list effective on and after 2023-12-26.\n            - 'infer': Selects based on `start` date relative to the transition.\n\n    Returns:\n        pl.Series: A Series of business days (name: 'bday').\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n        shape: (6,)\n        Series: 'bday' [date]\n        [\n            2023-12-22\n            2023-12-26\n            2023-12-27\n            2023-12-28\n            2023-12-29\n            2024-01-02\n        ]\n    \"\"\"\n    today = clock.today()\n    conv_start = cv.convert_dates(start) or today\n    conv_end = cv.convert_dates(end) or today\n\n    # Gera range completo de datas\n    s = pl.date_range(conv_start, conv_end, closed=closed, eager=True).alias(\"bday\")\n\n    # Pega feriados aplic\u00e1veis\n    holidays = br_holidays.get_holiday_series(\n        dates=conv_start, holiday_option=holiday_option\n    ).implode()\n\n    # Filtra: s\u00f3 dias \u00fateis (seg-sex e n\u00e3o feriado)\n    return s.filter((s.dt.weekday() &lt; SATURDAY_INDEX) &amp; (~s.is_in(holidays)))\n</code></pre>"},{"location":"bday/#pyield.bday.is_business_day","title":"<code>is_business_day(dates)</code>","text":"<p>Determine whether date(s) are Brazilian business days with per-element holiday regime selection.</p> <p>PER-ROW HOLIDAY REGIME: For EACH input date the appropriate holiday list (\"old\" vs. \"new\") is selected by comparing to the transition date <code>2023-12-26</code> (<code>TRANSITION_DATE</code>). Dates strictly before the transition use the old list; dates on or after it use the new list. This mirrors the behavior of <code>count</code> and <code>offset</code> which apply regime logic element-wise.</p> <p>ORDER &amp; SHAPE PRESERVATION: The output preserves the original element order. No sorting, deduplication, reshaping or alignment is performed; the i-th result corresponds to the i-th provided date after broadcasting (if any broadcasting occurred from a scalar input elsewhere in the call chain).</p> <p>NULL PROPAGATION: A null scalar argument short-circuits to <code>None</code>. Null values inside array-like inputs produce nulls at the corresponding output positions.</p> <p>RETURN TYPE: If the (non-null) input resolves to a single element a Python <code>bool</code> is returned. If that lone element is null, <code>None</code> is returned. Otherwise a <code>polars.Series</code> of booleans named <code>'is_bday'</code> is produced.</p> <p>WEEKENDS: Saturdays and Sundays are never business days regardless of the holiday regime.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>None | DateLike | ArrayLike</code> <p>Single date or collection (list/tuple/ndarray/Polars/Pandas Series). May include nulls which propagate. Null scalar input returns <code>None</code>.</p> required <p>Returns:</p> Type Description <code>None | bool | Series</code> <p>bool | pl.Series | None: <code>True</code> if business day, <code>False</code> otherwise</p> <code>None | bool | Series</code> <p>for scalar input; <code>None</code> for null scalar input; or a Polars boolean</p> <code>None | bool | Series</code> <p>Series (name: <code>'is_bday'</code>) for array inputs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas (old calendar)\nFalse\n&gt;&gt;&gt; bday.is_business_day(\"20-11-2024\")  # National Zumbi Day (new holiday)\nFalse\n&gt;&gt;&gt; bday.is_business_day([\"22-12-2023\", \"26-12-2023\"])  # Mixed periods\nshape: (2,)\nSeries: 'is_bday' [bool]\n[\n    true\n    true\n]\n</code></pre> Notes <ul> <li>Transition date defined in <code>TRANSITION_DATE</code>.</li> <li>Mirrors per-row logic used in <code>count</code> and <code>offset</code>.</li> <li>Weekends always evaluate to <code>False</code>.</li> <li>Null elements propagate.</li> </ul> Source code in <code>pyield/bday/core.py</code> <pre><code>def is_business_day(dates: None | DateLike | ArrayLike) -&gt; None | bool | pl.Series:\n    \"\"\"Determine whether date(s) are Brazilian business days with per-element\n    holiday regime selection.\n\n    PER-ROW HOLIDAY REGIME: For EACH input date the appropriate holiday list\n    (\"old\" vs. \"new\") is selected by comparing to the transition date\n    ``2023-12-26`` (``TRANSITION_DATE``). Dates strictly before the transition\n    use the old list; dates on or after it use the new list. This mirrors the\n    behavior of ``count`` and ``offset`` which apply regime logic element-wise.\n\n    ORDER &amp; SHAPE PRESERVATION: The output preserves the original element order.\n    No sorting, deduplication, reshaping or alignment is performed; the i-th\n    result corresponds to the i-th provided date after broadcasting (if any\n    broadcasting occurred from a scalar input elsewhere in the call chain).\n\n    NULL PROPAGATION: A null scalar argument short-circuits to ``None``. Null\n    values inside array-like inputs produce nulls at the corresponding output\n    positions.\n\n    RETURN TYPE: If the (non-null) input resolves to a single element a Python\n    ``bool`` is returned. If that lone element is null, ``None`` is returned.\n    Otherwise a ``polars.Series`` of booleans named ``'is_bday'`` is produced.\n\n    WEEKENDS: Saturdays and Sundays are never business days regardless of the\n    holiday regime.\n\n    Args:\n        dates: Single date or collection (list/tuple/ndarray/Polars/Pandas\n            Series). May include nulls which propagate. Null scalar input\n            returns ``None``.\n\n    Returns:\n        bool | pl.Series | None: ``True`` if business day, ``False`` otherwise\n        for scalar input; ``None`` for null scalar input; or a Polars boolean\n        Series (name: ``'is_bday'``) for array inputs.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas (old calendar)\n        False\n        &gt;&gt;&gt; bday.is_business_day(\"20-11-2024\")  # National Zumbi Day (new holiday)\n        False\n        &gt;&gt;&gt; bday.is_business_day([\"22-12-2023\", \"26-12-2023\"])  # Mixed periods\n        shape: (2,)\n        Series: 'is_bday' [bool]\n        [\n            true\n            true\n        ]\n\n    Notes:\n        - Transition date defined in ``TRANSITION_DATE``.\n        - Mirrors per-row logic used in ``count`` and ``offset``.\n        - Weekends always evaluate to ``False``.\n        - Null elements propagate.\n    \"\"\"\n    # Build DataFrame to allow conditional expression selecting the right holiday list\n    df = pl.DataFrame(\n        {\"dates\": cv.convert_dates(dates)},\n        schema={\"dates\": pl.Date},\n        nan_to_null=True,\n    )\n\n    is_bday_expr = (\n        pl.when(pl.col(\"dates\") &lt; TRANSITION_DATE)\n        .then(\n            pl.col(\"dates\").dt.is_business_day(holidays=OLD_HOLIDAYS_ARRAY),\n        )\n        .otherwise(\n            pl.col(\"dates\").dt.is_business_day(holidays=NEW_HOLIDAYS_ARRAY),\n        )\n        .alias(\"is_bday\")\n    )\n\n    s = df.select(is_bday_expr)[\"is_bday\"]\n\n    if not tp.has_array_like_args(dates):\n        return s.first()  # type: ignore[return-value]\n\n    return s\n</code></pre>"},{"location":"bday/#pyield.bday.last_business_day","title":"<code>last_business_day()</code>","text":"<p>Returns the last business day in Brazil. If the current date is a business day, it returns the current date. If it is a weekend or holiday, it returns the last business day before the current date.</p> <p>Returns:</p> Type Description <code>date</code> <p>dt.date: The last business day in Brazil.</p> Notes <ul> <li>The determination of the last business day considers the correct Brazilian holiday list (before or after the 2023-12-26 transition) applicable to the current date.</li> </ul> Source code in <code>pyield/bday/core.py</code> <pre><code>def last_business_day() -&gt; dt.date:\n    \"\"\"\n    Returns the last business day in Brazil. If the current date is a business day, it\n    returns the current date. If it is a weekend or holiday, it returns the last\n    business day before the current date.\n\n    Returns:\n        dt.date: The last business day in Brazil.\n\n    Notes:\n        - The determination of the last business day considers the correct Brazilian\n        holiday list (before or after the 2023-12-26 transition) applicable to\n        the current date.\n\n    \"\"\"\n    # Get the current date in Brazil without timezone information\n    bz_today = clock.today()\n    result = offset(bz_today, 0, roll=\"backward\")\n    assert isinstance(result, dt.date), (\n        \"Assumption violated: offset did not return a date for the current date.\"\n    )\n    return result\n</code></pre>"},{"location":"bday/#pyield.bday.offset","title":"<code>offset(dates, offset, roll='forward')</code>","text":"<p>Offset date(s) by a number of business days with per-row Brazilian holiday regime selection. The operation is performed in two steps per element: 1) ROLL: If the original date falls on a weekend or holiday, move it according    to <code>roll</code> (\"forward\" -&gt; next business day; \"backward\" -&gt; previous). 2) ADD: Apply the signed business-day <code>offset</code> (positive forward, negative    backward, zero = stay on the rolled date).</p> <p>ORDER PRESERVATION (critical): Output ordering strictly matches the element-wise pairing after broadcasting between <code>dates</code> and <code>offset</code>. No sorting, deduplication or shape changes occur. The i-th result corresponds to the i-th (date, offset) pair, enabling safe assignment back into the originating DataFrame.</p> <p>Holiday regime: For EACH date the appropriate holiday list (old vs. new) is chosen based on the transition date <code>2023-12-26</code> (<code>TRANSITION_DATE</code>). Dates before the transition use the old list; dates on/after use the new list.</p> <p>Roll semantics: <code>roll</code> only acts when the original date is not already a business day under its regime. After rolling, the subsequent business-day addition is applied from that rolled anchor. An <code>offset</code> of 0 therefore returns either the original date (if already a business day) or the rolled business day.</p> <p>Null propagation: If any scalar argument is null, the function short-circuits to <code>None</code>. Nulls inside array inputs propagate to their corresponding output positions.</p> <p>Broadcasting: <code>dates</code> and <code>offset</code> may be scalars or array-like. Standard Polars broadcasting rules apply when constructing the per-row pairs.</p> <p>Return type: If both inputs are non-null scalars a <code>datetime.date</code> is returned. Otherwise a <code>polars.Series</code> of dates named <code>'adjusted_date'</code> is produced. Null scalar inputs yield <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateLike | ArrayLike | None</code> <p>Single date or collection of dates to be rolled (if needed) and then offset. Each date independently selects the holiday regime.</p> required <code>offset</code> <code>int | ArrayLike | None</code> <p>Signed count of business days to apply after rolling. Positive moves forward, negative backward, zero keeps the rolled anchor.</p> required <code>roll</code> <code>Literal['forward', 'backward']</code> <p>Direction to roll a non-business starting date (\"forward\" or \"backward\"). Defaults to \"forward\".</p> <code>'forward'</code> <p>Returns:</p> Type Description <code>date | Series | None</code> <p>dt.date | pl.Series | None: A Python <code>date</code> for scalar inputs, a Polars</p> <code>date | Series | None</code> <p>Series of dates for any array input, or <code>None</code> if a null scalar argument</p> <code>date | Series | None</code> <p>was provided.</p> Notes <ul> <li>Wrapper around <code>polars.Expr.dt.add_business_days</code> applied conditionally.</li> <li>Holiday regime is decided per element by comparing to <code>TRANSITION_DATE</code>.</li> <li>Weekends are always treated as non-business days.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n</code></pre> <p>Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\ndatetime.date(2023, 12, 26)\n</code></pre> <p>Offset Friday before Christmas (no offset because it's a business day)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")</p> <p>No offset because it's a business day</p> <pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Offset to the first business day before \"23-12-2023\"</p> <pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Jump to the next business day (1 offset and roll=\"forward\")</p> <p>Offset Friday to the next business day (Friday is jumped -&gt; Monday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\ndatetime.date(2024, 9, 30)\n</code></pre> <p>Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\ndatetime.date(2024, 10, 1)\n</code></pre> <p>Jump to the previous business day (-1 offset and roll=\"backward\")</p> <p>Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\ndatetime.date(2024, 9, 26)\n</code></pre> <p>Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\ndatetime.date(2024, 9, 26)\n</code></pre>"},{"location":"bday/#pyield.bday.offset--list-of-dates-and-offsets","title":"List of dates and offsets","text":"<pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)\nshape: (2,)\nSeries: 'adjusted_date' [date]\n[\n    2024-09-20\n    2024-09-23\n]\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\nshape: (2,)\nSeries: 'adjusted_date' [date]\n[\n    2024-09-20\n    2024-09-23\n]\n</code></pre>"},{"location":"bday/#pyield.bday.offset--scalar-nulls-propagate-to-none","title":"Scalar nulls propagate to None","text":"<pre><code>&gt;&gt;&gt; print(bday.offset(None, 1))\nNone\n</code></pre>"},{"location":"bday/#pyield.bday.offset--scalar-null-propagates-inside-arrays","title":"Scalar null propagates inside arrays","text":"<pre><code>&gt;&gt;&gt; bday.offset(None, [1, 2])\nshape: (2,)\nSeries: 'adjusted_date' [date]\n[\n    null\n    null\n]\n</code></pre>"},{"location":"bday/#pyield.bday.offset--nulls-inside-arrays-are-preserved","title":"Nulls inside arrays are preserved","text":"<pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", None], 1)\nshape: (2,)\nSeries: 'adjusted_date' [date]\n[\n    2024-09-20\n    null\n]\n</code></pre> <pre><code>&gt;&gt;&gt; dates = [\"19-09-2024\", \"20-09-2024\", \"21-09-2024\"]\n&gt;&gt;&gt; bday.offset(dates, 1)\nshape: (3,)\nSeries: 'adjusted_date' [date]\n[\n    2024-09-20\n    2024-09-23\n    2024-09-24\n]\n</code></pre> Note <p>This function uses <code>polars.Expr.dt.add_business_days</code> under the hood. For detailed information, refer to the Polars documentation.</p> Source code in <code>pyield/bday/core.py</code> <pre><code>def offset(\n    dates: DateLike | ArrayLike | None,\n    offset: int | ArrayLike | None,\n    roll: Literal[\"forward\", \"backward\"] = \"forward\",\n) -&gt; dt.date | pl.Series | None:\n    \"\"\"\n    Offset date(s) by a number of business days with per-row Brazilian holiday\n    regime selection. The operation is performed in two steps per element:\n    1) ROLL: If the original date falls on a weekend or holiday, move it according\n       to ``roll`` (\"forward\" -&gt; next business day; \"backward\" -&gt; previous).\n    2) ADD: Apply the signed business-day ``offset`` (positive forward, negative\n       backward, zero = stay on the rolled date).\n\n    ORDER PRESERVATION (critical): Output ordering strictly matches the element-wise\n    pairing after broadcasting between ``dates`` and ``offset``. No sorting,\n    deduplication or shape changes occur. The i-th result corresponds to the i-th\n    (date, offset) pair, enabling safe assignment back into the originating DataFrame.\n\n    Holiday regime: For EACH date the appropriate holiday list (old vs. new) is\n    chosen based on the transition date ``2023-12-26`` (``TRANSITION_DATE``). Dates\n    before the transition use the *old* list; dates on/after use the *new* list.\n\n    Roll semantics: ``roll`` only acts when the original date is not already a\n    business day under its regime. After rolling, the subsequent business-day\n    addition is applied from that rolled anchor. An ``offset`` of 0 therefore\n    returns either the original date (if already a business day) or the rolled\n    business day.\n\n    Null propagation: If any scalar argument is null, the function short-circuits\n    to ``None``. Nulls inside array inputs propagate to their corresponding output\n    positions.\n\n    Broadcasting: ``dates`` and ``offset`` may be scalars or array-like. Standard\n    Polars broadcasting rules apply when constructing the per-row pairs.\n\n    Return type: If both inputs are non-null scalars a ``datetime.date`` is returned.\n    Otherwise a ``polars.Series`` of dates named ``'adjusted_date'`` is produced.\n    Null scalar inputs yield ``None``.\n\n    Args:\n        dates: Single date or collection of dates to be rolled (if needed) and then\n            offset. Each date independently selects the holiday regime.\n        offset: Signed count of business days to apply after rolling. Positive moves\n            forward, negative backward, zero keeps the rolled anchor.\n        roll: Direction to roll a non-business starting date (\"forward\" or\n            \"backward\"). Defaults to \"forward\".\n\n    Returns:\n        dt.date | pl.Series | None: A Python ``date`` for scalar inputs, a Polars\n        Series of dates for any array input, or ``None`` if a null scalar argument\n        was provided.\n\n    Notes:\n        - Wrapper around ``polars.Expr.dt.add_business_days`` applied conditionally.\n        - Holiday regime is decided per element by comparing to ``TRANSITION_DATE``.\n        - Weekends are always treated as non-business days.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n\n        Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\n        datetime.date(2023, 12, 26)\n\n        Offset Friday before Christmas (no offset because it's a business day)\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\n        datetime.date(2023, 12, 22)\n\n        Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")\n\n        No offset because it's a business day\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\n        datetime.date(2023, 12, 22)\n\n        Offset to the first business day before \"23-12-2023\"\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\n        datetime.date(2023, 12, 22)\n\n        Jump to the next business day (1 offset and roll=\"forward\")\n\n        Offset Friday to the next business day (Friday is jumped -&gt; Monday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\n        datetime.date(2024, 9, 30)\n\n        Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\n        datetime.date(2024, 10, 1)\n\n        Jump to the previous business day (-1 offset and roll=\"backward\")\n\n        Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\n        datetime.date(2024, 9, 26)\n\n        Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\n        datetime.date(2024, 9, 26)\n\n        # List of dates and offsets\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)\n        shape: (2,)\n        Series: 'adjusted_date' [date]\n        [\n            2024-09-20\n            2024-09-23\n        ]\n\n        &gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\n        shape: (2,)\n        Series: 'adjusted_date' [date]\n        [\n            2024-09-20\n            2024-09-23\n        ]\n\n        # Scalar nulls propagate to None\n        &gt;&gt;&gt; print(bday.offset(None, 1))\n        None\n\n        # Scalar null propagates inside arrays\n        &gt;&gt;&gt; bday.offset(None, [1, 2])\n        shape: (2,)\n        Series: 'adjusted_date' [date]\n        [\n            null\n            null\n        ]\n\n        # Nulls inside arrays are preserved\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", None], 1)\n        shape: (2,)\n        Series: 'adjusted_date' [date]\n        [\n            2024-09-20\n            null\n        ]\n\n        &gt;&gt;&gt; dates = [\"19-09-2024\", \"20-09-2024\", \"21-09-2024\"]\n        &gt;&gt;&gt; bday.offset(dates, 1)\n        shape: (3,)\n        Series: 'adjusted_date' [date]\n        [\n            2024-09-20\n            2024-09-23\n            2024-09-24\n        ]\n\n    Note:\n        This function uses `polars.Expr.dt.add_business_days` under the hood. For\n        detailed information, refer to the Polars documentation.\n    \"\"\"\n    # Coloca as entradas em um DataFrame para trabalhar com express\u00f5es em colunas\n    df = pl.DataFrame(\n        data={\"dates\": cv.convert_dates(dates), \"offset\": offset},\n        schema={\"dates\": pl.Date, \"offset\": pl.Int64},\n        nan_to_null=True,\n    )\n\n    # Cria a express\u00e3o condicional para aplicar a lista de feriados correta\n    offset_expr = (\n        pl.when(pl.col(\"dates\") &lt; TRANSITION_DATE)\n        .then(\n            pl.col(\"dates\").dt.add_business_days(\n                n=pl.col(\"offset\"),\n                roll=roll,\n                holidays=OLD_HOLIDAYS_ARRAY,\n            )\n        )\n        .otherwise(\n            pl.col(\"dates\").dt.add_business_days(\n                n=pl.col(\"offset\"),\n                roll=roll,\n                holidays=NEW_HOLIDAYS_ARRAY,\n            )\n        )\n        .alias(\"adjusted_date\")\n    )\n\n    # Executa a express\u00e3o e obt\u00e9m a s\u00e9rie de resultados\n    s = df.select(offset_expr)[\"adjusted_date\"]\n\n    if not tp.has_array_like_args(dates, offset):\n        return s.first()  # type: ignore[return-value]\n\n    return s\n</code></pre>"},{"location":"di1/","title":"DI Futures","text":""},{"location":"di1/#pyield.b3.di1.available_trade_dates","title":"<code>available_trade_dates()</code>","text":"<p>Returns all available (completed) trading dates in the DI dataset.</p> <p>Retrieves distinct 'TradeDate' values present in the historical DI futures data cache, sorted chronologically.</p> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A sorted Series of unique trade dates (dt.date) for which DI data is available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # DI Futures series starts from 1995-01-02\n&gt;&gt;&gt; di1.available_trade_dates().head(5)\nshape: (5,)\nSeries: 'available_dates' [date]\n[\n    1995-01-02\n    1995-01-03\n    1995-01-04\n    1995-01-05\n    1995-01-06\n]\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def available_trade_dates() -&gt; pl.Series:\n    \"\"\"\n    Returns all available (completed) trading dates in the DI dataset.\n\n    Retrieves distinct 'TradeDate' values present in the\n    historical DI futures data cache, sorted chronologically.\n\n    Returns:\n        pl.Series: A sorted Series of unique trade dates (dt.date)\n            for which DI data is available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # DI Futures series starts from 1995-01-02\n        &gt;&gt;&gt; di1.available_trade_dates().head(5)\n        shape: (5,)\n        Series: 'available_dates' [date]\n        [\n            1995-01-02\n            1995-01-03\n            1995-01-04\n            1995-01-05\n            1995-01-06\n        ]\n    \"\"\"\n    available_dates = (\n        get_cached_dataset(\"di1\")\n        .get_column(\"TradeDate\")\n        .unique()\n        .sort()\n        .alias(\"available_dates\")\n    )\n    return available_dates\n</code></pre>"},{"location":"di1/#pyield.b3.di1.data","title":"<code>data(dates, month_start=False, pre_filter=False)</code>","text":"<p>Retrieves DI Futures contract data for a specific trade date.</p> <p>Provides access to DI futures data, allowing adjustments to expiration dates (to month start) and optional filtering based on LTN and NTN-F bond maturities.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateLike</code> <p>The trade dates for which to retrieve DI contract data.</p> required <code>month_start</code> <code>bool</code> <p>If True, adjusts all expiration dates to the first day of their respective month (e.g., 2025-02-01 becomes 2025-01-01). Defaults to False.</p> <code>False</code> <code>pre_filter</code> <code>bool</code> <p>If True, filters DI contracts to include only those whose expiration dates match known prefixed Treasury bond (LTN, NTN-F) maturities from the TPF dataset nearest to the given trade date. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the DI futures contract data for the specified dates, sorted by trade dates and expiration dates. Returns an empty DataFrame if no data is found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; df = di1.data(dates=\"16-10-2024\", month_start=True)\n&gt;&gt;&gt; df\nshape: (38, 22)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 ExpirationDate \u2506 TickerSymbol \u2506 DaysToExp \u2506 \u2026 \u2506 MaxRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---            \u2506 ---          \u2506 ---       \u2506   \u2506 ---     \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 date           \u2506 str          \u2506 i64       \u2506   \u2506 f64     \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-10-16 \u2506 2024-11-01     \u2506 DI1X24       \u2506 16        \u2506 \u2026 \u2506 0.10656 \u2506 0.10652   \u2506 0.10653        \u2506 0.10653     \u2502\n\u2502 2024-10-16 \u2506 2024-12-01     \u2506 DI1Z24       \u2506 47        \u2506 \u2026 \u2506 0.10914 \u2506 0.10914   \u2506 0.1091         \u2506 0.110726    \u2502\n\u2502 2024-10-16 \u2506 2025-01-01     \u2506 DI1F25       \u2506 78        \u2506 \u2026 \u2506 0.11174 \u2506 0.11164   \u2506 0.11164        \u2506 0.1154      \u2502\n\u2502 2024-10-16 \u2506 2025-02-01     \u2506 DI1G25       \u2506 110       \u2506 \u2026 \u2506 0.1137  \u2506 0.11365   \u2506 0.11362        \u2506 0.118314    \u2502\n\u2502 2024-10-16 \u2506 2025-03-01     \u2506 DI1H25       \u2506 140       \u2506 \u2026 \u2506 0.11595 \u2506 0.11565   \u2506 0.1157         \u2506 0.12343     \u2502\n\u2502 \u2026          \u2506 \u2026              \u2506 \u2026            \u2506 \u2026         \u2506 \u2026 \u2506 \u2026       \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-10-16 \u2506 2035-01-01     \u2506 DI1F35       \u2506 3730      \u2506 \u2026 \u2506 0.1267  \u2506 0.1264    \u2506 0.1265         \u2506 0.124455    \u2502\n\u2502 2024-10-16 \u2506 2036-01-01     \u2506 DI1F36       \u2506 4095      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.124249    \u2502\n\u2502 2024-10-16 \u2506 2037-01-01     \u2506 DI1F37       \u2506 4461      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n\u2502 2024-10-16 \u2506 2038-01-01     \u2506 DI1F38       \u2506 4828      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n\u2502 2024-10-16 \u2506 2039-01-01     \u2506 DI1F39       \u2506 5192      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def data(\n    dates: DateLike | ArrayLike,\n    month_start: bool = False,\n    pre_filter: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves DI Futures contract data for a specific trade date.\n\n    Provides access to DI futures data, allowing adjustments to expiration dates\n    (to month start) and optional filtering based on LTN and NTN-F bond maturities.\n\n    Args:\n        dates (DateLike): The trade dates for which to retrieve DI contract data.\n        month_start (bool, optional): If True, adjusts all expiration dates to the\n            first day of their respective month (e.g., 2025-02-01 becomes\n            2025-01-01). Defaults to False.\n        pre_filter (bool, optional): If True, filters DI contracts to include only\n            those whose expiration dates match known prefixed Treasury bond (LTN, NTN-F)\n            maturities from the TPF dataset nearest to the given trade date.\n            Defaults to False.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the DI futures contract\n            data for the specified dates, sorted by trade dates and expiration dates.\n            Returns an empty DataFrame if no data is found\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; df = di1.data(dates=\"16-10-2024\", month_start=True)\n        &gt;&gt;&gt; df\n        shape: (38, 22)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 ExpirationDate \u2506 TickerSymbol \u2506 DaysToExp \u2506 \u2026 \u2506 MaxRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---            \u2506 ---          \u2506 ---       \u2506   \u2506 ---     \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 date           \u2506 str          \u2506 i64       \u2506   \u2506 f64     \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-10-16 \u2506 2024-11-01     \u2506 DI1X24       \u2506 16        \u2506 \u2026 \u2506 0.10656 \u2506 0.10652   \u2506 0.10653        \u2506 0.10653     \u2502\n        \u2502 2024-10-16 \u2506 2024-12-01     \u2506 DI1Z24       \u2506 47        \u2506 \u2026 \u2506 0.10914 \u2506 0.10914   \u2506 0.1091         \u2506 0.110726    \u2502\n        \u2502 2024-10-16 \u2506 2025-01-01     \u2506 DI1F25       \u2506 78        \u2506 \u2026 \u2506 0.11174 \u2506 0.11164   \u2506 0.11164        \u2506 0.1154      \u2502\n        \u2502 2024-10-16 \u2506 2025-02-01     \u2506 DI1G25       \u2506 110       \u2506 \u2026 \u2506 0.1137  \u2506 0.11365   \u2506 0.11362        \u2506 0.118314    \u2502\n        \u2502 2024-10-16 \u2506 2025-03-01     \u2506 DI1H25       \u2506 140       \u2506 \u2026 \u2506 0.11595 \u2506 0.11565   \u2506 0.1157         \u2506 0.12343     \u2502\n        \u2502 \u2026          \u2506 \u2026              \u2506 \u2026            \u2506 \u2026         \u2506 \u2026 \u2506 \u2026       \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-10-16 \u2506 2035-01-01     \u2506 DI1F35       \u2506 3730      \u2506 \u2026 \u2506 0.1267  \u2506 0.1264    \u2506 0.1265         \u2506 0.124455    \u2502\n        \u2502 2024-10-16 \u2506 2036-01-01     \u2506 DI1F36       \u2506 4095      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.124249    \u2502\n        \u2502 2024-10-16 \u2506 2037-01-01     \u2506 DI1F37       \u2506 4461      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2502 2024-10-16 \u2506 2038-01-01     \u2506 DI1F38       \u2506 4828      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2502 2024-10-16 \u2506 2039-01-01     \u2506 DI1F39       \u2506 5192      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if has_nullable_args(dates):\n        logger.warning(\"No valid 'dates' provided. Returning empty DataFrame.\")\n        return pl.DataFrame()\n    df = _get_data(dates=dates)\n\n    if month_start:\n        df = df.with_columns(pl.col(\"ExpirationDate\").dt.truncate(\"1mo\"))\n\n    if pre_filter:\n        df_pre = (\n            get_cached_dataset(\"tpf\")\n            .filter(pl.col(\"BondType\").is_in([\"LTN\", \"NTN-F\"]))\n            .unique(subset=[\"ReferenceDate\", \"MaturityDate\"])\n            .select(\n                TradeDate=pl.col(\"ReferenceDate\"),\n                ExpirationDate=pl.col(\"MaturityDate\"),\n            )\n        )\n\n        # garante que os dois lados est\u00e3o ordenados pelas chaves necess\u00e1rias\n        df = df.sort(\"TradeDate\", \"ExpirationDate\")\n        df_pre = df_pre.sort(\"TradeDate\", \"ExpirationDate\")\n\n        df = df.join_asof(\n            df_pre,\n            left_on=\"TradeDate\",\n            right_on=\"TradeDate\",\n            by=\"ExpirationDate\",  # garante matching por v\u00e9rtice\n            strategy=\"backward\",  # pega a data anterior se n\u00e3o tiver exata\n            check_sortedness=False,  # j\u00e1 garantimos a ordena\u00e7\u00e3o\n        )\n\n    return df\n</code></pre>"},{"location":"di1/#pyield.b3.di1.interpolate_rate","title":"<code>interpolate_rate(date, expiration, extrapolate=False)</code>","text":"<p>Interpolates or retrieves the DI rate for a single expiration date.</p> <p>Fetches DI contract data for the specified trade <code>date</code> and determines the settlement rate for the given <code>expiration</code>. If an exact match for the expiration date exists, its rate is returned. Otherwise, the rate is interpolated using the flat-forward method based on the rates of surrounding contracts.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The trade date for which to retrieve DI data.</p> required <code>expiration</code> <code>DateLike</code> <p>The target expiration date for the rate.</p> required <code>extrapolate</code> <code>bool</code> <p>If True, allows extrapolation if the <code>expiration</code> date falls outside the range of available contract expirations for the given <code>date</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The exact or interpolated DI settlement rate for the specified date and expiration. Returns <code>float(\"nan\")</code> if:     - No DI data is found for the <code>date</code>.     - The <code>expiration</code> is outside range and <code>extrapolate</code> is False.     - An interpolation calculation fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # Get rate for an existing contract expiration\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2027\")\n0.13901\n</code></pre> <pre><code>&gt;&gt;&gt; # Get rate for a non-existing contract expiration\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-11-2027\")\n0.13576348733268917\n</code></pre> <pre><code>&gt;&gt;&gt; # Extrapolate rate for a future expiration date\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2050\", extrapolate=True)\n0.13881\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def interpolate_rate(\n    date: DateLike,\n    expiration: DateLike,\n    extrapolate: bool = False,\n) -&gt; float:\n    \"\"\"\n    Interpolates or retrieves the DI rate for a single expiration date.\n\n    Fetches DI contract data for the specified trade `date` and determines the\n    settlement rate for the given `expiration`. If an exact match for the\n    expiration date exists, its rate is returned. Otherwise, the rate is\n    interpolated using the flat-forward method based on the rates of surrounding\n    contracts.\n\n    Args:\n        date (DateLike): The trade date for which to retrieve DI data.\n        expiration (DateLike): The target expiration date for the rate.\n        extrapolate (bool, optional): If True, allows extrapolation if the\n            `expiration` date falls outside the range of available contract\n            expirations for the given `date`. Defaults to False.\n\n    Returns:\n        float: The exact or interpolated DI settlement rate for the specified\n            date and expiration. Returns `float(\"nan\")` if:\n                - No DI data is found for the `date`.\n                - The `expiration` is outside range and `extrapolate` is False.\n                - An interpolation calculation fails.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # Get rate for an existing contract expiration\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2027\")\n        0.13901\n\n        &gt;&gt;&gt; # Get rate for a non-existing contract expiration\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-11-2027\")\n        0.13576348733268917\n\n        &gt;&gt;&gt; # Extrapolate rate for a future expiration date\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2050\", extrapolate=True)\n        0.13881\n    \"\"\"\n    if has_nullable_args(date, expiration):\n        logger.warning(\"Both 'date' and 'expiration' must be provided. Returning NaN.\")\n        return float(\"nan\")\n\n    converted_date = cv.convert_dates(date)\n    converted_expiration = cv.convert_dates(expiration)\n\n    if not isinstance(converted_date, dt.date) or not isinstance(\n        converted_expiration, dt.date\n    ):\n        raise ValueError(\"Both 'date' and 'expiration' must be single date values.\")\n\n    # Get the DI contract DataFrame\n    df = _get_data(dates=converted_date)\n\n    if df.is_empty():\n        return float(\"nan\")\n\n    ff_interp = interpolator.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=df[\"BDaysToExp\"],\n        known_rates=df[\"SettlementRate\"],\n        extrapolate=extrapolate,\n    )\n\n    bd = bday.count(converted_date, converted_expiration)\n    return ff_interp(bd)\n</code></pre>"},{"location":"di1/#pyield.b3.di1.interpolate_rates","title":"<code>interpolate_rates(dates, expirations, extrapolate=True)</code>","text":"<p>Interpolates DI rates for specified trade dates and expiration dates.</p> <p>Calculates interpolated DI rates using the flat-forward method for given sets of trade dates and expiration dates. This function is well-suited for vectorized calculations across multiple date pairs.</p> <p>If DI rates are unavailable for a given trade date, the corresponding interpolated rate(s) will be NaN.</p> <p>Handles broadcasting: If one argument is a scalar and the other is an array, the scalar value is applied to all elements of the array.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateLike | ArrayLike</code> <p>The trade date(s) for the rates.</p> required <code>expirations</code> <code>DateLike | ArrayLike</code> <p>The corresponding expiration date(s). Must be compatible in length with <code>dates</code> if both are arrays.</p> required <code>extrapolate</code> <code>bool</code> <p>Whether to allow extrapolation beyond the range of known DI rates for a given trade date. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series containing the interpolated DI rates (as floats). Values will be NaN where interpolation is not possible (e.g., no DI data for the trade date).</p> <p>Examples:</p> <ul> <li>Interpolate rates for multiple trade and expiration dates</li> </ul> <pre><code>&gt;&gt;&gt; # For contract with expiration 01-01-2027 in 08-05-2025\n&gt;&gt;&gt; # The rate is not interpolated (settlement rate is used)\n&gt;&gt;&gt; # There is no contract with expiration 25-11-2027 in 09-05-2025\n&gt;&gt;&gt; # The rate is interpolated (flat-forward method)\n&gt;&gt;&gt; # There is no data for trade date 10-05-2025 (Saturday) -&gt; NaN\n&gt;&gt;&gt; # Note: 0.13461282461562996 is shown as 0.134613\n&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=[\"08-05-2025\", \"09-05-2025\", \"10-05-2025\"],\n...     expirations=[\"01-01-2027\", \"25-11-2027\", \"01-01-2030\"],\n... )\nshape: (3,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.13972\n    0.134613\n    null\n]\n</code></pre> <ul> <li>Interpolate rates for a single trade date and multiple expiration dates</li> </ul> <pre><code>&gt;&gt;&gt; # There is no DI Contract in 09-05-2025 with expiration 01-01-2050\n&gt;&gt;&gt; # The longest available contract is used to extrapolate the rate\n&gt;&gt;&gt; # Note: extrapolation is allowed by default\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=\"25-04-2025\",\n...     expirations=[\"01-01-2027\", \"01-01-2050\"],\n... )\nshape: (2,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.13901\n    0.13881\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # With extrapolation set to False, the second rate will be null\n&gt;&gt;&gt; # Note: 0.13576348733268917 is shown as 0.135763\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=\"25-04-2025\",\n...     expirations=[\"01-11-2027\", \"01-01-2050\"],\n...     extrapolate=False,\n... )\nshape: (2,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.135763\n    null\n]\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dates</code> and <code>expirations</code> are both array-like but have different lengths.</p> Notes <ul> <li>All available settlement rates are used for the flat-forward interpolation.</li> <li>The function handles broadcasting of scalar and array-like inputs.</li> </ul> Source code in <code>pyield/b3/di1.py</code> <pre><code>def interpolate_rates(\n    dates: DateLike | ArrayLike,\n    expirations: DateLike | ArrayLike,\n    extrapolate: bool = True,\n) -&gt; pl.Series:\n    \"\"\"\n    Interpolates DI rates for specified trade dates and expiration dates.\n\n    Calculates interpolated DI rates using the **flat-forward** method for given\n    sets of trade dates and expiration dates. This function is well-suited\n    for vectorized calculations across multiple date pairs.\n\n    If DI rates are unavailable for a given trade date, the corresponding\n    interpolated rate(s) will be NaN.\n\n    Handles broadcasting: If one argument is a scalar and the other is an array,\n    the scalar value is applied to all elements of the array.\n\n    Args:\n        dates (DateLike | ArrayLike): The trade date(s) for the rates.\n        expirations (DateLike | ArrayLike): The corresponding expiration date(s).\n            Must be compatible in length with `dates` if both are arrays.\n        extrapolate (bool, optional): Whether to allow extrapolation beyond the\n            range of known DI rates for a given trade date. Defaults to True.\n\n    Returns:\n        pl.Series: A Series containing the interpolated DI rates (as floats).\n            Values will be NaN where interpolation is not possible\n            (e.g., no DI data for the trade date).\n\n    Examples:\n        - Interpolate rates for multiple trade and expiration dates\n        &gt;&gt;&gt; # For contract with expiration 01-01-2027 in 08-05-2025\n        &gt;&gt;&gt; # The rate is not interpolated (settlement rate is used)\n        &gt;&gt;&gt; # There is no contract with expiration 25-11-2027 in 09-05-2025\n        &gt;&gt;&gt; # The rate is interpolated (flat-forward method)\n        &gt;&gt;&gt; # There is no data for trade date 10-05-2025 (Saturday) -&gt; NaN\n        &gt;&gt;&gt; # Note: 0.13461282461562996 is shown as 0.134613\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=[\"08-05-2025\", \"09-05-2025\", \"10-05-2025\"],\n        ...     expirations=[\"01-01-2027\", \"25-11-2027\", \"01-01-2030\"],\n        ... )\n        shape: (3,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.13972\n            0.134613\n            null\n        ]\n\n        - Interpolate rates for a single trade date and multiple expiration dates\n        &gt;&gt;&gt; # There is no DI Contract in 09-05-2025 with expiration 01-01-2050\n        &gt;&gt;&gt; # The longest available contract is used to extrapolate the rate\n        &gt;&gt;&gt; # Note: extrapolation is allowed by default\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=\"25-04-2025\",\n        ...     expirations=[\"01-01-2027\", \"01-01-2050\"],\n        ... )\n        shape: (2,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.13901\n            0.13881\n        ]\n\n        &gt;&gt;&gt; # With extrapolation set to False, the second rate will be null\n        &gt;&gt;&gt; # Note: 0.13576348733268917 is shown as 0.135763\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=\"25-04-2025\",\n        ...     expirations=[\"01-11-2027\", \"01-01-2050\"],\n        ...     extrapolate=False,\n        ... )\n        shape: (2,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.135763\n            null\n        ]\n\n    Raises:\n        ValueError: If `dates` and `expirations` are both array-like but have\n            different lengths.\n\n    Notes:\n        - All available settlement rates are used for the flat-forward interpolation.\n        - The function handles broadcasting of scalar and array-like inputs.\n    \"\"\"\n    if has_nullable_args(dates, expirations):\n        logger.warning(\n            \"Both 'dates' and 'expirations' must be provided. Returning empty Series.\"\n        )\n        return pl.Series(dtype=pl.Float64)\n\n    dfi = _build_input_dataframe(dates, expirations)\n    if dfi.is_empty():\n        logger.warning(\"Invalid inputs provided. Returning empty Series.\")\n        return pl.Series(dtype=pl.Float64)\n\n    # Load DI rates dataset filtered by the provided reference dates\n    dfr = _get_data(dates=dates)\n    # Return an empty DataFrame if no rates are found\n    if dfr.is_empty():\n        return pl.Series(dtype=pl.Float64)\n\n    # 1. CRIA O \u00cdNDICE ORIGINAL AQUI\n    # Isso garante que saberemos a ordem exata depois\n    dfi = dfi.with_row_index(\"_temp_idx\")\n\n    s_bdays = bday.count(dfi[\"TradeDate\"], dfi[\"ExpirationDate\"])\n    # Inicializa FlatFwdRate como None\n    dfi = dfi.with_columns(BDaysToExp=s_bdays, FlatFwdRate=None)\n\n    # Lista para armazenar os peda\u00e7os processados\n    processed_chunks = []\n\n    # Iterate over each unique reference date\n    for date in dfi[\"TradeDate\"].unique():\n        # 1. Filtra apenas as linhas desta data (Particionamento)\n        df_subset = dfi.filter(pl.col(\"TradeDate\") == date)\n\n        # 2. Busca as taxas de refer\u00eancia para esta data\n        dfr_subset = dfr.filter(pl.col(\"TradeDate\") == date)\n\n        # Se n\u00e3o houver dados de curva (dfr), adicionamos o subset como est\u00e1 (com Nulls)\n        # e continuamos.\n        if dfr_subset.is_empty():\n            processed_chunks.append(df_subset)\n            continue\n\n        # Initialize the interpolator with known rates and business days\n        interp = interpolator.Interpolator(\n            method=\"flat_forward\",\n            known_bdays=dfr_subset[\"BDaysToExp\"],\n            known_rates=dfr_subset[\"SettlementRate\"],\n            extrapolate=extrapolate,\n        )\n\n        # 4. A M\u00e1gica: map_batches passa a Series inteira para o 'interp'\n        # O 'interp' retorna uma Series, que o Polars alinha perfeitamente\n        df_subset = df_subset.with_columns(\n            pl.col(\"BDaysToExp\")\n            .map_batches(interp)  # Passa Series -&gt; Recebe Series\n            .alias(\"FlatFwdRate\")\n        )\n\n        processed_chunks.append(df_subset)\n\n    if not processed_chunks:\n        return pl.Series(dtype=pl.Float64)\n\n    # 2. CONCATENA E ORDENA DE VOLTA\n    # O sort(\"_temp_idx\") restaura a ordem original dos inputs\n    df_final = pl.concat(processed_chunks).sort(\"_temp_idx\")\n\n    return df_final[\"FlatFwdRate\"].fill_nan(None)\n</code></pre>"},{"location":"forwards/","title":"Forwards","text":""},{"location":"forwards/#pyield.fwd.forward","title":"<code>forward(bday1, bday2, rate1, rate2)</code>","text":"<p>Calcula a taxa a termo (forward rate) entre dois prazos (dias \u00fateis).</p> Utiliza a f\u00f3rmula <p>f\u2081\u2192\u2082 = ((1 + r\u2082)^(du\u2082/252) / (1 + r\u2081)^(du\u2081/252))^(252/(du\u2082 - du\u2081)) - 1</p> Onde <ul> <li>r\u2081 \u00e9 a taxa zero para o primeiro prazo (du\u2081).</li> <li>r\u2082 \u00e9 a taxa zero para o segundo prazo (du\u2082).</li> <li>du\u2081 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a primeira data.</li> <li>du\u2082 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a segunda data.</li> <li>A constante 252 representa o n\u00famero de dias \u00fateis no ano.</li> </ul> <p>Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:</p> <pre><code>f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>bday1</code> <code>int</code> <p>N\u00famero de dias \u00fateis do primeiro ponto (prazo menor).</p> required <code>bday2</code> <code>int</code> <p>N\u00famero de dias \u00fateis do segundo ponto (prazo maior).</p> required <code>rate1</code> <code>float</code> <p>Taxa zero (spot rate) para o prazo <code>bday1</code>.</p> required <code>rate2</code> <code>float</code> <p>Taxa zero (spot rate) para o prazo <code>bday2</code>.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>A taxa a termo calculada entre <code>bday1</code> e <code>bday2</code>. Retorna <code>None</code> se <code>bday1 &gt;= bday2</code> ou se qualquer um dos argumentos de entrada for float('nan') ou None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Exemplo v\u00e1lido: bday2 &gt; bday1\n&gt;&gt;&gt; yd.forward(10, 20, 0.05, 0.06)\n0.0700952380952371\n&gt;&gt;&gt; # Exemplo inv\u00e1lido: bday1 &gt;= bday2\n&gt;&gt;&gt; print(yd.forward(20, 10, 0.06, 0.05))\nnan\n</code></pre> <pre><code>&gt;&gt;&gt; # Argumentos nulos retornam nan\n&gt;&gt;&gt; print(yd.forward(10, 20, 0.05, None))\nnan\n</code></pre> Note <p><code>bday2</code> precisa ser necessariamente maior que <code>bday1</code> para que o c\u00e1lculo da taxa a termo seja matematicamente v\u00e1lido.</p> <p>A f\u00f3rmula utilizada \u00e9 derivada da rela\u00e7\u00e3o entre taxas zero (spot rates) \u00e9: $$ f_{1 \\rightarrow 2} = \\left( \\frac{(1 + r_2)^{t_2}}{(1 + r_1)^{t_1}} \\right)^{\\frac{1}{t_2 - t_1}} - 1 $$</p> Source code in <code>pyield/fwd.py</code> <pre><code>def forward(\n    bday1: int,\n    bday2: int,\n    rate1: float,\n    rate2: float,\n) -&gt; float:\n    r\"\"\"\n    Calcula a taxa a termo (forward rate) entre dois prazos (dias \u00fateis).\n\n    Utiliza a f\u00f3rmula:\n        f\u2081\u2192\u2082 = ((1 + r\u2082)^(du\u2082/252) / (1 + r\u2081)^(du\u2081/252))^(252/(du\u2082 - du\u2081)) - 1\n\n    Onde:\n        - r\u2081 \u00e9 a taxa zero para o primeiro prazo (du\u2081).\n        - r\u2082 \u00e9 a taxa zero para o segundo prazo (du\u2082).\n        - du\u2081 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a primeira data.\n        - du\u2082 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a segunda data.\n        - A constante 252 representa o n\u00famero de dias \u00fateis no ano.\n\n    Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:\n\n        f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n\n    Args:\n        bday1 (int): N\u00famero de dias \u00fateis do primeiro ponto (prazo menor).\n        bday2 (int): N\u00famero de dias \u00fateis do segundo ponto (prazo maior).\n        rate1 (float): Taxa zero (spot rate) para o prazo `bday1`.\n        rate2 (float): Taxa zero (spot rate) para o prazo `bday2`.\n\n    Returns:\n        float: A taxa a termo calculada entre `bday1` e `bday2`. Retorna\n            `None` se `bday1 &gt;= bday2` ou se qualquer um dos\n            argumentos de entrada for float('nan') ou None.\n\n    Examples:\n        &gt;&gt;&gt; # Exemplo v\u00e1lido: bday2 &gt; bday1\n        &gt;&gt;&gt; yd.forward(10, 20, 0.05, 0.06)\n        0.0700952380952371\n        &gt;&gt;&gt; # Exemplo inv\u00e1lido: bday1 &gt;= bday2\n        &gt;&gt;&gt; print(yd.forward(20, 10, 0.06, 0.05))\n        nan\n\n        &gt;&gt;&gt; # Argumentos nulos retornam nan\n        &gt;&gt;&gt; print(yd.forward(10, 20, 0.05, None))\n        nan\n\n    Note:\n        `bday2` precisa ser necessariamente maior que `bday1` para que\n        o c\u00e1lculo da taxa a termo seja matematicamente v\u00e1lido.\n\n    A f\u00f3rmula utilizada \u00e9 derivada da rela\u00e7\u00e3o entre taxas zero (spot rates) \u00e9:\n    $$\n    f_{1 \\rightarrow 2} = \\left( \\frac{(1 + r_2)^{t_2}}{(1 + r_1)^{t_1}} \\right)^{\\frac{1}{t_2 - t_1}} - 1\n    $$\n    \"\"\"  # noqa: E501\n    if has_nullable_args(rate1, rate2, bday1, bday2):\n        # If any of the inputs are nullable, return None\n        return float(\"nan\")\n\n    # Handle the case where the two dates are the same\n    if bday2 &lt;= bday1:\n        return float(\"nan\")\n\n    # Convert business days to business years\n    t1 = bday1 / 252\n    t2 = bday2 / 252\n\n    # f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n    return ((1 + rate2) ** t2 / (1 + rate1) ** t1) ** (1 / (t2 - t1)) - 1\n</code></pre>"},{"location":"forwards/#pyield.fwd.forwards","title":"<code>forwards(bdays, rates, group_by=None)</code>","text":"<p>Calcula taxas a termo (forward rates) a partir de taxas zero (spot rates).</p> <p>A taxa a termo no v\u00e9rtice 'n' \u00e9 definida como:     fwd\u2096 = fwd\u2c7c\u2192\u2096 (a taxa a termo de j para k)</p> A f\u00f3rmula utilizada \u00e9 <p>fwd\u2096 = ((1 + r\u2096)^(du\u2096/252) / (1 + r\u2c7c)^(du\u2c7c/252))^(252/(du\u2096 - du\u2c7c)) - 1</p> <p>Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:</p> <pre><code>fwd\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c)^(1/(t\u2096 - t\u2c7c)) - 1\n</code></pre> <p>Em LaTeX, a f\u00f3rmula \u00e9 representada como: $$ fwd_k = \\left( \\frac{(1 + r_k)^{t_k}}{(1 + r_j)^{t_j}} \\right)^{\\frac{1}{t_k - t_j}} - 1 $$</p> Onde <ul> <li>r\u2c7c \u00e9 a taxa zero para o v\u00e9rtice anterior.</li> <li>r\u2096 \u00e9 a taxa zero para o v\u00e9rtice atual.</li> <li>t\u2c7c \u00e9 o prazo em anos para o v\u00e9rtice anterior (calculado como du\u2c7c/252).</li> <li>t\u2096 \u00e9 o prazo em anos para o v\u00e9rtice atual (calculado como du\u2096/252).</li> <li>A constante 252 representa o n\u00famero de dias \u00fateis no ano.</li> </ul> <p>A fun\u00e7\u00e3o preserva a ordem original dos dados de entrada e lida com valores nulos de forma apropriada. Valores nulos nas entradas resultar\u00e3o em valores nulos nas taxas a termo calculadas.</p> <p>A primeira taxa a termo de cada grupo \u00e9 definida como a taxa zero desse primeiro v\u00e9rtice (fwd\u2081 = r\u2081), dado que n\u00e3o existe um v\u00e9rtice anterior a r\u2081 para se calcular a taxa a termo no primeiro ponto.</p> <p>A fun\u00e7\u00e3o tamb\u00e9m lida com agrupamentos opcionais, permitindo calcular taxas a termo para diferentes grupos de datas. O agrupamento \u00e9 feito com base em <code>group_by</code>. Se este argumento for None, todos os dados ser\u00e3o tratados como um \u00fanico grupo.</p> <p>A fun\u00e7\u00e3o calcula as taxas a termo para todos os pontos, exceto o primeiro de cada grupo, que \u00e9 tratado separadamente.</p> <p>Args:     bdays (ArrayLike): N\u00famero de dias \u00fateis para cada taxa zero.     rates (ArrayLike): Taxas zero correspondentes aos dias \u00fateis.     group_by (GroupingCriteria, optional):         Crit\u00e9rio de agrupamento para os c\u00e1lculos (ex: datas de refer\u00eancia,         tickers de t\u00edtulos). Pode ser uma lista/s\u00e9rie de strings, inteiros         ou datas. Se None, todos os dados s\u00e3o tratados como um \u00fanico grupo.         Default None.</p> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie contendo as taxas a termo calculadas (tipo Float64). A primeira taxa de cada grupo corresponde \u00e0 taxa zero inicial.</p> <p>Raises:     polars.exceptions.ShapeError: Se os comprimentos de <code>bdays</code>, <code>rates</code>         e <code>group_by</code> (quando fornecido) n\u00e3o forem iguais.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bdays = [10, 20, 30]\n&gt;&gt;&gt; rates = [0.05, 0.06, 0.07]\n&gt;&gt;&gt; yd.forwards(bdays, rates)\nshape: (3,)\nSeries: 'fwd' [f64]\n[\n    0.05\n    0.070095\n    0.090284\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Exemplo com agrupamento (a \u00faltima est\u00e1 isolada em outro grupo)\n&gt;&gt;&gt; group_by = [\"LTN\", \"LTN\", \"NTN-F\"]\n&gt;&gt;&gt; yd.forwards(bdays, rates, group_by)\nshape: (3,)\nSeries: 'fwd' [f64]\n[\n    0.05\n    0.070095\n    0.07\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Exemplo com taxas indicativas de NTN-B em 16-09-2025\n&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; df = ntnb.data(\"16-09-2025\")\n&gt;&gt;&gt; yd.forwards(df[\"BDToMat\"], df[\"IndicativeRate\"])\nshape: (13,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.071549\n    0.072439\n    0.069558\n    0.076614\n    \u2026\n    0.068105\n    0.071278\n    0.069117\n    0.070373\n    0.073286\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Valores nulos s\u00e3o descartados no c\u00e1lculo e retornados como nulos\n&gt;&gt;&gt; du = [230, 415, 730, None, 914]\n&gt;&gt;&gt; tx = [0.0943, 0.084099, 0.079052, 0.1, 0.077134]\n&gt;&gt;&gt; yd.forwards(du, tx)\nshape: (5,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.071549\n    0.072439\n    null\n    0.069558\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # O algoritmo ordena os dados de entrada antes do c\u00e1lculo e retorna\n&gt;&gt;&gt; # os resultados na ordem original. Valores duplicados s\u00e3o tratados\n&gt;&gt;&gt; # como um \u00fanico ponto no c\u00e1lculo da taxa a termo (\u00faltimo valor \u00e9 mantido).\n&gt;&gt;&gt; du = [230, 730, 415, 230]\n&gt;&gt;&gt; tx = [0.1, 0.079052, 0.084099, 0.0943]\n&gt;&gt;&gt; yd.forwards(du, tx)\nshape: (4,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.072439\n    0.071549\n    0.0943\n]\n</code></pre> Note <ul> <li>A fun\u00e7\u00e3o ordena os dados de entrada primeiro por <code>group_by</code>, se for fornecido, e depois por <code>bdays</code> para garantir a ordem cronol\u00f3gica correta no c\u00e1lculo das taxas a termo.</li> <li>Valores nulos em <code>bdays</code> ou <code>rates</code> s\u00e3o ignorados no c\u00e1lculo, resultando em valores nulos nas posi\u00e7\u00f5es correspondentes na sa\u00edda.</li> <li>Os resultados s\u00e3o retornados na mesma ordem dos dados de entrada.</li> </ul> Source code in <code>pyield/fwd.py</code> <pre><code>def forwards(\n    bdays: ArrayLike,\n    rates: ArrayLike,\n    group_by: Sequence[str | int | dt.date] | pl.Series | None = None,\n) -&gt; pl.Series:\n    r\"\"\"\n    Calcula taxas a termo (forward rates) a partir de taxas zero (spot rates).\n\n    A taxa a termo no v\u00e9rtice 'n' \u00e9 definida como:\n        fwd\u2096 = fwd\u2c7c\u2192\u2096 (a taxa a termo de j para k)\n\n    A f\u00f3rmula utilizada \u00e9:\n        fwd\u2096 = ((1 + r\u2096)^(du\u2096/252) / (1 + r\u2c7c)^(du\u2c7c/252))^(252/(du\u2096 - du\u2c7c)) - 1\n\n    Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:\n\n        fwd\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c)^(1/(t\u2096 - t\u2c7c)) - 1\n\n    Em LaTeX, a f\u00f3rmula \u00e9 representada como:\n    $$\n    fwd_k = \\left( \\frac{(1 + r_k)^{t_k}}{(1 + r_j)^{t_j}} \\right)^{\\frac{1}{t_k - t_j}} - 1\n    $$\n\n    Onde:\n        - r\u2c7c \u00e9 a taxa zero para o v\u00e9rtice anterior.\n        - r\u2096 \u00e9 a taxa zero para o v\u00e9rtice atual.\n        - t\u2c7c \u00e9 o prazo em anos para o v\u00e9rtice anterior (calculado como du\u2c7c/252).\n        - t\u2096 \u00e9 o prazo em anos para o v\u00e9rtice atual (calculado como du\u2096/252).\n        - A constante 252 representa o n\u00famero de dias \u00fateis no ano.\n\n    A fun\u00e7\u00e3o preserva a ordem original dos dados de entrada e lida com valores nulos\n    de forma apropriada. Valores nulos nas entradas resultar\u00e3o em valores nulos\n    nas taxas a termo calculadas.\n\n    A primeira taxa a termo de cada grupo \u00e9 definida como a\n    taxa zero desse primeiro v\u00e9rtice (fwd\u2081 = r\u2081), dado que n\u00e3o existe um v\u00e9rtice\n    anterior a r\u2081 para se calcular a taxa a termo no primeiro ponto.\n\n    A fun\u00e7\u00e3o tamb\u00e9m lida com agrupamentos opcionais, permitindo calcular taxas\n    a termo para diferentes grupos de datas. O agrupamento \u00e9 feito com base em `group_by`.\n    Se este argumento for None, todos os dados ser\u00e3o tratados como um \u00fanico grupo.\n\n    A fun\u00e7\u00e3o calcula as taxas a termo para todos os pontos, exceto o primeiro\n    de cada grupo, que \u00e9 tratado separadamente.\n\n     Args:\n        bdays (ArrayLike): N\u00famero de dias \u00fateis para cada taxa zero.\n        rates (ArrayLike): Taxas zero correspondentes aos dias \u00fateis.\n        group_by (GroupingCriteria, optional):\n            Crit\u00e9rio de agrupamento para os c\u00e1lculos (ex: datas de refer\u00eancia,\n            tickers de t\u00edtulos). Pode ser uma lista/s\u00e9rie de strings, inteiros\n            ou datas. Se None, todos os dados s\u00e3o tratados como um \u00fanico grupo.\n            Default None.\n\n    Returns:\n        pl.Series: S\u00e9rie contendo as taxas a termo calculadas (tipo Float64).\n            A primeira taxa de cada grupo corresponde \u00e0 taxa zero inicial.\n\n     Raises:\n        polars.exceptions.ShapeError: Se os comprimentos de `bdays`, `rates`\n            e `group_by` (quando fornecido) n\u00e3o forem iguais.\n\n    Examples:\n        &gt;&gt;&gt; bdays = [10, 20, 30]\n        &gt;&gt;&gt; rates = [0.05, 0.06, 0.07]\n        &gt;&gt;&gt; yd.forwards(bdays, rates)\n        shape: (3,)\n        Series: 'fwd' [f64]\n        [\n            0.05\n            0.070095\n            0.090284\n        ]\n\n        &gt;&gt;&gt; # Exemplo com agrupamento (a \u00faltima est\u00e1 isolada em outro grupo)\n        &gt;&gt;&gt; group_by = [\"LTN\", \"LTN\", \"NTN-F\"]\n        &gt;&gt;&gt; yd.forwards(bdays, rates, group_by)\n        shape: (3,)\n        Series: 'fwd' [f64]\n        [\n            0.05\n            0.070095\n            0.07\n        ]\n\n        &gt;&gt;&gt; # Exemplo com taxas indicativas de NTN-B em 16-09-2025\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; df = ntnb.data(\"16-09-2025\")\n        &gt;&gt;&gt; yd.forwards(df[\"BDToMat\"], df[\"IndicativeRate\"])\n        shape: (13,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.071549\n            0.072439\n            0.069558\n            0.076614\n            \u2026\n            0.068105\n            0.071278\n            0.069117\n            0.070373\n            0.073286\n        ]\n\n        &gt;&gt;&gt; # Valores nulos s\u00e3o descartados no c\u00e1lculo e retornados como nulos\n        &gt;&gt;&gt; du = [230, 415, 730, None, 914]\n        &gt;&gt;&gt; tx = [0.0943, 0.084099, 0.079052, 0.1, 0.077134]\n        &gt;&gt;&gt; yd.forwards(du, tx)\n        shape: (5,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.071549\n            0.072439\n            null\n            0.069558\n        ]\n\n        &gt;&gt;&gt; # O algoritmo ordena os dados de entrada antes do c\u00e1lculo e retorna\n        &gt;&gt;&gt; # os resultados na ordem original. Valores duplicados s\u00e3o tratados\n        &gt;&gt;&gt; # como um \u00fanico ponto no c\u00e1lculo da taxa a termo (\u00faltimo valor \u00e9 mantido).\n        &gt;&gt;&gt; du = [230, 730, 415, 230]\n        &gt;&gt;&gt; tx = [0.1, 0.079052, 0.084099, 0.0943]\n        &gt;&gt;&gt; yd.forwards(du, tx)\n        shape: (4,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.072439\n            0.071549\n            0.0943\n        ]\n\n    Note:\n        - A fun\u00e7\u00e3o ordena os dados de entrada primeiro por `group_by`,\n        se for fornecido, e depois por `bdays` para garantir a ordem cronol\u00f3gica\n        correta no c\u00e1lculo das taxas a termo.\n        - Valores nulos em `bdays` ou `rates` s\u00e3o ignorados no c\u00e1lculo,\n        resultando em valores nulos nas posi\u00e7\u00f5es correspondentes na sa\u00edda.\n        - Os resultados s\u00e3o retornados na mesma ordem dos dados de entrada.\n    \"\"\"  # noqa: E501\n    # Valida\u00e7\u00f5es iniciais\n    if has_nullable_args(bdays, rates):\n        return pl.Series(dtype=pl.Float64)\n    # 1. Montar o DataFrame\n    # Criar coluna de agrupamento dummy se n\u00e3o for fornecida\n    group_by_exp = pl.Series(group_by) if group_by is not None else 0\n    df_orig = pl.DataFrame(\n        {\n            \"du_k\": bdays,\n            \"rate_k\": rates,\n            \"group_by\": group_by_exp,\n        }\n    )\n\n    # 3. Definir a f\u00f3rmula da taxa a termo\n    # f\u2096 = f\u2c7c\u2192\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c) ^ (1/(t\u2096 - t\u2c7c)) - 1\n    exp1 = (1 + pl.col(\"rate_k\")) ** pl.col(\"time_k\")  # (1 + r\u2096)^t\u2096\n    exp2 = (1 + pl.col(\"rate_j\")) ** pl.col(\"time_j\")  # (1 + r\u2c7c)^t\u2c7c\n    exp3 = 1 / (pl.col(\"time_k\") - pl.col(\"time_j\"))  # 1/(t\u2096 - t\u2c7c)\n    fwd_formula = (exp1 / exp2) ** exp3 - 1\n\n    # 4. Calcular as taxas a termo\n    df_fwd = (\n        df_orig.drop_nans()\n        .drop_nulls()\n        .unique(subset=[\"du_k\", \"group_by\"], keep=\"last\")\n        .sort([\"group_by\", \"du_k\"])\n        .with_columns(time_k=pl.col(\"du_k\") / 252)  # Criar coluna de tempo em anos\n        .with_columns(\n            # Calcular os valores deslocados (shift) dentro de cada grupo\n            rate_j=pl.col(\"rate_k\").shift(1).over(\"group_by\"),\n            time_j=pl.col(\"time_k\").shift(1).over(\"group_by\"),\n        )\n        .with_columns(fwd=fwd_formula)\n        .with_columns(\n            # A matriz de c\u00e1lculo j\u00e1 foi tratada: ela est\u00e1 deduplicada,\n            # sem nulos e ordenada por group_by e du_k. Ent\u00e3o, basta\n            # ajustar a primeira taxa fwd de cada grupo para ser igual \u00e0 taxa spot!\n            fwd=pl.when(pl.col(\"du_k\") == pl.first(\"du_k\").over(\"group_by\"))\n            .then(pl.col(\"rate_k\"))\n            .otherwise(pl.col(\"fwd\"))\n        )\n    )\n    # 5. Reunir os resultados na ordem original\n    df_orig = df_orig.join(\n        df_fwd.drop(\"rate_k\"),  # rate_k j\u00e1 existe em df_orig\n        on=[\"du_k\", \"group_by\"],\n        how=\"left\",\n        maintain_order=\"left\",\n    )\n\n    # Retornar a s\u00e9rie de taxas a termo\n    return df_orig[\"fwd\"]\n</code></pre>"},{"location":"futures/","title":"Futures","text":""},{"location":"futures/#pyield.futures.futures","title":"<code>futures(date, contract_code)</code>","text":"<p>Fetches data for a specified futures contract based on type and reference date.</p> <p>Parameters:</p> Name Type Description Default <code>contract_code</code> <code>str</code> <p>The B3 futures contract code identifying the derivative. Supported contract codes are: - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3. - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3. - \"FRC\": Forward Rate Agreement (FRA). - \"FRO\": FRA DE CUPOM CAMBIAL EM OC1 - \"DAP\": DI x IPCA Spread Futures. - \"DOL\": U.S. Dollar Futures from B3. - \"WDO\": Mini U.S. Dollar Futures from B3. - \"IND\": Ibovespa Futures from B3. - \"WIN\": Mini Ibovespa Futures from B3.</p> required <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame containing the fetched data for the specified futures contract.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the futures contract code is not recognized or supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; futures(\"31-05-2024\", \"DI1\")\nshape: (40, 20)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 DI1M24       \u2506 2024-06-03     \u2506 1          \u2506 \u2026 \u2506 0.10404      \u2506 0.10404   \u2506 0.10399        \u2506 0.10399     \u2502\n\u2502 2024-05-31 \u2506 DI1N24       \u2506 2024-07-01     \u2506 21         \u2506 \u2026 \u2506 0.1039       \u2506 0.10386   \u2506 0.1039         \u2506 0.103896    \u2502\n\u2502 2024-05-31 \u2506 DI1Q24       \u2506 2024-08-01     \u2506 44         \u2506 \u2026 \u2506 0.10374      \u2506 0.10374   \u2506 0.1037         \u2506 0.103517    \u2502\n\u2502 2024-05-31 \u2506 DI1U24       \u2506 2024-09-02     \u2506 66         \u2506 \u2026 \u2506 0.10365      \u2506 0.10355   \u2506 0.1036         \u2506 0.1034      \u2502\n\u2502 2024-05-31 \u2506 DI1V24       \u2506 2024-10-01     \u2506 87         \u2506 \u2026 \u2506 0.1036       \u2506 0.10355   \u2506 0.1036         \u2506 0.1036      \u2502\n\u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-05-31 \u2506 DI1F35       \u2506 2035-01-02     \u2506 2654       \u2506 \u2026 \u2506 0.1193       \u2506 0.1192    \u2506 0.11907        \u2506 0.12179     \u2502\n\u2502 2024-05-31 \u2506 DI1F36       \u2506 2036-01-02     \u2506 2903       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11674     \u2502\n\u2502 2024-05-31 \u2506 DI1F37       \u2506 2037-01-02     \u2506 3156       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2502 2024-05-31 \u2506 DI1F38       \u2506 2038-01-04     \u2506 3405       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2502 2024-05-31 \u2506 DI1F39       \u2506 2039-01-03     \u2506 3656       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; futures(\"31-05-2024\", \"DAP\")\nshape: (22, 19)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 DAPM24       \u2506 2024-06-17     \u2506 11         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.0555         \u2506 0.0555      \u2502\n\u2502 2024-05-31 \u2506 DAPN24       \u2506 2024-07-15     \u2506 31         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07524        \u2506 0.086254    \u2502\n\u2502 2024-05-31 \u2506 DAPQ24       \u2506 2024-08-15     \u2506 54         \u2506 \u2026 \u2506 null         \u2506 0.0885    \u2506 0.0885         \u2506 0.106631    \u2502\n\u2502 2024-05-31 \u2506 DAPU24       \u2506 2024-09-16     \u2506 76         \u2506 \u2026 \u2506 null         \u2506 0.0865    \u2506 0.0855         \u2506 0.078171    \u2502\n\u2502 2024-05-31 \u2506 DAPV24       \u2506 2024-10-15     \u2506 97         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07932        \u2506 0.057247    \u2502\n\u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-05-31 \u2506 DAPQ40       \u2506 2040-08-15     \u2506 4064       \u2506 \u2026 \u2506 null         \u2506 0.0609    \u2506 0.06099        \u2506 0.060553    \u2502\n\u2502 2024-05-31 \u2506 DAPK45       \u2506 2045-05-15     \u2506 5251       \u2506 \u2026 \u2506 null         \u2506 0.0619    \u2506 0.0588         \u2506 0.051336    \u2502\n\u2502 2024-05-31 \u2506 DAPQ50       \u2506 2050-08-15     \u2506 6566       \u2506 \u2026 \u2506 null         \u2506 0.0605    \u2506 0.06086        \u2506 0.069126    \u2502\n\u2502 2024-05-31 \u2506 DAPK55       \u2506 2055-05-17     \u2506 7755       \u2506 \u2026 \u2506 null         \u2506 0.0646    \u2506 0.06022        \u2506 0.056693    \u2502\n\u2502 2024-05-31 \u2506 DAPQ60       \u2506 2060-08-16     \u2506 9072       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.05821        \u2506 0.046451    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/b3/futures/core.py</code> <pre><code>def futures(\n    date: DateLike,\n    contract_code: ContractOptions | str,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches data for a specified futures contract based on type and reference date.\n\n    Args:\n        contract_code (str): The B3 futures contract code identifying the derivative.\n            Supported contract codes are:\n            - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3.\n            - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3.\n            - \"FRC\": Forward Rate Agreement (FRA).\n            - \"FRO\": FRA DE CUPOM CAMBIAL EM OC1\n            - \"DAP\": DI x IPCA Spread Futures.\n            - \"DOL\": U.S. Dollar Futures from B3.\n            - \"WDO\": Mini U.S. Dollar Futures from B3.\n            - \"IND\": Ibovespa Futures from B3.\n            - \"WIN\": Mini Ibovespa Futures from B3.\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame containing the fetched data for the specified futures\n            contract.\n\n    Raises:\n        ValueError: If the futures contract code is not recognized or supported.\n\n    Examples:\n        &gt;&gt;&gt; futures(\"31-05-2024\", \"DI1\")\n        shape: (40, 20)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 DI1M24       \u2506 2024-06-03     \u2506 1          \u2506 \u2026 \u2506 0.10404      \u2506 0.10404   \u2506 0.10399        \u2506 0.10399     \u2502\n        \u2502 2024-05-31 \u2506 DI1N24       \u2506 2024-07-01     \u2506 21         \u2506 \u2026 \u2506 0.1039       \u2506 0.10386   \u2506 0.1039         \u2506 0.103896    \u2502\n        \u2502 2024-05-31 \u2506 DI1Q24       \u2506 2024-08-01     \u2506 44         \u2506 \u2026 \u2506 0.10374      \u2506 0.10374   \u2506 0.1037         \u2506 0.103517    \u2502\n        \u2502 2024-05-31 \u2506 DI1U24       \u2506 2024-09-02     \u2506 66         \u2506 \u2026 \u2506 0.10365      \u2506 0.10355   \u2506 0.1036         \u2506 0.1034      \u2502\n        \u2502 2024-05-31 \u2506 DI1V24       \u2506 2024-10-01     \u2506 87         \u2506 \u2026 \u2506 0.1036       \u2506 0.10355   \u2506 0.1036         \u2506 0.1036      \u2502\n        \u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-05-31 \u2506 DI1F35       \u2506 2035-01-02     \u2506 2654       \u2506 \u2026 \u2506 0.1193       \u2506 0.1192    \u2506 0.11907        \u2506 0.12179     \u2502\n        \u2502 2024-05-31 \u2506 DI1F36       \u2506 2036-01-02     \u2506 2903       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11674     \u2502\n        \u2502 2024-05-31 \u2506 DI1F37       \u2506 2037-01-02     \u2506 3156       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2502 2024-05-31 \u2506 DI1F38       \u2506 2038-01-04     \u2506 3405       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2502 2024-05-31 \u2506 DI1F39       \u2506 2039-01-03     \u2506 3656       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; futures(\"31-05-2024\", \"DAP\")\n        shape: (22, 19)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 DAPM24       \u2506 2024-06-17     \u2506 11         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.0555         \u2506 0.0555      \u2502\n        \u2502 2024-05-31 \u2506 DAPN24       \u2506 2024-07-15     \u2506 31         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07524        \u2506 0.086254    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ24       \u2506 2024-08-15     \u2506 54         \u2506 \u2026 \u2506 null         \u2506 0.0885    \u2506 0.0885         \u2506 0.106631    \u2502\n        \u2502 2024-05-31 \u2506 DAPU24       \u2506 2024-09-16     \u2506 76         \u2506 \u2026 \u2506 null         \u2506 0.0865    \u2506 0.0855         \u2506 0.078171    \u2502\n        \u2502 2024-05-31 \u2506 DAPV24       \u2506 2024-10-15     \u2506 97         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07932        \u2506 0.057247    \u2502\n        \u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-05-31 \u2506 DAPQ40       \u2506 2040-08-15     \u2506 4064       \u2506 \u2026 \u2506 null         \u2506 0.0609    \u2506 0.06099        \u2506 0.060553    \u2502\n        \u2502 2024-05-31 \u2506 DAPK45       \u2506 2045-05-15     \u2506 5251       \u2506 \u2026 \u2506 null         \u2506 0.0619    \u2506 0.0588         \u2506 0.051336    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ50       \u2506 2050-08-15     \u2506 6566       \u2506 \u2026 \u2506 null         \u2506 0.0605    \u2506 0.06086        \u2506 0.069126    \u2502\n        \u2502 2024-05-31 \u2506 DAPK55       \u2506 2055-05-17     \u2506 7755       \u2506 \u2026 \u2506 null         \u2506 0.0646    \u2506 0.06022        \u2506 0.056693    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ60       \u2506 2060-08-16     \u2506 9072       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.05821        \u2506 0.046451    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if has_nullable_args(date, contract_code):\n        return pl.DataFrame()\n    trade_date = cv.convert_dates(date)\n\n    # Valida\u00e7\u00e3o centralizada (evita chamadas desnecess\u00e1rias \u00e0s APIs B3)\n    if not is_trade_date_valid(trade_date):\n        logger.warning(f\"{trade_date} is not a valid date. Returning empty DataFrame.\")\n        return pl.DataFrame()\n\n    selected_contract = str(contract_code).upper()\n\n    if _is_intraday_date(trade_date):\n        # \u00c9 um dia de negocia\u00e7\u00e3o intraday\n        time = clock.now().time()\n        if time &lt; INTRADAY_START_TIME:  # Mercado n\u00e3o est\u00e1 aberto ainda\n            logger.warning(\"Market is not open yet. Returning an empty DataFrame. \")\n            return pl.DataFrame()\n\n        # Existe a chance de que os dados consolidados estejam dispon\u00edveis ap\u00f3s as 18h\n        if time &gt;= INTRADAY_END_TIME:\n            df_hist = fetch_historical_df(trade_date, selected_contract)\n            if not df_hist.is_empty():\n                logger.info(\"Consolidated data is already available and will be used.\")\n                return df_hist\n\n        # Mercado est\u00e1 aberto e n\u00e3o h\u00e1 dados consolidados dispon\u00edveis ainda\n        return fetch_intraday_df(selected_contract)\n\n    else:  # \u00c9 um dia hist\u00f3rico\n        return fetch_historical_df(trade_date, selected_contract)\n</code></pre>"},{"location":"interpolator/","title":"Interpolator","text":""},{"location":"interpolator/#pyield.interpolator.Interpolator","title":"<code>Interpolator(method, known_bdays, known_rates, extrapolate=False)</code>","text":"<p>Interpolator class for interest rate interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['flat_forward', 'linear']</code> <p>The interpolation method to use.</p> required <code>known_bdays</code> <code>ArrayLike</code> <p>The known business days sequence.</p> required <code>known_rates</code> <code>ArrayLike</code> <p>The known interest rates sequence.</p> required <code>extrapolate</code> <code>bool</code> <p>If True, extrapolates beyond known business days using the last available rate. Defaults to False, returning NaN for out-of-range values.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If known_bdays and known_rates do not have the same length.</p> <code>ValueError</code> <p>If the interpolation method is not recognized</p> Note <ul> <li>This class uses a 252 business days per year convention.</li> <li>Instances of this class are immutable. To modify the interpolation   settings, create a new instance.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import Interpolator\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n</code></pre> <p>Linear interpolation:</p> <pre><code>&gt;&gt;&gt; linear = Interpolator(\"linear\", known_bdays, known_rates)\n&gt;&gt;&gt; linear(45)\n0.0475\n</code></pre> <p>Flat forward interpolation:</p> <pre><code>&gt;&gt;&gt; fforward = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; fforward(45)\n0.04833068080970859\n</code></pre> <p>Array interpolation (polars shows 6 decimal places by default):</p> <pre><code>&gt;&gt;&gt; fforward([15, 45, 75, 100])\nshape: (4,)\nSeries: 'interpolated_rate' [f64]\n[\n    0.045\n    0.048331\n    0.052997\n    null\n]\n</code></pre> <pre><code>&gt;&gt;&gt; print(fforward(100))  # Extrapolation disabled by default\nnan\n</code></pre> <pre><code>&gt;&gt;&gt; print(fforward(-10))  # Invalid input returns NaN\nnan\n</code></pre> <p>If extrapolation is enabled, the last known rate is used:</p> <pre><code>&gt;&gt;&gt; fforward_extrap = Interpolator(\n...     \"flat_forward\", known_bdays, known_rates, extrapolate=True\n... )\n&gt;&gt;&gt; print(fforward_extrap(100))\n0.055\n</code></pre> Source code in <code>pyield/interpolator.py</code> <pre><code>def __init__(\n    self,\n    method: Literal[\"flat_forward\", \"linear\"],\n    known_bdays: ArrayLike,\n    known_rates: ArrayLike,\n    extrapolate: bool = False,\n):\n    df = (\n        pl.DataFrame({\"bday\": known_bdays, \"rate\": known_rates})\n        .with_columns(pl.col(\"bday\").cast(pl.Int64))\n        .with_columns(pl.col(\"rate\").cast(pl.Float64))\n        .drop_nulls()\n        .drop_nans()\n        .unique(subset=\"bday\", keep=\"last\")\n        .sort(\"bday\")\n    )\n    self._df = df\n    self._method = str(method)\n    self._known_bdays = tuple(df.get_column(\"bday\"))\n    self._known_rates = tuple(df.get_column(\"rate\"))\n    self._extrapolate = bool(extrapolate)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__call__","title":"<code>__call__(bday)</code>","text":"<p>Allows the instance to be called as a function to perform interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float | Series</code> <p>The interest rate interpolated by the specified method for the given number of business days. If the input is out of range and extrapolation is disabled, returns float(\"nan\").</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __call__(self, bday: int | ArrayLike) -&gt; float | pl.Series:\n    \"\"\"\n    Allows the instance to be called as a function to perform interpolation.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for\n            the given number of business days. If the input is out of range and\n            extrapolation is disabled, returns float(\"nan\").\n    \"\"\"\n    return self.interpolate(bday)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of known business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the number of known business days.\"\"\"\n    return len(self._df)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__repr__","title":"<code>__repr__()</code>","text":"<p>Textual representation, used in terminal or scripts.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Textual representation, used in terminal or scripts.\"\"\"\n    return repr(self._df)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.flat_forward","title":"<code>flat_forward(bday, k)</code>","text":"<p>Performs the interest rate interpolation using the flat forward method.</p> <p>This method calculates the interpolated interest rate for a given number of business days (<code>bday</code>) using the flat forward methodology, based on two known points: the current point (<code>k</code>) and the previous point (<code>j</code>).</p> <p>Assuming interest rates are in decimal form, the interpolated rate is calculated. Time is measured in years based on a 252-business-day year.</p> <p>The interpolated rate is given by the formula:</p> \\[ \\left(f_j*\\left(\\frac{f_k}{f_j}\\right)^{f_t}\\right)^{\\frac{1}{time}}-1 \\] <p>Where the factors used in the formula are defined as:</p> <ul> <li><code>f\u2c7c = (1 + rate\u2c7c)^time\u2c7c</code> is the compounding factor at point <code>j</code>.</li> <li><code>f\u2096 = (1 + rate\u2096)^time\u2096</code> is the compounding factor at point <code>k</code>.</li> <li><code>f\u209c = (time - time\u2c7c)/(time\u2096 - time\u2c7c)</code> is the time factor.</li> </ul> <p>And the variables are defined as:</p> <ul> <li><code>time = bday/252</code> is the time in years for the interpolated point. <code>bday</code> is  the number of business days for the interpolated point (input to this method).</li> <li><code>k</code> is the index of the current known point.</li> <li><code>time\u2096 = bday\u2096/252</code> is the time in years of point <code>k</code>.</li> <li><code>rate\u2096</code> is the interest rate (decimal) at point <code>k</code>.</li> <li><code>j</code> is the index of the previous known point (<code>k - 1</code>).</li> <li><code>time\u2c7c = bday\u2c7c/252</code> is the time in years of point <code>j</code>.</li> <li><code>rate\u2c7c</code> is the interest rate (decimal) at point <code>j</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of bus. days for which the rate is to be interpolated.</p> required <code>k</code> <code>int</code> <p>The index in the known_bdays and known_rates arrays such that      known_bdays[k-1] &lt; bday &lt; known_bdays[k]. This <code>k</code> corresponds      to the index of the next known point after <code>bday</code>.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interpolated interest rate in decimal form.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def flat_forward(self, bday: int, k: int) -&gt; float:\n    r\"\"\"\n    Performs the interest rate interpolation using the flat forward method.\n\n    This method calculates the interpolated interest rate for a given\n    number of business days (`bday`) using the flat forward methodology,\n    based on two known points: the current point (`k`) and the previous point (`j`).\n\n    Assuming interest rates are in decimal form, the interpolated rate\n    is calculated. Time is measured in years based on a 252-business-day year.\n\n    The interpolated rate is given by the formula:\n\n    $$\n    \\left(f_j*\\left(\\frac{f_k}{f_j}\\right)^{f_t}\\right)^{\\frac{1}{time}}-1\n    $$\n\n    Where the factors used in the formula are defined as:\n\n    * `f\u2c7c = (1 + rate\u2c7c)^time\u2c7c` is the compounding factor at point `j`.\n    * `f\u2096 = (1 + rate\u2096)^time\u2096` is the compounding factor at point `k`.\n    * `f\u209c = (time - time\u2c7c)/(time\u2096 - time\u2c7c)` is the time factor.\n\n    And the variables are defined as:\n\n    * `time = bday/252` is the time in years for the interpolated point. `bday` is\n     the number of business days for the interpolated point (input to this method).\n    * `k` is the index of the current known point.\n    * `time\u2096 = bday\u2096/252` is the time in years of point `k`.\n    * `rate\u2096` is the interest rate (decimal) at point `k`.\n    * `j` is the index of the previous known point (`k - 1`).\n    * `time\u2c7c = bday\u2c7c/252` is the time in years of point `j`.\n    * `rate\u2c7c` is the interest rate (decimal) at point `j`.\n\n    Args:\n        bday (int): Number of bus. days for which the rate is to be interpolated.\n        k (int): The index in the known_bdays and known_rates arrays such that\n                 known_bdays[k-1] &lt; bday &lt; known_bdays[k]. This `k` corresponds\n                 to the index of the next known point after `bday`.\n\n    Returns:\n        float: The interpolated interest rate in decimal form.\n    \"\"\"\n    rate_j = self._known_rates[k - 1]\n    time_j = self._known_bdays[k - 1] / 252\n    rate_k = self._known_rates[k]\n    time_k = self._known_bdays[k] / 252\n    time = bday / 252\n\n    # Perform flat forward interpolation\n    f_j = (1 + rate_j) ** time_j\n    f_k = (1 + rate_k) ** time_k\n    f_t = (time - time_j) / (time_k - time_j)\n    return (f_j * (f_k / f_j) ** f_t) ** (1 / time) - 1\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.interpolate","title":"<code>interpolate(bdays)</code>","text":"<p>Interpolates rates for given business day(s).</p> <p>Parameters:</p> Name Type Description Default <code>bdays</code> <code>int | ArrayLike</code> <p>int or ArrayLike - Business day(s) for interpolation</p> required <p>Returns:</p> Type Description <code>float | Series</code> <p>float or pl.Series - Interpolated rate(s)</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bdays: int | ArrayLike) -&gt; float | pl.Series:\n    \"\"\"\n    Interpolates rates for given business day(s).\n\n    Args:\n        bdays: int or ArrayLike - Business day(s) for interpolation\n\n    Returns:\n        float or pl.Series - Interpolated rate(s)\n    \"\"\"\n    if is_array_like(bdays):\n        s_bdays = pl.Series(name=\"interpolated_rate\", values=bdays, dtype=pl.Int64)\n        result = s_bdays.map_elements(\n            self._interpolated_rate, return_dtype=pl.Float64\n        )\n        return result.fill_nan(None)\n\n    # Aceita QUALQUER coisa que se comporte como inteiro (int, np.int64, etc)\n    # Mas REJEITA floats (30.5) e Strings\n    elif isinstance(bdays, numbers.Integral):\n        return self._interpolated_rate(int(bdays))\n\n    else:\n        raise TypeError(\"bdays must be an int or an array-like structure.\")\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.linear","title":"<code>linear(bday, k)</code>","text":"<p>Performs the interest rate interpolation using the linear method.</p> <p>The interpolated rate is given by the formula: y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)</p> <p>Where: - (x, y) is the point to be interpolated (bday, interpolated_rate). - (x1, y1) is the previous known point (bday_j, rate_j). - (x2, y2) is the next known point (bday_k, rate_k).</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of bus. days for which the rate is to be interpolated.</p> required <code>k</code> <code>int</code> <p>The index such that known_bdays[k-1] &lt; bday &lt; known_bdays[k].</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interpolated interest rate in decimal form.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def linear(self, bday: int, k: int) -&gt; float:\n    \"\"\"\n    Performs the interest rate interpolation using the linear method.\n\n    The interpolated rate is given by the formula:\n    y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)\n\n    Where:\n    - (x, y) is the point to be interpolated (bday, interpolated_rate).\n    - (x1, y1) is the previous known point (bday_j, rate_j).\n    - (x2, y2) is the next known point (bday_k, rate_k).\n\n    Args:\n        bday (int): Number of bus. days for which the rate is to be interpolated.\n        k (int): The index such that known_bdays[k-1] &lt; bday &lt; known_bdays[k].\n\n    Returns:\n        float: The interpolated interest rate in decimal form.\n    \"\"\"\n    # Get the bracketing points for interpolation\n    bday_j, rate_j = self._known_bdays[k - 1], self._known_rates[k - 1]\n    bday_k, rate_k = self._known_bdays[k], self._known_rates[k]\n\n    # Perform linear interpolation\n    return rate_j + (bday - bday_j) * (rate_k - rate_j) / (bday_k - bday_j)\n</code></pre>"},{"location":"ipca/","title":"IPCA","text":""},{"location":"ipca/#pyield.ipca.indexes","title":"<code>indexes(start, end)</code>","text":"<p>Retrieves the IPCA index values for a specified date range.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]</p> <p>Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>The start date of the date range</p> required <code>end</code> <code>DateLike</code> <p>The end date of the date range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Get the IPCA indexes for the first quarter of 2025\n&gt;&gt;&gt; ipca.indexes(start=\"01-01-2025\", end=\"01-03-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Period \u2506 Value   \u2502\n\u2502 ---    \u2506 ---     \u2502\n\u2502 i64    \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 202501 \u2506 7111.86 \u2502\n\u2502 202502 \u2506 7205.03 \u2502\n\u2502 202503 \u2506 7245.38 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def indexes(start: DateLike, end: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves the IPCA index values for a specified date range.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]\n\n    Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]\n\n    Args:\n        start (DateLike): The start date of the date range\n        end (DateLike): The end date of the date range\n\n    Returns:\n        pl.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Get the IPCA indexes for the first quarter of 2025\n        &gt;&gt;&gt; ipca.indexes(start=\"01-01-2025\", end=\"01-03-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Period \u2506 Value   \u2502\n        \u2502 ---    \u2506 ---     \u2502\n        \u2502 i64    \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 202501 \u2506 7111.86 \u2502\n        \u2502 202502 \u2506 7205.03 \u2502\n        \u2502 202503 \u2506 7245.38 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(start, end):\n        return pl.DataFrame()\n    start = convert_dates(start)\n    end = convert_dates(end)\n\n    start_date = start.strftime(\"%Y%m\")\n    end_date = end.strftime(\"%Y%m\")\n    api_url = f\"{IPCA_URL}{start_date}-{end_date}/variaveis/2266?localidades=N1[all]\"\n    data_dict = _fetch_api_data(api_url)\n\n    return _process_ipca_dataframe(data_dict)\n</code></pre>"},{"location":"ipca/#pyield.ipca.last_indexes","title":"<code>last_indexes(num_months=1)</code>","text":"<p>Retrieves the last IPCA index values for a specified number of months.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]</p> <p>Example: For the last 2 months, the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>Number of months to retrieve. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Get the last month's IPCA index\n&gt;&gt;&gt; df = ipca.last_indexes(1)\n&gt;&gt;&gt; # Get the last 3 months' IPCA indexes\n&gt;&gt;&gt; df = ipca.last_indexes(3)\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def last_indexes(num_months: int = 1) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves the last IPCA index values for a specified number of months.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]\n\n    Example: For the last 2 months, the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]\n\n    Args:\n        num_months (int, optional): Number of months to retrieve. Defaults to 1.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Get the last month's IPCA index\n        &gt;&gt;&gt; df = ipca.last_indexes(1)\n        &gt;&gt;&gt; # Get the last 3 months' IPCA indexes\n        &gt;&gt;&gt; df = ipca.last_indexes(3)\n    \"\"\"\n    num_months = abs(num_months)\n    if num_months == 0:\n        return pl.DataFrame()\n\n    api_url = f\"{IPCA_URL}-{num_months}/variaveis/2266?localidades=N1[all]\"\n    data_dict = _fetch_api_data(api_url)\n\n    return _process_ipca_dataframe(data_dict)\n</code></pre>"},{"location":"ipca/#pyield.ipca.last_rates","title":"<code>last_rates(num_months=1)</code>","text":"<p>Retrieves the last IPCA monthly rates for a specified number of months.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]</p> <p>Example: For the last 2 months, the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>Number of months to retrieve. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If num_months is 0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Get the last month's IPCA rate\n&gt;&gt;&gt; df = ipca.last_rates(1)\n&gt;&gt;&gt; # Get the last 3 months' IPCA rates\n&gt;&gt;&gt; df = ipca.last_rates(3)\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def last_rates(num_months: int = 1) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves the last IPCA monthly rates for a specified number of months.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]\n\n    Example: For the last 2 months, the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]\n\n    Args:\n        num_months (int, optional): Number of months to retrieve. Defaults to 1.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Raises:\n        ValueError: If num_months is 0\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Get the last month's IPCA rate\n        &gt;&gt;&gt; df = ipca.last_rates(1)\n        &gt;&gt;&gt; # Get the last 3 months' IPCA rates\n        &gt;&gt;&gt; df = ipca.last_rates(3)\n    \"\"\"\n    num_months = abs(num_months)\n    if num_months == 0:\n        raise ValueError(\"The number of months must be greater than 0.\")\n\n    api_url = f\"{IPCA_URL}-{num_months}/variaveis/63?localidades=N1[all]\"\n    data_dict = _fetch_api_data(api_url)\n\n    return _process_ipca_dataframe(data_dict, is_in_pct=True)\n</code></pre>"},{"location":"ipca/#pyield.ipca.projected_rate","title":"<code>projected_rate()</code>","text":"<p>Retrieves the current IPCA projection from the ANBIMA website.</p> <p>This function makes an HTTP request to the ANBIMA website and extracts the IPCA projection data directly from the raw HTML using regular expressions.</p> Process <ol> <li>Accesses the ANBIMA indicators webpage.</li> <li>Searches for the \"Last Update\" text pattern to parse the timestamp.</li> <li>Searches for the specific IPCA block containing the \"Proje\u00e7\u00e3o\" label.</li> <li>Extracts the reference period (e.g., \"jan/26\") and the value.</li> <li>Converts the percentage string to a decimal float.</li> </ol> <p>Returns:</p> Name Type Description <code>IndicatorProjection</code> <code>IndicatorProjection</code> <p>An object containing: - last_updated (dt.datetime): Date and time of the last data update. - reference_period (str): Reference period of the projection as a string in   \"MMM/YY\" brazilian format (e.g., \"set/25\"). - projected_value (float): Projected IPCA value as a decimal number.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there are connection issues with the ANBIMA site.</p> <code>ValueError</code> <p>If the expected data patterns are not found in the page text.</p> Example <p>from pyield import ipca</p> Notes <ul> <li>The function requires internet connection to access the ANBIMA website.</li> <li>The extraction relies on text patterns (Regex). Significant changes to the   HTML structure or label text by ANBIMA may affect the function.</li> </ul> Source code in <code>pyield/ipca/projected.py</code> <pre><code>def projected_rate() -&gt; IndicatorProjection:\n    \"\"\"\n    Retrieves the current IPCA projection from the ANBIMA website.\n\n    This function makes an HTTP request to the ANBIMA website and extracts the\n    IPCA projection data directly from the raw HTML using regular expressions.\n\n    Process:\n        1. Accesses the ANBIMA indicators webpage.\n        2. Searches for the \"Last Update\" text pattern to parse the timestamp.\n        3. Searches for the specific IPCA block containing the \"Proje\u00e7\u00e3o\" label.\n        4. Extracts the reference period (e.g., \"jan/26\") and the value.\n        5. Converts the percentage string to a decimal float.\n\n    Returns:\n        IndicatorProjection: An object containing:\n            - last_updated (dt.datetime): Date and time of the last data update.\n            - reference_period (str): Reference period of the projection as a string in\n              \"MMM/YY\" brazilian format (e.g., \"set/25\").\n            - projected_value (float): Projected IPCA value as a decimal number.\n\n    Raises:\n        ConnectionError: If there are connection issues with the ANBIMA site.\n        ValueError: If the expected data patterns are not found in the page text.\n\n    Example:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Retrieve the current IPCA projection from ANBIMA\n        &gt;&gt;&gt; ipca.projected_rate()\n        IndicatorProjection(last_updated=..., reference_period=..., projected_value=...)\n\n    Notes:\n        - The function requires internet connection to access the ANBIMA website.\n        - The extraction relies on text patterns (Regex). Significant changes to the\n          HTML structure or label text by ANBIMA may affect the function.\n    \"\"\"\n    # 1. Obt\u00e9m o texto j\u00e1 decodificado (str)\n    html_content = _get_page_text()\n\n    # 2. Extrair Data de Atualiza\u00e7\u00e3o\n    # Procura por: \"Data e Hora da \u00daltima Atualiza\u00e7\u00e3o: 23/01/2026 - 16:48 h\"\n    update_pattern = r\"Data e Hora da \u00daltima Atualiza\u00e7\u00e3o:\\s*([0-9]{2}/[0-9]{2}/[0-9]{4}\\s*-\\s*[0-9]{2}:[0-9]{2})\"  # noqa:E501\n\n    match_update = re.search(update_pattern, html_content)\n    if not match_update:\n        raise ValueError(\"N\u00e3o foi poss\u00edvel encontrar a data de atualiza\u00e7\u00e3o na p\u00e1gina.\")\n\n    last_update_str = match_update.group(1)\n    # Remove espa\u00e7os extras que possam existir na captura\n    last_update_str = last_update_str.replace(\" - \", \"-\").strip()\n\n    # Formato esperado: \"23/01/2026-16:48\"\n    try:\n        last_updated = dt.datetime.strptime(last_update_str, \"%d/%m/%Y-%H:%M\")\n    except ValueError:\n        # Fallback caso o espa\u00e7o seja mantido ou o formato varie levemente\n        last_updated = dt.datetime.strptime(match_update.group(1), \"%d/%m/%Y - %H:%M\")\n\n    # 3. Extrair Bloco do IPCA\n    # Regex explicado:\n    # IPCA.*?        -&gt; Encontra IPCA e avan\u00e7a (ignora o IPCA \u00edndice, busca o pr\u00f3ximo)\n    # Proje\u00e7\u00e3o\\s*\\(  -&gt; Encontra 'Proje\u00e7\u00e3o ('\n    # (.*?)          -&gt; GRUPO 1: Captura o per\u00edodo (ex: jan/26)\n    # \\)             -&gt; Fecha par\u00eanteses\n    # .*?&gt;           -&gt; Avan\u00e7a at\u00e9 fechar a pr\u00f3xima tag HTML (&lt;td&gt;)\n    # ([0-9]+,[0-9]+)-&gt; GRUPO 2: Captura o valor (ex: 0,36)\n    # &lt;              -&gt; Garante que o n\u00famero acabou\n\n    ipca_pattern = r\"IPCA.*?Proje\u00e7\u00e3o\\s*\\((.*?)\\).*?&gt;([0-9]+,[0-9]+)&lt;\"\n\n    # Passamos flags= explicitamente para satisfazer linters estritos\n    match_ipca = re.search(ipca_pattern, html_content, flags=re.DOTALL | re.IGNORECASE)\n\n    if not match_ipca:\n        raise ValueError(\"N\u00e3o foi poss\u00edvel encontrar os dados de proje\u00e7\u00e3o do IPCA.\")\n\n    period_str = match_ipca.group(1)  # Ex: jan/26\n    value_str = match_ipca.group(2)  # Ex: 0,36\n\n    # Convers\u00e3o de valores\n    projected_value = float(value_str.replace(\",\", \".\")) / 100\n    projected_value = round(projected_value, 4)\n\n    return IndicatorProjection(\n        last_updated=last_updated,\n        reference_period=period_str,\n        projected_value=projected_value,\n    )\n</code></pre>"},{"location":"ipca/#pyield.ipca.projected_rate--retrieve-the-current-ipca-projection-from-anbima","title":"Retrieve the current IPCA projection from ANBIMA","text":"<p>ipca.projected_rate() IndicatorProjection(last_updated=..., reference_period=..., projected_value=...)</p>"},{"location":"ipca/#pyield.ipca.rates","title":"<code>rates(start, end)</code>","text":"<p>Retrieves the IPCA monthly rates for a specified date range.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]</p> <p>Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>The start date of the date range</p> required <code>end</code> <code>DateLike</code> <p>The end date of the date range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns 'Period' and 'Rate'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Get the IPCA rates for the first quarter of 2025\n&gt;&gt;&gt; ipca.rates(\"01-01-2025\", \"01-03-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Period \u2506 Value  \u2502\n\u2502 ---    \u2506 ---    \u2502\n\u2502 i64    \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 202501 \u2506 0.0016 \u2502\n\u2502 202502 \u2506 0.0131 \u2502\n\u2502 202503 \u2506 0.0056 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def rates(start: DateLike, end: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves the IPCA monthly rates for a specified date range.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]\n\n    Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]\n\n    Args:\n        start (DateLike): The start date of the date range\n        end (DateLike): The end date of the date range\n\n    Returns:\n        pl.DataFrame: DataFrame with columns 'Period' and 'Rate'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Get the IPCA rates for the first quarter of 2025\n        &gt;&gt;&gt; ipca.rates(\"01-01-2025\", \"01-03-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Period \u2506 Value  \u2502\n        \u2502 ---    \u2506 ---    \u2502\n        \u2502 i64    \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 202501 \u2506 0.0016 \u2502\n        \u2502 202502 \u2506 0.0131 \u2502\n        \u2502 202503 \u2506 0.0056 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(start, end):\n        return pl.DataFrame()\n    start = convert_dates(start)\n    end = convert_dates(end)\n\n    start_date = start.strftime(\"%Y%m\")\n    end_date = end.strftime(\"%Y%m\")\n    api_url = f\"{IPCA_URL}{start_date}-{end_date}/variaveis/63?localidades=N1[all]\"\n    data_dict = _fetch_api_data(api_url)\n\n    return _process_ipca_dataframe(data_dict, is_in_pct=True)\n</code></pre>"},{"location":"lft/","title":"LFT","text":""},{"location":"lft/#pyield.tn.lft.data","title":"<code>data(date)</code>","text":"<p>Fetch the LFT indicative rates for the given reference date from ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame containing the following columns: - ReferenceDate: The reference date for the data. - BondType: The type of bond. - MaturityDate: The maturity date of the LFT bond. - IndicativeRate: The Anbima indicative rate for the LFT bond. - Price: The price of the LFT bond.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.data(\"23-08-2024\")\nshape: (14, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000306  \u2506 0.000226  \u2506 0.000272       \u2506 0.10408  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000397 \u2506 -0.000481 \u2506 -0.000418      \u2506 0.11082  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000205 \u2506 -0.000258 \u2506 -0.00023       \u2506 0.114315 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000085  \u2506 0.00006   \u2506 0.000075       \u2506 0.114982 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000124  \u2506 0.000097  \u2506 0.000114       \u2506 0.114955 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001501  \u2506 0.001476  \u2506 0.001491       \u2506 0.11564  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001597  \u2506 0.001571  \u2506 0.001587       \u2506 0.115773 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001601  \u2506 0.001574  \u2506 0.001591       \u2506 0.115904 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001649  \u2506 0.001627  \u2506 0.001641       \u2506 0.115854 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001696  \u2506 0.00168   \u2506 0.001687       \u2506 0.115806 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the LFT indicative rates for the given reference date from ANBIMA.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame containing the following columns:\n            - ReferenceDate: The reference date for the data.\n            - BondType: The type of bond.\n            - MaturityDate: The maturity date of the LFT bond.\n            - IndicativeRate: The Anbima indicative rate for the LFT bond.\n            - Price: The price of the LFT bond.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.data(\"23-08-2024\")\n        shape: (14, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000306  \u2506 0.000226  \u2506 0.000272       \u2506 0.10408  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000397 \u2506 -0.000481 \u2506 -0.000418      \u2506 0.11082  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000205 \u2506 -0.000258 \u2506 -0.00023       \u2506 0.114315 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000085  \u2506 0.00006   \u2506 0.000075       \u2506 0.114982 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000124  \u2506 0.000097  \u2506 0.000114       \u2506 0.114955 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001501  \u2506 0.001476  \u2506 0.001491       \u2506 0.11564  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001597  \u2506 0.001571  \u2506 0.001587       \u2506 0.115773 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001601  \u2506 0.001574  \u2506 0.001591       \u2506 0.115904 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001649  \u2506 0.001627  \u2506 0.001641       \u2506 0.115854 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001696  \u2506 0.00168   \u2506 0.001687       \u2506 0.115806 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"LFT\")\n</code></pre>"},{"location":"lft/#pyield.tn.lft.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series of bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.maturities(\"22-08-2024\")\nshape: (14,)\nSeries: 'MaturityDate' [date]\n[\n    2024-09-01\n    2025-03-01\n    2025-09-01\n    2026-03-01\n    2026-09-01\n    \u2026\n    2029-03-01\n    2029-09-01\n    2030-03-01\n    2030-06-01\n    2030-09-01\n]\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def maturities(date: DateLike) -&gt; pl.Series:\n    \"\"\"\n    Fetch the bond maturities available for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.Series: A Series of bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.maturities(\"22-08-2024\")\n        shape: (14,)\n        Series: 'MaturityDate' [date]\n        [\n            2024-09-01\n            2025-03-01\n            2025-09-01\n            2026-03-01\n            2026-09-01\n            \u2026\n            2029-03-01\n            2029-09-01\n            2030-03-01\n            2030-06-01\n            2030-09-01\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"lft/#pyield.tn.lft.premium","title":"<code>premium(lft_rate, di_rate)</code>","text":"<p>Calculate the premium of the LFT bond over the DI Futures rate.</p> <p>Parameters:</p> Name Type Description Default <code>lft_rate</code> <code>float</code> <p>The annualized trading rate over the selic rate for the bond.</p> required <code>di_rate</code> <code>float</code> <p>The DI Futures annualized yield rate (interpolated to the same maturity as the LFT).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LFT bond over the DI Futures rate.</p> <p>Examples:</p> <p>Calculate the premium of a LFT in 28/04/2025</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft_rate = 0.001124  # 0.1124%\n&gt;&gt;&gt; di_rate = 0.13967670224373396  # 13.967670224373396%\n&gt;&gt;&gt; lft.premium(lft_rate, di_rate)\n1.008594331960501\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def premium(lft_rate: float, di_rate: float) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LFT bond over the DI Futures rate.\n\n    Args:\n        lft_rate (float): The annualized trading rate over the selic rate for the bond.\n        di_rate (float): The DI Futures annualized yield rate (interpolated to the same\n            maturity as the LFT).\n\n    Returns:\n        float: The premium of the LFT bond over the DI Futures rate.\n\n    Examples:\n        Calculate the premium of a LFT in 28/04/2025\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft_rate = 0.001124  # 0.1124%\n        &gt;&gt;&gt; di_rate = 0.13967670224373396  # 13.967670224373396%\n        &gt;&gt;&gt; lft.premium(lft_rate, di_rate)\n        1.008594331960501\n    \"\"\"\n    if has_nullable_args(lft_rate, di_rate):\n        return float(\"nan\")\n    # daily rate\n    ltt_factor = (lft_rate + 1) ** (1 / 252)\n    di_factor = (di_rate + 1) ** (1 / 252)\n    return (ltt_factor * di_factor - 1) / (di_factor - 1)\n</code></pre>"},{"location":"lft/#pyield.tn.lft.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the LFT price using Brazilian Treasury rules.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the LFT bond.</p> required <code>quotation</code> <code>float</code> <p>The LFT quotation in base 100.</p> required <p>Returns:     float: The LFT price truncated to 6 decimal places.</p> References <ul> <li>SEI Proccess 17944.005214/2024-09</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.price(15785.324502, 99.9291)\n15774.132706\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the LFT price using Brazilian Treasury rules.\n\n    Args:\n        vna (float): The nominal value of the LFT bond.\n        quotation (float): The LFT quotation in base 100.\n    Returns:\n        float: The LFT price truncated to 6 decimal places.\n\n    References:\n         - SEI Proccess 17944.005214/2024-09\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.price(15785.324502, 99.9291)\n        15774.132706\n    \"\"\"\n    if has_nullable_args(vna, quotation):\n        return float(\"nan\")\n    return tools.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"lft/#pyield.tn.lft.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the quotation of a LFT bond using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date of the bond.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The annualized yield rate of the bond</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The quotation of the bond.</p> <p>Examples:</p> <p>Calculate the quotation of a LFT bond with a 0.02 yield rate:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.quotation(\n...     settlement=\"24-07-2024\",\n...     maturity=\"01-09-2030\",\n...     rate=0.001717,  # 0.1717%\n... )\n98.9645\n</code></pre> <p>Nullable inputs return float('nan'):</p> <pre><code>&gt;&gt;&gt; lft.quotation(settlement=None, maturity=\"01-09-2030\", rate=0.001717)\nnan\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def quotation(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the quotation of a LFT bond using Anbima rules.\n\n    Args:\n        settlement (DateLike): The settlement date of the bond.\n        maturity (DateLike): The maturity date of the bond.\n        rate (float): The annualized yield rate of the bond\n\n    Returns:\n        float: The quotation of the bond.\n\n    Examples:\n        Calculate the quotation of a LFT bond with a 0.02 yield rate:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.quotation(\n        ...     settlement=\"24-07-2024\",\n        ...     maturity=\"01-09-2030\",\n        ...     rate=0.001717,  # 0.1717%\n        ... )\n        98.9645\n\n        Nullable inputs return float('nan'):\n        &gt;&gt;&gt; lft.quotation(settlement=None, maturity=\"01-09-2030\", rate=0.001717)\n        nan\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n    # The number of bdays between settlement (inclusive) and the maturity (exclusive)\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = tools.truncate(bdays / 252, 14)\n\n    discount_factor = 1 / (1 + rate) ** num_of_years\n\n    return tools.truncate(100 * discount_factor, 4)\n</code></pre>"},{"location":"ltn/","title":"LTN","text":""},{"location":"ltn/#pyield.tn.ltn.data","title":"<code>data(date)</code>","text":"<p>Fetch the LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.data(\"23-08-2024\")\nshape: (13, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-07-08    \u2506 \u2026 \u2506 0.10459  \u2506 0.104252 \u2506 0.104416       \u2506 0.10472 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2018-02-01    \u2506 \u2026 \u2506 0.107366 \u2506 0.107016 \u2506 0.107171       \u2506 0.10823 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-01-06    \u2506 \u2026 \u2506 0.110992 \u2506 0.110746 \u2506 0.110866       \u2506 0.11179 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.11315  \u2506 0.112947 \u2506 0.113032       \u2506 0.11365 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.114494 \u2506 0.114277 \u2506 0.114374       \u2506 0.11463 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026       \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.115424 \u2506 0.115283 \u2506 0.115357       \u2506 0.11494 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.115452 \u2506 0.115247 \u2506 0.115335       \u2506 0.11498 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.115758 \u2506 0.115633 \u2506 0.115694       \u2506 0.11508 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.11647  \u2506 0.116341 \u2506 0.116417       \u2506 0.11554 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.117504 \u2506 0.11737  \u2506 0.117436       \u2506 0.11594 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.data(\"23-08-2024\")\n        shape: (13, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-07-08    \u2506 \u2026 \u2506 0.10459  \u2506 0.104252 \u2506 0.104416       \u2506 0.10472 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2018-02-01    \u2506 \u2026 \u2506 0.107366 \u2506 0.107016 \u2506 0.107171       \u2506 0.10823 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-01-06    \u2506 \u2026 \u2506 0.110992 \u2506 0.110746 \u2506 0.110866       \u2506 0.11179 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.11315  \u2506 0.112947 \u2506 0.113032       \u2506 0.11365 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.114494 \u2506 0.114277 \u2506 0.114374       \u2506 0.11463 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026       \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.115424 \u2506 0.115283 \u2506 0.115357       \u2506 0.11494 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.115452 \u2506 0.115247 \u2506 0.115335       \u2506 0.11498 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.115758 \u2506 0.115633 \u2506 0.115694       \u2506 0.11508 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.11647  \u2506 0.116341 \u2506 0.116417       \u2506 0.11554 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.117504 \u2506 0.11737  \u2506 0.117436       \u2506 0.11594 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>Defini\u00e7\u00e3o do spread (forma bruta):     DISpread_raw = IndicativeRate - SettlementRate</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - BondType - MaturityDate - DISpread (decimal ou bps conforme par\u00e2metro)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.di_spreads(\"30-05-2025\", bps=True)\nshape: (13, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 LTN      \u2506 2028-01-01   \u2506 0.55     \u2502\n\u2502 LTN      \u2506 2028-07-01   \u2506 1.5      \u2502\n\u2502 LTN      \u2506 2029-01-01   \u2506 10.77    \u2502\n\u2502 LTN      \u2506 2030-01-01   \u2506 11.0     \u2502\n\u2502 LTN      \u2506 2032-01-01   \u2506 11.24    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def di_spreads(date: DateLike, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    Defini\u00e7\u00e3o do spread (forma bruta):\n        DISpread_raw = IndicativeRate - SettlementRate\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Default False.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - BondType\n            - MaturityDate\n            - DISpread (decimal ou bps conforme par\u00e2metro)\n\n    Raises:\n        ValueError: Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.di_spreads(\"30-05-2025\", bps=True)\n        shape: (13, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 LTN      \u2506 2028-01-01   \u2506 0.55     \u2502\n        \u2502 LTN      \u2506 2028-07-01   \u2506 1.5      \u2502\n        \u2502 LTN      \u2506 2029-01-01   \u2506 10.77    \u2502\n        \u2502 LTN      \u2506 2030-01-01   \u2506 11.0     \u2502\n        \u2502 LTN      \u2506 2032-01-01   \u2506 11.24    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return pre_di_spreads(date, bps=bps).filter(pl.col(\"BondType\") == \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.dv01","title":"<code>dv01(settlement, maturity, rate)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an LTN in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) of the bond.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.dv01(\"26-03-2025\", \"01-01-2032\", 0.150970)\n0.2269059999999854\n</code></pre> <p>Nullable inputs return float('nan')</p> <pre><code>&gt;&gt;&gt; ltn.dv01(None, \"01-01-2032\", 0.150970)\nnan\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an LTN in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateLike): The settlement date.\n        maturity (DateLike): The maturity date.\n        rate (float): The discount rate (yield to maturity) of the bond.\n\n    Returns:\n        float: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.dv01(\"26-03-2025\", \"01-01-2032\", 0.150970)\n        0.2269059999999854\n\n        Nullable inputs return float('nan')\n        &gt;&gt;&gt; ltn.dv01(None, \"01-01-2032\", 0.150970)\n        nan\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n\n    price1 = price(settlement, maturity, rate)\n    price2 = price(settlement, maturity, rate + 0.0001)\n    return price1 - price2\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.forwards","title":"<code>forwards(date)</code>","text":"<p>Calcula as taxas forward da LTN para uma data de refer\u00eancia.</p> <p>As taxas indicativas da LTN j\u00e1 s\u00e3o spot (zero-coupon) por constru\u00e7\u00e3o, pois o t\u00edtulo n\u00e3o paga cupons. Portanto o c\u00e1lculo de forward \u00e9 direto usando a estrutura de vencimentos e suas taxas.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia das taxas indicativas.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - MaturityDate - BDToMat - IndicativeRate (spot) - ForwardRate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.forwards(\"17-10-2025\")\nshape: (13, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n\u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2026-01-01   \u2506 52      \u2506 0.148307       \u2506 0.148307    \u2502\n\u2502 2026-04-01   \u2506 113     \u2506 0.147173       \u2506 0.146207    \u2502\n\u2502 2026-07-01   \u2506 174     \u2506 0.145206       \u2506 0.141571    \u2502\n\u2502 2026-10-01   \u2506 239     \u2506 0.142424       \u2506 0.13501     \u2502\n\u2502 2027-04-01   \u2506 361     \u2506 0.138155       \u2506 0.129838    \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2028-07-01   \u2506 676     \u2506 0.133411       \u2506 0.131654    \u2502\n\u2502 2029-01-01   \u2506 800     \u2506 0.134254       \u2506 0.138861    \u2502\n\u2502 2029-07-01   \u2506 924     \u2506 0.135264       \u2506 0.141802    \u2502\n\u2502 2030-01-01   \u2506 1049    \u2506 0.135967       \u2506 0.141177    \u2502\n\u2502 2032-01-01   \u2506 1553    \u2506 0.13883        \u2506 0.144812    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def forwards(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"Calcula as taxas forward da LTN para uma data de refer\u00eancia.\n\n    As taxas indicativas da LTN j\u00e1 s\u00e3o spot (zero-coupon) por constru\u00e7\u00e3o, pois o\n    t\u00edtulo n\u00e3o paga cupons. Portanto o c\u00e1lculo de forward \u00e9 direto usando a\n    estrutura de vencimentos e suas taxas.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia das taxas indicativas.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - MaturityDate\n            - BDToMat\n            - IndicativeRate (spot)\n            - ForwardRate\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.forwards(\"17-10-2025\")\n        shape: (13, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n        \u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2026-01-01   \u2506 52      \u2506 0.148307       \u2506 0.148307    \u2502\n        \u2502 2026-04-01   \u2506 113     \u2506 0.147173       \u2506 0.146207    \u2502\n        \u2502 2026-07-01   \u2506 174     \u2506 0.145206       \u2506 0.141571    \u2502\n        \u2502 2026-10-01   \u2506 239     \u2506 0.142424       \u2506 0.13501     \u2502\n        \u2502 2027-04-01   \u2506 361     \u2506 0.138155       \u2506 0.129838    \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2028-07-01   \u2506 676     \u2506 0.133411       \u2506 0.131654    \u2502\n        \u2502 2029-01-01   \u2506 800     \u2506 0.134254       \u2506 0.138861    \u2502\n        \u2502 2029-07-01   \u2506 924     \u2506 0.135264       \u2506 0.141802    \u2502\n        \u2502 2030-01-01   \u2506 1049    \u2506 0.135967       \u2506 0.141177    \u2502\n        \u2502 2032-01-01   \u2506 1553    \u2506 0.13883        \u2506 0.144812    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(date):\n        return pl.DataFrame()\n    df = data(date).select(\"MaturityDate\", \"BDToMat\", \"IndicativeRate\")\n    fwd_rates = fwd.forwards(bdays=df[\"BDToMat\"], rates=df[\"IndicativeRate\"])\n    return df.with_columns(ForwardRate=fwd_rates).sort(\"MaturityDate\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series of bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.maturities(\"22-08-2024\")\nshape: (13,)\nSeries: 'MaturityDate' [date]\n[\n    2024-10-01\n    2025-01-01\n    2025-04-01\n    2025-07-01\n    2025-10-01\n    \u2026\n    2026-10-01\n    2027-07-01\n    2028-01-01\n    2028-07-01\n    2030-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def maturities(date: DateLike) -&gt; pl.Series:\n    \"\"\"\n    Fetch the bond maturities available for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.Series: A Series of bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.maturities(\"22-08-2024\")\n        shape: (13,)\n        Series: 'MaturityDate' [date]\n        [\n            2024-10-01\n            2025-01-01\n            2025-04-01\n            2025-07-01\n            2025-10-01\n            \u2026\n            2026-10-01\n            2027-07-01\n            2028-01-01\n            2028-07-01\n            2030-01-01\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.premium","title":"<code>premium(ltn_rate, di_rate)</code>","text":"<p>Calculate the premium of the LTN bond over the DI Future rate using provided rates.</p> <p>Parameters:</p> Name Type Description Default <code>ltn_rate</code> <code>float</code> <p>The annualized LTN rate.</p> required <code>di_rate</code> <code>float</code> <p>The annualized DI Future rate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LTN bond over the DI Future rate.</p> <p>Examples:</p> <p>Reference date: 22-08-2024 LTN rate for 01-01-2030: 0.118746 DI (JAN30) Settlement rate: 0.11725</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.premium(0.118746, 0.11725)\n1.0120718007994287\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def premium(ltn_rate: float, di_rate: float) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LTN bond over the DI Future rate using provided rates.\n\n    Args:\n        ltn_rate (float): The annualized LTN rate.\n        di_rate (float): The annualized DI Future rate.\n\n    Returns:\n        float: The premium of the LTN bond over the DI Future rate.\n\n    Examples:\n        Reference date: 22-08-2024\n        LTN rate for 01-01-2030: 0.118746\n        DI (JAN30) Settlement rate: 0.11725\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.premium(0.118746, 0.11725)\n        1.0120718007994287\n    \"\"\"\n    if has_nullable_args(ltn_rate, di_rate):\n        return float(\"nan\")\n    # C\u00e1lculo das taxas di\u00e1rias\n    ltn_daily_rate = (1 + ltn_rate) ** (1 / 252) - 1\n    di_daily_rate = (1 + di_rate) ** (1 / 252) - 1\n\n    # Retorno do c\u00e1lculo do pr\u00eamio\n    return ltn_daily_rate / di_daily_rate\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the LTN price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) of the bond.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The LTN price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n535.279902\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def price(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the LTN price using Anbima rules.\n\n    Args:\n        settlement (DateLike): The settlement date.\n        maturity (DateLike): The maturity date.\n        rate (float): The discount rate (yield to maturity) of the bond.\n\n    Returns:\n        float: The LTN price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n        535.279902\n    \"\"\"\n    # Validate and normalize inputs\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rule\n    num_of_years = tools.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Truncate the price to 6 decimal places as per Anbima rules\n    return tools.truncate(FACE_VALUE / discount_factor, 6)\n</code></pre>"},{"location":"ntnb/","title":"NTN-B","text":""},{"location":"ntnb/#pyield.tn.ntnb.bei_rates","title":"<code>bei_rates(settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates)</code>","text":"<p>Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real interest rates. The BEI represents the inflation rate that equalizes the real and nominal yields. The calculation is based on the spot rates for NTN-B bonds.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date of the operation.</p> required <code>ntnb_maturities</code> <code>ArrayLike</code> <p>The maturity dates for the NTN-B bonds.</p> required <code>ntnb_rates</code> <code>ArrayLike</code> <p>The real interest rates (Yield to Maturity - YTM) corresponding to the given NTN-B maturities.</p> required <code>nominal_maturities</code> <code>ArrayLike</code> <p>The maturity dates to be used as reference for nominal rates.</p> required <code>nominal_rates</code> <code>ArrayLike</code> <p>The nominal interest rates (e.g. DI Futures or  zero prefixed bonds rates) used as reference for the calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame containing the calculated breakeven inflation rates.</p> Returned columns <ul> <li>MaturityDate: The maturity date of the bonds.</li> <li>BDToMat: The number of business days from the settlement to the maturity.</li> <li>RIR: The calculated Real Interest Rates based on the spot rates.</li> <li>NIR: The Nominal Interest Rates interpolated for the maturity date.</li> <li>BEI: The calculated Breakeven Inflation Rates.</li> </ul> Notes <p>The BEI is calculated by comparing the nominal and real interest rates, indicating the market's inflation expectations over the period from the settlement date to the bond's maturity.</p> <p>Examples:</p> <p>Get the NTN-B rates for a specific reference date. These are YTM rates and the spot rates are calculated based on them</p> <pre><code>&gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n</code></pre> <p>Get the DI Futures settlement rates for the same reference date to be used as reference for the nominal rates:</p> <pre><code>&gt;&gt;&gt; df_di = yd.di1.data(\"05-09-2024\")\n</code></pre> <p>Calculate the BEI rates considering the settlement at the reference date:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.bei_rates(\n...     settlement=\"05-09-2024\",\n...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n...     nominal_maturities=df_di[\"ExpirationDate\"],\n...     nominal_rates=df_di[\"SettlementRate\"],\n... )\nshape: (14, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 RIR      \u2506 NIR      \u2506 BEI      \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2506 ---      \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-05-15   \u2506 171     \u2506 0.061748 \u2506 0.113836 \u2506 0.049059 \u2502\n\u2502 2026-08-15   \u2506 488     \u2506 0.066133 \u2506 0.117126 \u2506 0.04783  \u2502\n\u2502 2027-05-15   \u2506 673     \u2506 0.063816 \u2506 0.117169 \u2506 0.050152 \u2502\n\u2502 2028-08-15   \u2506 988     \u2506 0.063635 \u2506 0.11828  \u2506 0.051376 \u2502\n\u2502 2029-05-15   \u2506 1172    \u2506 0.062532 \u2506 0.11838  \u2506 0.052561 \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2506 \u2026        \u2506 \u2026        \u2502\n\u2502 2040-08-15   \u2506 3995    \u2506 0.060468 \u2506 0.11759  \u2506 0.053865 \u2502\n\u2502 2045-05-15   \u2506 5182    \u2506 0.0625   \u2506 0.11759  \u2506 0.05185  \u2502\n\u2502 2050-08-15   \u2506 6497    \u2506 0.063016 \u2506 0.11759  \u2506 0.051339 \u2502\n\u2502 2055-05-15   \u2506 7686    \u2506 0.062252 \u2506 0.11759  \u2506 0.052095 \u2502\n\u2502 2060-08-15   \u2506 9003    \u2506 0.063001 \u2506 0.11759  \u2506 0.051354 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def bei_rates(\n    settlement: DateLike,\n    ntnb_maturities: ArrayLike,\n    ntnb_rates: ArrayLike,\n    nominal_maturities: ArrayLike,\n    nominal_rates: ArrayLike,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real\n    interest rates. The BEI represents the inflation rate that equalizes the real and\n    nominal yields. The calculation is based on the spot rates for NTN-B bonds.\n\n    Args:\n        settlement (DateLike): The settlement date of the operation.\n        ntnb_maturities (ArrayLike): The maturity dates for the NTN-B bonds.\n        ntnb_rates (ArrayLike): The real interest rates (Yield to Maturity - YTM)\n            corresponding to the given NTN-B maturities.\n        nominal_maturities (ArrayLike): The maturity dates to be used as reference for\n            nominal rates.\n        nominal_rates (ArrayLike): The nominal interest rates (e.g. DI Futures or\n             zero prefixed bonds rates) used as reference for the calculation.\n\n    Returns:\n        pl.DataFrame: DataFrame containing the calculated breakeven inflation rates.\n\n    Returned columns:\n        - MaturityDate: The maturity date of the bonds.\n        - BDToMat: The number of business days from the settlement to the maturity.\n        - RIR: The calculated Real Interest Rates based on the spot rates.\n        - NIR: The Nominal Interest Rates interpolated for the maturity date.\n        - BEI: The calculated Breakeven Inflation Rates.\n\n    Notes:\n        The BEI is calculated by comparing the nominal and real interest rates,\n        indicating the market's inflation expectations over the period from the\n        settlement date to the bond's maturity.\n\n    Examples:\n        Get the NTN-B rates for a specific reference date.\n        These are YTM rates and the spot rates are calculated based on them\n        &gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n\n        Get the DI Futures settlement rates for the same reference date to be used as\n        reference for the nominal rates:\n        &gt;&gt;&gt; df_di = yd.di1.data(\"05-09-2024\")\n\n        Calculate the BEI rates considering the settlement at the reference date:\n        &gt;&gt;&gt; yd.ntnb.bei_rates(\n        ...     settlement=\"05-09-2024\",\n        ...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n        ...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n        ...     nominal_maturities=df_di[\"ExpirationDate\"],\n        ...     nominal_rates=df_di[\"SettlementRate\"],\n        ... )\n        shape: (14, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 RIR      \u2506 NIR      \u2506 BEI      \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2506 ---      \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2506 f64      \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-05-15   \u2506 171     \u2506 0.061748 \u2506 0.113836 \u2506 0.049059 \u2502\n        \u2502 2026-08-15   \u2506 488     \u2506 0.066133 \u2506 0.117126 \u2506 0.04783  \u2502\n        \u2502 2027-05-15   \u2506 673     \u2506 0.063816 \u2506 0.117169 \u2506 0.050152 \u2502\n        \u2502 2028-08-15   \u2506 988     \u2506 0.063635 \u2506 0.11828  \u2506 0.051376 \u2502\n        \u2502 2029-05-15   \u2506 1172    \u2506 0.062532 \u2506 0.11838  \u2506 0.052561 \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2506 \u2026        \u2506 \u2026        \u2502\n        \u2502 2040-08-15   \u2506 3995    \u2506 0.060468 \u2506 0.11759  \u2506 0.053865 \u2502\n        \u2502 2045-05-15   \u2506 5182    \u2506 0.0625   \u2506 0.11759  \u2506 0.05185  \u2502\n        \u2502 2050-08-15   \u2506 6497    \u2506 0.063016 \u2506 0.11759  \u2506 0.051339 \u2502\n        \u2502 2055-05-15   \u2506 7686    \u2506 0.062252 \u2506 0.11759  \u2506 0.052095 \u2502\n        \u2502 2060-08-15   \u2506 9003    \u2506 0.063001 \u2506 0.11759  \u2506 0.051354 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(\n        settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates\n    ):\n        return pl.DataFrame()\n    # Normalize input dates\n    settlement = cv.convert_dates(settlement)\n    ntnb_maturities = cv.convert_dates(ntnb_maturities)\n\n    ff_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, nominal_maturities),\n        known_rates=nominal_rates,\n        extrapolate=True,\n    )\n    df_spot = spot_rates(settlement, ntnb_maturities, ntnb_rates)\n    df = (\n        df_spot.rename({\"SpotRate\": \"RIR\"})\n        .with_columns(\n            NIR=ff_interpolator(df_spot[\"BDToMat\"]),\n        )\n        .with_columns(\n            BEI=((pl.col(\"NIR\") + 1) / (pl.col(\"RIR\") + 1)) - 1,\n        )\n        .select(\"MaturityDate\", \"BDToMat\", \"RIR\", \"NIR\", \"BEI\")\n    )\n\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Generate the cash flows for NTN-B bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date (exclusive) to start generating the cash flows.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\". Returns empty DataFrame if settlement &gt;= maturity.</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-15  \u2506 2.956301   \u2502\n\u2502 2024-11-15  \u2506 2.956301   \u2502\n\u2502 2025-05-15  \u2506 102.956301 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def cash_flows(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-B bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (DateLike): The settlement date (exclusive) to start generating\n            the cash flows.\n        maturity (DateLike): The maturity date of the bond.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n            Returns empty DataFrame if settlement &gt;= maturity.\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-15  \u2506 2.956301   \u2502\n        \u2502 2024-11-15  \u2506 2.956301   \u2502\n        \u2502 2025-05-15  \u2506 102.956301 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(settlement, maturity):\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    # Get the coupon dates between the settlement and maturity dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n    p_dates = payment_dates(settlement, maturity)\n\n    # Return empty DataFrame if no payment dates (settlement &gt;= maturity)\n    if p_dates.is_empty():\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    df = pl.DataFrame(\n        {\"PaymentDate\": p_dates},\n    ).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == maturity)\n        .then(FINAL_PMT)\n        .otherwise(COUPON_PMT)\n        .alias(\"CashFlow\")\n    )\n\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.data","title":"<code>data(date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> Returned columns <ul> <li>ReferenceDate: The reference date of the data.</li> <li>BondType: The type of the bond (NTN-B).</li> <li>SelicCode: The SELIC code of the bond.</li> <li>IssueBaseDate: The issue base date of the bond.</li> <li>MaturityDate: The maturity date of the bond.</li> <li>BDToMat: The number of business days to maturity.</li> <li>Duration: The duration of the bond.</li> <li>DV01: The DV01 of the bond.</li> <li>DV01USD: The DV01 in USD of the bond.</li> <li>Price: The price of the bond.</li> <li>BidRate: The bid rate of the bond.</li> <li>AskRate: The ask rate of the bond.</li> <li>IndicativeRate: The indicative rate for the bond.</li> <li>DIRate: The interpolated DI rate for the bond.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.data(\"23-08-2024\")\nshape: (14, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063961 \u2506 0.063667 \u2506 0.063804       \u2506 0.112749 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.06594  \u2506 0.065635 \u2506 0.065795       \u2506 0.114963 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063925 \u2506 0.063601 \u2506 0.063794       \u2506 0.114888 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063217 \u2506 0.062905 \u2506 0.063094       \u2506 0.115595 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.062245 \u2506 0.061954 \u2506 0.0621         \u2506 0.115665 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.060005 \u2506 0.059574 \u2506 0.059797       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061107 \u2506 0.060733 \u2506 0.060923       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061304 \u2506 0.060931 \u2506 0.06114        \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061053 \u2506 0.06074  \u2506 0.060892       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061211 \u2506 0.0608   \u2506 0.061005       \u2506 0.11511  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Returned columns:\n        - ReferenceDate: The reference date of the data.\n        - BondType: The type of the bond (NTN-B).\n        - SelicCode: The SELIC code of the bond.\n        - IssueBaseDate: The issue base date of the bond.\n        - MaturityDate: The maturity date of the bond.\n        - BDToMat: The number of business days to maturity.\n        - Duration: The duration of the bond.\n        - DV01: The DV01 of the bond.\n        - DV01USD: The DV01 in USD of the bond.\n        - Price: The price of the bond.\n        - BidRate: The bid rate of the bond.\n        - AskRate: The ask rate of the bond.\n        - IndicativeRate: The indicative rate for the bond.\n        - DIRate: The interpolated DI rate for the bond.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.data(\"23-08-2024\")\n        shape: (14, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063961 \u2506 0.063667 \u2506 0.063804       \u2506 0.112749 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.06594  \u2506 0.065635 \u2506 0.065795       \u2506 0.114963 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063925 \u2506 0.063601 \u2506 0.063794       \u2506 0.114888 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063217 \u2506 0.062905 \u2506 0.063094       \u2506 0.115595 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.062245 \u2506 0.061954 \u2506 0.0621         \u2506 0.115665 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.060005 \u2506 0.059574 \u2506 0.059797       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061107 \u2506 0.060733 \u2506 0.060923       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061304 \u2506 0.060931 \u2506 0.06114        \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061053 \u2506 0.06074  \u2506 0.060892       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061211 \u2506 0.0608   \u2506 0.061005       \u2506 0.11511  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"NTN-B\")\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration of the NTN-B bond in business years.</p> Formula <p>Sum( t * CF\u209c / (1 + y)\u1d57 )</p> <pre><code> MacD = ---------------------------------\n                 Current Bond Price\n</code></pre> <p>Where:      t    = time in years until payment      CF\u209c = cash flow at time t      y    = yield to maturity (periodic)      Price = Sum( CF\u209c / (1 + y)\u1d57 )</p> <p>Args:      settlement (DateLike): The settlement date of the operation.      maturity (DateLike): The maturity date of the NTN-B bond.      rate (float): The discount rate used to calculate the duration.</p> <p>Returns:      float: The Macaulay duration of the NTN-B bond in business years.</p> <p>Examples:      &gt;&gt;&gt; from pyield import ntnb      &gt;&gt;&gt; ntnb.duration(\"23-08-2024\", \"15-08-2060\", 0.061005)      15.08305431313046</p> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def duration(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n     Calculate the Macaulay duration of the NTN-B bond in business years.\n\n    Formula:\n                   Sum( t * CF\u209c / (1 + y)\u1d57 )\n         MacD = ---------------------------------\n                         Current Bond Price\n\n     Where:\n         t    = time in years until payment\n         CF\u209c = cash flow at time t\n         y    = yield to maturity (periodic)\n         Price = Sum( CF\u209c / (1 + y)\u1d57 )\n\n     Args:\n         settlement (DateLike): The settlement date of the operation.\n         maturity (DateLike): The maturity date of the NTN-B bond.\n         rate (float): The discount rate used to calculate the duration.\n\n     Returns:\n         float: The Macaulay duration of the NTN-B bond in business years.\n\n     Examples:\n         &gt;&gt;&gt; from pyield import ntnb\n         &gt;&gt;&gt; ntnb.duration(\"23-08-2024\", \"15-08-2060\", 0.061005)\n         15.08305431313046\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    byears = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** byears\n    duration = (dcf * byears).sum() / dcf.sum()\n    # Truncar para 14 casas decimais para repetibilidade dos resultados\n    return tl.truncate(duration, 14)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.dv01","title":"<code>dv01(settlement, maturity, rate, vna)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an NTN-B in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) of the NTN-B bond.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.dv01(\"26-03-2025\", \"15-08-2060\", 0.074358, 4470.979474)\n4.640875999999935\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    vna: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an NTN-B in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateLike): The settlement date.\n        maturity (DateLike): The maturity date.\n        rate (float): The discount rate (yield to maturity) of the NTN-B bond.\n\n    Returns:\n        float: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.dv01(\"26-03-2025\", \"15-08-2060\", 0.074358, 4470.979474)\n        4.640875999999935\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate, vna):\n        return float(\"nan\")\n\n    quotation1 = quotation(settlement, maturity, rate)\n    quotation2 = quotation(settlement, maturity, rate + 0.0001)\n    price1 = price(vna, quotation1)\n    price2 = price(vna, quotation2)\n    return price1 - price2\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.forwards","title":"<code>forwards(date, zero_coupon=True)</code>","text":"<p>Calculate the NTN-B forward rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <code>zero_coupon</code> <code>bool</code> <p>If True, use zero-coupon rates for forward rate calculation. Defaults to True. If False, the yield to maturity rates are used instead.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the forward rates.</p> Columns returned <ul> <li>MaturityDate: The maturity date of the bond.</li> <li>BDToMat: The number of business days to maturity.</li> <li>IndicativeRate: The indicative rate for the bond.</li> <li>ForwardRate: The calculated forward rate for the bond.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.forwards(\"17-10-2025\", zero_coupon=True)\nshape: (13, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n\u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2026-08-15   \u2506 207     \u2506 0.10089        \u2506 0.10089     \u2502\n\u2502 2027-05-15   \u2506 392     \u2506 0.088776       \u2506 0.074793    \u2502\n\u2502 2028-08-15   \u2506 707     \u2506 0.083615       \u2506 0.076598    \u2502\n\u2502 2029-05-15   \u2506 891     \u2506 0.0818         \u2506 0.074148    \u2502\n\u2502 2030-08-15   \u2506 1205    \u2506 0.080902       \u2506 0.077857    \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2040-08-15   \u2506 3714    \u2506 0.076067       \u2506 0.070587    \u2502\n\u2502 2045-05-15   \u2506 4901    \u2506 0.075195       \u2506 0.069811    \u2502\n\u2502 2050-08-15   \u2506 6216    \u2506 0.074087       \u2506 0.064348    \u2502\n\u2502 2055-05-15   \u2506 7405    \u2506 0.073702       \u2506 0.067551    \u2502\n\u2502 2060-08-15   \u2506 8722    \u2506 0.073795       \u2506 0.074505    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def forwards(\n    date: DateLike,\n    zero_coupon: bool = True,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate the NTN-B forward rates for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n        zero_coupon (bool, optional): If True, use zero-coupon rates for\n            forward rate calculation. Defaults to True. If False, the\n            yield to maturity rates are used instead.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the forward rates.\n\n    Columns returned:\n        - MaturityDate: The maturity date of the bond.\n        - BDToMat: The number of business days to maturity.\n        - IndicativeRate: The indicative rate for the bond.\n        - ForwardRate: The calculated forward rate for the bond.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.forwards(\"17-10-2025\", zero_coupon=True)\n        shape: (13, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n        \u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2026-08-15   \u2506 207     \u2506 0.10089        \u2506 0.10089     \u2502\n        \u2502 2027-05-15   \u2506 392     \u2506 0.088776       \u2506 0.074793    \u2502\n        \u2502 2028-08-15   \u2506 707     \u2506 0.083615       \u2506 0.076598    \u2502\n        \u2502 2029-05-15   \u2506 891     \u2506 0.0818         \u2506 0.074148    \u2502\n        \u2502 2030-08-15   \u2506 1205    \u2506 0.080902       \u2506 0.077857    \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2040-08-15   \u2506 3714    \u2506 0.076067       \u2506 0.070587    \u2502\n        \u2502 2045-05-15   \u2506 4901    \u2506 0.075195       \u2506 0.069811    \u2502\n        \u2502 2050-08-15   \u2506 6216    \u2506 0.074087       \u2506 0.064348    \u2502\n        \u2502 2055-05-15   \u2506 7405    \u2506 0.073702       \u2506 0.067551    \u2502\n        \u2502 2060-08-15   \u2506 8722    \u2506 0.073795       \u2506 0.074505    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(date):\n        return pl.DataFrame()\n\n    # Validate and normalize the date\n    df = data(date).select(\"MaturityDate\", \"BDToMat\", \"IndicativeRate\")\n    if zero_coupon:\n        df_ref = spot_rates(\n            settlement=date,\n            maturities=df[\"MaturityDate\"],\n            rates=df[\"IndicativeRate\"],\n        ).rename({\"SpotRate\": \"ReferenceRate\"})\n    else:\n        df_ref = df.rename({\"IndicativeRate\": \"ReferenceRate\"})\n    fwd_rates = fwd.forwards(bdays=df_ref[\"BDToMat\"], rates=df_ref[\"ReferenceRate\"])\n    df_ref = df_ref.with_columns(ForwardRate=fwd_rates)\n    df = df.join(\n        df_ref.select(\"MaturityDate\", \"ForwardRate\"),\n        on=\"MaturityDate\",\n        how=\"inner\",\n    ).sort(\"MaturityDate\")\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.maturities","title":"<code>maturities(date)</code>","text":"<p>Get the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Series containing the maturity dates for the NTN-B bonds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.maturities(\"16-08-2024\")\nshape: (14,)\nSeries: 'MaturityDate' [date]\n[\n    2025-05-15\n    2026-08-15\n    2027-05-15\n    2028-08-15\n    2029-05-15\n    \u2026\n    2040-08-15\n    2045-05-15\n    2050-08-15\n    2055-05-15\n    2060-08-15\n]\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def maturities(date: DateLike) -&gt; pl.Series:\n    \"\"\"\n    Get the bond maturities available for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.Series: Series containing the maturity dates for the NTN-B bonds.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.maturities(\"16-08-2024\")\n        shape: (14,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-05-15\n            2026-08-15\n            2027-05-15\n            2028-08-15\n            2029-05-15\n            \u2026\n            2040-08-15\n            2045-05-15\n            2050-08-15\n            2055-05-15\n            2060-08-15\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. Coupon payments are made on the 15th of February, May, August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date (exlusive) to start generating the coupon dates.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Series of coupon dates within the specified range. Returns an empty Series if the maturity date is before or equal to the settlement date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\nshape: (3,)\nSeries: 'payment_dates' [date]\n[\n    2024-05-15\n    2024-11-15\n    2025-05-15\n]\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def payment_dates(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. Coupon payments are made on the 15th of February, May,\n    August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B\n    bond is determined by its maturity date.\n\n    Args:\n        settlement (DateLike): The settlement date (exlusive) to start generating\n            the coupon dates.\n        maturity (DateLike): The maturity date.\n\n    Returns:\n        pl.Series: Series of coupon dates within the specified range. Returns an empty\n            Series if the maturity date is before or equal to the settlement date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n        shape: (3,)\n        Series: 'payment_dates' [date]\n        [\n            2024-05-15\n            2024-11-15\n            2025-05-15\n        ]\n    \"\"\"\n    if has_nullable_args(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    if maturity &lt;= settlement:\n        return pl.Series(dtype=pl.Date)\n\n    coupon_date = maturity\n    coupon_dates = []\n\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        coupon_date -= relativedelta(months=6)\n\n    return pl.Series(name=\"payment_dates\", values=coupon_dates).sort()\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-B price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-B bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-B quotation in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n4271.864805\n&gt;&gt;&gt; ntnb.price(4315.498383, 100.6409)\n4343.156412\n&gt;&gt;&gt; ntnb.price(None, 99.5341)  # Nullable inputs return float('nan')\nnan\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B price using Anbima rules.\n\n    Args:\n        vna (float): The nominal value of the NTN-B bond.\n        quotation (float): The NTN-B quotation in base 100.\n\n    Returns:\n        float: The NTN-B price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n        4271.864805\n        &gt;&gt;&gt; ntnb.price(4315.498383, 100.6409)\n        4343.156412\n        &gt;&gt;&gt; ntnb.price(None, 99.5341)  # Nullable inputs return float('nan')\n        nan\n    \"\"\"\n    if has_nullable_args(vna, quotation):\n        return float(\"nan\")\n    return tl.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-B quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B quotation truncated to 4 decimal places. Returns float('nan') if the calculation cannot be performed due to invalid inputs.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n&gt;&gt;&gt; ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n100.6409\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def quotation(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (DateLike): The settlement date of the operation.\n        maturity (DateLike): The maturity date of the NTN-B bond.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n\n    Returns:\n        float: The NTN-B quotation truncated to 4 decimal places. Returns float('nan')\n            if the calculation cannot be performed due to invalid inputs.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n        99.3651\n        &gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n        99.5341\n        &gt;&gt;&gt; ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n        100.6409\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df_cf = cash_flows(settlement, maturity)\n    if df_cf.is_empty():\n        return float(\"nan\")\n\n    cf_dates = df_cf[\"PaymentDate\"]\n    cf_values = df_cf[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    byears = tl.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** byears\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return tl.truncate(cf_present_value.sum(), 4)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.spot_rates","title":"<code>spot_rates(settlement, maturities, rates, show_coupons=False)</code>","text":"<p>Calculate the spot rates for NTN-B bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The reference date for settlement.</p> required <code>maturities</code> <code>ArrayLike</code> <p>Series of maturity dates for the bonds.</p> required <code>rates</code> <code>ArrayLike</code> <p>Series of yield to maturity rates.</p> required <code>show_coupons</code> <code>bool</code> <p>If True, the result will include the intermediate coupon dates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; # Get the NTN-B rates for a specific reference date\n&gt;&gt;&gt; df = ntnb.data(\"16-08-2024\")\n&gt;&gt;&gt; # Calculate the spot rates considering the settlement at the reference date\n&gt;&gt;&gt; ntnb.spot_rates(\n...     settlement=\"16-08-2024\",\n...     maturities=df[\"MaturityDate\"],\n...     rates=df[\"IndicativeRate\"],\n... )\nshape: (14, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-05-15   \u2506 185     \u2506 0.063893 \u2502\n\u2502 2026-08-15   \u2506 502     \u2506 0.066141 \u2502\n\u2502 2027-05-15   \u2506 687     \u2506 0.064087 \u2502\n\u2502 2028-08-15   \u2506 1002    \u2506 0.063057 \u2502\n\u2502 2029-05-15   \u2506 1186    \u2506 0.061458 \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n\u2502 2040-08-15   \u2506 4009    \u2506 0.058326 \u2502\n\u2502 2045-05-15   \u2506 5196    \u2506 0.060371 \u2502\n\u2502 2050-08-15   \u2506 6511    \u2506 0.060772 \u2502\n\u2502 2055-05-15   \u2506 7700    \u2506 0.059909 \u2502\n\u2502 2060-08-15   \u2506 9017    \u2506 0.060652 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>The calculation of the spot rates for NTN-B bonds considers the following steps:     - Map all all possible payment dates up to the longest maturity date.     - Interpolate the YTM rates in the intermediate payment dates.     - Calculate the NTN-B quotation for each maturity date.     - Calculate the real spot rates for each maturity date.</p> Columns returned <ul> <li>MaturityDate: The maturity date of the bond.</li> <li>BDToMat: The number of business days from settlement to maturities.</li> <li>SpotRate: The real spot rate for the bond.</li> </ul> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def spot_rates(\n    settlement: DateLike,\n    maturities: ArrayLike,\n    rates: ArrayLike,\n    show_coupons: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate the spot rates for NTN-B bonds using the bootstrap method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price.\n\n    Args:\n        settlement (DateLike): The reference date for settlement.\n        maturities (ArrayLike): Series of maturity dates for the bonds.\n        rates (ArrayLike): Series of yield to maturity rates.\n        show_coupons (bool, optional): If True, the result will include the\n            intermediate coupon dates. Defaults to False.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; # Get the NTN-B rates for a specific reference date\n        &gt;&gt;&gt; df = ntnb.data(\"16-08-2024\")\n        &gt;&gt;&gt; # Calculate the spot rates considering the settlement at the reference date\n        &gt;&gt;&gt; ntnb.spot_rates(\n        ...     settlement=\"16-08-2024\",\n        ...     maturities=df[\"MaturityDate\"],\n        ...     rates=df[\"IndicativeRate\"],\n        ... )\n        shape: (14, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-05-15   \u2506 185     \u2506 0.063893 \u2502\n        \u2502 2026-08-15   \u2506 502     \u2506 0.066141 \u2502\n        \u2502 2027-05-15   \u2506 687     \u2506 0.064087 \u2502\n        \u2502 2028-08-15   \u2506 1002    \u2506 0.063057 \u2502\n        \u2502 2029-05-15   \u2506 1186    \u2506 0.061458 \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n        \u2502 2040-08-15   \u2506 4009    \u2506 0.058326 \u2502\n        \u2502 2045-05-15   \u2506 5196    \u2506 0.060371 \u2502\n        \u2502 2050-08-15   \u2506 6511    \u2506 0.060772 \u2502\n        \u2502 2055-05-15   \u2506 7700    \u2506 0.059909 \u2502\n        \u2502 2060-08-15   \u2506 9017    \u2506 0.060652 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        The calculation of the spot rates for NTN-B bonds considers the following steps:\n            - Map all all possible payment dates up to the longest maturity date.\n            - Interpolate the YTM rates in the intermediate payment dates.\n            - Calculate the NTN-B quotation for each maturity date.\n            - Calculate the real spot rates for each maturity date.\n\n    Columns returned:\n        - MaturityDate: The maturity date of the bond.\n        - BDToMat: The number of business days from settlement to maturities.\n        - SpotRate: The real spot rate for the bond.\n    \"\"\"\n    if has_nullable_args(settlement, maturities, rates):\n        return pl.DataFrame()\n\n    settlement, maturities, rates = _validate_spot_rate_inputs(\n        settlement, maturities, rates\n    )\n\n    df = _create_bootstrap_dataframe(settlement, rates, maturities)\n\n    # Bootstrap method to calculate spot rates iteratively\n    df_dicts = df.to_dicts()\n    first_maturity = maturities.min()\n    for row in df_dicts:\n        maturity = row[\"MaturityDate\"]\n\n        # Spot rates &lt;= first maturity are YTM rates by definition\n        if maturity &lt;= first_maturity:\n            spot_rate = row[\"YTM\"]\n            df = _update_spot_rate(df, maturity, spot_rate)\n            continue\n\n        # Calculate the spot rate for the current maturity\n        coupons_pv = _calculate_coupons_present_value(df, settlement, maturity)\n        bond_price = quotation(settlement, maturity, row[\"YTM\"])\n        price_factor = FINAL_PMT / (bond_price - coupons_pv)\n        spot_rate = price_factor ** (1 / row[\"BYears\"]) - 1\n\n        df = _update_spot_rate(df, maturity, spot_rate)\n\n    if not show_coupons:\n        df = df.filter(pl.col(\"MaturityDate\").is_in(maturities.to_list()))\n    return df.select([\"MaturityDate\", \"BDToMat\", \"SpotRate\"])\n</code></pre>"},{"location":"ntnb1/","title":"NTN-B1","text":""},{"location":"ntnb1/#pyield.tn.ntnb1.CommercialName","title":"<code>CommercialName</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Commercial Name Enum used to identify the kind of used NTN-B1 in the scope of the calculation (Renda+ or Educa+).</p>"},{"location":"ntnb1/#pyield.tn.ntnb1.cash_flows","title":"<code>cash_flows(settlement, maturity, commercial_name)</code>","text":"<p>Generate the cash flows for NTN-B1 bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date (exclusive) to start generating the cash flows.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the bond.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>The commercial name of the NTN-B1 bond (Renda+ or Educa+).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.cash_flows(\"10-05-2024\", \"15-12-2060\", r_mais)\nshape: (240, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow \u2502\n\u2502 ---         \u2506 ---      \u2502\n\u2502 date        \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2041-01-15  \u2506 0.004167 \u2502\n\u2502 2041-02-15  \u2506 0.004167 \u2502\n\u2502 2041-03-15  \u2506 0.004167 \u2502\n\u2502 2041-04-15  \u2506 0.004167 \u2502\n\u2502 2041-05-15  \u2506 0.004167 \u2502\n\u2502 \u2026           \u2506 \u2026        \u2502\n\u2502 2060-08-15  \u2506 0.004167 \u2502\n\u2502 2060-09-15  \u2506 0.004167 \u2502\n\u2502 2060-10-15  \u2506 0.004167 \u2502\n\u2502 2060-11-15  \u2506 0.004167 \u2502\n\u2502 2060-12-15  \u2506 0.004167 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def cash_flows(\n    settlement: DateLike, maturity: DateLike, commercial_name: CommercialName\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-B1 bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (DateLike): The settlement date (exclusive) to start generating\n            the cash flows.\n        maturity (DateLike): The maturity date of the bond.\n        commercial_name (CommercialName): The commercial name of the NTN-B1 bond\n            (Renda+ or Educa+).\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.cash_flows(\"10-05-2024\", \"15-12-2060\", r_mais)\n        shape: (240, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow \u2502\n        \u2502 ---         \u2506 ---      \u2502\n        \u2502 date        \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2041-01-15  \u2506 0.004167 \u2502\n        \u2502 2041-02-15  \u2506 0.004167 \u2502\n        \u2502 2041-03-15  \u2506 0.004167 \u2502\n        \u2502 2041-04-15  \u2506 0.004167 \u2502\n        \u2502 2041-05-15  \u2506 0.004167 \u2502\n        \u2502 \u2026           \u2506 \u2026        \u2502\n        \u2502 2060-08-15  \u2506 0.004167 \u2502\n        \u2502 2060-09-15  \u2506 0.004167 \u2502\n        \u2502 2060-10-15  \u2506 0.004167 \u2502\n        \u2502 2060-11-15  \u2506 0.004167 \u2502\n        \u2502 2060-12-15  \u2506 0.004167 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    if has_nullable_args(settlement, maturity, commercial_name):\n        return pl.DataFrame({\"PaymentDate\": [], \"CashFlow\": []})\n\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Get the coupon dates between the settlement and maturity dates\n    p_dates = payment_dates(settlement, maturity, commercial_name)\n    df = pl.DataFrame({\"PaymentDate\": p_dates})\n\n    # Get bond parameters\n    amort_payment, final_amort_payment, _ = _get_bond_parameters(commercial_name)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    df = df.with_columns(\n        pl.when(pl.col(\"PaymentDate\") == maturity)\n        .then(final_amort_payment)\n        .otherwise(amort_payment)\n        .alias(\"CashFlow\")\n    )\n\n    # Return a dataframe with the payment dates and cash flows\n    return df\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.duration","title":"<code>duration(settlement, maturity, rate, commercial_name)</code>","text":"<p>Calculate the Macaulay duration of the NTN-B bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the duration.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>The commercial name of the NTN-B1 bond (Renda+ or Educa+).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration of the NTN-B bond in business years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.duration(\"23-06-2025\", \"15-12-2084\", 0.0686, r_mais)\n47.10493458167134\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def duration(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    commercial_name: CommercialName,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration of the NTN-B bond in business years.\n\n    Args:\n        settlement (DateLike): The settlement date of the operation.\n        maturity (DateLike): The maturity date of the NTN-B bond.\n        rate (float): The discount rate used to calculate the duration.\n        commercial_name (CommercialName): The commercial name of the NTN-B1 bond\n            (Renda+ or Educa+).\n\n    Returns:\n        float: The Macaulay duration of the NTN-B bond in business years.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.duration(\"23-06-2025\", \"15-12-2084\", 0.0686, r_mais)\n        47.10493458167134\n    \"\"\"\n    # Return NaN if any input is nullable\n    if has_nullable_args(settlement, maturity, rate, commercial_name):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity, commercial_name)\n    s_byears = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    s_dcf = df[\"CashFlow\"] / (1 + rate) ** s_byears\n    duration = (s_dcf * s_byears).sum() / s_dcf.sum()\n\n    # Truncate duration to 14 decimal places for result reproducibility\n    return bt.truncate(duration, 14)\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.dv01","title":"<code>dv01(settlement, maturity, rate, vna, commercial_name=CommercialName.RENDA_MAIS)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an NTN-B1 in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) of the NTN-B bond.</p> required <code>vna</code> <code>float</code> <p>The nominal value of the NTN-B bond.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>The commercial name of the NTN-B1 bond</p> <code>RENDA_MAIS</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.dv01(\"23-06-2025\", \"15-12-2084\", 0.0686, 4299.160173, r_mais)\n0.7738490000000127\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    vna: float,\n    commercial_name: CommercialName = CommercialName.RENDA_MAIS,\n) -&gt; float:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an NTN-B1 in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateLike): The settlement date.\n        maturity (DateLike): The maturity date of the NTN-B bond.\n        rate (float): The discount rate (yield to maturity) of the NTN-B bond.\n        vna (float): The nominal value of the NTN-B bond.\n        commercial_name (CommercialName): The commercial name of the NTN-B1 bond\n\n    Returns:\n        float: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.dv01(\"23-06-2025\", \"15-12-2084\", 0.0686, 4299.160173, r_mais)\n        0.7738490000000127\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate, vna, commercial_name):\n        return float(\"nan\")\n\n    quotation1 = quotation(settlement, maturity, rate, commercial_name)\n    quotation2 = quotation(settlement, maturity, rate + 0.0001, commercial_name)\n    price1 = price(vna, quotation1)\n    price2 = price(vna, quotation2)\n    return price1 - price2\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.payment_dates","title":"<code>payment_dates(settlement, maturity, commercial_name)</code>","text":"<p>Generate all remaining amortization dates between a given date and the maturity date. The dates are inclusive. Payments are made from January 15th of the year of conversion to December 15 of maturity year.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date (exclusive) to start generating the amortization dates.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>The commercial name of the NTN-B1 bond (Renda+ or Educa+).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Series of coupon dates within the specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.payment_dates(\"10-05-2024\", \"15-12-2050\", r_mais)\nshape: (240,)\nSeries: 'payment_dates' [date]\n[\n    2031-01-15\n    2031-02-15\n    2031-03-15\n    2031-04-15\n    2031-05-15\n    \u2026\n    2050-08-15\n    2050-09-15\n    2050-10-15\n    2050-11-15\n    2050-12-15\n]\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def payment_dates(\n    settlement: DateLike, maturity: DateLike, commercial_name: CommercialName\n) -&gt; pl.Series:\n    \"\"\"\n    Generate all remaining amortization dates between a given date and the maturity\n    date.\n    The dates are inclusive. Payments are made from January 15th of the year of\n    conversion to December 15 of maturity year.\n\n    Args:\n        settlement (DateLike): The settlement date (exclusive) to start generating\n            the amortization dates.\n        maturity (DateLike): The maturity date.\n        commercial_name (CommercialName): The commercial name of the NTN-B1 bond\n            (Renda+ or Educa+).\n\n    Returns:\n        pl.Series: Series of coupon dates within the specified range.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.payment_dates(\"10-05-2024\", \"15-12-2050\", r_mais)\n        shape: (240,)\n        Series: 'payment_dates' [date]\n        [\n            2031-01-15\n            2031-02-15\n            2031-03-15\n            2031-04-15\n            2031-05-15\n            \u2026\n            2050-08-15\n            2050-09-15\n            2050-10-15\n            2050-11-15\n            2050-12-15\n        ]\n    \"\"\"\n    if has_nullable_args(settlement, maturity, commercial_name):\n        return pl.Series(\"payment_dates\", dtype=pl.Date)\n\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    if maturity &lt;= settlement:\n        raise ValueError(\"Maturity date must be after the settlement date.\")\n\n    maturity = maturity.replace(day=15)\n\n    # Get bond parameters\n    _, _, n_amortizations = _get_bond_parameters(commercial_name)\n\n    amtz_dates = [maturity - relativedelta(months=i) for i in range(n_amortizations)]\n\n    if len(amtz_dates) == 0:\n        raise ValueError(\"No amortization dates found after settlement date.\")\n\n    pmt_dates = pl.Series(name=\"payment_dates\", values=amtz_dates).cast(pl.Date)\n\n    return pmt_dates.filter(pmt_dates &gt; settlement).sort()\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-B1 price using Brazilian Treasury rules.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-B bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-B quotation in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B1 price truncated to 6 decimal places.</p> References <ul> <li>SEI Proccess 17944.005214/2024-09</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; ntnb1.price(4299.160173, 99.3651 / 100)\n4271.864805\n&gt;&gt;&gt; ntnb1.price(4315.498383, 100.6409 / 100)\n4343.156412\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B1 price using Brazilian Treasury rules.\n\n    Args:\n        vna (float): The nominal value of the NTN-B bond.\n        quotation (float): The NTN-B quotation in base 100.\n\n    Returns:\n        float: The NTN-B1 price truncated to 6 decimal places.\n\n    References:\n         - SEI Proccess 17944.005214/2024-09\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; ntnb1.price(4299.160173, 99.3651 / 100)\n        4271.864805\n        &gt;&gt;&gt; ntnb1.price(4315.498383, 100.6409 / 100)\n        4343.156412\n    \"\"\"\n    if has_nullable_args(vna, quotation):\n        return float(\"nan\")\n    return bt.truncate(vna * quotation, 6)\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.quotation","title":"<code>quotation(settlement, maturity, rate, commercial_name)</code>","text":"<p>Calculate the NTN-B quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>The commercial name of the NTN-B1 bond (Renda+ or Educa+).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B quotation truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.quotation(\"18-06-2025\", \"15-12-2084\", 0.07010, r_mais)\n0.038332\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def quotation(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    commercial_name: CommercialName,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (DateLike): The settlement date of the operation.\n        maturity (DateLike): The maturity date of the NTN-B bond.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n        commercial_name (CommercialName): The commercial name of the NTN-B1 bond\n            (Renda+ or Educa+).\n\n    Returns:\n        float: The NTN-B quotation truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.quotation(\"18-06-2025\", \"15-12-2084\", 0.07010, r_mais)\n        0.038332\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate, commercial_name):\n        return float(\"nan\")\n\n    cf_df = cash_flows(settlement, maturity, commercial_name)\n    cf_dates = cf_df[\"PaymentDate\"]\n    cf_values = cf_df[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    b_days = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = bt.truncate(b_days / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return bt.truncate(cf_present_value.sum(), 6)\n</code></pre>"},{"location":"ntnbp/","title":"NTN-B Principal","text":""},{"location":"ntnbp/#pyield.tn.ntnbprinc.dv01","title":"<code>dv01(settlement, maturity, rate, face_value)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an LTN in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) of the bond.</p> required <code>face_value</code> <code>float</code> <p>The face value of the bond (VNA).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnbprinc as bp\n&gt;&gt;&gt; bp.dv01(\"02-12-2025\", \"15-05-2029\", 0.0777, 4567.033825)\n1.1200559999997495\n</code></pre> Source code in <code>pyield/tn/ntnbprinc.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    face_value: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an LTN in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateLike): The settlement date.\n        maturity (DateLike): The maturity date.\n        rate (float): The discount rate (yield to maturity) of the bond.\n        face_value (float): The face value of the bond (VNA).\n\n    Returns:\n        float: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnbprinc as bp\n        &gt;&gt;&gt; bp.dv01(\"02-12-2025\", \"15-05-2029\", 0.0777, 4567.033825)\n        1.1200559999997495\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate, face_value):\n        return float(\"nan\")\n\n    price1 = price(settlement, maturity, rate, face_value)\n    price2 = price(settlement, maturity, rate + 0.0001, face_value)\n    return price1 - price2\n</code></pre>"},{"location":"ntnbp/#pyield.tn.ntnbprinc.price","title":"<code>price(settlement, maturity, rate, face_value)</code>","text":"<p>Calculate the NTN-B PRINCIPAL price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) of the bond.</p> required <code>face_value</code> <code>float</code> <p>The face value of the bond (VNA).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B PRINCIPAL price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnbprinc\n&gt;&gt;&gt; ntnbprinc.price(\"02-12-2025\", \"15-05-2029\", 0.0777, 4567.033825)\n3537.763157\n</code></pre> Source code in <code>pyield/tn/ntnbprinc.py</code> <pre><code>def price(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    face_value: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B PRINCIPAL price using Anbima rules.\n\n    Args:\n        settlement (DateLike): The settlement date.\n        maturity (DateLike): The maturity date.\n        rate (float): The discount rate (yield to maturity) of the bond.\n        face_value (float): The face value of the bond (VNA).\n\n    Returns:\n        float: The NTN-B PRINCIPAL price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnbprinc\n        &gt;&gt;&gt; ntnbprinc.price(\"02-12-2025\", \"15-05-2029\", 0.0777, 4567.033825)\n        3537.763157\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate, face_value):\n        return float(\"nan\")\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rule\n    byears = tools.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** byears\n\n    # Truncate the price to 6 decimal places as per Anbima rules\n    return tools.truncate(face_value / discount_factor, 6)\n</code></pre>"},{"location":"ntnc/","title":"NTN-C","text":""},{"location":"ntnc/#pyield.tn.ntnc.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Generate the cash flows for NTN-C bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date (exclusive) to start generating the cash flows.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.cash_flows(\"21-03-2025\", \"01-01-2031\")\nshape: (12, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-07-01  \u2506 5.830052   \u2502\n\u2502 2026-01-01  \u2506 5.830052   \u2502\n\u2502 2026-07-01  \u2506 5.830052   \u2502\n\u2502 2027-01-01  \u2506 5.830052   \u2502\n\u2502 2027-07-01  \u2506 5.830052   \u2502\n\u2502 \u2026           \u2506 \u2026          \u2502\n\u2502 2029-01-01  \u2506 5.830052   \u2502\n\u2502 2029-07-01  \u2506 5.830052   \u2502\n\u2502 2030-01-01  \u2506 5.830052   \u2502\n\u2502 2030-07-01  \u2506 5.830052   \u2502\n\u2502 2031-01-01  \u2506 105.830052 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def cash_flows(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-C bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (DateLike): The settlement date (exclusive) to start generating\n            the cash flows.\n        maturity (DateLike): The maturity date of the bond.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.cash_flows(\"21-03-2025\", \"01-01-2031\")\n        shape: (12, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-07-01  \u2506 5.830052   \u2502\n        \u2502 2026-01-01  \u2506 5.830052   \u2502\n        \u2502 2026-07-01  \u2506 5.830052   \u2502\n        \u2502 2027-01-01  \u2506 5.830052   \u2502\n        \u2502 2027-07-01  \u2506 5.830052   \u2502\n        \u2502 \u2026           \u2506 \u2026          \u2502\n        \u2502 2029-01-01  \u2506 5.830052   \u2502\n        \u2502 2029-07-01  \u2506 5.830052   \u2502\n        \u2502 2030-01-01  \u2506 5.830052   \u2502\n        \u2502 2030-07-01  \u2506 5.830052   \u2502\n        \u2502 2031-01-01  \u2506 105.830052 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(settlement, maturity):\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Get the coupon dates between the settlement and maturity dates\n    pay_dates = payment_dates(settlement, maturity)\n\n    # Return empty DataFrame if no payment dates (settlement &gt;= maturity)\n    if pay_dates.is_empty():\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    # Get the right coupon payment and final payment values\n    coupon_pmt = _get_coupon_pmt(maturity)\n    final_pmt = _get_final_pmt(maturity)\n\n    # Build dataframe and assign cash flows using Polars expressions\n    df = pl.DataFrame({\"PaymentDate\": pay_dates}).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == maturity)\n        .then(final_pmt)\n        .otherwise(coupon_pmt)\n        .alias(\"CashFlow\")\n    )\n    return df\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.data","title":"<code>data(date)</code>","text":"<p>Fetch the LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.data(\"23-08-2024\")\nshape: (1, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-C    \u2506 770100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.061591 \u2506 0.057587 \u2506 0.059617       \u2506 0.11575 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.data(\"23-08-2024\")\n        shape: (1, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-C    \u2506 770100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.061591 \u2506 0.057587 \u2506 0.059617       \u2506 0.11575 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"NTN-C\")\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration of the NTN-C bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the NTN-C bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the duration.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration of the NTN-C bond in business years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.duration(\"21-03-2025\", \"01-01-2031\", 0.067626)\n4.405363320448\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def duration(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration of the NTN-C bond in business years.\n\n    Args:\n        settlement (DateLike): The settlement date of the operation.\n        maturity (DateLike): The maturity date of the NTN-C bond.\n        rate (float): The discount rate used to calculate the duration.\n\n    Returns:\n        float: The Macaulay duration of the NTN-C bond in business years.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.duration(\"21-03-2025\", \"01-01-2031\", 0.067626)\n        4.405363320448\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    b_years = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** b_years\n    duration = (dcf * b_years).sum() / dcf.sum()\n    # Truncar para 14 casas decimais para repetibilidade dos resultados\n    return tl.truncate(duration, 14)\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. The NTN-C bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date (exlusive) to start generating the coupon dates.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Series of coupon dates within the specified range. Returns an empty Series if the maturity date is before the settlement date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.payment_dates(\"21-03-2025\", \"01-01-2031\")\nshape: (12,)\nSeries: '' [date]\n[\n    2025-07-01\n    2026-01-01\n    2026-07-01\n    2027-01-01\n    2027-07-01\n    \u2026\n    2029-01-01\n    2029-07-01\n    2030-01-01\n    2030-07-01\n    2031-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def payment_dates(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. The NTN-C bond is determined by its maturity date.\n\n    Args:\n        settlement (DateLike): The settlement date (exlusive) to start generating\n            the coupon dates.\n        maturity (DateLike): The maturity date.\n\n    Returns:\n        pl.Series: Series of coupon dates within the specified range. Returns an\n            empty Series if the maturity date is before the settlement date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.payment_dates(\"21-03-2025\", \"01-01-2031\")\n        shape: (12,)\n        Series: '' [date]\n        [\n            2025-07-01\n            2026-01-01\n            2026-07-01\n            2027-01-01\n            2027-07-01\n            \u2026\n            2029-01-01\n            2029-07-01\n            2030-01-01\n            2030-07-01\n            2031-01-01\n        ]\n    \"\"\"\n    if has_nullable_args(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt; settlement:\n        return pl.Series(dtype=pl.Date)\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= relativedelta(months=6)\n\n    return pl.Series(coupon_dates).sort()\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-C price using Anbima rules.</p> <p>price = VNA * quotation / 100</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-C bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-C quotation in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-C price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.price(6598.913723, 126.4958)\n8347.348705\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-C price using Anbima rules.\n\n    price = VNA * quotation / 100\n\n    Args:\n        vna (float): The nominal value of the NTN-C bond.\n        quotation (float): The NTN-C quotation in base 100.\n\n    Returns:\n        float: The NTN-C price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.price(6598.913723, 126.4958)\n        8347.348705\n    \"\"\"\n    if has_nullable_args(vna, quotation):\n        return float(\"nan\")\n    return tl.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-C quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the NTN-C bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-C.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-C quotation truncated to 4 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.quotation(\"21-03-2025\", \"01-01-2031\", 0.067626)\n126.4958\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def quotation(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-C quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (DateLike): The settlement date of the operation.\n        maturity (DateLike): The maturity date of the NTN-C bond.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-C.\n\n    Returns:\n        float: The NTN-C quotation truncated to 4 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.quotation(\"21-03-2025\", \"01-01-2031\", 0.067626)\n        126.4958\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n\n    cf_df = cash_flows(settlement, maturity)\n    if cf_df.is_empty():\n        return float(\"nan\")\n\n    cf_dates = cf_df[\"PaymentDate\"]\n    cf_values = cf_df[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = tl.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return tl.truncate(cf_present_value.sum(), 4)\n</code></pre>"},{"location":"ntnf/","title":"NTN-F","text":""},{"location":"ntnf/#pyield.tn.ntnf.cash_flows","title":"<code>cash_flows(settlement, maturity, adj_payment_dates=False)</code>","text":"<p>Generate the cash flows for the NTN-F bond between the settlement (exclusive) and maturity dates (inclusive). The cash flows are the coupon payments and the final payment at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The date (exclusive) for starting the cash flows.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the bond.</p> required <code>adj_payment_dates</code> <code>bool</code> <p>If True, adjust the payment dates to the next business day.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.cash_flows(\"15-05-2024\", \"01-01-2027\")\nshape: (6, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-07-01  \u2506 48.80885   \u2502\n\u2502 2025-01-01  \u2506 48.80885   \u2502\n\u2502 2025-07-01  \u2506 48.80885   \u2502\n\u2502 2026-01-01  \u2506 48.80885   \u2502\n\u2502 2026-07-01  \u2506 48.80885   \u2502\n\u2502 2027-01-01  \u2506 1048.80885 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def cash_flows(\n    settlement: DateLike,\n    maturity: DateLike,\n    adj_payment_dates: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Generate the cash flows for the NTN-F bond between the settlement (exclusive) and\n    maturity dates (inclusive). The cash flows are the coupon payments and the final\n    payment at maturity.\n\n    Args:\n        settlement (DateLike): The date (exclusive) for starting the cash flows.\n        maturity (DateLike): The maturity date of the bond.\n        adj_payment_dates (bool): If True, adjust the payment dates to the next\n            business day.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.cash_flows(\"15-05-2024\", \"01-01-2027\")\n        shape: (6, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-07-01  \u2506 48.80885   \u2502\n        \u2502 2025-01-01  \u2506 48.80885   \u2502\n        \u2502 2025-07-01  \u2506 48.80885   \u2502\n        \u2502 2026-01-01  \u2506 48.80885   \u2502\n        \u2502 2026-07-01  \u2506 48.80885   \u2502\n        \u2502 2027-01-01  \u2506 1048.80885 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(settlement, maturity):\n        return pl.DataFrame()\n    # Normalize input dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Get the payment dates between the settlement and maturity dates\n    pmt_dates = payment_dates(settlement, maturity)\n\n    # Return empty DataFrame if no payment dates (settlement &gt;= maturity)\n    if pmt_dates.is_empty():\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    df = pl.DataFrame(\n        data={\"PaymentDate\": pmt_dates},\n    ).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == maturity)\n        .then(FINAL_PMT)\n        .otherwise(COUPON_PMT)\n        .alias(\"CashFlow\")\n    )\n\n    if adj_payment_dates:\n        adj_pay_dates = bday.offset(pmt_dates, 0)\n        df = df.with_columns(PaymentDate=adj_pay_dates)\n    return df\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.data","title":"<code>data(date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.data(\"23-08-2024\")\nshape: (6, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2014-01-10    \u2506 \u2026 \u2506 0.107864 \u2506 0.107524 \u2506 0.107692       \u2506 0.10823 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.11527  \u2506 0.114948 \u2506 0.115109       \u2506 0.11467 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.116468 \u2506 0.11621  \u2506 0.116337       \u2506 0.1156  \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.117072 \u2506 0.116958 \u2506 0.117008       \u2506 0.11575 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.116473 \u2506 0.116164 \u2506 0.116307       \u2506 0.11554 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.116662 \u2506 0.116523 \u2506 0.116586       \u2506 0.11531 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.data(\"23-08-2024\")\n        shape: (6, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2014-01-10    \u2506 \u2026 \u2506 0.107864 \u2506 0.107524 \u2506 0.107692       \u2506 0.10823 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.11527  \u2506 0.114948 \u2506 0.115109       \u2506 0.11467 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.116468 \u2506 0.11621  \u2506 0.116337       \u2506 0.1156  \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.117072 \u2506 0.116958 \u2506 0.117008       \u2506 0.11575 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.116473 \u2506 0.116164 \u2506 0.116307       \u2506 0.11554 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.116662 \u2506 0.116523 \u2506 0.116586       \u2506 0.11531 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa\n    return anbima.tpf_data(date, \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.di_net_spread","title":"<code>di_net_spread(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates)</code>","text":"<p>Calculate the net DI spread for a bond given the YTM and the DI rates.</p> <p>This function determines the spread over the DI curve that equates the present value of the bond's cash flows to its market price. It interpolates the DI rates to match the bond's cash flow payment dates and uses the Brent method to find the spread (in bps) that zeroes the difference between the bond's market price and its discounted cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date to calculate the spread.</p> required <code>ntnf_maturity</code> <code>DateLike</code> <p>The bond maturity date.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the bond.</p> required <code>di_rates</code> <code>ArrayLike</code> <p>A Series of DI rates.</p> required <code>di_expirations</code> <code>ArrayLike</code> <p>A list or Series of DI expiration dates.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The net DI spread in decimal format (e.g., 0.0012 for 12 bps). If calculation fails, returns NaN.</p> <p>Examples:</p>"},{"location":"ntnf/#pyield.tn.ntnf.di_net_spread--obs-only-some-of-the-di-rates-will-be-used-in-the-example","title":"Obs: only some of the DI rates will be used in the example.","text":"<pre><code>&gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n&gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n&gt;&gt;&gt; spread = di_net_spread(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n&gt;&gt;&gt; round(spread * 10_000, 2)  # Convert to bps for display\n12.13\n</code></pre> <pre><code>&gt;&gt;&gt; # Nullable inputs return float('nan')\n&gt;&gt;&gt; di_net_spread(\n...     settlement=None,\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\nnan\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def di_net_spread(  # noqa\n    settlement: DateLike,\n    ntnf_maturity: DateLike,\n    ntnf_rate: float,\n    di_expirations: ArrayLike,\n    di_rates: ArrayLike,\n) -&gt; float:\n    \"\"\"\n    Calculate the net DI spread for a bond given the YTM and the DI rates.\n\n    This function determines the spread over the DI curve that equates the present value\n    of the bond's cash flows to its market price. It interpolates the DI rates to match\n    the bond's cash flow payment dates and uses the Brent method to find the spread\n    (in bps) that zeroes the difference between the bond's market price and its\n    discounted cash flows.\n\n    Args:\n        settlement (DateLike): The settlement date to calculate the spread.\n        ntnf_maturity (DateLike): The bond maturity date.\n        ntnf_rate (float): The yield to maturity (YTM) of the bond.\n        di_rates (ArrayLike): A Series of DI rates.\n        di_expirations (ArrayLike): A list or Series of DI expiration dates.\n\n    Returns:\n        float: The net DI spread in decimal format (e.g., 0.0012 for 12 bps).\n            If calculation fails, returns NaN.\n\n    Examples:\n        # Obs: only some of the DI rates will be used in the example.\n        &gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n        &gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n        &gt;&gt;&gt; spread = di_net_spread(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        &gt;&gt;&gt; round(spread * 10_000, 2)  # Convert to bps for display\n        12.13\n\n        &gt;&gt;&gt; # Nullable inputs return float('nan')\n        &gt;&gt;&gt; di_net_spread(\n        ...     settlement=None,\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        nan\n    \"\"\"\n    # Valida\u00e7\u00e3o de inputs\n    if has_nullable_args(\n        settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates\n    ):\n        return float(\"nan\")\n\n    # Force di_rates to be a Polars Series\n    if not isinstance(di_rates, pl.Series):\n        di_rates = pl.Series(di_rates)\n\n    # Cria\u00e7\u00e3o do interpolador\n    ff_interpolator = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    # Gera\u00e7\u00e3o dos fluxos de caixa do NTN-F\n    df = cash_flows(settlement, ntnf_maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    bdays_to_payment = bday.count(settlement, df[\"PaymentDate\"])\n    byears_to_payment = bdays_to_payment / 252\n\n    df = df.with_columns(\n        BDaysToPayment=bdays_to_payment,\n        DIRateInterp=ff_interpolator(bdays_to_payment),\n    )\n\n    # Extra\u00e7\u00e3o dos dados para o c\u00e1lculo num\u00e9rico\n    bond_price = price(settlement, ntnf_maturity, ntnf_rate)\n    bond_cash_flows = df[\"CashFlow\"]\n    di_interp = df[\"DIRateInterp\"]\n\n    # Fun\u00e7\u00e3o de diferen\u00e7a de pre\u00e7o para o solver\n    def price_difference(p: float) -&gt; float:\n        discounted_cf = bond_cash_flows / (1 + di_interp + p) ** byears_to_payment\n        return discounted_cf.sum() - bond_price\n\n    # 7. Resolver para o spread\n    return _solve_spread(price_difference)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>Defini\u00e7\u00e3o do spread (forma bruta):     DISpread_raw = IndicativeRate - SettlementRate</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - BondType - MaturityDate - DISpread (decimal ou bps conforme par\u00e2metro)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.di_spreads(\"30-05-2025\", bps=True)\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def di_spreads(date: DateLike, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    Defini\u00e7\u00e3o do spread (forma bruta):\n        DISpread_raw = IndicativeRate - SettlementRate\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Default False.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - BondType\n            - MaturityDate\n            - DISpread (decimal ou bps conforme par\u00e2metro)\n\n    Raises:\n        ValueError: Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.di_spreads(\"30-05-2025\", bps=True)\n        shape: (5, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return pre_di_spreads(date, bps=bps).filter(pl.col(\"BondType\") == \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration for an NTN-F bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date to calculate the duration.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The yield to maturity (YTM) used to discount the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration in business business years. Returns NaN if calculation is not possible due to invalid inputs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n6.32854218039796\n</code></pre> <p>Nullable inputs return NaN:</p> <pre><code>&gt;&gt;&gt; ntnf.duration(None, \"01-01-2035\", 0.121785)\nnan\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def duration(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration for an NTN-F bond in business years.\n\n    Args:\n        settlement (DateLike): The settlement date to calculate the duration.\n        maturity (DateLike): The maturity date of the bond.\n        rate (float): The yield to maturity (YTM) used to discount the cash flows.\n\n    Returns:\n        float: The Macaulay duration in business business years. Returns NaN if\n            calculation is not possible due to invalid inputs.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n        6.32854218039796\n\n        Nullable inputs return NaN:\n        &gt;&gt;&gt; ntnf.duration(None, \"01-01-2035\", 0.121785)\n        nan\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    byears = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** byears\n    duration = (dcf * byears).sum() / dcf.sum()\n    return duration\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.dv01","title":"<code>dv01(settlement, maturity, rate)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an NTN-F in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) of the bond.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.dv01(\"26-03-2025\", \"01-01-2035\", 0.151375)\n0.39025200000003224\n</code></pre> <p>Nullable inputs return NaN:</p> <pre><code>&gt;&gt;&gt; ntnf.dv01(\"\", \"01-01-2035\", 0.151375)\nnan\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an NTN-F in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateLike): The settlement date.\n        maturity (DateLike): The maturity date.\n        rate (float): The discount rate (yield to maturity) of the bond.\n\n    Returns:\n        float: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.dv01(\"26-03-2025\", \"01-01-2035\", 0.151375)\n        0.39025200000003224\n\n        Nullable inputs return NaN:\n        &gt;&gt;&gt; ntnf.dv01(\"\", \"01-01-2035\", 0.151375)\n        nan\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n\n    price1 = price(settlement, maturity, rate)\n    price2 = price(settlement, maturity, rate + 0.0001)\n    return price1 - price2\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the NTN-F bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series of NTN-F bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.maturities(\"23-08-2024\")\nshape: (6,)\nSeries: 'MaturityDate' [date]\n[\n    2025-01-01\n    2027-01-01\n    2029-01-01\n    2031-01-01\n    2033-01-01\n    2035-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def maturities(date: DateLike) -&gt; pl.Series:\n    \"\"\"\n    Fetch the NTN-F bond maturities available for the given reference date.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.Series: A Series of NTN-F bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.maturities(\"23-08-2024\")\n        shape: (6,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-01-01\n            2027-01-01\n            2029-01-01\n            2031-01-01\n            2033-01-01\n            2035-01-01\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a settlement date and a maturity date. The dates are exclusive for the settlement date and inclusive for the maturity date. Coupon payments are made on the 1st of January and July. The NTN-F bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series containing the coupon dates between the settlement (exclusive) and maturity (inclusive) dates. Returns an empty Series if the maturity date is before or equal to the settlement date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.payment_dates(\"15-05-2024\", \"01-01-2027\")\nshape: (6,)\nSeries: 'payment_dates' [date]\n[\n    2024-07-01\n    2025-01-01\n    2025-07-01\n    2026-01-01\n    2026-07-01\n    2027-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def payment_dates(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a settlement date and a maturity date.\n    The dates are exclusive for the settlement date and inclusive for the maturity date.\n    Coupon payments are made on the 1st of January and July.\n    The NTN-F bond is determined by its maturity date.\n\n    Args:\n        settlement (DateLike): The settlement date.\n        maturity (DateLike): The maturity date.\n\n    Returns:\n        pl.Series: A Series containing the coupon dates between the settlement\n            (exclusive) and maturity (inclusive) dates. Returns an empty Series if\n            the maturity date is before or equal to the settlement date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.payment_dates(\"15-05-2024\", \"01-01-2027\")\n        shape: (6,)\n        Series: 'payment_dates' [date]\n        [\n            2024-07-01\n            2025-01-01\n            2025-07-01\n            2026-01-01\n            2026-07-01\n            2027-01-01\n        ]\n    \"\"\"\n    if has_nullable_args(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n    # Normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt;= settlement:\n        return pl.Series(dtype=pl.Date)\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= relativedelta(months=6)\n\n    return pl.Series(name=\"payment_dates\", values=coupon_dates).sort()\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.premium","title":"<code>premium(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates)</code>","text":"<p>Calculate the premium of an NTN-F bond over DI rates.</p> <p>This function computes the premium of an NTN-F bond by comparing its implied discount factor with that of the DI curve. It determines the net premium based on the difference between the discount factors of the bond's yield-to-maturity (YTM) and the interpolated DI rates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date to calculate the premium.</p> required <code>ntnf_maturity</code> <code>DateLike</code> <p>The maturity date of the NTN-F bond.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the NTN-F bond.</p> required <code>di_expirations</code> <code>DateLike</code> <p>Series with the expiration dates for the DI.</p> required <code>di_rates</code> <code>ArrayLike</code> <p>Series containing the DI rates corresponding to the expiration dates.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the NTN-F bond over the DI curve, expressed as a</p> <code>float</code> <p>factor. If calculation fails, returns NaN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Obs: only some of the DI rates will be used in the example.\n&gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n&gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n&gt;&gt;&gt; premium(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n1.0099602679927115\n</code></pre> Notes <ul> <li>The function adjusts coupon payment dates to business days and calculates   the present value of cash flows for the NTN-F bond using DI rates.</li> </ul> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def premium(  # noqa\n    settlement: DateLike,\n    ntnf_maturity: DateLike,\n    ntnf_rate: float,\n    di_expirations: DateLike,\n    di_rates: ArrayLike,\n) -&gt; float:\n    \"\"\"\n    Calculate the premium of an NTN-F bond over DI rates.\n\n    This function computes the premium of an NTN-F bond by comparing its implied\n    discount factor with that of the DI curve. It determines the net premium based\n    on the difference between the discount factors of the bond's yield-to-maturity\n    (YTM) and the interpolated DI rates.\n\n    Args:\n        settlement (DateLike): The settlement date to calculate the premium.\n        ntnf_maturity (DateLike): The maturity date of the NTN-F bond.\n        ntnf_rate (float): The yield to maturity (YTM) of the NTN-F bond.\n        di_expirations (DateLike): Series with the expiration dates for the DI.\n        di_rates (ArrayLike): Series containing the DI rates corresponding to\n            the expiration dates.\n\n    Returns:\n        float: The premium of the NTN-F bond over the DI curve, expressed as a\n        factor. If calculation fails, returns NaN.\n\n    Examples:\n        &gt;&gt;&gt; # Obs: only some of the DI rates will be used in the example.\n        &gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n        &gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n        &gt;&gt;&gt; premium(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        1.0099602679927115\n\n    Notes:\n        - The function adjusts coupon payment dates to business days and calculates\n          the present value of cash flows for the NTN-F bond using DI rates.\n\n    \"\"\"\n    if has_nullable_args(\n        settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates\n    ):\n        return float(\"nan\")\n\n    if not isinstance(di_rates, pl.Series):\n        di_rates = pl.Series(di_rates)\n\n    df_cf = cash_flows(settlement, ntnf_maturity, adj_payment_dates=True)\n    if df_cf.is_empty():\n        return float(\"nan\")\n\n    ff_interpolator = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    bdays_to_payments = bday.count(settlement, df_cf[\"PaymentDate\"])\n    df = df_cf.with_columns(\n        BDToMat=bdays_to_payments,\n        BYears=bdays_to_payments / 252,\n        DIRate=ff_interpolator(bdays_to_payments),\n    )\n\n    bond_price = tools.calculate_present_value(\n        cash_flows=df[\"CashFlow\"],\n        rates=df[\"DIRate\"],\n        periods=df[\"BYears\"],\n    )\n\n    if math.isnan(bond_price):\n        return float(\"nan\")\n\n    def price_difference(rate: float) -&gt; float:\n        discounted_cf = df[\"CashFlow\"] / (1 + rate) ** df[\"BYears\"]\n        return discounted_cf.sum() - bond_price\n\n    di_ytm = _solve_spread(price_difference)\n\n    if math.isnan(di_ytm):\n        return float(\"nan\")\n\n    factor_ntnf = (1 + ntnf_rate) ** (1 / 252)\n    factor_di = (1 + di_ytm) ** (1 / 252)\n    if factor_di == 1:\n        return float(\"inf\") if factor_ntnf &gt; 1 else 0.0\n\n    premium_val = (factor_ntnf - 1) / (factor_di - 1)\n    return premium_val\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-F price using Anbima rules, which corresponds to the present     value of the cash flows discounted at the given yield to maturity rate (YTM).</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date to calculate the price.</p> required <code>maturity</code> <code>DateLike</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) used to calculate the present value of the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-F price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 48.81, which represents a 10% annual   coupon rate compounded semi-annually and rounded to 5 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n895.359254\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def price(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-F price using Anbima rules, which corresponds to the present\n        value of the cash flows discounted at the given yield to maturity rate (YTM).\n\n    Args:\n        settlement (DateLike): The settlement date to calculate the price.\n        maturity (DateLike): The maturity date of the bond.\n        rate (float): The discount rate (yield to maturity) used to calculate the\n            present value of the cash flows.\n\n    Returns:\n        float: The NTN-F price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 48.81, which represents a 10% annual\n          coupon rate compounded semi-annually and rounded to 5 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n        895.359254\n    \"\"\"\n    if has_nullable_args(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df_cf = cash_flows(settlement, maturity)\n    if df_cf.is_empty():\n        return float(\"nan\")\n\n    cf_values = df_cf[\"CashFlow\"]\n    bdays = bday.count(settlement, df_cf[\"PaymentDate\"])\n    byears = tools.truncate(bdays / 252, 14)\n    discount_factors = (1 + rate) ** byears\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    dcf = (cf_values / discount_factors).round(9)\n    # Return the sum of the discounted cash flows truncated as per Anbima rules\n    return tools.truncate(dcf.sum(), 6)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.spot_rates","title":"<code>spot_rates(settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates, show_coupons=False)</code>","text":"<p>Calculate the spot rates (zero coupon rates) for NTN-F bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price. It uses the LTN rates, which are zero coupon bonds, up to the last LTN maturity available. For maturities after the last LTN maturity, it calculates the spot rates using the bootstrap method.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>The settlement date for the spot rates calculation.</p> required <code>ltn_maturities</code> <code>ArrayLike</code> <p>The LTN known maturities.</p> required <code>ltn_rates</code> <code>ArrayLike</code> <p>The LTN known rates.</p> required <code>ntnf_maturities</code> <code>ArrayLike</code> <p>The NTN-F known maturities.</p> required <code>ntnf_rates</code> <code>ArrayLike</code> <p>The NTN-F known rates.</p> required <code>show_coupons</code> <code>bool</code> <p>If True, show also July rates corresponding to the coupon payments. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\" and \"SpotRate\". \"BDToMat\" is the business days from the settlement date to the maturities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf, ltn\n&gt;&gt;&gt; df_ltn = ltn.data(\"03-09-2024\")\n&gt;&gt;&gt; df_ntnf = ntnf.data(\"03-09-2024\")\n&gt;&gt;&gt; ntnf.spot_rates(\n...     settlement=\"03-09-2024\",\n...     ltn_maturities=df_ltn[\"MaturityDate\"],\n...     ltn_rates=df_ltn[\"IndicativeRate\"],\n...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n... )\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-01   \u2506 83      \u2506 0.108837 \u2502\n\u2502 2027-01-01   \u2506 584     \u2506 0.119981 \u2502\n\u2502 2029-01-01   \u2506 1083    \u2506 0.122113 \u2502\n\u2502 2031-01-01   \u2506 1584    \u2506 0.122231 \u2502\n\u2502 2033-01-01   \u2506 2088    \u2506 0.121355 \u2502\n\u2502 2035-01-01   \u2506 2587    \u2506 0.121398 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def spot_rates(  # noqa\n    settlement: DateLike,\n    ltn_maturities: ArrayLike,\n    ltn_rates: ArrayLike,\n    ntnf_maturities: ArrayLike,\n    ntnf_rates: ArrayLike,\n    show_coupons: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate the spot rates (zero coupon rates) for NTN-F bonds using the bootstrap\n    method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price. It uses the LTN rates, which are zero coupon bonds, up to the\n    last LTN maturity available. For maturities after the last LTN maturity,\n    it calculates the spot rates using the bootstrap method.\n\n\n    Args:\n        settlement (DateLike): The settlement date for the spot rates calculation.\n        ltn_maturities (ArrayLike): The LTN known maturities.\n        ltn_rates (ArrayLike): The LTN known rates.\n        ntnf_maturities (ArrayLike): The NTN-F known maturities.\n        ntnf_rates (ArrayLike): The NTN-F known rates.\n        show_coupons (bool): If True, show also July rates corresponding to the\n            coupon payments. Defaults to False.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\" and\n            \"SpotRate\". \"BDToMat\" is the business days from the settlement date\n            to the maturities.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf, ltn\n        &gt;&gt;&gt; df_ltn = ltn.data(\"03-09-2024\")\n        &gt;&gt;&gt; df_ntnf = ntnf.data(\"03-09-2024\")\n        &gt;&gt;&gt; ntnf.spot_rates(\n        ...     settlement=\"03-09-2024\",\n        ...     ltn_maturities=df_ltn[\"MaturityDate\"],\n        ...     ltn_rates=df_ltn[\"IndicativeRate\"],\n        ...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n        ...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n        ... )\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-01   \u2506 83      \u2506 0.108837 \u2502\n        \u2502 2027-01-01   \u2506 584     \u2506 0.119981 \u2502\n        \u2502 2029-01-01   \u2506 1083    \u2506 0.122113 \u2502\n        \u2502 2031-01-01   \u2506 1584    \u2506 0.122231 \u2502\n        \u2502 2033-01-01   \u2506 2088    \u2506 0.121355 \u2502\n        \u2502 2035-01-01   \u2506 2587    \u2506 0.121398 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_nullable_args(\n        settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates\n    ):\n        return pl.DataFrame()\n    # 1. Converter e normalizar inputs para Polars\n    settlement = cv.convert_dates(settlement)\n    ltn_maturities = cv.convert_dates(ltn_maturities)\n    ntnf_maturities = cv.convert_dates(ntnf_maturities)\n    if not isinstance(ltn_rates, pl.Series):\n        ltn_rates = pl.Series(ltn_rates).cast(pl.Float64)\n    if not isinstance(ntnf_rates, pl.Series):\n        ntnf_rates = pl.Series(ntnf_rates).cast(pl.Float64)\n\n    # 2. Criar interpoladores (aceitam pl.Series diretamente)\n    ltn_rate_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ltn_maturities),\n        known_rates=ltn_rates,\n    )\n    ntnf_rate_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ntnf_maturities),\n        known_rates=ntnf_rates,\n    )\n\n    # 3. Gerar todas as datas de cupom at\u00e9 o \u00faltimo vencimento NTN-F\n    last_maturity = ntnf_maturities.max()\n    all_coupon_dates = payment_dates(settlement, last_maturity)\n\n    # 4. Construir DataFrame inicial\n    bdays_to_mat = bday.count(settlement, all_coupon_dates)\n    ytm_rates = ntnf_rate_interpolator(bdays_to_mat)\n    df = pl.DataFrame(\n        {\n            \"MaturityDate\": all_coupon_dates,\n            \"BDToMat\": bdays_to_mat,\n            \"BYears\": bdays_to_mat / 252,\n            \"YTM\": ytm_rates,\n        }\n    ).with_columns(\n        Coupon=pl.lit(COUPON_PMT),\n    )\n\n    # 5. Loop de bootstrap (iterativo por depend\u00eancia sequencial)\n    last_ltn_maturity = ltn_maturities.max()\n    maturities_list = df[\"MaturityDate\"]\n    bdays_list = df[\"BDToMat\"]\n    byears_list = df[\"BYears\"]\n    ytm_list = df[\"YTM\"]\n\n    solved_spot_rates: list[float] = []\n    spot_map: dict[pl.Date, float] = {}\n\n    for i in range(len(df)):\n        mat_date = maturities_list[i]\n        bdays_val = int(bdays_list[i])\n        byears_val = float(byears_list[i])\n        ytm_val = float(ytm_list[i])\n\n        # Caso esteja antes (ou igual) ao \u00faltimo vencimento LTN: usar interpolador LTN\n        if mat_date &lt;= last_ltn_maturity:\n            spot_rate = ltn_rate_interpolator(bdays_val)\n            solved_spot_rates.append(spot_rate)\n            spot_map[mat_date] = spot_rate\n            continue\n\n        # Datas de cupom (exclui \u00faltimo pagamento) para este vencimento\n        cf_dates = payment_dates(settlement, mat_date)[:-1]\n        if len(cf_dates) == 0:\n            # Caso improv\u00e1vel, mas protege contra divis\u00e3o por zero mais adiante\n            spot_rate = None\n            solved_spot_rates.append(spot_rate)\n            spot_map[mat_date] = spot_rate\n            continue\n\n        # Recuperar SpotRates j\u00e1 solucionadas para estes cupons\n        cf_spot_rates = [spot_map[d] for d in cf_dates]\n        cf_periods = bday.count(settlement, cf_dates) / 252\n        cf_cash_flows = [COUPON_PMT] * len(cf_dates)\n\n        cf_present_value = tools.calculate_present_value(\n            cash_flows=pl.Series(cf_cash_flows),\n            rates=pl.Series(cf_spot_rates),\n            periods=cf_periods,\n        )\n\n        bond_price = price(settlement, mat_date, ytm_val)\n        price_factor = FINAL_PMT / (bond_price - cf_present_value)\n        spot_rate = price_factor ** (1 / byears_val) - 1\n\n        solved_spot_rates.append(spot_rate)\n        spot_map[mat_date] = spot_rate\n\n    # 6. Anexar coluna SpotRate\n    df = df.with_columns(SpotRate=pl.Series(solved_spot_rates, dtype=pl.Float64))\n\n    # 7. Selecionar colunas finais\n    df = df.select([\"MaturityDate\", \"BDToMat\", \"SpotRate\"])\n\n    # 8. Remover cupons (Julho) se n\u00e3o solicitado\n    if not show_coupons:\n        df = df.filter(pl.col(\"MaturityDate\").is_in(ntnf_maturities.implode()))\n\n    return df\n</code></pre>"},{"location":"pre/","title":"PRE","text":""},{"location":"pre/#pyield.tn.pre.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>spread = taxa indicativa do PRE - taxa de ajuste do DI</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - BondType - MaturityDate - DISpread (decimal ou bps conforme par\u00e2metro)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\nshape: (18, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def di_spreads(date: DateLike, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    spread = taxa indicativa do PRE - taxa de ajuste do DI\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Default False.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - BondType\n            - MaturityDate\n            - DISpread (decimal ou bps conforme par\u00e2metro)\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\n        shape: (18, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Fetch bond rates, filtering for LTN and NTN-F types\n    df = (\n        tpf.tpf_data(date, \"PRE\")\n        .with_columns(DISpread=pl.col(\"IndicativeRate\") - pl.col(\"DIRate\"))\n        .select(\"BondType\", \"MaturityDate\", \"DISpread\")\n        .sort(\"BondType\", \"MaturityDate\")\n    )\n\n    if bps:\n        df = df.with_columns(pl.col(\"DISpread\") * 10_000)\n\n    return df\n</code></pre>"},{"location":"pre/#pyield.tn.pre.spot_rates","title":"<code>spot_rates(date)</code>","text":"<p>Create the PRE curve (zero coupon rates) for Brazilian fixed rate bonds.</p> <p>This function combines LTN rates (which are already zero coupon) with spot rates derived from NTN-F bonds using the bootstrap method.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\", and \"SpotRate\".          Contains zero coupon rates for all available maturities.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any maturity date cannot be processed or business days cannot be calculated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.spot_rates(\"18-06-2025\")\nshape: (17, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-07-01   \u2506 8       \u2506 0.14835  \u2502\n\u2502 2025-10-01   \u2506 74      \u2506 0.147463 \u2502\n\u2502 2026-01-01   \u2506 138     \u2506 0.147752 \u2502\n\u2502 2026-04-01   \u2506 199     \u2506 0.147947 \u2502\n\u2502 2026-07-01   \u2506 260     \u2506 0.147069 \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n\u2502 2030-01-01   \u2506 1135    \u2506 0.137279 \u2502\n\u2502 2031-01-01   \u2506 1387    \u2506 0.138154 \u2502\n\u2502 2032-01-01   \u2506 1639    \u2506 0.13876  \u2502\n\u2502 2033-01-01   \u2506 1891    \u2506 0.1393   \u2502\n\u2502 2035-01-01   \u2506 2390    \u2506 0.141068 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def spot_rates(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Create the PRE curve (zero coupon rates) for Brazilian fixed rate bonds.\n\n    This function combines LTN rates (which are already zero coupon) with\n    spot rates derived from NTN-F bonds using the bootstrap method.\n\n    Args:\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\", and \"SpotRate\".\n                     Contains zero coupon rates for all available maturities.\n\n    Raises:\n        ValueError: If any maturity date cannot be processed or business days cannot be\n            calculated.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.spot_rates(\"18-06-2025\")\n        shape: (17, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-07-01   \u2506 8       \u2506 0.14835  \u2502\n        \u2502 2025-10-01   \u2506 74      \u2506 0.147463 \u2502\n        \u2502 2026-01-01   \u2506 138     \u2506 0.147752 \u2502\n        \u2502 2026-04-01   \u2506 199     \u2506 0.147947 \u2502\n        \u2502 2026-07-01   \u2506 260     \u2506 0.147069 \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n        \u2502 2030-01-01   \u2506 1135    \u2506 0.137279 \u2502\n        \u2502 2031-01-01   \u2506 1387    \u2506 0.138154 \u2502\n        \u2502 2032-01-01   \u2506 1639    \u2506 0.13876  \u2502\n        \u2502 2033-01-01   \u2506 1891    \u2506 0.1393   \u2502\n        \u2502 2035-01-01   \u2506 2390    \u2506 0.141068 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Fetch LTN data (zero coupon bonds)\n    df_ltn = anbima.tpf_data(date, \"LTN\")\n\n    # Fetch NTN-F data (coupon bonds)\n    df_ntnf = anbima.tpf_data(date, \"NTN-F\")\n\n    # Check if we have data for both bond types\n    if df_ltn.is_empty() and df_ntnf.is_empty():\n        return pl.DataFrame(\n            schema={\n                \"MaturityDate\": pl.Date,\n                \"BDToMat\": pl.Int64,\n                \"SpotRate\": pl.Float64,\n            }\n        )\n\n    # If we only have NTN-F data, we can't bootstrap without LTN rates\n    if df_ltn.is_empty():\n        raise ValueError(\n            \"Cannot construct PRE curve without LTN rates for bootstrapping\"\n        )\n\n    # If we only have LTN data, return it directly (LTN are already zero coupon)\n    if df_ntnf.is_empty():\n        df_combined = _process_additional_ltn(date, df_ltn)\n    else:\n        # Use the existing spot_rates function to calculate zero coupon rates\n        df_spots = ntnf.spot_rates(\n            settlement=date,\n            ltn_maturities=df_ltn[\"MaturityDate\"],\n            ltn_rates=df_ltn[\"IndicativeRate\"],\n            ntnf_maturities=df_ntnf[\"MaturityDate\"],\n            ntnf_rates=df_ntnf[\"IndicativeRate\"],\n            show_coupons=False,\n        )\n\n        # Find LTN maturities that are not in the NTN-F result\n        ltn_mask = ~df_ltn[\"MaturityDate\"].is_in(df_spots[\"MaturityDate\"].to_list())\n        ltn_not_in_ntnf = df_ltn.filter(ltn_mask)\n\n        if not ltn_not_in_ntnf.is_empty():\n            # Process additional LTN maturities\n            ltn_subset = _process_additional_ltn(date, ltn_not_in_ntnf)\n\n            # Combine LTN and NTN-F derived spot rates\n            df_combined = pl.concat([df_spots, ltn_subset])\n        else:\n            df_combined = df_spots\n\n    # Final validation - ensure no NaN values in the result\n    _validate_final_result(df_combined)\n\n    # Sort by maturity date and return\n    return df_combined.sort(\"MaturityDate\")\n</code></pre>"},{"location":"tn/","title":"Overview","text":""},{"location":"tn/#pyield.tn.auction","title":"<code>auction(auction_date)</code>","text":"<p>Fetches and processes Brazilian Treasury auction data for a given date.</p> <p>This function queries the Tesouro Nacional API to retrieve auction results for a specific date. It then processes the JSON response using the Polars library to create a well-structured and typed DataFrame.</p> <p>Exemplo de resposta da API de leil\u00f5es do Tesouro: https://apiapex.tesouro.gov.br/aria/v1/api-leiloes-pub/custom/resultados?dataleilao=30/09/2025</p> <pre><code>{\n\"registros\": [\n    {...},\n    {\n    \"quantidade_bcb\": 0,\n    \"liquidacao_segunda_volta\": \"30/09/2025\",\n    \"oferta_segunda_volta\": 37499,\n    \"data_leilao\": \"30/09/2025\",\n    \"oferta\": 150000,\n    \"titulo\": \"LFT\",\n    \"liquidacao\": \"01/10/2025\",\n    \"financeiro_aceito_segunda_volta\": 0,\n    \"quantidade_aceita\": 150000,\n    \"prazo\": 1067,\n    \"vencimento\": \"01/09/2028\",\n    \"benchmark\": \"LFT 3 anos\",\n    \"pu_medio\": 17434.81182753125,\n    \"taxa_media\": 0.0669,\n    \"financeiro_aceito\": 2615194916.22,\n    \"pu_minimo\": 17434.632775,\n    \"numero_edital\": 230,\n    \"taxa_maxima\": 0.0669,\n    \"tipo_leilao\": \"Venda\",\n    \"financeiro_bcb\": 0,\n    \"quantidade_aceita_segunda_volta\": 0\n    },\n    {...},\n],\n\"status\": \"ok\"\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>auction_date</code> <code>DateLike</code> <p>The date of the auction in the format accepted by PYield DateLike (e.g., \"DD-MM-YYYY\", datetime.date, etc.).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Um DataFrame do Polars contendo os dados processados do leil\u00e3o. As colunas s\u00e3o:</p> <code>DataFrame</code> <ul> <li>data_1v: Data de realiza\u00e7\u00e3o do leil\u00e3o (1\u00aa volta).</li> </ul> <code>DataFrame</code> <ul> <li>data_liquidacao_1v: Data de liquida\u00e7\u00e3o financeira da 1\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>data_liquidacao_2v: Data de liquida\u00e7\u00e3o financeira da 2\u00aa volta (se houver).</li> </ul> <code>DataFrame</code> <ul> <li>numero_edital: N\u00famero do edital que rege o leil\u00e3o.</li> </ul> <code>DataFrame</code> <ul> <li>tipo_leilao: Tipo da opera\u00e7\u00e3o (ex: \"Venda\", \"Compra\").</li> </ul> <code>DataFrame</code> <ul> <li>titulo: C\u00f3digo do t\u00edtulo p\u00fablico leiloado (ex: \"NTN-B\", \"LFT\").</li> </ul> <code>DataFrame</code> <ul> <li>benchmark: Descri\u00e7\u00e3o de refer\u00eancia do t\u00edtulo (ex: \"NTN-B 3 anos\").</li> </ul> <code>DataFrame</code> <ul> <li>data_vencimento: Data de vencimento do t\u00edtulo.</li> </ul> <code>DataFrame</code> <ul> <li>dias_uteis: N\u00famero de dias \u00fateis entre a liquida\u00e7\u00e3o (1v) e o vencimento.</li> </ul> <code>DataFrame</code> <ul> <li>dias_corridos: Prazo em dias corridos do t\u00edtulo, conforme informado pela API.</li> </ul> <code>DataFrame</code> <ul> <li>duration: A Dura\u00e7\u00e3o de Macaulay do t\u00edtulo em anos, calculada entre a liquida\u00e7\u00e3o da 1\u00aa volta e o vencimento do t\u00edtulo.</li> </ul> <code>DataFrame</code> <ul> <li>prazo_medio: A maturidade m\u00e9dia do t\u00edtulo em anos, conforme metodologia do Tesouro, calculada entre a liquida\u00e7\u00e3o da 1\u00aa volta e o vencimento do t\u00edtulo.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_ofertada_1v: Quantidade de t\u00edtulos ofertados na 1\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_ofertada_2v: Quantidade de t\u00edtulos ofertados na 2\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_aceita_1v: Quantidade de t\u00edtulos com propostas aceitas na 1\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_aceita_2v: Quantidade de t\u00edtulos aceitos na 2\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_aceita_total: Soma das quantidades aceitas nas duas voltas.</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_ofertado_1v: Financeiro ofertado total na 1\u00aa volta (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_ofertado_2v: Financeiro ofertado total na 2\u00aa volta (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_ofertado_total: Financeiro total ofertado nas duas voltas (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_aceito_1v: Financeiro aceito total na 1\u00aa volta (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_aceito_2v: Financeiro aceito total na 2\u00aa volta (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_aceito_total: Soma do financeiro aceito nas duas voltas (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_bcb: Quantidade de t\u00edtulos adquirida pelo Banco Central.</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_bcb: Financeiro adquirido pelo Banco Central.</li> </ul> <code>DataFrame</code> <ul> <li>colocacao_1v: Taxa de coloca\u00e7\u00e3o da 1\u00aa volta (quantidade aceita / ofertada).</li> </ul> <code>DataFrame</code> <ul> <li>colocacao_2v: Taxa de coloca\u00e7\u00e3o da 2\u00aa volta (quantidade aceita / ofertada).</li> </ul> <code>DataFrame</code> <ul> <li>colocacao_total: Taxa de coloca\u00e7\u00e3o total (quantidade aceita / ofertada).</li> </ul> <code>DataFrame</code> <ul> <li>dv01_1v: DV01 da 1\u00aa volta em BRL.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_2v: DV01 da 2\u00aa volta em BRL.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_total: DV01 total do leil\u00e3o em BRL.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_1v_usd: DV01 da 1\u00aa volta em USD usando a PTAX do dia.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_2v_usd: DV01 da 2\u00aa volta em USD usando a PTAX do dia.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_total_usd: DV01 total das duas voltas em USD usando a PTAX do dia.</li> </ul> <code>DataFrame</code> <ul> <li>pu_minimo: Pre\u00e7o Unit\u00e1rio m\u00ednimo aceito no leil\u00e3o.</li> </ul> <code>DataFrame</code> <ul> <li>pu_medio: Pre\u00e7o Unit\u00e1rio m\u00e9dio ponderado das propostas aceitas.</li> </ul> <code>DataFrame</code> <ul> <li>tipo_pu_medio: Indica se o PU m\u00e9dio \u00e9 \"original\" (fornecido pela API) ou \"calculado\" (recalculado pela fun\u00e7\u00e3o).</li> </ul> <code>DataFrame</code> <ul> <li>taxa_media: Taxa de juros m\u00e9dia das propostas aceitas (em formato decimal).</li> </ul> <code>DataFrame</code> <ul> <li>taxa_maxima: Taxa de juros m\u00e1xima aceita no leil\u00e3o (taxa de corte, em formato decimal).</li> </ul> <p>Retorna um DataFrame do Pandas vazio se ocorrer um erro na requisi\u00e7\u00e3o, no processamento, ou se n\u00e3o houver dados para a data especificada.</p> Source code in <code>pyield/tn/auctions.py</code> <pre><code>def auction(auction_date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches and processes Brazilian Treasury auction data for a given date.\n\n    This function queries the Tesouro Nacional API to retrieve auction results\n    for a specific date. It then processes the JSON response using the Polars\n    library to create a well-structured and typed DataFrame.\n\n    Exemplo de resposta da API de leil\u00f5es do Tesouro:\n    https://apiapex.tesouro.gov.br/aria/v1/api-leiloes-pub/custom/resultados?dataleilao=30/09/2025\n\n        {\n        \"registros\": [\n            {...},\n            {\n            \"quantidade_bcb\": 0,\n            \"liquidacao_segunda_volta\": \"30/09/2025\",\n            \"oferta_segunda_volta\": 37499,\n            \"data_leilao\": \"30/09/2025\",\n            \"oferta\": 150000,\n            \"titulo\": \"LFT\",\n            \"liquidacao\": \"01/10/2025\",\n            \"financeiro_aceito_segunda_volta\": 0,\n            \"quantidade_aceita\": 150000,\n            \"prazo\": 1067,\n            \"vencimento\": \"01/09/2028\",\n            \"benchmark\": \"LFT 3 anos\",\n            \"pu_medio\": 17434.81182753125,\n            \"taxa_media\": 0.0669,\n            \"financeiro_aceito\": 2615194916.22,\n            \"pu_minimo\": 17434.632775,\n            \"numero_edital\": 230,\n            \"taxa_maxima\": 0.0669,\n            \"tipo_leilao\": \"Venda\",\n            \"financeiro_bcb\": 0,\n            \"quantidade_aceita_segunda_volta\": 0\n            },\n            {...},\n        ],\n        \"status\": \"ok\"\n        }\n\n    Args:\n        auction_date: The date of the auction in the format accepted by PYield\n            DateLike (e.g., \"DD-MM-YYYY\", datetime.date, etc.).\n\n    Returns:\n        Um DataFrame do Polars contendo os dados processados do leil\u00e3o. As colunas s\u00e3o:\n        - data_1v: Data de realiza\u00e7\u00e3o do leil\u00e3o (1\u00aa volta).\n        - data_liquidacao_1v: Data de liquida\u00e7\u00e3o financeira da 1\u00aa volta.\n        - data_liquidacao_2v: Data de liquida\u00e7\u00e3o financeira da 2\u00aa volta (se houver).\n        - numero_edital: N\u00famero do edital que rege o leil\u00e3o.\n        - tipo_leilao: Tipo da opera\u00e7\u00e3o (ex: \"Venda\", \"Compra\").\n        - titulo: C\u00f3digo do t\u00edtulo p\u00fablico leiloado (ex: \"NTN-B\", \"LFT\").\n        - benchmark: Descri\u00e7\u00e3o de refer\u00eancia do t\u00edtulo (ex: \"NTN-B 3 anos\").\n        - data_vencimento: Data de vencimento do t\u00edtulo.\n        - dias_uteis: N\u00famero de dias \u00fateis entre a liquida\u00e7\u00e3o (1v) e o vencimento.\n        - dias_corridos: Prazo em dias corridos do t\u00edtulo, conforme informado pela API.\n        - duration: A Dura\u00e7\u00e3o de Macaulay do t\u00edtulo em anos, calculada entre a\n            liquida\u00e7\u00e3o da 1\u00aa volta e o vencimento do t\u00edtulo.\n        - prazo_medio: A maturidade m\u00e9dia do t\u00edtulo em anos, conforme metodologia do\n            Tesouro, calculada entre a liquida\u00e7\u00e3o da 1\u00aa volta e o vencimento do t\u00edtulo.\n        - quantidade_ofertada_1v: Quantidade de t\u00edtulos ofertados na 1\u00aa volta.\n        - quantidade_ofertada_2v: Quantidade de t\u00edtulos ofertados na 2\u00aa volta.\n        - quantidade_aceita_1v: Quantidade de t\u00edtulos com propostas aceitas na 1\u00aa volta.\n        - quantidade_aceita_2v: Quantidade de t\u00edtulos aceitos na 2\u00aa volta.\n        - quantidade_aceita_total: Soma das quantidades aceitas nas duas voltas.\n        - financeiro_ofertado_1v: Financeiro ofertado total na 1\u00aa volta (em BRL).\n        - financeiro_ofertado_2v: Financeiro ofertado total na 2\u00aa volta (em BRL).\n        - financeiro_ofertado_total: Financeiro total ofertado nas duas voltas (em BRL).\n        - financeiro_aceito_1v: Financeiro aceito total na 1\u00aa volta (em BRL).\n        - financeiro_aceito_2v: Financeiro aceito total na 2\u00aa volta (em BRL).\n        - financeiro_aceito_total: Soma do financeiro aceito nas duas voltas (em BRL).\n        - quantidade_bcb: Quantidade de t\u00edtulos adquirida pelo Banco Central.\n        - financeiro_bcb: Financeiro adquirido pelo Banco Central.\n        - colocacao_1v: Taxa de coloca\u00e7\u00e3o da 1\u00aa volta (quantidade aceita / ofertada).\n        - colocacao_2v: Taxa de coloca\u00e7\u00e3o da 2\u00aa volta (quantidade aceita / ofertada).\n        - colocacao_total: Taxa de coloca\u00e7\u00e3o total (quantidade aceita / ofertada).\n        - dv01_1v: DV01 da 1\u00aa volta em BRL.\n        - dv01_2v: DV01 da 2\u00aa volta em BRL.\n        - dv01_total: DV01 total do leil\u00e3o em BRL.\n        - dv01_1v_usd: DV01 da 1\u00aa volta em USD usando a PTAX do dia.\n        - dv01_2v_usd: DV01 da 2\u00aa volta em USD usando a PTAX do dia.\n        - dv01_total_usd: DV01 total das duas voltas em USD usando a PTAX do dia.\n        - pu_minimo: Pre\u00e7o Unit\u00e1rio m\u00ednimo aceito no leil\u00e3o.\n        - pu_medio: Pre\u00e7o Unit\u00e1rio m\u00e9dio ponderado das propostas aceitas.\n        - tipo_pu_medio: Indica se o PU m\u00e9dio \u00e9 \"original\" (fornecido pela API) ou\n            \"calculado\" (recalculado pela fun\u00e7\u00e3o).\n        - taxa_media: Taxa de juros m\u00e9dia das propostas aceitas (em formato decimal).\n        - taxa_maxima: Taxa de juros m\u00e1xima aceita no leil\u00e3o (taxa de corte, em formato\n            decimal).\n\n    Retorna um DataFrame do Pandas vazio se ocorrer um erro na requisi\u00e7\u00e3o, no\n    processamento, ou se n\u00e3o houver dados para a data especificada.\n    \"\"\"\n    if has_nullable_args(auction_date):\n        logger.info(\"No auction date provided.\")\n        return pl.DataFrame()\n    try:\n        auction_date = cv.convert_dates(auction_date)\n        data = _fetch_auction_data(auction_date)\n        if not data:\n            logger.info(f\"No auction data available for {auction_date}.\")\n            return pl.DataFrame()\n        df = _transform_raw_data(data)\n        df = _add_duration(df)\n        df = _add_dv01(df)\n        df = _add_dv01_usd(df)\n        df = _add_avg_maturity(df)\n        df = df.select(FINAL_COLUMN_ORDER)\n\n        # Substituir eventuais NaNs por None para compatibilidade com bancos de dados\n        df = df.with_columns(cs.float().fill_nan(None))\n        return df\n\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"An error occurred during the API request: {e}\")\n        return pl.DataFrame()\n    except (ValueError, TypeError) as e:\n        logger.error(f\"An error occurred while parsing the JSON response: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"tn/#pyield.tn.benchmarks","title":"<code>benchmarks(bond_type=None, include_history=False)</code>","text":"<p>Fetches benchmark data for Brazilian Treasury Bonds from the TN API.</p> <p>This function retrieves current or historical benchmark data for various Brazilian Treasury bond types (e.g., LTN, LFT, NTN-B). The data is sourced directly from the official Tesouro Nacional API.</p> <p>Parameters:</p> Name Type Description Default <code>include_history</code> <code>bool</code> <p>If <code>True</code>, includes historical benchmark data. If <code>False</code> (default), only current benchmarks are returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A Polars DataFrame containing the benchmark data. The DataFrame includes the following columns: *   <code>BondType</code> (str): The type of the bond (e.g., 'LTN', 'LFT', 'NTN-B'). *   <code>MaturityDate</code> (datetime.date): The maturity date of the benchmark. *   <code>Benchmark</code> (str): The name or identifier of the benchmark     (e.g., 'LFT 3 anos'). *   <code>StartDate</code> (datetime.date): The start date for the benchmark's period. *   <code>EndDate</code> (datetime.date): The end date for the benchmark's period.</p> Notes <ul> <li>Data is sourced from the official Tesouro Nacional (Brazilian Treasury) API.</li> <li>An retry mechanism is implemented for SSL certificate verification errors.</li> <li>The API documentation can be found at:     https://portal-conhecimento.tesouro.gov.br/catalogo-componentes/api-leil%C3%B5es</li> <li>Rows with any <code>NaN</code> values are dropped before returning the DataFrame.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import tn\n&gt;&gt;&gt; df_current = tn.benchmarks()\n&gt;&gt;&gt; # Get historical benchmarks\n&gt;&gt;&gt; tn.benchmarks(bond_type=\"LFT\", include_history=True).head()\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 Benchmark  \u2506 StartDate  \u2506 EndDate    \u2502\n\u2502 ---      \u2506 ---          \u2506 ---        \u2506 ---        \u2506 ---        \u2502\n\u2502 str      \u2506 date         \u2506 str        \u2506 date       \u2506 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LFT      \u2506 2020-03-01   \u2506 LFT 6 anos \u2506 2014-01-01 \u2506 2014-06-30 \u2502\n\u2502 LFT      \u2506 2020-09-01   \u2506 LFT 6 anos \u2506 2014-07-01 \u2506 2014-12-31 \u2502\n\u2502 LFT      \u2506 2021-03-01   \u2506 LFT 6 anos \u2506 2015-01-01 \u2506 2015-04-30 \u2502\n\u2502 LFT      \u2506 2021-09-01   \u2506 LFT 6 anos \u2506 2015-05-01 \u2506 2015-12-31 \u2502\n\u2502 LFT      \u2506 2022-03-01   \u2506 LFT 6 anos \u2506 2016-01-01 \u2506 2016-06-30 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/benchmark.py</code> <pre><code>def benchmarks(bond_type: str = None, include_history: bool = False) -&gt; pl.DataFrame:\n    \"\"\"Fetches benchmark data for Brazilian Treasury Bonds from the TN API.\n\n    This function retrieves current or historical benchmark data for various Brazilian\n    Treasury bond types (e.g., LTN, LFT, NTN-B). The data is sourced directly from the\n    official Tesouro Nacional API.\n\n    Args:\n        include_history (bool, optional): If `True`, includes historical benchmark data.\n            If `False` (default), only current benchmarks are returned.\n\n    Returns:\n        pl.DataFrame: A Polars DataFrame containing the benchmark data.\n            The DataFrame includes the following columns:\n            *   `BondType` (str): The type of the bond (e.g., 'LTN', 'LFT', 'NTN-B').\n            *   `MaturityDate` (datetime.date): The maturity date of the benchmark.\n            *   `Benchmark` (str): The name or identifier of the benchmark\n                (e.g., 'LFT 3 anos').\n            *   `StartDate` (datetime.date): The start date for the benchmark's period.\n            *   `EndDate` (datetime.date): The end date for the benchmark's period.\n\n    Notes:\n        *   Data is sourced from the official Tesouro Nacional (Brazilian Treasury) API.\n        *   An retry mechanism is implemented for SSL certificate verification errors.\n        *   The API documentation can be found at:\n            https://portal-conhecimento.tesouro.gov.br/catalogo-componentes/api-leil%C3%B5es\n        *   Rows with any `NaN` values are dropped before returning the DataFrame.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import tn\n        &gt;&gt;&gt; df_current = tn.benchmarks()\n        &gt;&gt;&gt; # Get historical benchmarks\n        &gt;&gt;&gt; tn.benchmarks(bond_type=\"LFT\", include_history=True).head()\n        shape: (5, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 Benchmark  \u2506 StartDate  \u2506 EndDate    \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---        \u2506 ---        \u2506 ---        \u2502\n        \u2502 str      \u2506 date         \u2506 str        \u2506 date       \u2506 date       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LFT      \u2506 2020-03-01   \u2506 LFT 6 anos \u2506 2014-01-01 \u2506 2014-06-30 \u2502\n        \u2502 LFT      \u2506 2020-09-01   \u2506 LFT 6 anos \u2506 2014-07-01 \u2506 2014-12-31 \u2502\n        \u2502 LFT      \u2506 2021-03-01   \u2506 LFT 6 anos \u2506 2015-01-01 \u2506 2015-04-30 \u2502\n        \u2502 LFT      \u2506 2021-09-01   \u2506 LFT 6 anos \u2506 2015-05-01 \u2506 2015-12-31 \u2502\n        \u2502 LFT      \u2506 2022-03-01   \u2506 LFT 6 anos \u2506 2016-01-01 \u2506 2016-06-30 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    api_data = _fetch_raw_benchmarks(include_history=include_history)\n    df = _process_api_data(api_data)\n\n    # Definir a ordena\u00e7\u00e3o final com base no caso de uso\n    if include_history:\n        # Para dados hist\u00f3ricos, a ordem cronol\u00f3gica \u00e9 mais \u00fatil\n        sort_columns = [\"StartDate\", \"BondType\", \"MaturityDate\"]\n    else:\n        # Para dados atuais, agrupar por tipo de t\u00edtulo \u00e9 mais \u00fatil\n        sort_columns = [\"BondType\", \"MaturityDate\"]\n        # Filtrar apenas os dados atuais\n        today = clock.today()\n        df = df.filter(pl.lit(today).is_between(pl.col(\"StartDate\"), pl.col(\"EndDate\")))\n\n    if bond_type:\n        df = df.filter(pl.col(\"BondType\") == bond_type)\n\n    return df.select(FINAL_COLUMN_ORDER).sort(sort_columns)\n</code></pre>"},{"location":"tn/#pyield.tn.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>spread = taxa indicativa do PRE - taxa de ajuste do DI</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - BondType - MaturityDate - DISpread (decimal ou bps conforme par\u00e2metro)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\nshape: (18, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def di_spreads(date: DateLike, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    spread = taxa indicativa do PRE - taxa de ajuste do DI\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Default False.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - BondType\n            - MaturityDate\n            - DISpread (decimal ou bps conforme par\u00e2metro)\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\n        shape: (18, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Fetch bond rates, filtering for LTN and NTN-F types\n    df = (\n        tpf.tpf_data(date, \"PRE\")\n        .with_columns(DISpread=pl.col(\"IndicativeRate\") - pl.col(\"DIRate\"))\n        .select(\"BondType\", \"MaturityDate\", \"DISpread\")\n        .sort(\"BondType\", \"MaturityDate\")\n    )\n\n    if bps:\n        df = df.with_columns(pl.col(\"DISpread\") * 10_000)\n\n    return df\n</code></pre>"},{"location":"articles/pyield_intro/","title":"Introdu\u00e7\u00e3o ao PYield","text":""},{"location":"articles/pyield_intro/#pyield-analise-de-renda-fixa-brasileira-em-python","title":"PYield: An\u00e1lise de Renda Fixa Brasileira em Python","text":""},{"location":"articles/pyield_intro/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Qualquer pessoa que trabalhe com an\u00e1lise de renda fixa no Brasil sabe que a obten\u00e7\u00e3o de dados de fontes como ANBIMA, B3 e Banco Central pode ser uma tarefa trabalhosa. \u00c9 preciso lidar com diferentes APIs, formatos de dados variados e, frequentemente, processar informa\u00e7\u00f5es diretamente de sites. Para quem n\u00e3o tem acesso a terminais pagos como Bloomberg, esse desafio se torna ainda maior.</p> <p>Al\u00e9m disso, h\u00e1 a complexidade do calend\u00e1rio de dias \u00fateis brasileiro. Feriados nacionais, estaduais e municipais precisam ser considerados em praticamente todos os c\u00e1lculos financeiros - desde a apura\u00e7\u00e3o de taxas at\u00e9 a precifica\u00e7\u00e3o de t\u00edtulos. Essa \u00e9 uma funcionalidade b\u00e1sica, mas essencial para qualquer an\u00e1lise de renda fixa.</p> <p>PYield foi criado para resolver esses problemas. \u00c9 uma biblioteca Python que centraliza a obten\u00e7\u00e3o e processamento de dados de instrumentos de renda fixa brasileiros, oferecendo uma API unificada e consistente.</p>"},{"location":"articles/pyield_intro/#o-que-e-pyield","title":"O que \u00e9 PYield?","text":"<p>PYield \u00e9 uma biblioteca Python especializada em an\u00e1lise de renda fixa brasileira. Ela busca e processa dados de m\u00faltiplas fontes:</p> <ul> <li>ANBIMA: Taxas indicativas de t\u00edtulos p\u00fablicos, curvas de juros (ETTJ), \u00edndices IMA</li> <li>Banco Central (BCB): SELIC, PTAX, taxas de reposit\u00f3rio, VNA</li> <li>B3: Futuros de DI, DDI, cupom cambial e outros contratos</li> <li>IBGE: Dados de infla\u00e7\u00e3o (IPCA)</li> </ul> <p>Todos os dados retornados pela biblioteca s\u00e3o Polars DataFrames ou Series, proporcionando alto desempenho e seguran\u00e7a de tipos para pipelines de dados modernos.</p>"},{"location":"articles/pyield_intro/#caracteristicas-principais","title":"Caracter\u00edsticas Principais","text":"<ul> <li>Coleta unificada de dados: Uma \u00fanica biblioteca para acessar ANBIMA, BCB, B3 e IBGE</li> <li>API consistente: Todos os m\u00f3dulos seguem as mesmas conven\u00e7\u00f5es de nomenclatura e assinaturas de fun\u00e7\u00e3o</li> <li>Retorno em Polars: DataFrames e Series do Polars para pipelines r\u00e1pidos e type-safe</li> <li>Calend\u00e1rio de dias \u00fateis: Fun\u00e7\u00f5es completas para contagem e gera\u00e7\u00e3o de dias \u00fateis com feriados brasileiros integrados</li> <li>Precifica\u00e7\u00e3o de t\u00edtulos: C\u00e1lculo de cota\u00e7\u00f5es, pre\u00e7os e spreads de t\u00edtulos p\u00fablicos</li> <li>Interpola\u00e7\u00e3o de taxas: Suporte para interpola\u00e7\u00e3o linear e flat forward (padr\u00e3o de mercado) usando conven\u00e7\u00e3o 252 dias \u00fateis/ano</li> <li>Convers\u00e3o flex\u00edvel de datas: Aceita diversos formatos de entrada (strings DD-MM-YYYY, DD/MM/YYYY, YYYY-MM-DD, objetos datetime, etc.)</li> </ul>"},{"location":"articles/pyield_intro/#instalacao","title":"Instala\u00e7\u00e3o","text":"<p>A instala\u00e7\u00e3o \u00e9 simples via pip:</p> <pre><code>pip install pyield\n</code></pre> <p>Requisitos: Python &gt;= 3.12</p>"},{"location":"articles/pyield_intro/#exemplos-praticos","title":"Exemplos Pr\u00e1ticos","text":""},{"location":"articles/pyield_intro/#1-dias-uteis-business-days","title":"1. Dias \u00dateis (Business Days)","text":"<p>O m\u00f3dulo <code>bday</code> \u00e9 a base de todos os c\u00e1lculos na biblioteca. Feriados brasileiros s\u00e3o automaticamente considerados.</p> <pre><code>import pyield as yd\n\n# Contar dias \u00fateis entre duas datas (in\u00edcio inclusivo, fim exclusivo)\nyd.bday.count(\"29-12-2023\", \"02-01-2024\")  # -&gt; 1\n\n# Avan\u00e7ar N dias \u00fateis a partir de uma data\nyd.bday.offset(\"29-12-2023\", 1)  # -&gt; datetime.date(2024, 1, 2)\n\n# Ajustar data para o pr\u00f3ximo dia \u00fatil (se n\u00e3o for dia \u00fatil)\nyd.bday.offset(\"30-12-2023\", 0)  # -&gt; datetime.date(2024, 1, 2)\n\n# Como 29-12-2023 j\u00e1 \u00e9 dia \u00fatil, retorna a mesma data\nyd.bday.offset(\"29-12-2023\", 0)  # -&gt; datetime.date(2023, 12, 29)\n\n# Gerar s\u00e9rie de dias \u00fateis entre duas datas\nyd.bday.generate(\"22-12-2023\", \"02-01-2024\")\n# -&gt; Polars Series: [2023-12-22, 2023-12-26, 2023-12-27, 2023-12-28, 2023-12-29, 2024-01-02]\n\n# Verificar se \u00e9 dia \u00fatil\nyd.bday.is_business_day(\"25-12-2023\")  # -&gt; False (Natal)\n</code></pre> <p>Todas as fun\u00e7\u00f5es suportam opera\u00e7\u00f5es vetorizadas com listas, Series ou arrays.</p>"},{"location":"articles/pyield_intro/#2-futuros-de-di-b3","title":"2. Futuros de DI (B3)","text":"<p>Obtenha dados de contratos futuros negociados na B3:</p> <pre><code># Dados de Futuros de DI em uma data espec\u00edfica\ndf = yd.futures(\"31-05-2024\", \"DI1\")\n\n# DataFrame retornado cont\u00e9m colunas:\n# TradeDate, TickerSymbol, ExpirationDate, BDaysToExp, SettlementRate,\n# OpeningRate, MinRate, MaxRate, TradesCount, ContractsCount, Volume, ...\n\n# Outros contratos dispon\u00edveis: DDI, FRC, DAP, DOL, WDO, IND, WIN\ndf_dap = yd.futures(\"31-05-2024\", \"DAP\")  # Cupom Cambial\n</code></pre>"},{"location":"articles/pyield_intro/#3-titulos-publicos-tesouro-nacional","title":"3. T\u00edtulos P\u00fablicos (Tesouro Nacional)","text":"<p>Acesse taxas indicativas da ANBIMA e dados de t\u00edtulos p\u00fablicos:</p> <pre><code># LTN (Letras do Tesouro Nacional - pr\u00e9-fixado)\ndf_ltn = yd.ltn.data(\"23-08-2024\")\n# Colunas: BondType, ReferenceDate, MaturityDate, BidRate, AskRate, IndicativeRate\n\n# NTN-B (Notas do Tesouro Nacional s\u00e9rie B - IPCA+)\ndf_ntnb = yd.ntnb.data(\"23-08-2024\")\n# Colunas: BondType, ReferenceDate, MaturityDate, BidRate, AskRate, IndicativeRate, VNA\n\n# NTN-F (Notas do Tesouro Nacional s\u00e9rie F - pr\u00e9-fixado com cupom)\ndf_ntnf = yd.ntnf.data(\"23-08-2024\")\n\n# Obs: Dados da ANBIMA est\u00e3o dispon\u00edveis para os \u00faltimos 5 dias \u00fateis\n# (membros da ANBIMA t\u00eam acesso autom\u00e1tico ao hist\u00f3rico completo)\n</code></pre>"},{"location":"articles/pyield_intro/#4-precificacao-de-titulos","title":"4. Precifica\u00e7\u00e3o de T\u00edtulos","text":"<p>Calcule cota\u00e7\u00f5es e pre\u00e7os de t\u00edtulos p\u00fablicos:</p> <pre><code># Cota\u00e7\u00e3o de NTN-B (base 100)\nyd.ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)  # -&gt; 99.3651\n\n# Cota\u00e7\u00e3o para vencimento mais longo\nyd.ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)  # -&gt; 99.5341\n\n# Spreads DI para t\u00edtulos pr\u00e9-fixados (em pontos-base)\ndf_spreads = yd.ltn.di_spreads(\"30-05-2024\", bps=True)\n# Colunas: BondType, MaturityDate, DISpread\n\n# Spreads para NTN-F\ndf_spreads_ntnf = yd.ntnf.di_spreads(\"30-05-2024\", bps=True)\n</code></pre>"},{"location":"articles/pyield_intro/#5-interpolacao-de-taxas","title":"5. Interpola\u00e7\u00e3o de Taxas","text":"<p>Interpolar taxas de juros usando conven\u00e7\u00e3o de mercado (252 dias \u00fateis/ano):</p> <pre><code># Obter curva de DI Futuro\ndf = yd.futures(\"31-05-2024\", \"DI1\")\n\n# Criar interpolador flat forward (padr\u00e3o de mercado)\ninterp = yd.Interpolator(\"flat_forward\", df[\"BDaysToExp\"], df[\"SettlementRate\"])\n\n# Interpolar para 45 dias \u00fateis\ninterp(45)  # -&gt; Taxa interpolada (ex: 0.1037)\n\n# Vetorizado\ninterp([30, 60, 90])  # -&gt; Polars Series com 3 taxas interpoladas\n\n# Interpola\u00e7\u00e3o linear (alternativa)\nlinear_interp = yd.Interpolator(\"linear\", df[\"BDaysToExp\"], df[\"SettlementRate\"])\nlinear_interp(45)  # -&gt; Taxa interpolada linearmente\n</code></pre>"},{"location":"articles/pyield_intro/#6-indicadores-do-banco-central","title":"6. Indicadores do Banco Central","text":"<p>Acesse indicadores econ\u00f4micos do BCB:</p> <pre><code># SELIC Over (taxa anualizada)\nyd.bc.selic_over(\"31-05-2024\")  # -&gt; 0.104  (10.4% a.a.)\n\n# PTAX (taxa de c\u00e2mbio oficial)\nyd.bc.ptax(\"31-05-2024\")  # -&gt; 5.4407\n\n# DI Over (taxa anualizada do mercado interbanc\u00e1rio)\nyd.bc.di_over(\"31-05-2024\")  # -&gt; 0.104  (10.4% a.a.)\n\n# Taxa SELIC meta (definida pelo COPOM)\nyd.bc.selic_target(\"31-05-2024\")  # -&gt; 0.1075  (10.75% a.a.)\n\n# VNA da LFT (Valor Nominal Atualizado)\nyd.bc.vna_lft(\"31-05-2024\")  # -&gt; 15234.56\n</code></pre>"},{"location":"articles/pyield_intro/#7-inflacao-ipca","title":"7. Infla\u00e7\u00e3o (IPCA)","text":"<p>Obtenha dados de infla\u00e7\u00e3o do IBGE:</p> <pre><code># Taxas mensais de IPCA\ndf_ipca = yd.ipca.rates(\"01-01-2024\", \"01-03-2024\")\n# Colunas: ReferenceDate, Rate\n\n# \u00cdndices de IPCA\ndf_indices = yd.ipca.indexes(\"01-01-2024\", \"01-03-2024\")\n# Colunas: ReferenceDate, Index\n\n# Proje\u00e7\u00f5es futuras (quando dispon\u00edveis)\ndf_proj = yd.ipca.rates(\"01-01-2025\", \"01-12-2025\")\n</code></pre>"},{"location":"articles/pyield_intro/#conversao-para-pandas","title":"Convers\u00e3o para Pandas","text":"<p>Embora PYield retorne Polars DataFrames por padr\u00e3o (desde a vers\u00e3o 0.40.0), \u00e9 f\u00e1cil converter para Pandas quando necess\u00e1rio:</p> <pre><code>import pyield as yd\n\n# Obter DataFrame Polars\ndf_polars = yd.ltn.data(\"23-08-2024\")\n\n# Converter para Pandas\ndf_pandas = df_polars.to_pandas(use_pyarrow_extension_array=True)\n</code></pre> <p>A convers\u00e3o com <code>use_pyarrow_extension_array=True</code> mant\u00e9m a compatibilidade de tipos e oferece melhor desempenho.</p>"},{"location":"articles/pyield_intro/#manuseio-de-datas","title":"Manuseio de Datas","text":"<p>PYield aceita formatos flex\u00edveis de data (<code>DateLike</code>):</p> <ul> <li>Strings: <code>\"31-05-2024\"</code>, <code>\"31/05/2024\"</code>, <code>\"2024-05-31\"</code></li> <li>Objetos Python: <code>datetime.date</code>, <code>datetime.datetime</code></li> <li>Objetos Pandas/NumPy: <code>pandas.Timestamp</code>, <code>numpy.datetime64</code></li> </ul> <p>Fun\u00e7\u00f5es escalares retornam <code>datetime.date</code>. Fun\u00e7\u00f5es vetorizadas retornam <code>polars.Series</code>.</p> <p>Para valores nulos, fun\u00e7\u00f5es escalares retornam <code>float('nan')</code>. Fun\u00e7\u00f5es vetorizadas propagam <code>null</code> element-wise:</p> <pre><code># Exemplo com null\nyd.ntnb.quotation(None, \"15-05-2035\", 0.06149)  # -&gt; nan\nyd.bday.count([\"01-01-2024\", None], \"01-02-2024\")  # -&gt; Series: [22, null]\n</code></pre>"},{"location":"articles/pyield_intro/#recursos-adicionais","title":"Recursos Adicionais","text":""},{"location":"articles/pyield_intro/#colab-notebook","title":"Colab Notebook","text":"<p>Um notebook interativo com exemplos pr\u00e1ticos est\u00e1 dispon\u00edvel no Google Colab:</p> <p></p>"},{"location":"articles/pyield_intro/#documentacao-completa","title":"Documenta\u00e7\u00e3o Completa","text":"<p>A documenta\u00e7\u00e3o completa com refer\u00eancia da API est\u00e1 dispon\u00edvel em: https://crdcj.github.io/PYield/</p>"},{"location":"articles/pyield_intro/#codigo-fonte","title":"C\u00f3digo-Fonte","text":"<p>O c\u00f3digo da biblioteca \u00e9 open source e est\u00e1 hospedado no GitHub: https://github.com/crdcj/PYield</p>"},{"location":"articles/pyield_intro/#conclusao","title":"Conclus\u00e3o","text":"<p>PYield oferece uma solu\u00e7\u00e3o integrada para an\u00e1lise de renda fixa brasileira em Python. Com uma API unificada, suporte para m\u00faltiplas fontes de dados e retorno em Polars DataFrames, a biblioteca permite que voc\u00ea foque na an\u00e1lise em vez de se preocupar com a obten\u00e7\u00e3o e processamento de dados.</p> <p>Se voc\u00ea trabalha com renda fixa no Brasil - seja como analista, pesquisador ou desenvolvedor - PYield pode acelerar significativamente seu fluxo de trabalho.</p> <p>Contribui\u00e7\u00f5es s\u00e3o bem-vindas! Entre em contato: cr.cj@outlook.com</p>"}]}