{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyield-brazilian-fixed-income-toolkit","title":"PYield: Brazilian Fixed Income Toolkit","text":"<p>PYield is a Python library designed for the analysis of Brazilian fixed income instruments. Leveraging the power of popular Python libraries like Pandas and Requests, PYield simplifies the process of obtaining and processing data from key sources such as ANBIMA, BCB, IBGE and B3.</p> <p>Documentation: https://crdcj.github.io/PYield/</p> <p>Source Code: https://github.com/crdcj/PYield</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Data Collection: Automated fetching of data from ANBIMA and B3.</li> <li>Data Processing: Efficient processing and normalization of fixed income data.</li> <li>Analysis Tools: Built-in functions for common analysis tasks in fixed income markets.</li> <li>Easy Integration: Seamless integration with pandas data analysis workflows.</li> <li>Type Hints: Full support for static type checking, enhancing development experience and code quality.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install PYield using pip: <pre><code>pip install pyield\n</code></pre></p>"},{"location":"#how-to-use-pyield","title":"How to use PYield","text":""},{"location":"#important-note-on-date-formats","title":"Important Note on Date Formats","text":"<p>When using date strings in PYield functions, please ensure that the date format is day-first (e.g., \"31-05-2024\"). This format was chosen to be consistent with the Brazilian date convention.</p> <p>For production code, it is recommended to parse date strings with <code>pandas.to_datetime</code> using an explicit format to avoid ambiguity and ensure consistency.</p> <p>For example: <pre><code>import pandas as pd\n# Converting a date string to a pandas Timestamp with a specific format\ndate = pd.to_datetime(\"2024/31/05\", format=\"%Y/%d/%m\")\ndate = pd.to_datetime(\"05-31-2024\", format=\"%m-%d-%Y\")\n</code></pre></p>"},{"location":"#brazilian-treasury-bonds-tools","title":"Brazilian Treasury Bonds Tools","text":"<pre><code>&gt;&gt;&gt; from pyield import ntnb, ntnf, ltn\n\n# Calculate the quotation of a NTN-B bond as per ANBIMA's rules\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n\n# Calculate the DI Spread of NTN-F bonds in a given date\n&gt;&gt;&gt; ntnf.di_spreads(\"17-07-2024\")\n2025-01-01   -2.31\n2027-01-01   -1.88\n2029-01-01   -3.26\n2031-01-01    3.61\n2033-01-01   -3.12\n2035-01-01   -1.00\nName: DISpread, dtype: Float64\n\n# Get ANBIMA's indicative rates for LTN bonds\n&gt;&gt;&gt; ltn.anbima_rates(\"17-07-2024\")\n2024-10-01    0.104236\n2025-01-01    0.105400\n2025-04-01    0.107454\n2025-07-01    0.108924\n2025-10-01    0.110751\n2026-01-01    0.111753\n2026-04-01    0.112980\n2026-07-01    0.113870\n2026-10-01    0.114592\n2027-07-01    0.116090\n2028-01-01    0.117160\n2028-07-01    0.118335\n2030-01-01    0.120090\nName: IndicativeRate, dtype: Float64\n</code></pre>"},{"location":"#business-days-tools-brazilian-holidays-are-automatically-considered","title":"Business Days Tools (Brazilian holidays are automatically considered)","text":"<pre><code>&gt;&gt;&gt; from pyield import bday\n# Count the number of business days between two dates\n# Start date is included, end date is excluded\n&gt;&gt;&gt; bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Get the next business day after a given date (offset=1)\n&gt;&gt;&gt; bday.offset(dates=\"29-12-2023\", offset=1)\nTimestamp('2024-01-02 00:00:00')\n\n# Get the next business day if it is not a business day (offset=0)\n&gt;&gt;&gt; bday.offset(dates=\"30-12-2023\", offset=0)\nTimestamp('2024-01-02 00:00:00')\n\n# Since 29-12-2023 is a business day, it returns the same date (offset=0)\n&gt;&gt;&gt; bday.offset(dates=\"29-12-2023\", offset=0)\nTimestamp('2023-12-29 00:00:00')\n\n# Generate a pandas series with the business days between two dates\n&gt;&gt;&gt; bday.generate(start='29-12-2023', end='03-01-2024')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\ndtype: datetime64[ns]\n</code></pre>"},{"location":"#futures-data","title":"Futures Data","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n# Fetch current DI Futures data from B3 (15 minutes delay)\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\")\nTradeTime      TickerSymbol ExpirationDate BDaysToExp ... MaxRate LastAskRate LastBidRate CurrentRate\n2024-04-21 13:37:39       DI1K24     2024-05-02          7 ... 0.10660     0.10652     0.10660  0.10660\n2024-04-21 13:37:39       DI1M24     2024-06-03         28 ... 0.10518     0.10510     0.10516  0.10518\n2024-04-21 13:37:39       DI1N24     2024-07-01         48 ... 0.10480     0.10456     0.10462  0.10460\n                ...          ...            ...        ... ...     ...         ...         ...      ...\n2024-04-21 13:37:39       DI1F37     2037-01-02       3183 ...    &lt;NA&gt;        &lt;NA&gt;     0.11600     &lt;NA&gt;\n2024-04-21 13:37:39       DI1F38     2038-01-04       3432 ...    &lt;NA&gt;        &lt;NA&gt;     0.11600     &lt;NA&gt;\n2024-04-21 13:37:39       DI1F39     2039-01-03       3683 ...    &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;     &lt;NA&gt;\n\n# Fetch historical DI Futures data from B3\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", reference_date='08-03-2024')\nTradeDate  TickerSymbol ExpirationDate BDaysToExp ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08       DI1J24     2024-04-01         15 ...   10.952      10.952      10.956         10.956\n2024-03-08       DI1K24     2024-05-02         37 ...   10.776      10.774      10.780         10.777\n2024-03-08       DI1M24     2024-06-03         58 ...   10.604      10.602      10.604         10.608\n       ...          ...            ...        ... ...      ...         ...         ...            ...\n2024-03-08       DI1F37     2037-01-02       3213 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.859\n2024-03-08       DI1F38     2038-01-04       3462 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.859\n2024-03-08       DI1F39     2039-01-03       3713 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.85\n</code></pre>"},{"location":"#indicators-data","title":"Indicators Data","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n# Fetch the SELIC target rate from the Central Bank of Brazil\n&gt;&gt;&gt; yd.indicator(indicator_code=\"SELIC_TARGET\", reference_date='12-04-2024')\n0.1075  # 10.75%\n\n# Fetch the IPCA monthly inflation rate from IBGE\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", reference_date='18-03-2024')\n0.0016  # 0.16%\n</code></pre>"},{"location":"#projections-data","title":"Projections Data","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n# Fetch current month projection for IPCA from IBGE API\n&gt;&gt;&gt; ipca = yd.projection(projection_code=\"IPCA_CM\")\n&gt;&gt;&gt; print(ipca)\nIndicatorProjection(\n    last_updated=Timestamp('2024-04-19 18:55:00'),\n    reference_month_ts=Timestamp('2024-04-01 00:00:00'),\n    reference_month_br='ABR/2024',\n    projected_value=0.0035  # 0.35%\n)\n&gt;&gt;&gt; ipca.projected_value\n0.0035  # 0.35%\n</code></pre>"},{"location":"#interpolation-tools","title":"Interpolation Tools","text":"<pre><code>&gt;&gt;&gt; from pyield import Interpolator\n# Interpolate interest rates for specific business days using the Interpolator class.\n\n# Initialize the Interpolator with known business days and interest rates.\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n&gt;&gt;&gt; linear_interpolator = Interpolator(\"linear\", known_bdays, known_rates)\n\n# Interpolate the interest rate for a given number of business days.\n&gt;&gt;&gt; linear_interpolator(45)\n0.0475\n\n# Use the flat forward method for interpolation.\n&gt;&gt;&gt; ff_interpolator = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; ff_interpolator(45)\n0.04833068080970859\n</code></pre>"},{"location":"anbima/","title":"Anbima Data (anbima)","text":""},{"location":"bday/","title":"Business Day Tool (bday)","text":""},{"location":"bday/#pyield.bday.BrHolidays","title":"<code>BrHolidays</code>","text":"Source code in <code>pyield/holidays/brholidays.py</code> <pre><code>class BrHolidays:\n    # The date (inclusive) when the new holidays list starts to be valid\n    TRANSITION_DATE = pd.to_datetime(\"2023-12-26\")\n\n    def __init__(self):\n        current_dir = Path(__file__).parent\n        new_holidays_path = current_dir / \"br_holidays_new.txt\"\n        old_holidays_path = current_dir / \"br_holidays_old.txt\"\n        self.new_holidays = self._load_holidays(new_holidays_path)\n        self.old_holidays = self._load_holidays(old_holidays_path)\n\n    @staticmethod\n    def _load_holidays(file_path: Path) -&gt; pd.Series:\n        \"\"\"Loads the holidays from a file and returns it as a Series of Timestamps.\"\"\"\n        df = pd.read_csv(file_path, header=None, names=[\"date\"], comment=\"#\")\n        holidays = pd.to_datetime(df[\"date\"], format=\"%d/%m/%Y\")\n        return holidays.astype(\"datetime64[ns]\")\n\n    def get_holiday_series(\n        self,\n        dates: pd.Timestamp | pd.Series | None = None,\n        holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n    ) -&gt; pd.Series:\n        \"\"\"\n        Returns the correct list of holidays to use based on the most recent date in\n        the input.\n\n        Args:\n            dates (pd.Timestamp | pd.Series | None): The dates to use for inferring\n                the holiday list. If a single date is provided, it is used directly.\n                If a Series of dates is provided, the earliest date is used.\n\n            holiday_option (Literal): The holidays list to use. Valid options are\n                'old', 'new' or 'infer'. If 'infer' is used, the list of holidays is\n                selected based on the earliest (minimum) date in the input.\n\n        Returns:\n            pd.Series: The list of holidays as a Series of Timestamps.\n        \"\"\"\n        match holiday_option:\n            case \"old\":\n                holidays = self.old_holidays\n\n            case \"new\":\n                return self.new_holidays\n\n            case \"infer\":\n                if dates is None:\n                    msg = \"Dates must be provided when using 'infer' option.\"\n                    raise ValueError(msg)\n                if isinstance(dates, pd.Timestamp):\n                    earliest_date = dates\n                else:\n                    earliest_date = dates.min()\n\n                if earliest_date &lt; BrHolidays.TRANSITION_DATE:\n                    holidays = self.old_holidays\n                else:\n                    holidays = self.new_holidays\n            case _:\n                raise ValueError(\"Invalid holiday list option.\")\n\n        return holidays\n\n    def get_holiday_array(\n        self,\n        dates: pd.Timestamp | pd.Series | None = None,\n        holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Returns the correct list of holidays to use based on the most recent date in\n        the input.\n\n        Args:\n            dates (pd.Timestamp | pd.Series | None): The dates to use for inferring\n                the holiday list. If a single date is provided, it is used directly.\n                If a Series of dates is provided, the earliest date is used.\n\n            holiday_option (Literal): The holidays list to use. Valid options are\n                'old', 'new' or 'infer'. If 'infer' is used, the list of holidays is\n                selected based on the earliest (minimum) date in the input.\n\n        Returns:\n            np.ndarray: The list of holidays as a NumPy array of datetime64[D].\n        \"\"\"\n        holidays = self.get_holiday_series(dates, holiday_option)\n        return holidays.to_numpy().astype(\"datetime64[D]\")\n</code></pre>"},{"location":"bday/#pyield.bday.BrHolidays.get_holiday_array","title":"<code>get_holiday_array(dates=None, holiday_option='infer')</code>","text":"<p>Returns the correct list of holidays to use based on the most recent date in the input.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>Timestamp | Series | None</code> <p>The dates to use for inferring the holiday list. If a single date is provided, it is used directly. If a Series of dates is provided, the earliest date is used.</p> <code>None</code> <code>holiday_option</code> <code>Literal</code> <p>The holidays list to use. Valid options are 'old', 'new' or 'infer'. If 'infer' is used, the list of holidays is selected based on the earliest (minimum) date in the input.</p> <code>'infer'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The list of holidays as a NumPy array of datetime64[D].</p> Source code in <code>pyield/holidays/brholidays.py</code> <pre><code>def get_holiday_array(\n    self,\n    dates: pd.Timestamp | pd.Series | None = None,\n    holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n) -&gt; np.ndarray:\n    \"\"\"\n    Returns the correct list of holidays to use based on the most recent date in\n    the input.\n\n    Args:\n        dates (pd.Timestamp | pd.Series | None): The dates to use for inferring\n            the holiday list. If a single date is provided, it is used directly.\n            If a Series of dates is provided, the earliest date is used.\n\n        holiday_option (Literal): The holidays list to use. Valid options are\n            'old', 'new' or 'infer'. If 'infer' is used, the list of holidays is\n            selected based on the earliest (minimum) date in the input.\n\n    Returns:\n        np.ndarray: The list of holidays as a NumPy array of datetime64[D].\n    \"\"\"\n    holidays = self.get_holiday_series(dates, holiday_option)\n    return holidays.to_numpy().astype(\"datetime64[D]\")\n</code></pre>"},{"location":"bday/#pyield.bday.BrHolidays.get_holiday_series","title":"<code>get_holiday_series(dates=None, holiday_option='infer')</code>","text":"<p>Returns the correct list of holidays to use based on the most recent date in the input.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>Timestamp | Series | None</code> <p>The dates to use for inferring the holiday list. If a single date is provided, it is used directly. If a Series of dates is provided, the earliest date is used.</p> <code>None</code> <code>holiday_option</code> <code>Literal</code> <p>The holidays list to use. Valid options are 'old', 'new' or 'infer'. If 'infer' is used, the list of holidays is selected based on the earliest (minimum) date in the input.</p> <code>'infer'</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: The list of holidays as a Series of Timestamps.</p> Source code in <code>pyield/holidays/brholidays.py</code> <pre><code>def get_holiday_series(\n    self,\n    dates: pd.Timestamp | pd.Series | None = None,\n    holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n) -&gt; pd.Series:\n    \"\"\"\n    Returns the correct list of holidays to use based on the most recent date in\n    the input.\n\n    Args:\n        dates (pd.Timestamp | pd.Series | None): The dates to use for inferring\n            the holiday list. If a single date is provided, it is used directly.\n            If a Series of dates is provided, the earliest date is used.\n\n        holiday_option (Literal): The holidays list to use. Valid options are\n            'old', 'new' or 'infer'. If 'infer' is used, the list of holidays is\n            selected based on the earliest (minimum) date in the input.\n\n    Returns:\n        pd.Series: The list of holidays as a Series of Timestamps.\n    \"\"\"\n    match holiday_option:\n        case \"old\":\n            holidays = self.old_holidays\n\n        case \"new\":\n            return self.new_holidays\n\n        case \"infer\":\n            if dates is None:\n                msg = \"Dates must be provided when using 'infer' option.\"\n                raise ValueError(msg)\n            if isinstance(dates, pd.Timestamp):\n                earliest_date = dates\n            else:\n                earliest_date = dates.min()\n\n            if earliest_date &lt; BrHolidays.TRANSITION_DATE:\n                holidays = self.old_holidays\n            else:\n                holidays = self.new_holidays\n        case _:\n            raise ValueError(\"Invalid holiday list option.\")\n\n    return holidays\n</code></pre>"},{"location":"bday/#pyield.bday.count","title":"<code>count(start, end)</code>","text":"<p>Counts the number of business days between a <code>start</code> date (inclusive) and an <code>end</code> date (exclusive). The function can handle single dates, arrays of dates and mixed inputs, returning either a single integer or a series of integers depending on the inputs. It accounts for specified holidays, effectively excluding them from the business day count.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>ScalarDateTypes | ArrayDateTypes</code> <p>The start date(s) for counting.</p> required <code>end</code> <code>ScalarDateTypes | ArrayDateTypes</code> <p>The end date(s) for counting, which is excluded from the count themselves.</p> required <code>holiday_option</code> <code>Literal['old', 'new', 'infer']</code> <p>Specifies which set of holidays to consider in the count. 'old' or 'new' refer to predefined holiday lists, while 'infer' automatically selects the list based on the most recent date in the input. Defaults to \"infer\".</p> required <p>Returns:</p> Type Description <code>int | Series</code> <p>int | pd.Series: Returns an integer if <code>start</code> and <code>end</code> are single dates, or a Series if any of them is an array of dates.</p> Notes <ul> <li>This function is a wrapper around <code>numpy.busday_count</code>, adapted to work   directly with various Pandas and Numpy date formats.</li> <li>It supports flexible date inputs, including single dates, lists, Series, and   more, for both <code>start</code> and <code>end</code> parameters.</li> <li>The return type depends on the input types: single dates return an int, while   arrays of dates return a pd.Series with the count for each date range.</li> <li>See <code>numpy.busday_count</code> documentation for more details on how holidays are   handled and how business day counts are calculated:   https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n10\n</code></pre>"},{"location":"bday/#pyield.bday.count--total-business-days-in-january-and-february-since-the-start-of-the-year","title":"Total business days in January and February since the start of the year","text":"<pre><code>&gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n0    22\n1    41\ndtype: Int64\n</code></pre>"},{"location":"bday/#pyield.bday.count--the-remaining-business-days-in-january-and-february-to-the-end-of-the-year","title":"The remaining business days in January and February to the end of the year","text":"<pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n0    253\n1    231\ndtype: Int64\n</code></pre>"},{"location":"bday/#pyield.bday.count--the-total-business-days-in-january-and-february-of-2024","title":"The total business days in January and February of 2024","text":"<pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n0    22\n1    19\ndtype: Int64\n</code></pre> Source code in <code>pyield/bday.py</code> <pre><code>def count(\n    start: ScalarDateTypes | ArrayDateTypes,\n    end: ScalarDateTypes | ArrayDateTypes,\n) -&gt; int | pd.Series:\n    \"\"\"\n    Counts the number of business days between a `start` date (inclusive) and an `end`\n    date (exclusive). The function can handle single dates, arrays of dates and\n    mixed inputs, returning either a single integer or a series of integers depending\n    on the inputs. It accounts for specified holidays, effectively excluding them from\n    the business day count.\n\n    Args:\n        start (ScalarDateTypes | ArrayDateTypes): The start date(s)\n            for counting.\n        end (ScalarDateTypes | ArrayDateTypes): The end date(s) for counting, which\n            is excluded from the count themselves.\n        holiday_option (Literal[\"old\", \"new\", \"infer\"], optional):\n            Specifies which set of holidays to consider in the count. 'old' or 'new'\n            refer to predefined holiday lists, while 'infer' automatically selects the\n            list based on the most recent date in the input. Defaults to \"infer\".\n\n    Returns:\n        int | pd.Series: Returns an integer if `start` and `end` are single dates,\n            or a Series if any of them is an array of dates.\n\n    Notes:\n        - This function is a wrapper around `numpy.busday_count`, adapted to work\n          directly with various Pandas and Numpy date formats.\n        - It supports flexible date inputs, including single dates, lists, Series, and\n          more, for both `start` and `end` parameters.\n        - The return type depends on the input types: single dates return an int, while\n          arrays of dates return a pd.Series with the count for each date range.\n        - See `numpy.busday_count` documentation for more details on how holidays are\n          handled and how business day counts are calculated:\n          https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n\n        &gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n        10\n\n        # Total business days in January and February since the start of the year\n        &gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n        0    22\n        1    41\n        dtype: Int64\n\n        # The remaining business days in January and February to the end of the year\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n        0    253\n        1    231\n        dtype: Int64\n\n        # The total business days in January and February of 2024\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n        0    22\n        1    19\n        dtype: Int64\n    \"\"\"\n    start_pd = dc.convert_input_dates(start)\n    end_pd = dc.convert_input_dates(end)\n\n    # If inputs are Series, check if they have different lengths\n    if isinstance(start_pd, pd.Series) and isinstance(end_pd, pd.Series):\n        if start_pd.size != end_pd.size:\n            raise ValueError(\"Input Series must have the same length.\")\n\n    # Only start is used to determine the holiday list\n    if isinstance(start_pd, pd.Series):\n        # Divide the input in order to apply the correct holiday list\n        start1 = start_pd[start_pd &lt; br_holidays.TRANSITION_DATE]\n        start2 = start_pd[start_pd &gt;= br_holidays.TRANSITION_DATE]\n        start3 = start_pd[start_pd.isna()]\n\n        # If end is a Series, it must be divided as well\n        if isinstance(end_pd, pd.Series):\n            end1 = end_pd[start1.index]\n            end2 = end_pd[start2.index]\n        else:\n            end1 = end_pd\n            end2 = end_pd\n\n        result1 = np.busday_count(\n            begindates=dc.to_numpy_date_type(start1),\n            enddates=dc.to_numpy_date_type(end1),\n            holidays=OLD_HOLIDAYS_ARRAY,\n        )\n        result2 = np.busday_count(\n            begindates=dc.to_numpy_date_type(start2),\n            enddates=dc.to_numpy_date_type(end2),\n            holidays=NEW_HOLIDAYS_ARRAY,\n        )\n\n        # Prepare results to be rejoined\n        result1 = pd.Series(result1, dtype=\"Int64\")\n        result2 = pd.Series(result2, dtype=\"Int64\")\n        # Convert the third result from NaT to NA\n        result3 = pd.Series(pd.NA, index=start3.index, dtype=\"Int64\")\n\n        # Old index is used to rejoin the results\n        result1.index = start1.index\n        result2.index = start2.index\n\n        # Reorder the result to match the original input order\n        result = pd.concat([result1, result2, result3]).sort_index()\n\n    else:  # Start is a single date\n        result = np.busday_count(\n            begindates=dc.to_numpy_date_type(start_pd),\n            enddates=dc.to_numpy_date_type(end_pd),\n            holidays=br_holidays.get_holiday_array(start_pd),\n        )\n        result = pd.Series(result, dtype=\"Int64\")\n\n    if result.size == 1:\n        return int(result[0])\n    return result\n</code></pre>"},{"location":"bday/#pyield.bday.generate","title":"<code>generate(start=None, end=None, inclusive='both', holiday_option='infer')</code>","text":"<p>Generates a Series of business days between a <code>start</code> and <code>end</code> date, considering the list of Brazilian holidays. It supports customization of holiday lists and inclusion options for start and end dates. It wraps <code>pandas.bdate_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>ScalarDateTypes | None</code> <p>The start date for generating business days. If None, the current date is used. Defaults to None.</p> <code>None</code> <code>end</code> <code>ScalarDateTypes | None</code> <p>The end date for generating business days. If None, the current date is used. Defaults to None.</p> <code>None</code> <code>inclusive</code> <code>Literal['both', 'neither', 'left', 'right']</code> <p>Determines which of the start and end dates are included in the result. Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.</p> <code>'both'</code> <code>holiday_option</code> <code>Literal['old', 'new', 'infer']</code> <p>Specifies the list of holidays to consider. 'old' or 'new' refer to predefined lists, 'infer' selects the list based on the most recent date in the range. Defaults to \"infer\".</p> <code>'infer'</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series representing a range of business days between the specified start and end dates, considering the specified holidays.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n0   2023-12-22\n1   2023-12-26\n2   2023-12-27\n3   2023-12-28\n4   2023-12-29\n5   2024-01-02\ndtype: datetime64[ns]\n</code></pre> Note <p>For detailed information on parameters and error handling, refer to <code>pandas.bdate_range</code> documentation: https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.</p> Source code in <code>pyield/bday.py</code> <pre><code>def generate(\n    start: ScalarDateTypes | None = None,\n    end: ScalarDateTypes | None = None,\n    inclusive: Literal[\"both\", \"neither\", \"left\", \"right\"] = \"both\",\n    holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n) -&gt; pd.Series:\n    \"\"\"\n    Generates a Series of business days between a `start` and `end` date, considering\n    the list of Brazilian holidays. It supports customization of holiday lists and\n    inclusion options for start and end dates. It wraps `pandas.bdate_range`.\n\n    Args:\n        start (ScalarDateTypes | None, optional):\n            The start date for generating business days. If None, the current date is\n            used. Defaults to None.\n        end (ScalarDateTypes | None, optional):\n            The end date for generating business days. If None, the current date is\n            used. Defaults to None.\n        inclusive (Literal[\"both\", \"neither\", \"left\", \"right\"], optional):\n            Determines which of the start and end dates are included in the result.\n            Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.\n        holiday_option (Literal[\"old\", \"new\", \"infer\"], optional):\n            Specifies the list of holidays to consider. 'old' or 'new' refer to\n            predefined lists, 'infer' selects the list based on the most recent date in\n            the range. Defaults to \"infer\".\n\n    Returns:\n        pd.Series: A Series representing a range of business days between the specified\n            start and end dates, considering the specified holidays.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n        0   2023-12-22\n        1   2023-12-26\n        2   2023-12-27\n        3   2023-12-28\n        4   2023-12-29\n        5   2024-01-02\n        dtype: datetime64[ns]\n\n    Note:\n        For detailed information on parameters and error handling, refer to\n        `pandas.bdate_range` documentation:\n        https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.\n    \"\"\"\n    if start:\n        start_pd = dc.convert_input_dates(start)\n    else:\n        start_pd = pd.Timestamp.today()\n\n    if end:\n        end_pd = dc.convert_input_dates(end)\n    else:\n        end_pd = pd.Timestamp.today()\n\n    holidays_list = br_holidays.get_holiday_series(start_pd).to_list()\n\n    # Get the result as a DatetimeIndex (dti)\n    result_dti = pd.bdate_range(\n        start=start_pd,\n        end=end_pd,\n        freq=\"C\",\n        inclusive=inclusive,\n        holidays=holidays_list,\n    )\n    return pd.Series(result_dti.values)\n</code></pre>"},{"location":"bday/#pyield.bday.is_business_day","title":"<code>is_business_day(date)</code>","text":"<p>Checks if the input date is a business day.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>ScalarDateTypes</code> <p>The date to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the input date is a business day, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas\nFalse\n</code></pre> Source code in <code>pyield/bday.py</code> <pre><code>def is_business_day(date: ScalarDateTypes) -&gt; bool:\n    \"\"\"\n    Checks if the input date is a business day.\n\n    Args:\n        date (ScalarDateTypes): The date to check.\n\n    Returns:\n        bool: True if the input date is a business day, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas\n        False\n    \"\"\"\n    date_pd = dc.convert_input_dates(date)\n    shifted_date = offset(date_pd, 0)  # Shift the date if it is not a bus. day\n    return date_pd == shifted_date\n</code></pre>"},{"location":"bday/#pyield.bday.offset","title":"<code>offset(dates, offset, roll='forward')</code>","text":"<p>First adjusts the date to fall on a valid day according to the roll rule, then applies offsets to the given dates to the next or previous business day, considering brazilian holidays. This function supports both single dates and collections of dates. It is a wrapper for <code>numpy.busday_offset</code> adapted for Pandas data types and brazilian holidays.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>ScalarDateTypes | ArrayDateTypes</code> <p>The date(s) to offset. Can be a single date in various formats (string, <code>datetime</code>, <code>Timestamp</code>, etc.) or a collection of dates (list, tuple, <code>Series</code>, etc.).</p> required <code>offset</code> <code>int | Series | ndarray | list[int] | tuple[int]</code> <p>The number of business days to offset the dates. Positive for future dates, negative for past dates. Zero will return the same date if it's a business day, or the next business day otherwise.</p> required <code>roll</code> <code>Literal['forward', 'backward']</code> <p>Direction to roll the date if it falls on a holiday or weekend. 'forward' to the next business day, 'backward' to the previous. Defaults to 'forward'.</p> <code>'forward'</code> <p>Returns:</p> Type Description <code>Timestamp | Series</code> <p>pd.Timestamp | pd.Series: If a single date is provided, returns a single <code>Timestamp</code> of the offset date. If a series of dates is provided, returns a <code>Series</code> of offset dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n</code></pre> <p>Offset to the next business day if not a bday (offset=0 and roll=\"forward\")</p>"},{"location":"bday/#pyield.bday.offset--offset-saturday-before-christmas-to-the-next-b-day-tuesday-after-christmas","title":"Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\nTimestamp('2023-12-26 00:00:00')\n</code></pre>"},{"location":"bday/#pyield.bday.offset--offset-friday-before-christmas-no-offset-because-its-a-business-day","title":"Offset Friday before Christmas (no offset because it's a business day)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\nTimestamp('2023-12-22 00:00:00')\n</code></pre> <p>Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")</p>"},{"location":"bday/#pyield.bday.offset--no-offset-because-its-a-business-day","title":"No offset because it's a business day","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\nTimestamp('2023-12-22 00:00:00')\n</code></pre>"},{"location":"bday/#pyield.bday.offset--offset-to-the-first-business-day-before-23-12-2023","title":"Offset to the first business day before \"23-12-2023\"","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\nTimestamp('2023-12-22 00:00:00')\n</code></pre> <p>Jump to the next business day (1 offset and roll=\"forward\")</p>"},{"location":"bday/#pyield.bday.offset--offset-friday-to-the-next-business-day-friday-is-jumped-monday","title":"Offset Friday to the next business day (Friday is jumped -&gt; Monday)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\nTimestamp('2024-09-30 00:00:00')\n</code></pre>"},{"location":"bday/#pyield.bday.offset--offset-saturday-to-the-next-business-day-monday-is-jumped-tuesday","title":"Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\nTimestamp('2024-10-01 00:00:00')\n</code></pre> <p>Jump to the previous business day (-1 offset and roll=\"backward\")</p>"},{"location":"bday/#pyield.bday.offset--offset-friday-to-the-previous-business-day-friday-is-jumped-thursday","title":"Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\nTimestamp('2024-09-26 00:00:00')\n</code></pre>"},{"location":"bday/#pyield.bday.offset--offset-saturday-to-the-previous-business-day-friday-is-jumped-thursday","title":"Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\nTimestamp('2024-09-26 00:00:00')\n</code></pre> <p>List of dates and offsets</p> <pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)  # a list of dates\n0   2024-09-20\n1   2024-09-23\ndtype: datetime64[ns]\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\n0   2024-09-20\n1   2024-09-23\ndtype: datetime64[ns]\n</code></pre> Note <p>This function uses <code>numpy.busday_offset</code> under the hood, which means it follows the same conventions and limitations for business day calculations. For detailed information on error handling and behavior, refer to the <code>numpy.busday_offset</code> documentation: https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html</p> Source code in <code>pyield/bday.py</code> <pre><code>def offset(\n    dates: ScalarDateTypes | ArrayDateTypes,\n    offset: ScalarIntTypes | ArrayIntTypes,\n    roll: Literal[\"forward\", \"backward\"] = \"forward\",\n) -&gt; pd.Timestamp | pd.Series:\n    \"\"\"\n    First adjusts the date to fall on a valid day according to the roll rule, then\n    applies offsets to the given dates to the next or previous business day, considering\n    brazilian holidays. This function supports both single dates and collections of\n    dates. It is a wrapper for `numpy.busday_offset` adapted for Pandas data types and\n    brazilian holidays.\n\n    Args:\n        dates (ScalarDateTypes | ArrayDateTypes):\n            The date(s) to offset. Can be a single date in various formats (string,\n            `datetime`, `Timestamp`, etc.) or a collection of dates (list, tuple,\n            `Series`, etc.).\n        offset (int | Series | np.ndarray | list[int] | tuple[int], optional):\n            The number of business days to offset the dates. Positive for future dates,\n            negative for past dates. Zero will return the same date if it's a business\n            day, or the next business day otherwise.\n        roll (Literal[\"forward\", \"backward\"], optional): Direction to roll the date if\n            it falls on a holiday or weekend. 'forward' to the next business day,\n            'backward' to the previous. Defaults to 'forward'.\n\n    Returns:\n        pd.Timestamp | pd.Series: If a single date is provided, returns a single\n            `Timestamp` of the offset date. If a series of dates is provided, returns a\n            `Series` of offset dates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n\n        Offset to the next business day if not a bday (offset=0 and roll=\"forward\")\n\n        # Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\n        Timestamp('2023-12-26 00:00:00')\n\n        # Offset Friday before Christmas (no offset because it's a business day)\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\n        Timestamp('2023-12-22 00:00:00')\n\n        Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")\n\n        # No offset because it's a business day\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\n        Timestamp('2023-12-22 00:00:00')\n\n        # Offset to the first business day before \"23-12-2023\"\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\n        Timestamp('2023-12-22 00:00:00')\n\n        Jump to the next business day (1 offset and roll=\"forward\")\n\n        # Offset Friday to the next business day (Friday is jumped -&gt; Monday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\n        Timestamp('2024-09-30 00:00:00')\n\n        # Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\n        Timestamp('2024-10-01 00:00:00')\n\n        Jump to the previous business day (-1 offset and roll=\"backward\")\n\n        # Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\n        Timestamp('2024-09-26 00:00:00')\n\n        # Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\n        Timestamp('2024-09-26 00:00:00')\n\n        List of dates and offsets\n\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)  # a list of dates\n        0   2024-09-20\n        1   2024-09-23\n        dtype: datetime64[ns]\n\n        &gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\n        0   2024-09-20\n        1   2024-09-23\n        dtype: datetime64[ns]\n\n    Note:\n        This function uses `numpy.busday_offset` under the hood, which means it follows\n        the same conventions and limitations for business day calculations. For detailed\n        information on error handling and behavior, refer to the `numpy.busday_offset`\n        documentation:\n        https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html\n    \"\"\"\n    dates_pd = dc.convert_input_dates(dates)\n\n    if isinstance(dates_pd, pd.Series):\n        # Divide the input in order to apply the correct holiday list\n        dates1 = dates_pd[dates_pd &lt; br_holidays.TRANSITION_DATE]\n        dates2 = dates_pd[dates_pd &gt;= br_holidays.TRANSITION_DATE]\n        dates3 = dates_pd[dates_pd.isna()]\n\n        offsetted_dates1 = np.busday_offset(\n            dc.to_numpy_date_type(dates1),\n            offsets=offset,\n            roll=roll,\n            holidays=OLD_HOLIDAYS_ARRAY,\n        )\n\n        offsetted_dates2 = np.busday_offset(\n            dc.to_numpy_date_type(dates2),\n            offsets=offset,\n            roll=roll,\n            holidays=NEW_HOLIDAYS_ARRAY,\n        )\n\n        # Convert from numpy.datetime64 to pandas.Timestamp\n        offsetted_dates1 = pd.to_datetime(offsetted_dates1)\n        offsetted_dates2 = pd.to_datetime(offsetted_dates2)\n\n        # 'pd.to_datetime' does not necessarily return datetime64[ns] Series\n        offsetted_dates1 = pd.Series(offsetted_dates1).astype(\"datetime64[ns]\")\n        offsetted_dates2 = pd.Series(offsetted_dates2).astype(\"datetime64[ns]\")\n\n        # Use old index to rejoin the results\n        offsetted_dates1.index = dates1.index\n        offsetted_dates2.index = dates2.index\n\n        offsetted_dates = pd.concat([offsetted_dates1, offsetted_dates2, dates3])\n\n        # Reorder the result to match the original input order\n        return offsetted_dates.sort_index()\n\n    elif isinstance(dates_pd, pd.Timestamp):\n        offsetted_dates_np = np.busday_offset(\n            dc.to_numpy_date_type(dates_pd),\n            offsets=offset,\n            roll=roll,\n            holidays=br_holidays.get_holiday_array(dates_pd),\n        )\n        if isinstance(offsetted_dates_np, np.datetime64):\n            return pd.Timestamp(offsetted_dates_np).as_unit(\"ns\")\n        else:\n            return pd.Series(offsetted_dates_np).astype(\"datetime64[ns]\")\n\n    else:\n        raise ValueError(\"Invalid input type for 'dates'.\")\n</code></pre>"},{"location":"di/","title":"DI Data (di)","text":""},{"location":"di/#pyield.di.data","title":"<code>data(trade_date, adj_expirations=False, prefixed_filter=False)</code>","text":"<p>Retrieve DI contract data for a specified trade date.</p> <p>This function retrieves DI contract data for the given trade date. If the historical data is not available, it attempts to fetch the data from the B3 website. The function can also filter and adjust expiration dates based on the provided options.</p> <p>Parameters:</p> Name Type Description Default <code>trade_date</code> <code>str | Timestamp</code> <p>The trade date for which the DI data is required.</p> required <code>adj_expirations</code> <code>bool</code> <p>If True, adjusts the expiration dates to the start of the month.</p> <code>False</code> <code>prefixed_filter</code> <code>bool</code> <p>If True, filters the DI contracts to match prefixed Anbima bond maturities.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing DI contract data, with columns for expiration dates and selected rates. The DataFrame is sorted by the expiration date.</p> Source code in <code>pyield/di.py</code> <pre><code>def data(\n    trade_date: str | pd.Timestamp,\n    adj_expirations: bool = False,\n    prefixed_filter: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Retrieve DI contract data for a specified trade date.\n\n    This function retrieves DI contract data for the given trade date. If the historical\n    data is not available, it attempts to fetch the data from the B3 website. The\n    function can also filter and adjust expiration dates based on the provided options.\n\n    Args:\n        trade_date (str | pd.Timestamp): The trade date for which the DI data is\n            required.\n        adj_expirations (bool): If True, adjusts the expiration dates to the\n            start of the month.\n        prefixed_filter (bool): If True, filters the DI contracts to match prefixed\n            Anbima bond maturities.\n\n    Returns:\n        pd.DataFrame: DataFrame containing DI contract data, with columns for\n            expiration dates and selected rates. The DataFrame is sorted by the\n            expiration date.\n    \"\"\"\n    trade_date = dc.convert_input_dates(trade_date)\n    df = get_di_dataframe()\n    df.query(\"TradeDate == @trade_date\", inplace=True)\n\n    if df.empty:\n        # There is no historical data for date provided.\n        # Let's try to fetch the data from the B3 website.\n        df = futures(contract_code=\"DI1\", trade_date=trade_date)\n    if df.empty:\n        # If it is still empty, return an empty DataFrame.\n        return pd.DataFrame()\n\n    df.drop(columns=[\"TradeDate\"], inplace=True)\n    if \"DaysToExpiration\" in df.columns:\n        df.drop(columns=[\"DaysToExpiration\"], inplace=True)\n\n    if prefixed_filter:\n        df_pre = (\n            get_anbima_dataframe()\n            .query(\"ReferenceDate == @trade_date\")\n            .query(\"BondType in ['LTN', 'NTN-F']\")\n            .drop_duplicates(ignore_index=True)\n        )\n        pre_maturities = df_pre[\"MaturityDate\"]\n        adj_pre_maturities = bday.offset(pre_maturities, 0)  # noqa\n        df.query(\"ExpirationDate in @adj_pre_maturities\", inplace=True)\n\n    if adj_expirations:\n        df[\"ExpirationDate\"] = df[\"ExpirationDate\"].dt.to_period(\"M\")\n        df[\"ExpirationDate\"] = df[\"ExpirationDate\"].dt.to_timestamp()\n\n    return df.sort_values([\"ExpirationDate\"], ignore_index=True)\n</code></pre>"},{"location":"di/#pyield.di.expirations","title":"<code>expirations(trade_date, adj_expirations=False, prefixed_filter=False)</code>","text":"<p>Retrieve unique expiration dates for DI contracts on a specified trade date.</p> <p>This function returns a Series of unique expiration dates for DI contracts for the given trade date. The expiration dates can be adjusted or filtered based on the provided options.</p> <p>Parameters:</p> Name Type Description Default <code>trade_date</code> <code>str | Timestamp</code> <p>The trade date for which expiration dates are required.</p> required <code>adj_expirations</code> <code>bool</code> <p>If True, adjusts the expiration dates to the start of the month.</p> <code>False</code> <code>prefixed_filter</code> <code>bool</code> <p>If True, filters the DI contracts to match prefixed Anbima bond maturities.</p> <code>False</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of unique expiration dates for DI contracts.</p> Source code in <code>pyield/di.py</code> <pre><code>def expirations(\n    trade_date: str | pd.Timestamp,\n    adj_expirations: bool = False,\n    prefixed_filter: bool = False,\n) -&gt; pd.Series:\n    \"\"\"Retrieve unique expiration dates for DI contracts on a specified trade date.\n\n    This function returns a Series of unique expiration dates for DI contracts\n    for the given trade date. The expiration dates can be adjusted or filtered\n    based on the provided options.\n\n    Args:\n        trade_date (str | pd.Timestamp): The trade date for which expiration dates are\n            required.\n        adj_expirations (bool): If True, adjusts the expiration dates to the start of\n            the month.\n        prefixed_filter (bool): If True, filters the DI contracts to match prefixed\n            Anbima bond maturities.\n\n    Returns:\n        pd.Series: A Series of unique expiration dates for DI contracts.\n    \"\"\"\n    trade_date = dc.convert_input_dates(trade_date)\n    df = data(trade_date, adj_expirations, prefixed_filter)\n    df = df.drop_duplicates(subset=[\"ExpirationDate\"], ignore_index=True)\n    return df[\"ExpirationDate\"]\n</code></pre>"},{"location":"di/#pyield.di.futures","title":"<code>futures(contract_code, trade_date)</code>","text":"<p>Fetches data for a specified futures contract based on type and reference date.</p> <p>Parameters:</p> Name Type Description Default <code>contract_code</code> <code>str</code> <p>The B3 futures contract code identifying the derivative. Supported contract codes are: - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3. - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3. - \"FRC\": Forward Rate Agreement (FRA) from B3. - \"DAP\": DI x IPCA Spread Futures. - \"DOL\": U.S. Dollar Futures from B3. - \"WDO\": Mini U.S. Dollar Futures from B3. - \"IND\": Ibovespa Futures from B3. - \"WIN\": Mini Ibovespa Futures from B3.</p> required <code>trade_date</code> <code>str | Timestamp</code> <p>The date for which to fetch the data. If the reference date is a string, it should be in 'DD-MM-YYYY' format.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the fetched data for the specified futures contract.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the futures contract code is not recognized or supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n    TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n0  2024-05-31       DI1M24  ...      0.10404    0.10404\n1  2024-05-31       DI1N24  ...       0.1039    0.10386\n2  2024-05-31       DI1Q24  ...      0.10374    0.10374\n3  2024-05-31       DI1U24  ...      0.10365    0.10355\n...\n&gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n    TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n0  2024-05-31       DAPM24  ...         &lt;NA&gt;       &lt;NA&gt;\n1  2024-05-31       DAPN24  ...         &lt;NA&gt;       &lt;NA&gt;\n2  2024-05-31       DAPQ24  ...         &lt;NA&gt;     0.0885\n3  2024-05-31       DAPU24  ...         &lt;NA&gt;     0.0865\n...\n</code></pre> Source code in <code>pyield/b3_futures/__init__.py</code> <pre><code>def futures(\n    contract_code: str,\n    trade_date: str | pd.Timestamp,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches data for a specified futures contract based on type and reference date.\n\n    Args:\n        contract_code (str): The B3 futures contract code identifying the derivative.\n            Supported contract codes are:\n            - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3.\n            - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3.\n            - \"FRC\": Forward Rate Agreement (FRA) from B3.\n            - \"DAP\": DI x IPCA Spread Futures.\n            - \"DOL\": U.S. Dollar Futures from B3.\n            - \"WDO\": Mini U.S. Dollar Futures from B3.\n            - \"IND\": Ibovespa Futures from B3.\n            - \"WIN\": Mini Ibovespa Futures from B3.\n        trade_date (str | pd.Timestamp): The date for which to fetch the data.\n            If the reference date is a string, it should be in 'DD-MM-YYYY' format.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the fetched data for the specified futures\n            contract.\n\n    Raises:\n        ValueError: If the futures contract code is not recognized or supported.\n\n    Examples:\n        &gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n            TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n        0  2024-05-31       DI1M24  ...      0.10404    0.10404\n        1  2024-05-31       DI1N24  ...       0.1039    0.10386\n        2  2024-05-31       DI1Q24  ...      0.10374    0.10374\n        3  2024-05-31       DI1U24  ...      0.10365    0.10355\n        ...\n        &gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n            TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n        0  2024-05-31       DAPM24  ...         &lt;NA&gt;       &lt;NA&gt;\n        1  2024-05-31       DAPN24  ...         &lt;NA&gt;       &lt;NA&gt;\n        2  2024-05-31       DAPQ24  ...         &lt;NA&gt;     0.0885\n        3  2024-05-31       DAPU24  ...         &lt;NA&gt;     0.0865\n        ...\n    \"\"\"\n    contract_code = contract_code.upper()\n    if contract_code not in SUPPORTED_FUTURES:\n        raise ValueError(\"Futures contract not supported.\")\n\n    trade_date = dc.convert_input_dates(trade_date)\n\n    # First, try to fetch historical data for the specified date\n    df = fetch_historical_df(contract_code, trade_date)\n\n    bz_today = dt.datetime.now(TIMEZONE_BZ).date()\n    # If there is no historical data available, try to fetch intraday data\n    if trade_date.date() == bz_today and df.empty:\n        df = fetch_intraday_df(contract_code)\n\n    return df\n</code></pre>"},{"location":"di/#pyield.di.rate","title":"<code>rate(trade_date, expiration, interpolate=True, extrapolate=False)</code>","text":"<p>Retrieve the DI rate for a specified trade date and expiration date.</p> <p>This function returns the DI rate for the given trade date and expiration date. The function uses the SettlementRate column from the DI contract data and interpolates the rate using the flat forward method if required.</p> <p>Parameters:</p> Name Type Description Default <code>trade_date</code> <code>str | Timestamp</code> <p>The trade date for which the DI rate is required.</p> required <code>expiration</code> <code>str | Timestamp</code> <p>The expiration date for the DI contract.</p> required <code>interpolate</code> <code>bool</code> <p>If True, interpolates the rate for the provided expiration date.</p> <code>True</code> <code>extrapolate</code> <code>bool</code> <p>If True, extrapolates the rate for expiration dates beyond the available data.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The DI rate for the specified trade date and expiration date, or NaN    if the rate cannot be determined.</p> Source code in <code>pyield/di.py</code> <pre><code>def rate(\n    trade_date: str | pd.Timestamp,\n    expiration: str | pd.Timestamp,\n    interpolate: bool = True,\n    extrapolate: bool = False,\n) -&gt; float:\n    \"\"\"Retrieve the DI rate for a specified trade date and expiration date.\n\n    This function returns the DI rate for the given trade date and expiration date.\n    The function uses the SettlementRate column from the DI contract data and\n    interpolates the rate using the flat forward method if required.\n\n    Args:\n        trade_date (str | pd.Timestamp): The trade date for which the DI rate is\n            required.\n        expiration (str | pd.Timestamp): The expiration date for the DI contract.\n        interpolate (bool): If True, interpolates the rate for the provided expiration\n            date.\n        extrapolate (bool): If True, extrapolates the rate for expiration dates beyond\n            the available data.\n\n    Returns:\n        float: The DI rate for the specified trade date and expiration date, or NaN\n               if the rate cannot be determined.\n    \"\"\"\n    # Convert input dates to consistent format\n    trade_date = dc.convert_input_dates(trade_date)\n    # Adjust expiration date to the nearest business day\n    expiration = bday.offset(expiration, 0)\n\n    # Return an error if interpolation is not allowed and extrapolation is required\n    if not interpolate and extrapolate:\n        raise ValueError(\"Extrapolation is not allowed without interpolation.\")\n\n    # Retrieve the data for the given trade date\n    df = data(trade_date)\n\n    # Return NaN if no data is found for the trade date\n    if df.empty:\n        return float(\"NaN\")\n\n    # Filter data for the specified expiration date\n    df_exp = df.query(\"ExpirationDate == @expiration\")\n\n    # Return NaN if no exact match is found and interpolation is not allowed\n    if df_exp.empty and not interpolate:\n        return float(\"NaN\")\n\n    if expiration in df_exp[\"ExpirationDate\"]:\n        # Return the rate if an exact match is found\n        return float(df_exp[\"SettlementRate\"].iloc[0])\n\n    if not interpolate:\n        # Return NaN if no exact match is found and interpolation is not allowed\n        return float(\"NaN\")\n\n    # Perform flat forward interpolation if required\n    ff_interpolator = interpolator.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(trade_date, df[\"ExpirationDate\"]),\n        known_rates=df[\"SettlementRate\"],\n        extrapolate=extrapolate,\n    )\n\n    # Return the interpolated rate for the calculated business days\n    return ff_interpolator(bday.count(trade_date, expiration))\n</code></pre>"},{"location":"di/#pyield.di.trade_dates","title":"<code>trade_dates(start_date=None, end_date=None)</code>","text":"<p>Retrieve unique trade dates for DI contracts within a specified date range.</p> <p>This function returns a Series of unique trade dates for DI contracts within the given date range.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str | Timestamp</code> <p>The start date of the date range. If None, the earliest available date is used.</p> <code>None</code> <code>end_date</code> <code>str | Timestamp</code> <p>The end date of the date range. If None, the latest available date is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of unique trade dates for DI contracts.</p> Source code in <code>pyield/di.py</code> <pre><code>def trade_dates(\n    start_date: str | pd.Timestamp | None = None,\n    end_date: str | pd.Timestamp | None = None,\n) -&gt; pd.Series:\n    \"\"\"Retrieve unique trade dates for DI contracts within a specified date range.\n\n    This function returns a Series of unique trade dates for DI contracts within the\n    given date range.\n\n    Args:\n        start_date (str | pd.Timestamp): The start date of the date range. If None,\n            the earliest available date is used.\n        end_date (str | pd.Timestamp): The end date of the date range. If None, the\n            latest available date is used.\n\n    Returns:\n        pd.Series: A Series of unique trade dates for DI contracts.\n    \"\"\"\n    df = get_di_dataframe()\n    if start_date:\n        start_date = dc.convert_input_dates(start_date)\n        df = df.query(\"TradeDate &gt;= @start_date\")\n    if end_date:\n        end_date = dc.convert_input_dates(end_date)\n        df = df.query(\"TradeDate &lt;= @end_date\")\n\n    df = df.drop_duplicates(subset=[\"TradeDate\"], ignore_index=True)\n    return df[\"TradeDate\"]\n</code></pre>"},{"location":"futures/","title":"Futures Data (futures)","text":"<p>Fetches data for a specified futures contract based on type and reference date.</p> <p>Parameters:</p> Name Type Description Default <code>contract_code</code> <code>str</code> <p>The B3 futures contract code identifying the derivative. Supported contract codes are: - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3. - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3. - \"FRC\": Forward Rate Agreement (FRA) from B3. - \"DAP\": DI x IPCA Spread Futures. - \"DOL\": U.S. Dollar Futures from B3. - \"WDO\": Mini U.S. Dollar Futures from B3. - \"IND\": Ibovespa Futures from B3. - \"WIN\": Mini Ibovespa Futures from B3.</p> required <code>trade_date</code> <code>str | Timestamp</code> <p>The date for which to fetch the data. If the reference date is a string, it should be in 'DD-MM-YYYY' format.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the fetched data for the specified futures contract.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the futures contract code is not recognized or supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n    TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n0  2024-05-31       DI1M24  ...      0.10404    0.10404\n1  2024-05-31       DI1N24  ...       0.1039    0.10386\n2  2024-05-31       DI1Q24  ...      0.10374    0.10374\n3  2024-05-31       DI1U24  ...      0.10365    0.10355\n...\n&gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n    TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n0  2024-05-31       DAPM24  ...         &lt;NA&gt;       &lt;NA&gt;\n1  2024-05-31       DAPN24  ...         &lt;NA&gt;       &lt;NA&gt;\n2  2024-05-31       DAPQ24  ...         &lt;NA&gt;     0.0885\n3  2024-05-31       DAPU24  ...         &lt;NA&gt;     0.0865\n...\n</code></pre> Source code in <code>pyield/b3_futures/__init__.py</code> <pre><code>def futures(\n    contract_code: str,\n    trade_date: str | pd.Timestamp,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches data for a specified futures contract based on type and reference date.\n\n    Args:\n        contract_code (str): The B3 futures contract code identifying the derivative.\n            Supported contract codes are:\n            - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3.\n            - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3.\n            - \"FRC\": Forward Rate Agreement (FRA) from B3.\n            - \"DAP\": DI x IPCA Spread Futures.\n            - \"DOL\": U.S. Dollar Futures from B3.\n            - \"WDO\": Mini U.S. Dollar Futures from B3.\n            - \"IND\": Ibovespa Futures from B3.\n            - \"WIN\": Mini Ibovespa Futures from B3.\n        trade_date (str | pd.Timestamp): The date for which to fetch the data.\n            If the reference date is a string, it should be in 'DD-MM-YYYY' format.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the fetched data for the specified futures\n            contract.\n\n    Raises:\n        ValueError: If the futures contract code is not recognized or supported.\n\n    Examples:\n        &gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n            TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n        0  2024-05-31       DI1M24  ...      0.10404    0.10404\n        1  2024-05-31       DI1N24  ...       0.1039    0.10386\n        2  2024-05-31       DI1Q24  ...      0.10374    0.10374\n        3  2024-05-31       DI1U24  ...      0.10365    0.10355\n        ...\n        &gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n            TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n        0  2024-05-31       DAPM24  ...         &lt;NA&gt;       &lt;NA&gt;\n        1  2024-05-31       DAPN24  ...         &lt;NA&gt;       &lt;NA&gt;\n        2  2024-05-31       DAPQ24  ...         &lt;NA&gt;     0.0885\n        3  2024-05-31       DAPU24  ...         &lt;NA&gt;     0.0865\n        ...\n    \"\"\"\n    contract_code = contract_code.upper()\n    if contract_code not in SUPPORTED_FUTURES:\n        raise ValueError(\"Futures contract not supported.\")\n\n    trade_date = dc.convert_input_dates(trade_date)\n\n    # First, try to fetch historical data for the specified date\n    df = fetch_historical_df(contract_code, trade_date)\n\n    bz_today = dt.datetime.now(TIMEZONE_BZ).date()\n    # If there is no historical data available, try to fetch intraday data\n    if trade_date.date() == bz_today and df.empty:\n        df = fetch_intraday_df(contract_code)\n\n    return df\n</code></pre>"},{"location":"indicators/","title":"Indicators (indicator)","text":""},{"location":"indicators/#pyield.indicators.indicator","title":"<code>indicator(indicator_code, reference_date)</code>","text":"<p>Fetches the economic indicator value for a specified reference date.</p> <p>This function retrieves the value of a specified economic indicator, such as IPCA (monthly inflation), SELIC (target or overnight rate), DI (interbank deposit rate), or the VNA of LFT (Valor Nominal Atualizado), based on the given reference date. The correct API is dynamically chosen based on the indicator code provided.</p> <p>Parameters:</p> Name Type Description Default <code>indicator_code</code> <code>IndicatorCode</code> <p>The code of the economic indicator to fetch. The available options are: - \"IPCA_MR\": IPCA Monthly Rate (inflation). - \"SELIC_TARGET\": SELIC Target rate. - \"SELIC_OVER\": SELIC Over (overnight) rate. - \"DI\": DI (interbank deposit rate). - \"VNA_LFT\": Valor Nominal Atualizado for LFT (Treasury Bills).</p> required <code>reference_date</code> <code>str | Timestamp</code> <p>The date for which the indicator value is fetched. This can be passed as a string in \"DD-MM-YYYY\" format or as a <code>pd.Timestamp</code>.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the requested economic indicator for the specified date.</p> <code>float</code> <p>Returns NaN if the value cannot be retrieved or an error occurs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid <code>indicator_code</code> is provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.indicator(\"IPCA_MR\", \"01-04-2024\")\n0.0038\n</code></pre> <pre><code>&gt;&gt;&gt; yd.indicator(\"SELIC_TARGET\", \"31-05-2024\")\n0.105\n</code></pre> <pre><code>&gt;&gt;&gt; yd.indicator(\"DI\", \"31-05-2024\")\n0.104\n</code></pre> <pre><code>&gt;&gt;&gt; yd.indicator(\"VNA_LFT\", \"31-05-2024\")\n14903.01148\n</code></pre> <pre><code>&gt;&gt;&gt; yd.indicator(\"SELIC_OVER\", \"31-05-2024\")\n0.104\n</code></pre> Source code in <code>pyield/indicators.py</code> <pre><code>def indicator(\n    indicator_code: IndicatorCode,\n    reference_date: str | pd.Timestamp,\n) -&gt; float:\n    \"\"\"\n    Fetches the economic indicator value for a specified reference date.\n\n    This function retrieves the value of a specified economic indicator, such as IPCA\n    (monthly inflation), SELIC (target or overnight rate), DI (interbank deposit rate),\n    or the VNA of LFT (Valor Nominal Atualizado), based on the given reference date. The\n    correct API is dynamically chosen based on the indicator code provided.\n\n    Args:\n        indicator_code (IndicatorCode): The code of the economic indicator to fetch.\n            The available options are:\n            - \"IPCA_MR\": IPCA Monthly Rate (inflation).\n            - \"SELIC_TARGET\": SELIC Target rate.\n            - \"SELIC_OVER\": SELIC Over (overnight) rate.\n            - \"DI\": DI (interbank deposit rate).\n            - \"VNA_LFT\": Valor Nominal Atualizado for LFT (Treasury Bills).\n        reference_date (str | pd.Timestamp):\n            The date for which the indicator value is fetched. This can be passed as a\n            string in \"DD-MM-YYYY\" format or as a `pd.Timestamp`.\n\n    Returns:\n        float: The value of the requested economic indicator for the specified date.\n        Returns NaN if the value cannot be retrieved or an error occurs.\n\n    Raises:\n        ValueError: If an invalid `indicator_code` is provided.\n\n    Examples:\n        &gt;&gt;&gt; yd.indicator(\"IPCA_MR\", \"01-04-2024\")\n        0.0038\n\n        &gt;&gt;&gt; yd.indicator(\"SELIC_TARGET\", \"31-05-2024\")\n        0.105\n\n        &gt;&gt;&gt; yd.indicator(\"DI\", \"31-05-2024\")\n        0.104\n\n        &gt;&gt;&gt; yd.indicator(\"VNA_LFT\", \"31-05-2024\")\n        14903.01148\n\n        &gt;&gt;&gt; yd.indicator(\"SELIC_OVER\", \"31-05-2024\")\n        0.104\n\n    \"\"\"\n    reference_date = dc.convert_input_dates(reference_date)\n    code = str(indicator_code).upper()\n    match code:\n        case \"IPCA_MR\":\n            return ipca_monthly_rate(reference_date)\n        case \"SELIC_TARGET\":\n            return _selic_target(reference_date)\n        case \"SELIC_OVER\":\n            return _selic_over(reference_date)\n        case \"DI\":\n            return _di(reference_date)\n        case \"VNA_LFT\":\n            return _vna_lft(reference_date)\n        case _:\n            raise ValueError(f\"Invalid indicator type: {code}\")\n</code></pre>"},{"location":"indicators/#pyield.indicators.ipca_monthly_rate","title":"<code>ipca_monthly_rate(reference_date)</code>","text":"<p>The function makes an API call to the IBGE's data portal to retrieve the data. An example of the API call: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202403/variaveis/63?localidades=N1[all] where '202403' is the reference date in 'YYYYMM' format. The API URL is constructed dynamically based on the reference date provided.</p> Source code in <code>pyield/indicators.py</code> <pre><code>def ipca_monthly_rate(reference_date: pd.Timestamp) -&gt; float:\n    \"\"\"\n    The function makes an API call to the IBGE's data portal to retrieve the data.\n    An example of the API call: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202403/variaveis/63?localidades=N1[all]\n    where '202403' is the reference date in 'YYYYMM' format.\n    The API URL is constructed dynamically based on the reference date provided.\n    \"\"\"\n    # Format the date as 'YYYYMM' for the API endpoint\n    ipca_date = reference_date.strftime(\"%Y%m\")\n\n    # Construct the API URL using the formatted date\n    api_url = f\"https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/{ipca_date}/variaveis/63?localidades=N1[all]\"\n\n    # Send a GET request to the API\n    response = requests.get(api_url, timeout=10)\n\n    # Raises HTTPError, if one occurred\n    response.raise_for_status()\n\n    # Parse the JSON response\n    data = response.json()\n\n    if not data:\n        return float(\"nan\")\n    # Extract and return the IPCA monthly growth rate if data is available\n    ipca_str = data[0][\"resultados\"][0][\"series\"][0][\"serie\"][ipca_date]\n    return round(float(ipca_str) / 100, 4)\n</code></pre>"},{"location":"interpolator/","title":"Interpolator (intepolator)","text":""},{"location":"interpolator/#pyield.interpolator.Interpolator","title":"<code>Interpolator</code>","text":"Source code in <code>pyield/interpolator.py</code> <pre><code>class Interpolator:\n    def __init__(\n        self,\n        method: Literal[\"flat_forward\", \"linear\"],\n        known_bdays: pd.Series | list,\n        known_rates: pd.Series | list,\n        extrapolate: bool = False,\n    ):\n        \"\"\"\n        Initialize the Interpolator with given atributes.\n\n        Args:\n            method (Literal[\"flat_forward\", \"linear\"]): Interpolation method.\n            known_bdays (pd.Series | pd.Index | list): Series of known business days.\n            known_rates (pd.Series | pd.Index | list): Series of known interest rates.\n            extrapolate (bool, optional): Whether to extrapolate beyond the known data.\n\n        Raises:\n            ValueError: If known_bdays and known_rates do not have the same length.\n            ValueError: If the interpolation method is not recognized\n\n        Returns:\n            Interpolator: An instance of the Interpolator\n\n        Note:\n            This class uses a 252 business days per year convention.\n        Examples:\n            &gt;&gt;&gt; from pyield import Interpolator\n            &gt;&gt;&gt; known_bdays = [30, 60, 90]\n            &gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n\n            &gt;&gt;&gt; lin_interp = Interpolator(\"linear\", known_bdays, known_rates)\n            &gt;&gt;&gt; lin_interp(45)\n            0.0475\n\n            &gt;&gt;&gt; ffo_interp = Interpolator(\"flat_forward\", known_bdays, known_rates)\n            &gt;&gt;&gt; ffo_interp(45)\n            0.04833068080970859\n\n        \"\"\"\n        self.method = method\n        self.known_bdays = known_bdays\n        self.known_rates = known_rates\n        self.extrapolate = extrapolate\n        self._validate_and_process_inputs()\n\n    def _validate_and_process_inputs(self) -&gt; None:\n        \"\"\"Validate and process the inputs of the Interpolator.\"\"\"\n        known_bdays = self.known_bdays\n        known_rates = self.known_rates\n        # Series may have different index, so we convert to list\n        if isinstance(known_bdays, pd.Series):\n            known_bdays = known_bdays.to_list()\n        if isinstance(known_rates, pd.Series):\n            known_rates = known_rates.to_list()\n\n        if len(known_bdays) != len(known_rates):\n            raise ValueError(\"known_bdays and known_rates must have the same length.\")\n\n        df = pd.DataFrame({\"bday\": known_bdays, \"rate\": known_rates})\n        df = df.dropna().drop_duplicates(subset=\"bday\").sort_values(\"bday\")\n\n        self._known_bdays = df[\"bday\"].to_list()\n        self._known_rates = df[\"rate\"].to_list()\n\n    def _flat_forward(self, bday: int) -&gt; float:\n        \"\"\"Performs the interest rate interpolation using the flat forward method.\"\"\"\n\n        # Find i such that known_bdays[i-1] &lt; bday &lt; known_bdays[i]\n        i = bisect.bisect_left(self._known_bdays, bday)\n\n        # Get previous and next known rates and business days\n        prev_rate = self._known_rates[i - 1]\n        prev_bday = self._known_bdays[i - 1]\n        next_rate = self._known_rates[i]\n        next_bday = self._known_bdays[i]\n\n        # Perform flat forward interpolation\n        a = (1 + prev_rate) ** (prev_bday / 252)\n        b = (1 + next_rate) ** (next_bday / 252)\n        c = (bday - prev_bday) / (next_bday - prev_bday)\n        return (a * (b / a) ** c) ** (252 / bday) - 1\n\n    def _linear(self, bday: int) -&gt; float:\n        \"\"\"Performs linear interpolation.\"\"\"\n        np_float = np.interp(bday, self._known_bdays, self._known_rates)\n        return float(np_float)\n\n    def interpolate(self, bday: int) -&gt; float:\n        \"\"\"\n        Finds the appropriate interpolation point and returns the interest rate\n        interpolated by the specified method from that point.\n\n        Args:\n            bday (int): Number of business days for which the interest rate is to be\n                calculated.\n\n        Returns:\n            float: The interest rate interpolated by the specified method for the given\n                number of business days.\n        \"\"\"\n        # Check for cases where interpolation is not needed\n        if bday &lt; self._known_bdays[0]:\n            return self._known_rates[0]\n        elif bday in self._known_bdays:\n            return self._known_rates[self._known_bdays.index(bday)]\n        elif bday &gt; self._known_bdays[-1]:\n            if self.extrapolate:\n                return self._known_rates[-1]\n            else:\n                return float(\"NaN\")  # Return NaN if extrapolation is not allowed\n\n        if self.method == \"flat_forward\":\n            return self._flat_forward(bday)\n        elif self.method == \"linear\":\n            return self._linear(bday)\n        else:\n            raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n\n    def __call__(self, bday: int) -&gt; float:\n        \"\"\"\n        Allows the instance to be called as a function to perform interpolation.\n\n        Args:\n            bday (int): Number of business days for which the interest rate is to be\n                calculated.\n\n        Returns:\n            float: The interest rate interpolated by the specified method for the given\n                number of business days.\n        \"\"\"\n        return self.interpolate(bday)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.interpolate","title":"<code>interpolate(bday)</code>","text":"<p>Finds the appropriate interpolation point and returns the interest rate interpolated by the specified method from that point.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interest rate interpolated by the specified method for the given number of business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bday: int) -&gt; float:\n    \"\"\"\n    Finds the appropriate interpolation point and returns the interest rate\n    interpolated by the specified method from that point.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for the given\n            number of business days.\n    \"\"\"\n    # Check for cases where interpolation is not needed\n    if bday &lt; self._known_bdays[0]:\n        return self._known_rates[0]\n    elif bday in self._known_bdays:\n        return self._known_rates[self._known_bdays.index(bday)]\n    elif bday &gt; self._known_bdays[-1]:\n        if self.extrapolate:\n            return self._known_rates[-1]\n        else:\n            return float(\"NaN\")  # Return NaN if extrapolation is not allowed\n\n    if self.method == \"flat_forward\":\n        return self._flat_forward(bday)\n    elif self.method == \"linear\":\n        return self._linear(bday)\n    else:\n        raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n</code></pre>"},{"location":"lft/","title":"LFT (lft)","text":""},{"location":"lft/#pyield.bonds.lft.maturities","title":"<code>maturities(reference_date)</code>","text":"<p>Fetch the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of bond maturities available for the reference date.</p> Source code in <code>pyield/bonds/lft.py</code> <pre><code>def maturities(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch the bond maturities available for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series of bond maturities available for the reference date.\n    \"\"\"\n    df_rates = rates(reference_date)\n    return df_rates[\"MaturityDate\"]\n</code></pre>"},{"location":"lft/#pyield.bonds.lft.premium","title":"<code>premium(lft_rate, selic_over)</code>","text":"<p>Calculate the premium of the LFT bond over the Selic rate (overnight). Obs: The Selic rate (overnight) is not the same as the Selic target rate</p> <p>Parameters:</p> Name Type Description Default <code>lft_rate</code> <code>float</code> <p>The LFT rate for the bond.</p> required <code>selic_over</code> <code>float</code> <p>The Selic overnight rate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LFT bond over the Selic rate.</p> <p>Examples:</p> <p>Calculate the premium of a LFT bond with a 0.02 yield rate over the Selic rate:</p> <pre><code>&gt;&gt;&gt; lft_rate = 0.1695 / 100  # 0.1695%\n&gt;&gt;&gt; selic_over = 10.40 / 100  # 10.40%\n&gt;&gt;&gt; yd.lft.premium(lft_rate, selic_over)\n1.017121\n</code></pre> Source code in <code>pyield/bonds/lft.py</code> <pre><code>def premium(lft_rate: float, selic_over: float) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LFT bond over the Selic rate (overnight).\n    Obs: The Selic rate (overnight) is not the same as the Selic target rate\n\n    Args:\n        lft_rate (float): The LFT rate for the bond.\n        selic_over (float): The Selic overnight rate.\n\n    Returns:\n        float: The premium of the LFT bond over the Selic rate.\n\n    Examples:\n        Calculate the premium of a LFT bond with a 0.02 yield rate over the Selic rate:\n        &gt;&gt;&gt; lft_rate = 0.1695 / 100  # 0.1695%\n        &gt;&gt;&gt; selic_over = 10.40 / 100  # 10.40%\n        &gt;&gt;&gt; yd.lft.premium(lft_rate, selic_over)\n        1.017121\n    \"\"\"\n    adjusted_lft_rate = (lft_rate + 1) * (selic_over + 1) - 1\n    f1 = (adjusted_lft_rate + 1) ** (1 / 252) - 1\n    f2 = (selic_over + 1) ** (1 / 252) - 1\n    return round(f1 / f2, 6)\n</code></pre>"},{"location":"lft/#pyield.bonds.lft.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the quotation of a LFT bond using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date of the bond.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The annualized yield rate of the bond</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The quotation of the bond.</p> <p>Examples:</p> <p>Calculate the quotation of a LFT bond with a 0.02 yield rate:</p> <pre><code>&gt;&gt;&gt; yd.lft.quotation(\n...     settlement=\"24-07-2024\",\n...     maturity=\"01-09-2030\",\n...     rate=0.001717,  # 0.1717%\n... )\n98.9645\n</code></pre> Source code in <code>pyield/bonds/lft.py</code> <pre><code>def quotation(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the quotation of a LFT bond using Anbima rules.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date of the bond.\n        maturity (str | pd.Timestamp): The maturity date of the bond.\n        rate (float): The annualized yield rate of the bond\n\n    Returns:\n        float: The quotation of the bond.\n\n    Examples:\n        Calculate the quotation of a LFT bond with a 0.02 yield rate:\n        &gt;&gt;&gt; yd.lft.quotation(\n        ...     settlement=\"24-07-2024\",\n        ...     maturity=\"01-09-2030\",\n        ...     rate=0.001717,  # 0.1717%\n        ... )\n        98.9645\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # The number of bdays between settlement (inclusive) and the maturity (exclusive)\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = bt.truncate(bdays / 252, 14)\n\n    discount_factor = 1 / (1 + rate) ** num_of_years\n\n    return bt.truncate(100 * discount_factor, 4)\n</code></pre>"},{"location":"lft/#pyield.bonds.lft.rates","title":"<code>rates(reference_date)</code>","text":"<p>Fetch the bond Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> Source code in <code>pyield/bonds/lft.py</code> <pre><code>def rates(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the bond Anbima indicative rates for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n    \"\"\"\n    lft_rates = anbima.rates(reference_date, \"LFT\")\n    if lft_rates.empty:\n        return pd.DataFrame()\n    return lft_rates[[\"MaturityDate\", \"IndicativeRate\"]]\n</code></pre>"},{"location":"ltn/","title":"LTN (ltn)","text":""},{"location":"ltn/#pyield.bonds.ltn.di_spreads","title":"<code>di_spreads(reference_date)</code>","text":"<p>Calculates the DI spread for the LTN based on ANBIMA's indicative rates.</p> <p>This function fetches the indicative rates for the NTN-F bonds and the DI futures rates and calculates the spread between these rates in basis points.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for the spread calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with the columns \"MaturityDate\" and \"DISpread\" (in bps).</p> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def di_spreads(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the DI spread for the LTN based on ANBIMA's indicative rates.\n\n    This function fetches the indicative rates for the NTN-F bonds and the DI futures\n    rates and calculates the spread between these rates in basis points.\n\n    Parameters:\n        reference_date (str | pd.Timestamp, optional): The reference date for the\n            spread calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame with the columns \"MaturityDate\" and \"DISpread\" (in bps).\n    \"\"\"\n    # Fetch DI Spreads for the reference date\n    df = bt.di_spreads(reference_date)\n    df.query(\"BondType == 'LTN'\", inplace=True)\n    df.sort_values([\"MaturityDate\"], ignore_index=True, inplace=True)\n    return df[[\"MaturityDate\", \"DISpread\"]]\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.historical_premium","title":"<code>historical_premium(reference_date, maturity)</code>","text":"<p>Calculate the premium of the LTN bond over the DI Future rate for a given date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date to fetch the rates.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date of the LTN bond.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LTN bond over the DI Future rate for the given date.    If the data is not available, returns NaN.</p> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def historical_premium(\n    reference_date: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LTN bond over the DI Future rate for a given date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date to fetch the rates.\n        maturity (str | pd.Timestamp): The maturity date of the LTN bond.\n\n    Returns:\n        float: The premium of the LTN bond over the DI Future rate for the given date.\n               If the data is not available, returns NaN.\n    \"\"\"\n    # Convert input dates to a consistent format\n    reference_date = dc.convert_input_dates(reference_date)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Retrieve LTN rates for the reference date\n    df_anbima = rates(reference_date)\n    if df_anbima.empty:\n        return float(\"NaN\")\n\n    # Extract the LTN rate for the specified maturity date\n    ltn_rates = df_anbima.query(\"MaturityDate == @maturity\")[\"IndicativeRate\"]\n    if ltn_rates.empty:\n        return float(\"NaN\")\n    ltn_rate = float(ltn_rates.iloc[0])\n\n    # Retrieve DI rate for the reference date and maturity\n    di_rate = di.rate(trade_date=reference_date, expiration=maturity)\n    if pd.isnull(di_rate):  # Check if the DI rate is NaN\n        return float(\"NaN\")\n\n    # Calculate and return the premium using the extracted rates\n    return premium(ltn_rate, di_rate)\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.maturities","title":"<code>maturities(reference_date)</code>","text":"<p>Fetch the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of bond maturities available for the reference date.</p> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def maturities(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch the bond maturities available for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series of bond maturities available for the reference date.\n    \"\"\"\n    df_rates = rates(reference_date)\n    return df_rates[\"MaturityDate\"]\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.premium","title":"<code>premium(ltn_rate, di_rate)</code>","text":"<p>Calculate the premium of the LTN bond over the DI Future rate using provided rates.</p> <p>Parameters:</p> Name Type Description Default <code>ltn_rate</code> <code>float</code> <p>The annualized LTN rate.</p> required <code>di_rate</code> <code>float</code> <p>The annualized DI Future rate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LTN bond over the DI Future rate.</p> <p>Examples:</p> <p>Reference date: 22-08-2024 LTN rate for 01-01-2030: 0.118746 DI (JAN30) Settlement rate: 0.11725</p> <pre><code>&gt;&gt;&gt; yd.ltn.premium(0.118746, 0.11725)\n1.012072\n</code></pre> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def premium(ltn_rate: float, di_rate: float) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LTN bond over the DI Future rate using provided rates.\n\n    Args:\n        ltn_rate (float): The annualized LTN rate.\n        di_rate (float): The annualized DI Future rate.\n\n    Returns:\n        float: The premium of the LTN bond over the DI Future rate.\n\n    Examples:\n        Reference date: 22-08-2024\n        LTN rate for 01-01-2030: 0.118746\n        DI (JAN30) Settlement rate: 0.11725\n        &gt;&gt;&gt; yd.ltn.premium(0.118746, 0.11725)\n        1.012072\n    \"\"\"\n    # C\u00e1lculo das taxas di\u00e1rias\n    ltn_factor = (1 + ltn_rate) ** (1 / 252)\n    di_factor = (1 + di_rate) ** (1 / 252)\n\n    # Retorno do c\u00e1lculo do pr\u00eamio\n    return round((ltn_factor - 1) / (di_factor - 1), 6)\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the LTN price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-F.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The LTN price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n535.279902\n</code></pre> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def price(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the LTN price using Anbima rules.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-F.\n\n    Returns:\n        float: The LTN price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; yd.ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n        535.279902\n    \"\"\"\n\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rule\n    num_of_years = bt.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Truncate the price to 6 decimal places as per Anbima rules\n    return bt.truncate(FACE_VALUE / discount_factor, 6)\n</code></pre>"},{"location":"ltn/#pyield.bonds.ltn.rates","title":"<code>rates(reference_date)</code>","text":"<p>Fetch the LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> Source code in <code>pyield/bonds/ltn.py</code> <pre><code>def rates(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n    \"\"\"\n    ltn_rates = anbima.rates(reference_date, \"LTN\")\n    if ltn_rates.empty:\n        return pd.DataFrame()\n    return ltn_rates[[\"MaturityDate\", \"IndicativeRate\"]]\n</code></pre>"},{"location":"ntnb/","title":"NTN-B (ntnb)","text":""},{"location":"ntnb/#pyield.bonds.ntnb.Interpolator","title":"<code>Interpolator</code>","text":"Source code in <code>pyield/interpolator.py</code> <pre><code>class Interpolator:\n    def __init__(\n        self,\n        method: Literal[\"flat_forward\", \"linear\"],\n        known_bdays: pd.Series | list,\n        known_rates: pd.Series | list,\n        extrapolate: bool = False,\n    ):\n        \"\"\"\n        Initialize the Interpolator with given atributes.\n\n        Args:\n            method (Literal[\"flat_forward\", \"linear\"]): Interpolation method.\n            known_bdays (pd.Series | pd.Index | list): Series of known business days.\n            known_rates (pd.Series | pd.Index | list): Series of known interest rates.\n            extrapolate (bool, optional): Whether to extrapolate beyond the known data.\n\n        Raises:\n            ValueError: If known_bdays and known_rates do not have the same length.\n            ValueError: If the interpolation method is not recognized\n\n        Returns:\n            Interpolator: An instance of the Interpolator\n\n        Note:\n            This class uses a 252 business days per year convention.\n        Examples:\n            &gt;&gt;&gt; from pyield import Interpolator\n            &gt;&gt;&gt; known_bdays = [30, 60, 90]\n            &gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n\n            &gt;&gt;&gt; lin_interp = Interpolator(\"linear\", known_bdays, known_rates)\n            &gt;&gt;&gt; lin_interp(45)\n            0.0475\n\n            &gt;&gt;&gt; ffo_interp = Interpolator(\"flat_forward\", known_bdays, known_rates)\n            &gt;&gt;&gt; ffo_interp(45)\n            0.04833068080970859\n\n        \"\"\"\n        self.method = method\n        self.known_bdays = known_bdays\n        self.known_rates = known_rates\n        self.extrapolate = extrapolate\n        self._validate_and_process_inputs()\n\n    def _validate_and_process_inputs(self) -&gt; None:\n        \"\"\"Validate and process the inputs of the Interpolator.\"\"\"\n        known_bdays = self.known_bdays\n        known_rates = self.known_rates\n        # Series may have different index, so we convert to list\n        if isinstance(known_bdays, pd.Series):\n            known_bdays = known_bdays.to_list()\n        if isinstance(known_rates, pd.Series):\n            known_rates = known_rates.to_list()\n\n        if len(known_bdays) != len(known_rates):\n            raise ValueError(\"known_bdays and known_rates must have the same length.\")\n\n        df = pd.DataFrame({\"bday\": known_bdays, \"rate\": known_rates})\n        df = df.dropna().drop_duplicates(subset=\"bday\").sort_values(\"bday\")\n\n        self._known_bdays = df[\"bday\"].to_list()\n        self._known_rates = df[\"rate\"].to_list()\n\n    def _flat_forward(self, bday: int) -&gt; float:\n        \"\"\"Performs the interest rate interpolation using the flat forward method.\"\"\"\n\n        # Find i such that known_bdays[i-1] &lt; bday &lt; known_bdays[i]\n        i = bisect.bisect_left(self._known_bdays, bday)\n\n        # Get previous and next known rates and business days\n        prev_rate = self._known_rates[i - 1]\n        prev_bday = self._known_bdays[i - 1]\n        next_rate = self._known_rates[i]\n        next_bday = self._known_bdays[i]\n\n        # Perform flat forward interpolation\n        a = (1 + prev_rate) ** (prev_bday / 252)\n        b = (1 + next_rate) ** (next_bday / 252)\n        c = (bday - prev_bday) / (next_bday - prev_bday)\n        return (a * (b / a) ** c) ** (252 / bday) - 1\n\n    def _linear(self, bday: int) -&gt; float:\n        \"\"\"Performs linear interpolation.\"\"\"\n        np_float = np.interp(bday, self._known_bdays, self._known_rates)\n        return float(np_float)\n\n    def interpolate(self, bday: int) -&gt; float:\n        \"\"\"\n        Finds the appropriate interpolation point and returns the interest rate\n        interpolated by the specified method from that point.\n\n        Args:\n            bday (int): Number of business days for which the interest rate is to be\n                calculated.\n\n        Returns:\n            float: The interest rate interpolated by the specified method for the given\n                number of business days.\n        \"\"\"\n        # Check for cases where interpolation is not needed\n        if bday &lt; self._known_bdays[0]:\n            return self._known_rates[0]\n        elif bday in self._known_bdays:\n            return self._known_rates[self._known_bdays.index(bday)]\n        elif bday &gt; self._known_bdays[-1]:\n            if self.extrapolate:\n                return self._known_rates[-1]\n            else:\n                return float(\"NaN\")  # Return NaN if extrapolation is not allowed\n\n        if self.method == \"flat_forward\":\n            return self._flat_forward(bday)\n        elif self.method == \"linear\":\n            return self._linear(bday)\n        else:\n            raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n\n    def __call__(self, bday: int) -&gt; float:\n        \"\"\"\n        Allows the instance to be called as a function to perform interpolation.\n\n        Args:\n            bday (int): Number of business days for which the interest rate is to be\n                calculated.\n\n        Returns:\n            float: The interest rate interpolated by the specified method for the given\n                number of business days.\n        \"\"\"\n        return self.interpolate(bday)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.Interpolator.interpolate","title":"<code>interpolate(bday)</code>","text":"<p>Finds the appropriate interpolation point and returns the interest rate interpolated by the specified method from that point.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interest rate interpolated by the specified method for the given number of business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bday: int) -&gt; float:\n    \"\"\"\n    Finds the appropriate interpolation point and returns the interest rate\n    interpolated by the specified method from that point.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for the given\n            number of business days.\n    \"\"\"\n    # Check for cases where interpolation is not needed\n    if bday &lt; self._known_bdays[0]:\n        return self._known_rates[0]\n    elif bday in self._known_bdays:\n        return self._known_rates[self._known_bdays.index(bday)]\n    elif bday &gt; self._known_bdays[-1]:\n        if self.extrapolate:\n            return self._known_rates[-1]\n        else:\n            return float(\"NaN\")  # Return NaN if extrapolation is not allowed\n\n    if self.method == \"flat_forward\":\n        return self._flat_forward(bday)\n    elif self.method == \"linear\":\n        return self._linear(bday)\n    else:\n        raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.bei_rates","title":"<code>bei_rates(settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates)</code>","text":"<p>Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real interest rates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str or Timestamp</code> <p>The settlement date for the bonds.</p> required <code>ntnb_maturities</code> <code>Series</code> <p>Series of maturity dates for the inflation-indexed bonds (NTN-B).</p> required <code>ntnb_rates</code> <code>Series</code> <p>Series of real interest rates (Yield to Maturity - YTM) corresponding to the inflation-indexed bonds' maturity dates.</p> required <code>nominal_maturities</code> <code>Series</code> <p>Series of maturity dates corresponding to the nominal reates.</p> required <code>nominal_rates</code> <code>Series</code> <p>Series of nominal interest rates (e.g., DI or prefixed bonds) used as reference for the calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the calculated breakeven inflation rates.</p> Returned columns <ul> <li>MaturityDate: The maturity date of the bonds.</li> <li>BDays: Number of business days from the settlement date to the maturity date.</li> <li>RIR: The calculated Real Interest Rate based on the spot rates.</li> <li>NIR: Nominal Interest Rate interpolated for the corresponding maturity date.</li> <li>BEI: The calculated Breakeven Inflation Rate, which represents the inflation     rate that equalizes the real and nominal yields.</li> </ul> Notes <p>The BEI is calculated by comparing the nominal and real interest rates, indicating the market's inflation expectations over the period from the settlement date to the bond's maturity.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def bei_rates(\n    settlement: str | pd.Timestamp,\n    ntnb_maturities: pd.Series,\n    ntnb_rates: pd.Series,\n    nominal_maturities: pd.Series,\n    nominal_rates: pd.Series,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real\n    interest rates.\n\n    Args:\n        settlement (str or pd.Timestamp): The settlement date for the bonds.\n        ntnb_maturities (pd.Series): Series of maturity dates for the inflation-indexed\n            bonds (NTN-B).\n        ntnb_rates (pd.Series): Series of real interest rates (Yield to Maturity - YTM)\n            corresponding to the inflation-indexed bonds' maturity dates.\n        nominal_maturities (pd.Series): Series of maturity dates corresponding to the\n            nominal reates.\n        nominal_rates (pd.Series): Series of nominal interest rates\n            (e.g., DI or prefixed bonds) used as reference for the calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the calculated breakeven inflation rates.\n\n    Returned columns:\n        - MaturityDate: The maturity date of the bonds.\n        - BDays: Number of business days from the settlement date to the maturity date.\n        - RIR: The calculated Real Interest Rate based on the spot rates.\n        - NIR: Nominal Interest Rate interpolated for the corresponding maturity date.\n        - BEI: The calculated Breakeven Inflation Rate, which represents the inflation\n            rate that equalizes the real and nominal yields.\n\n    Notes:\n        The BEI is calculated by comparing the nominal and real interest rates,\n        indicating the market's inflation expectations over the period from the\n        settlement date to the bond's maturity.\n    \"\"\"\n    # Normalize input dates\n    settlement = dc.convert_input_dates(settlement)\n    ntnb_maturities = pd.to_datetime(ntnb_maturities, errors=\"coerce\", dayfirst=True)\n\n    # Calculate Real Interest Rate (RIR)\n    df = spot_rates(settlement, ntnb_maturities, ntnb_rates)\n    df[\"BDays\"] = bday.count(settlement, df[\"MaturityDate\"])\n    df = df.rename(columns={\"SpotRate\": \"RIR\"})\n\n    nir_interplator = Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, nominal_maturities),\n        known_rates=nominal_rates,\n        extrapolate=True,\n    )\n\n    df[\"NIR\"] = df[\"BDays\"].apply(nir_interplator).astype(\"Float64\")\n    # Calculate Breakeven Inflation Rate (BEI)\n    df[\"BEI\"] = ((df[\"NIR\"] + 1) / (df[\"RIR\"] + 1)) - 1\n\n    cols_reordered = [\n        \"MaturityDate\",\n        \"RIR\",\n        \"NIR\",\n        \"BEI\",\n    ]\n    return df[cols_reordered].copy()\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Generate the cash flows for NTN-B bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n  PaymentDate    CashFlow\n0  2024-05-15    2.956301\n1  2024-11-15    2.956301\n2  2025-05-15  102.956301\n</code></pre> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def cash_flows(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-B bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n          PaymentDate    CashFlow\n        0  2024-05-15    2.956301\n        1  2024-11-15    2.956301\n        2  2025-05-15  102.956301\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Get the coupon dates between the settlement and maturity dates\n    p_dates = payment_dates(settlement, maturity)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cfs = np.where(p_dates == maturity, FINAL_PMT, COUPON_PMT).tolist()\n\n    # Return a dataframe with the payment dates and cash flows\n    return pd.DataFrame(data={\"PaymentDate\": p_dates, \"CashFlow\": cfs})\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.maturities","title":"<code>maturities(reference_date)</code>","text":"<p>Get the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series containing the maturity dates for the NTN-B bonds.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def maturities(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Get the bond maturities available for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: Series containing the maturity dates for the NTN-B bonds.\n    \"\"\"\n    df_rates = rates(reference_date)\n    return df_rates[\"MaturityDate\"]\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. Coupon payments are made on the 15th of February, May, August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date (exlusive) to start generating coupon dates.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series of coupon dates within the specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n0   2024-05-15\n1   2024-11-15\n2   2025-05-15\ndtype: datetime64[ns]\n</code></pre> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def payment_dates(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. Coupon payments are made on the 15th of February, May,\n    August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B\n    bond is determined by its maturity date.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date (exlusive) to\n            start generating coupon dates.\n        maturity (str | pd.Timestamp): The maturity date.\n\n    Returns:\n        pd.Series: Series of coupon dates within the specified range.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n        0   2024-05-15\n        1   2024-11-15\n        2   2025-05-15\n        dtype: datetime64[ns]\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n    _check_maturities(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt; settlement:\n        raise ValueError(\"Maturity date must be after the start date.\")\n\n    # Initialize loop variables\n    coupon_dates = maturity\n    cp_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_dates &gt; settlement:\n        cp_dates.append(coupon_dates)\n        # Move the coupon date back 6 months\n        coupon_dates -= pd.DateOffset(months=6)\n\n    return pd.Series(cp_dates).sort_values(ignore_index=True)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-B price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-B bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-B quotation in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.price(4299.160173, 99.3651)\n4271.864805\n</code></pre> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B price using Anbima rules.\n\n    Args:\n        vna (float): The nominal value of the NTN-B bond.\n        quotation (float): The NTN-B quotation in base 100.\n\n    Returns:\n        float: The NTN-B price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.price(4299.160173, 99.3651)\n        4271.864805\n    \"\"\"\n    return bt.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-B quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B quotation truncated to 4 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; yd.ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n</code></pre> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def quotation(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n\n    Returns:\n        float: The NTN-B quotation truncated to 4 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n        99.3651\n        &gt;&gt;&gt; yd.ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n        99.5341\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n    _check_maturities(maturity)\n\n    cf_df = cash_flows(settlement, maturity)\n    cf_dates = cf_df[\"PaymentDate\"]\n    cf_values = cf_df[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = bt.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return bt.truncate(cf_present_value.sum(), 4)\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.rates","title":"<code>rates(reference_date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def rates(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n    \"\"\"\n    ntnb_rates = anbima.rates(reference_date, \"NTN-B\")\n    if ntnb_rates.empty:\n        return pd.DataFrame()\n    return ntnb_rates[[\"MaturityDate\", \"IndicativeRate\"]]\n</code></pre>"},{"location":"ntnb/#pyield.bonds.ntnb.spot_rates","title":"<code>spot_rates(settlement, maturities, rates)</code>","text":"<p>Calculate the spot rates for NTN-B bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The reference date for settlement.</p> required <code>maturities</code> <code>Series</code> <p>Series of maturity dates for the bonds.</p> required <code>rates</code> <code>Series</code> <p>Series of yield to maturity rates.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".</p> Notes <p>The calculation of the spot rates for NTN-B bonds considers the following steps:     - Map all all possible payment dates up to the longest maturity date.     - Interpolate the YTM rates in the intermediate payment dates.     - Calculate the NTN-B quotation for each maturity date.     - Calculate the real spot rates for each maturity date.     - Columns in the returned DataFrame:         - MaturityDate: The maturity date of the bond.         - YTM: The yield to maturity rate for the bond.         - SpotRate: The real spot rate for the bond.</p> Source code in <code>pyield/bonds/ntnb.py</code> <pre><code>def spot_rates(\n    settlement: str | pd.Timestamp,\n    maturities: pd.Series,\n    rates: pd.Series,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the spot rates for NTN-B bonds using the bootstrap method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price.\n\n\n    Args:\n        settlement (str | pd.Timestamp): The reference date for settlement.\n        maturities (pd.Series): Series of maturity dates for the bonds.\n        rates (pd.Series): Series of yield to maturity rates.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".\n\n    Notes:\n        The calculation of the spot rates for NTN-B bonds considers the following steps:\n            - Map all all possible payment dates up to the longest maturity date.\n            - Interpolate the YTM rates in the intermediate payment dates.\n            - Calculate the NTN-B quotation for each maturity date.\n            - Calculate the real spot rates for each maturity date.\n            - Columns in the returned DataFrame:\n                - MaturityDate: The maturity date of the bond.\n                - YTM: The yield to maturity rate for the bond.\n                - SpotRate: The real spot rate for the bond.\n    \"\"\"\n    # Process and validate the input data\n    settlement = dc.convert_input_dates(settlement)\n    maturities = pd.to_datetime(maturities, errors=\"raise\", dayfirst=True)\n    _check_maturities(maturities)\n\n    # Create the interpolator object\n    ff_interpolator = Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, maturities),\n        known_rates=rates,\n    )\n\n    # Generate coupon dates up to the longest maturity date\n    all_coupon_dates = _generate_coupon_dates_map(\n        start=settlement, end=maturities.max()\n    )\n\n    # Create a DataFrame with all coupon dates and the corresponding YTM\n    df = pd.DataFrame(data=all_coupon_dates, columns=[\"MaturityDate\"])\n    df[\"BDays\"] = bday.count(settlement, df[\"MaturityDate\"])\n    df[\"BYears\"] = df[\"BDays\"] / 252\n    df[\"YTM\"] = df[\"BDays\"].apply(ff_interpolator)\n    df[\"Coupon\"] = COUPON_PMT\n    df[\"SpotRate\"] = np.nan\n\n    # The Bootstrap loop to calculate spot rates\n    for index, row in df.iterrows():\n        # Get the cash flow dates for the bond\n        cf_dates = payment_dates(settlement, row[\"MaturityDate\"])\n\n        # If there is only one coupon date and this date is the first maturity date\n        # of an existing bond, the ytm rate is also a spot rate.\n        if len(cf_dates) == 1 and cf_dates[0] == maturities[0]:\n            df.at[index, \"SpotRate\"] = row[\"YTM\"]\n            continue\n\n        # Calculate the present value of the cash flows without last payment\n        cf_dates = cf_dates[:-1]\n        cf_df = df.query(\"MaturityDate in @cf_dates\").reset_index(drop=True)\n        cf_present_value = bt.calculate_present_value(\n            cash_flows=cf_df[\"Coupon\"],\n            rates=cf_df[\"SpotRate\"],\n            periods=cf_df[\"BYears\"],\n        )\n\n        # Calculate the Spot Rate for the bond\n        bond_price = quotation(settlement, row[\"MaturityDate\"], row[\"YTM\"])\n        price_factor = FINAL_PMT / (bond_price - cf_present_value)\n        df.at[index, \"SpotRate\"] = price_factor ** (1 / row[\"BYears\"]) - 1\n\n    df = df[[\"MaturityDate\", \"SpotRate\"]].copy()\n    # Force Float64 type in float columns to standardize the output\n    df[\"SpotRate\"] = df[\"SpotRate\"].astype(\"Float64\")\n    # Return the result without the intermediate coupon dates (virtual bonds)\n    return df.query(\"MaturityDate in @maturities\").reset_index(drop=True)\n</code></pre>"},{"location":"ntnf/","title":"NTN-F (ntnf)","text":""},{"location":"ntnf/#pyield.bonds.ntnf.Interpolator","title":"<code>Interpolator</code>","text":"Source code in <code>pyield/interpolator.py</code> <pre><code>class Interpolator:\n    def __init__(\n        self,\n        method: Literal[\"flat_forward\", \"linear\"],\n        known_bdays: pd.Series | list,\n        known_rates: pd.Series | list,\n        extrapolate: bool = False,\n    ):\n        \"\"\"\n        Initialize the Interpolator with given atributes.\n\n        Args:\n            method (Literal[\"flat_forward\", \"linear\"]): Interpolation method.\n            known_bdays (pd.Series | pd.Index | list): Series of known business days.\n            known_rates (pd.Series | pd.Index | list): Series of known interest rates.\n            extrapolate (bool, optional): Whether to extrapolate beyond the known data.\n\n        Raises:\n            ValueError: If known_bdays and known_rates do not have the same length.\n            ValueError: If the interpolation method is not recognized\n\n        Returns:\n            Interpolator: An instance of the Interpolator\n\n        Note:\n            This class uses a 252 business days per year convention.\n        Examples:\n            &gt;&gt;&gt; from pyield import Interpolator\n            &gt;&gt;&gt; known_bdays = [30, 60, 90]\n            &gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n\n            &gt;&gt;&gt; lin_interp = Interpolator(\"linear\", known_bdays, known_rates)\n            &gt;&gt;&gt; lin_interp(45)\n            0.0475\n\n            &gt;&gt;&gt; ffo_interp = Interpolator(\"flat_forward\", known_bdays, known_rates)\n            &gt;&gt;&gt; ffo_interp(45)\n            0.04833068080970859\n\n        \"\"\"\n        self.method = method\n        self.known_bdays = known_bdays\n        self.known_rates = known_rates\n        self.extrapolate = extrapolate\n        self._validate_and_process_inputs()\n\n    def _validate_and_process_inputs(self) -&gt; None:\n        \"\"\"Validate and process the inputs of the Interpolator.\"\"\"\n        known_bdays = self.known_bdays\n        known_rates = self.known_rates\n        # Series may have different index, so we convert to list\n        if isinstance(known_bdays, pd.Series):\n            known_bdays = known_bdays.to_list()\n        if isinstance(known_rates, pd.Series):\n            known_rates = known_rates.to_list()\n\n        if len(known_bdays) != len(known_rates):\n            raise ValueError(\"known_bdays and known_rates must have the same length.\")\n\n        df = pd.DataFrame({\"bday\": known_bdays, \"rate\": known_rates})\n        df = df.dropna().drop_duplicates(subset=\"bday\").sort_values(\"bday\")\n\n        self._known_bdays = df[\"bday\"].to_list()\n        self._known_rates = df[\"rate\"].to_list()\n\n    def _flat_forward(self, bday: int) -&gt; float:\n        \"\"\"Performs the interest rate interpolation using the flat forward method.\"\"\"\n\n        # Find i such that known_bdays[i-1] &lt; bday &lt; known_bdays[i]\n        i = bisect.bisect_left(self._known_bdays, bday)\n\n        # Get previous and next known rates and business days\n        prev_rate = self._known_rates[i - 1]\n        prev_bday = self._known_bdays[i - 1]\n        next_rate = self._known_rates[i]\n        next_bday = self._known_bdays[i]\n\n        # Perform flat forward interpolation\n        a = (1 + prev_rate) ** (prev_bday / 252)\n        b = (1 + next_rate) ** (next_bday / 252)\n        c = (bday - prev_bday) / (next_bday - prev_bday)\n        return (a * (b / a) ** c) ** (252 / bday) - 1\n\n    def _linear(self, bday: int) -&gt; float:\n        \"\"\"Performs linear interpolation.\"\"\"\n        np_float = np.interp(bday, self._known_bdays, self._known_rates)\n        return float(np_float)\n\n    def interpolate(self, bday: int) -&gt; float:\n        \"\"\"\n        Finds the appropriate interpolation point and returns the interest rate\n        interpolated by the specified method from that point.\n\n        Args:\n            bday (int): Number of business days for which the interest rate is to be\n                calculated.\n\n        Returns:\n            float: The interest rate interpolated by the specified method for the given\n                number of business days.\n        \"\"\"\n        # Check for cases where interpolation is not needed\n        if bday &lt; self._known_bdays[0]:\n            return self._known_rates[0]\n        elif bday in self._known_bdays:\n            return self._known_rates[self._known_bdays.index(bday)]\n        elif bday &gt; self._known_bdays[-1]:\n            if self.extrapolate:\n                return self._known_rates[-1]\n            else:\n                return float(\"NaN\")  # Return NaN if extrapolation is not allowed\n\n        if self.method == \"flat_forward\":\n            return self._flat_forward(bday)\n        elif self.method == \"linear\":\n            return self._linear(bday)\n        else:\n            raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n\n    def __call__(self, bday: int) -&gt; float:\n        \"\"\"\n        Allows the instance to be called as a function to perform interpolation.\n\n        Args:\n            bday (int): Number of business days for which the interest rate is to be\n                calculated.\n\n        Returns:\n            float: The interest rate interpolated by the specified method for the given\n                number of business days.\n        \"\"\"\n        return self.interpolate(bday)\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.Interpolator.interpolate","title":"<code>interpolate(bday)</code>","text":"<p>Finds the appropriate interpolation point and returns the interest rate interpolated by the specified method from that point.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interest rate interpolated by the specified method for the given number of business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bday: int) -&gt; float:\n    \"\"\"\n    Finds the appropriate interpolation point and returns the interest rate\n    interpolated by the specified method from that point.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for the given\n            number of business days.\n    \"\"\"\n    # Check for cases where interpolation is not needed\n    if bday &lt; self._known_bdays[0]:\n        return self._known_rates[0]\n    elif bday in self._known_bdays:\n        return self._known_rates[self._known_bdays.index(bday)]\n    elif bday &gt; self._known_bdays[-1]:\n        if self.extrapolate:\n            return self._known_rates[-1]\n        else:\n            return float(\"NaN\")  # Return NaN if extrapolation is not allowed\n\n    if self.method == \"flat_forward\":\n        return self._flat_forward(bday)\n    elif self.method == \"linear\":\n        return self._linear(bday)\n    else:\n        raise ValueError(f\"Unknown interpolation method: {self.method}.\")\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.cash_flows","title":"<code>cash_flows(settlement, maturity, adj_payment_dates=False)</code>","text":"<p>Generate the cash flows for the NTN-F bond between the settlement (exclusive) and maturity dates (inclusive). The cash flows are the coupon payments and the final payment at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>adj_payment_dates</code> <code>bool</code> <p>If True, adjust the payment dates to the next business day.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.cash_flows(\"15-05-2024\", \"01-01-2025\")\n  PaymentDate    CashFlow\n0  2024-07-01    48.80885\n1  2025-01-01  1048.80885\n</code></pre> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def cash_flows(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n    adj_payment_dates: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate the cash flows for the NTN-F bond between the settlement (exclusive) and\n    maturity dates (inclusive). The cash flows are the coupon payments and the final\n    payment at maturity.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n        adj_payment_dates (bool): If True, adjust the payment dates to the next\n            business day.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnf.cash_flows(\"15-05-2024\", \"01-01-2025\")\n          PaymentDate    CashFlow\n        0  2024-07-01    48.80885\n        1  2025-01-01  1048.80885\n    \"\"\"\n    # Validate input dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n    _check_maturity_date(maturity)\n\n    # Get the coupon payment dates between the settlement and maturity dates\n    pay_dates = payment_dates(settlement, maturity)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cf_values = np.where(pay_dates == maturity, FINAL_PMT, COUPON_PMT)\n\n    df = pd.DataFrame(data={\"PaymentDate\": pay_dates, \"CashFlow\": cf_values})\n\n    if adj_payment_dates:\n        df[\"PaymentDate\"] = bday.offset(df[\"PaymentDate\"], 0)\n\n    return df\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.di_net_spread","title":"<code>di_net_spread(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates, initial_guess=None)</code>","text":"<p>Calculate the net DI spread for a bond given the YTM and the DI rates.</p> <p>This function determines the spread over the DI curve that equates the present value of the bond's cash flows to its market price. It interpolates the DI rates to match the bond's cash flow payment dates and uses the Brent method to find the spread (in bps) that zeroes the difference between the bond's market price and its discounted cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The bond settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>ntnf_maturity</code> <code>str | Timestamp</code> <p>The bond maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the bond.</p> required <code>di_rates</code> <code>Series</code> <p>A Series of DI rates.</p> required <code>di_expirations</code> <code>Series</code> <p>A list or Series of DI expiration dates.</p> required <code>initial_guess</code> <code>float</code> <p>An initial guess for the spread. Defaults to None. A good initial guess is the DI gross spread for the bond.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The net DI spread in basis points.</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def di_net_spread(  # noqa\n    settlement: str | pd.Timestamp,\n    ntnf_maturity: str | pd.Timestamp,\n    ntnf_rate: float,\n    di_expirations: pd.Series,\n    di_rates: pd.Series,\n    initial_guess: float | None = None,\n) -&gt; float:\n    \"\"\"\n    Calculate the net DI spread for a bond given the YTM and the DI rates.\n\n    This function determines the spread over the DI curve that equates the present value\n    of the bond's cash flows to its market price. It interpolates the DI rates to match\n    the bond's cash flow payment dates and uses the Brent method to find the spread\n    (in bps) that zeroes the difference between the bond's market price and its\n    discounted cash flows.\n\n    Args:\n        settlement (str | pd.Timestamp): The bond settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        ntnf_maturity (str | pd.Timestamp): The bond maturity date in 'DD-MM-YYYY'\n            format or a pandas Timestamp.\n        ntnf_rate (float): The yield to maturity (YTM) of the bond.\n        di_rates (pd.Series): A Series of DI rates.\n        di_expirations (pd.Series): A list or Series of DI expiration dates.\n        initial_guess (float, optional): An initial guess for the spread. Defaults to\n            None. A good initial guess is the DI gross spread for the bond.\n\n    Returns:\n        float: The net DI spread in basis points.\n    \"\"\"\n    # Create an interpolator for the DI rates using the flat-forward method\n    settlement = dc.convert_input_dates(settlement)\n    ntnf_maturity = dc.convert_input_dates(ntnf_maturity)\n\n    ff_interpolator = Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    # Ensure the DI data is valid\n    if len(di_rates) != len(di_expirations):\n        raise ValueError(\"di_rates and di_expirations must have the same length.\")\n    if len(di_rates) == 0:\n        return float(\"NaN\")\n\n    # Calculate cash flows and business days between settlement and payment dates\n    df = cash_flows(settlement, ntnf_maturity).reset_index()\n    df[\"BDays\"] = bday.count(settlement, df[\"PaymentDate\"])\n\n    byears = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    di_interp = df[\"BDays\"].apply(ff_interpolator)\n    bond_price = price(settlement, ntnf_maturity, ntnf_rate)\n    bond_cash_flows = df[\"CashFlow\"]\n\n    def price_difference(p):\n        # Difference between the bond's price and its discounted cash flows\n        return (bond_cash_flows / (1 + di_interp + p) ** byears).sum() - bond_price\n\n    # Solve for the spread that zeroes the price difference using the bisection method\n    p_solution = _solve_spread(price_difference, initial_guess)\n    # Convert the solution to basis points (bps) and round to two decimal places\n    return round((p_solution * 10_000), 2)\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.di_spreads","title":"<code>di_spreads(reference_date)</code>","text":"<p>Calculates the DI spread for the NTN-F based on ANBIMA's indicative rates.</p> <p>This function fetches the indicative rates for the NTN-F bonds and the DI futures rates and calculates the spread between these rates in basis points.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for the spread calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\", \"DISpread\".</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def di_spreads(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the DI spread for the NTN-F based on ANBIMA's indicative rates.\n\n    This function fetches the indicative rates for the NTN-F bonds and the DI futures\n    rates and calculates the spread between these rates in basis points.\n\n    Parameters:\n        reference_date (str | pd.Timestamp, optional): The reference date for the\n            spread calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\", \"DISpread\".\n    \"\"\"\n    # Fetch DI Spreads for the reference date\n    df = bt.di_spreads(reference_date)\n    df.query(\"BondType == 'NTN-F'\", inplace=True)\n    df.sort_values([\"MaturityDate\"], ignore_index=True, inplace=True)\n    return df[[\"MaturityDate\", \"DISpread\"]]\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration for an NTN-F bond.</p> <p>The Macaulay duration is a weighted average of the times until each payment is received, with the weights proportional to the present value of the cash flows. It measures the bond's sensitivity to interest rate changes.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>rate</code> <code>float</code> <p>The yield to maturity (YTM) used to discount the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration in years.</p> Example <p>yd.ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785) 6.32854218039796</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def duration(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration for an NTN-F bond.\n\n    The Macaulay duration is a weighted average of the times until each payment is\n    received, with the weights proportional to the present value of the cash flows.\n    It measures the bond's sensitivity to interest rate changes.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        rate (float): The yield to maturity (YTM) used to discount the cash flows.\n\n    Returns:\n        float: The Macaulay duration in years.\n\n    Example:\n        &gt;&gt;&gt; yd.ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n        6.32854218039796\n    \"\"\"\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    df = cash_flows(settlement, maturity)\n    df[\"BY\"] = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    df[\"DCF\"] = df[\"CashFlow\"] / (1 + rate) ** df[\"BY\"]\n    np_duration = (df[\"DCF\"] * df[\"BY\"]).sum() / df[\"DCF\"].sum()\n    return float(np_duration)\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.maturities","title":"<code>maturities(reference_date)</code>","text":"<p>Fetch the NTN-F bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of NTN-F bond maturities available for the reference date.</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def maturities(reference_date: str | pd.Timestamp) -&gt; pd.Series:\n    \"\"\"\n    Fetch the NTN-F bond maturities available for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series of NTN-F bond maturities available for the reference date.\n    \"\"\"\n    df_rates = rates(reference_date)\n    return df_rates[\"MaturityDate\"]\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a settlement date and a maturity date. The dates are exclusive for the settlement date and inclusive for the maturity date. Coupon payments are made on the 1st of January and July. The NTN-F bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the coupon dates between the settlement (exclusive) and maturity (inclusive) dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.payment_dates(\"15-05-2024\", \"01-01-2025\")\n0   2024-07-01\n1   2025-01-01\ndtype: datetime64[ns]\n</code></pre> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def payment_dates(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a settlement date and a maturity date.\n    The dates are exclusive for the settlement date and inclusive for the maturity date.\n    Coupon payments are made on the 1st of January and July.\n    The NTN-F bond is determined by its maturity date.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date.\n        maturity (str | pd.Timestamp): The maturity date.\n\n    Returns:\n        pd.Series: A Series containing the coupon dates between the settlement\n            (exclusive) and maturity (inclusive) dates.\n\n    Examples:\n\n        &gt;&gt;&gt; yd.ntnf.payment_dates(\"15-05-2024\", \"01-01-2025\")\n        0   2024-07-01\n        1   2025-01-01\n        dtype: datetime64[ns]\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Check if the maturity date is valid\n    _check_maturity_date(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt;= settlement:\n        raise ValueError(\"Maturity date must be after the settlement date.\")\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= pd.DateOffset(months=6)\n\n    # Return the coupon dates as a sorted Series\n    return pd.Series(coupon_dates).sort_values(ignore_index=True)\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-F price using Anbima rules, which corresponds to the present     value of the cash flows discounted at the given yield to maturity rate (YTM).</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity</code> <code>str | Timestamp</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) used to calculate the present value of the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-F price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 48.81, which represents a 10% annual   coupon rate compounded semi-annually and rounded to 5 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n895.359254\n</code></pre> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def price(\n    settlement: str | pd.Timestamp,\n    maturity: str | pd.Timestamp,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-F price using Anbima rules, which corresponds to the present\n        value of the cash flows discounted at the given yield to maturity rate (YTM).\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity (str | pd.Timestamp): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n        rate (float): The discount rate (yield to maturity) used to calculate the\n            present value of the cash flows.\n\n    Returns:\n        float: The NTN-F price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 48.81, which represents a 10% annual\n          coupon rate compounded semi-annually and rounded to 5 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n        895.359254\n    \"\"\"\n    cf_df = cash_flows(settlement, maturity)\n    cf_values = cf_df[\"CashFlow\"]\n    bdays = bday.count(settlement, cf_df[\"PaymentDate\"])\n    byears = bt.truncate(bdays / 252, 14)\n    discount_factors = (1 + rate) ** byears\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    dcf = (cf_values / discount_factors).round(9)\n    # Return the sum of the discounted cash flows truncated as per Anbima rules\n    return bt.truncate(dcf.sum(), 6)\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.rates","title":"<code>rates(reference_date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>reference_date</code> <code>str | Timestamp</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def rates(reference_date: str | pd.Timestamp) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        reference_date (str | pd.Timestamp): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n    \"\"\"\n    ntnf_rates = anbima.rates(reference_date, \"NTN-F\")\n    if ntnf_rates.empty:\n        return pd.DataFrame()\n    return ntnf_rates[[\"MaturityDate\", \"IndicativeRate\"]]\n</code></pre>"},{"location":"ntnf/#pyield.bonds.ntnf.spot_rates","title":"<code>spot_rates(settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates, show_coupon_rates=False)</code>","text":"<p>Calculate the spot rates for NTN-F bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str | Timestamp</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>ltn_maturities</code> <code>Series</code> <p>The LTN known maturities.</p> required <code>ltn_rates</code> <code>Series</code> <p>The LTN known rates.</p> required <code>ntnf_maturities</code> <code>Series</code> <p>The NTN-F known maturities.</p> required <code>ntnf_rates</code> <code>Series</code> <p>The NTN-F known rates.</p> required <code>show_coupon_rates</code> <code>bool</code> <p>If True, show also July rates corresponding to the coupon payments.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"SpotRate\"</p> Source code in <code>pyield/bonds/ntnf.py</code> <pre><code>def spot_rates(  # noqa\n    settlement: str | pd.Timestamp,\n    ltn_maturities: pd.Series,\n    ltn_rates: pd.Series,\n    ntnf_maturities: pd.Series,\n    ntnf_rates: pd.Series,\n    show_coupon_rates: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the spot rates for NTN-F bonds using the bootstrap method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price.\n\n    Args:\n        settlement (str | pd.Timestamp): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        ltn_maturities (pd.Series): The LTN known maturities.\n        ltn_rates (pd.Series): The LTN known rates.\n        ntnf_maturities (pd.Series): The NTN-F known maturities.\n        ntnf_rates (pd.Series): The NTN-F known rates.\n        show_coupon_rates (bool): If True, show also July rates corresponding to the\n            coupon payments.\n\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"SpotRate\"\n    \"\"\"\n    # Process and validate the input data\n    settlement = dc.convert_input_dates(settlement)\n\n    # Create flat forward interpolators for LTN and NTN-F rates\n    ltn_rate_interpolator = Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ltn_maturities),\n        known_rates=ltn_rates,\n    )\n    ntnf_rate_interpolator = Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ntnf_maturities),\n        known_rates=ntnf_rates,\n    )\n\n    # Generate all coupon dates up to the last NTN-F maturity date\n    all_coupon_dates = payment_dates(settlement, ntnf_maturities.max())\n\n    # Create a DataFrame with all coupon dates and the corresponding YTM\n    df = pd.DataFrame(data=all_coupon_dates, columns=[\"MaturityDate\"])\n    df[\"BDays\"] = bday.count(start=settlement, end=df[\"MaturityDate\"])\n    df[\"BYears\"] = df[\"BDays\"] / 252\n    df[\"Coupon\"] = COUPON_PMT\n    df[\"YTM\"] = df[\"BDays\"].apply(ntnf_rate_interpolator)\n\n    # The Bootstrap loop to calculate spot rates\n    for index, row in df.iterrows():\n        if row[\"MaturityDate\"] &lt;= ltn_maturities.max():\n            # Use LTN rates for maturities before the last LTN maturity date\n            df.at[index, \"SpotRate\"] = ltn_rate_interpolator(row[\"BDays\"])\n            continue\n\n        # Calculate the present value of the coupon payments\n        cf_dates = payment_dates(settlement, row[\"MaturityDate\"])[:-1]  # noqa\n        cf_df = df.query(\"MaturityDate in @cf_dates\").reset_index(drop=True)\n        cf_present_value = bt.calculate_present_value(\n            cash_flows=cf_df[\"Coupon\"],\n            rates=cf_df[\"SpotRate\"],\n            periods=cf_df[\"BDays\"] / 252,\n        )\n\n        bond_price = price(settlement, row[\"MaturityDate\"], row[\"YTM\"])\n        price_factor = FINAL_PMT / (bond_price - cf_present_value)\n        df.at[index, \"SpotRate\"] = price_factor ** (1 / row[\"BYears\"]) - 1\n\n    df = df[[\"MaturityDate\", \"SpotRate\"]].copy()\n    df[\"SpotRate\"] = df[\"SpotRate\"].astype(\"Float64\")\n    if show_coupon_rates:\n        return df\n    else:\n        return df.query(\"MaturityDate in @ntnf_maturities\").reset_index(drop=True)\n</code></pre>"},{"location":"tools/","title":"Tools (tools)","text":""},{"location":"tools/#pyield.tools.forward_rates","title":"<code>forward_rates(business_days, zero_rates, groupby_dates=None)</code>","text":"<p>Calculates forward rates from zero rates.</p> <p>Parameters:</p> Name Type Description Default <code>business_days</code> <code>Series</code> <p>Number of business days for each zero rate.</p> required <code>zero_rates</code> <code>Series</code> <p>Zero rates corresponding to the business days.</p> required <code>groupby_dates</code> <code>Series | None</code> <p>Optional grouping criteria to segment calculations. If not provided, calculations will not be grouped.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series of calculated forward rates with the first rate set to the corresponding zero rate.</p> Source code in <code>pyield/tools.py</code> <pre><code>def forward_rates(\n    business_days: pd.Series,\n    zero_rates: pd.Series,\n    groupby_dates: pd.Series | None = None,\n) -&gt; pd.Series:\n    \"\"\"Calculates forward rates from zero rates.\n\n    Args:\n        business_days (pd.Series): Number of business days for each zero rate.\n        zero_rates (pd.Series): Zero rates corresponding to the business days.\n        groupby_dates (pd.Series | None, optional): Optional grouping criteria to\n            segment calculations. If not provided, calculations will not be grouped.\n\n    Returns:\n        pd.Series: Series of calculated forward rates with the first rate set to the\n            corresponding zero rate.\n    \"\"\"\n    # Reset Series indexes to avoid misalignment issues during calculations\n    business_days = business_days.reset_index(drop=True)\n    zero_rates = zero_rates.reset_index(drop=True)\n    if groupby_dates is not None:\n        groupby_dates = groupby_dates.reset_index(drop=True)\n\n    # Create a DataFrame to work with the given series\n    df = pd.DataFrame({\"bd\": business_days, \"zero_rate\": zero_rates})\n\n    # If no groupby_dates is provided, create a dummy column to group the DataFrame\n    if groupby_dates is not None:\n        df[\"groupby_date\"] = groupby_dates\n    else:\n        df[\"groupby_date\"] = 0  # Dummy value to group the DataFrame\n\n    # Sort by the groupby_dates and bd columns to ensure proper chronological order\n    df.sort_values(by=[\"groupby_date\", \"bd\"], inplace=True)\n\n    # Calculate the next zero rate and business day for each group\n    df[\"next_rate\"] = df.groupby(\"groupby_date\")[\"zero_rate\"].shift(1)\n    df[\"next_bday\"] = df.groupby(\"groupby_date\")[\"bd\"].shift(1)\n\n    # Calculate the forward rates using the formula\n    factor1 = (1 + df[\"next_rate\"]) ** (df[\"next_bday\"] / 252)\n    factor2 = (1 + df[\"zero_rate\"]) ** (df[\"bd\"] / 252)\n    factor3 = 252 / (df[\"next_bday\"] - df[\"bd\"])\n    df[\"fwd_rate\"] = (factor1 / factor2) ** factor3 - 1\n\n    # Identifify the first index of each group of dates\n    first_indices = df.groupby(\"groupby_date\").head(1).index\n    # Set the first forward rate of each group to the zero rate\n    df.loc[first_indices, \"fwd_rate\"] = df.loc[first_indices, \"zero_rate\"]\n\n    df[\"fwd_rate\"] = df[\"fwd_rate\"].astype(\"Float64\")\n\n    return df[\"fwd_rate\"]\n</code></pre>"},{"location":"articles/pyield_intro/","title":"Introdu\u00e7\u00e3o a PYield","text":""},{"location":"articles/pyield_intro/#uma-biblioteca-em-python-para-obtecao-de-dados-de-instrumentos-de-renda-fixa-brasileira","title":"Uma biblioteca em Python para obte\u00e7\u00e3o de dados de instrumentos de Renda Fixa brasileira","text":"<p>Se voc\u00ea \u00e9 um entusiasta de VBA e Excel, pode pular esse artigo que aqui n\u00e3o \u00e9 lugar para voc\u00ea! Brincadeira, voc\u00ea \u00e9 bem-vindo tamb\u00e9m. Afinal, essa pode ser uma \u00f3tima desculpa para voc\u00ea finalmente aprender Python \ud83d\ude02</p> <p>Brincadeiras \u00e0 parte, qualquer um que trabalhe com an\u00e1lise de renda fixa no sabe que a obten\u00e7\u00e3o de dados de fontes como ANBIMA e B3 pode ser uma tarefa complicada. Outro ponto refere-se ao tratamento dos feriados e dias \u00fateis, um verdadeiro pesadelo para quem precisa calcular prazos e vencimentos, ainda mais depois que criaram um novo feriado nacional no final do ano passado. Sim, agora temos que considerar duas listas de feriados nacionais, uma para dados ateriores a 26-12-2023 e outra para depois.</p> <p>Claro que para os afortunados com acesso a servi\u00e7os pagos como Bloomberg, a obten\u00e7\u00e3o desse tipo de dados j\u00e1 \u00e9 bem f\u00e1cil. Mas para a maioria dos analistas financeiros, pesquisadores e entusiastas do mercado, a obten\u00e7\u00e3o e processamento desses dados pode ser um desafio. Afinal, voc\u00ea ter\u00e1 que lidar com chamadas para diversas APIs como a do IBGE, do BACEN, da ANBIMA, da B3, e por a\u00ed vai. Em alguns casos, o dado tem que ser extra\u00eddo diretamente de sites, o que pode ser ainda mais complicado.</p>"},{"location":"articles/pyield_intro/#o-que-e-pyield","title":"O que \u00e9 PYield?","text":"<p>A biblioteca Python foi projetada especificamente para a obten\u00e7\u00e3o e tratamento de dados de instrumentos de renda fixa. Ou seja, \u00e9 uma tentativa de  simplificar a obten\u00e7\u00e3o e processamento de dados de fontes prim\u00e1rias como ANBIMA e B3, fornecendo uma API de f\u00e1cil utiliza\u00e7\u00e3o.</p> <p>Utilizando a robustez de bibliotecas populares de Python, como Pandas, Requests e Numpy, PYield pode ser usada como backend de aplica\u00e7\u00f5es mais complexas, removendo a parte pesada relacionada a obten\u00e7\u00e3o e processamento de dados de fontes e formatos diversos.</p>"},{"location":"articles/pyield_intro/#caracteristicas-principais","title":"Caracter\u00edsticas Principais","text":"<ul> <li>Coleta de Dados: Obtenha dados diretamente de fontes prim\u00e1rias como ANBIMA e B3 de forma simples e r\u00e1pida.</li> <li>Processamento de Dados: Os dados s\u00e3o processados e entregues em formatos f\u00e1ceis de usar, como DataFrames do Pandas.</li> <li>Ferramentas de An\u00e1lise: Acesse fun\u00e7\u00f5es para tarefas comuns de an\u00e1lise do mercado de renda fixa, como c\u00e1lculos de dias \u00fateis e feriados.</li> </ul>"},{"location":"articles/pyield_intro/#como-instalar-o-pyield","title":"Como Instalar o PYield","text":"<p>A instala\u00e7\u00e3o do PYield \u00e9 r\u00e1pida e f\u00e1cil atrav\u00e9s do pip, o gerenciador de pacotes do Python. Basta abrir o terminal e executar o seguinte comando no seu ambiente virtual:</p> <p><pre><code>pip install pyield\n</code></pre> Este comando instala a \u00faltima vers\u00e3o do PYield, deixando voc\u00ea pronto para come\u00e7ar a utilizar a biblioteca em seus projetos.</p> <p>Exemplos Pr\u00e1ticos de Uso:</p>"},{"location":"articles/pyield_intro/#ferramentas-de-dias-uteis-feriados-brasileiros-sao-automaticamente-considerados","title":"Ferramentas de Dias \u00dateis (Feriados brasileiros s\u00e3o automaticamente considerados)","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n\n# Contar o n\u00famero de dias \u00fateis entre duas datas.\n# A data de in\u00edcio \u00e9 inclusiva, a data de t\u00e9rmino \u00e9 exclusiva.\n&gt;&gt;&gt; yd.bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Obtenha o pr\u00f3ximo dia \u00fatil ap\u00f3s uma determinada data (offset=1).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=1)\nTimestamp('2024-01-02 00:00:00')\n\n# Obtenha o pr\u00f3ximo dia \u00fatil se n\u00e3o for um dia \u00fatil (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"30-12-2023\", offset=0)\nTimestamp('2024-01-02 00:00:00')\n\n# Como 2023-12-29 j\u00e1 \u00e9 um dia \u00fatil, a fun\u00e7\u00e3o retorna a mesma data (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=0)\nTimestamp('2023-12-29 00:00:00')\n\n# Gerar uma s\u00e9rie de dias \u00fateis entre duas datas.\n&gt;&gt;&gt; yd.bday.generate(start='2023-12-29', end='2024-01-03')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\ndtype: datetime64[ns]\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-futuro-de-di","title":"Dados de Futuro de DI","text":"<pre><code># Obtenha um DataFrame com os dados dos Futuros de DI da B3 de uma data espec\u00edfica.\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", reference_date='2024-03-08')\n\nTradeDate  ExpirationCode ExpirationDate BDaysToExp  ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08 J24            2024-04-01     15              ... 10.952   10.952      10.956      10.956\n2024-03-08 K24            2024-05-02     37              ... 10.776   10.774      10.780      10.777\n2024-03-08 M24            2024-06-03     58              ... 10.604   10.602      10.604      10.608\n...        ...            ...            ...             ... ...      ...         ...         ...\n2024-03-08 F37            2037-01-02     3213            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F38            2038-01-04     3462            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F39            2039-01-03     3713            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.85\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-titulos-do-tesouro","title":"Dados de T\u00edtulos do Tesouro","text":"<pre><code># Obtenha um DataFrame com os dados dos t\u00edtulos NTN-B da ANBIMA.\n# Os dados da Anbima est\u00e3o dispon\u00edveis para os \u00faltimos 5 dias \u00fateis.\n# Obs: Para quem \u00e9 membro da Anbima, o acesso ao hist\u00f3rico \u00e9 liberado automaticamente pela biblioteca.\n&gt;&gt;&gt; yd.anbima(bond_type=\"NTN-B\", reference_date='2024-04-12')\n\nBondType ReferenceDate MaturityDate BidRate AskRate IndicativeRate Price\nNTN-B    2024-04-12    2024-08-15   0.07540 0.07504 0.07523        4,271.43565\nNTN-B    2024-04-12    2025-05-15   0.05945 0.05913 0.05930        4,361.34391\nNTN-B    2024-04-12    2026-08-15   0.05927 0.05897 0.05910        4,301.40082\n...      ...           ...          ...     ...     ...            ...\nNTN-B    2024-04-12    2050-08-15   0.06039 0.06006 0.06023        4,299.28233\nNTN-B    2024-04-12    2055-05-15   0.06035 0.05998 0.06017        4,367.13360\nNTN-B    2024-04-12    2060-08-15   0.06057 0.06016 0.06036        4,292.26323\n</code></pre>"},{"location":"articles/pyield_intro/#calculo-de-spreads","title":"C\u00e1lculo de spreads","text":"<pre><code># Calcule o spread entre o futuro de DI e os t\u00edtulos pr\u00e9-fixados do Tesouro.\n&gt;&gt;&gt; yd.spreads(spread_type=\"DI_PRE\", reference_date=\"2024-4-11\")\n\nBondType ReferenceDate MaturityDate  DISpread\nLTN      2024-04-11    2024-07-01    -20.28\nLTN      2024-04-11    2024-10-01    -10.19\nLTN      2024-04-11    2025-01-01    -15.05\n...      ...           ...           ...\nNTN-F    2024-04-11    2031-01-01    -0.66\nNTN-F    2024-04-11    2033-01-01    -5.69\nNTN-F    2024-04-11    2035-01-01    -1.27\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-indicadores","title":"Dados de Indicadores","text":"<pre><code># Obtenha a taxa SELIC meta do BCB em um determinado dia.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"SELIC\", reference_date='2024-04-12')\n0.1075  # 10.75%\n\n# Obtenha a taxa mensal (Monthly Rate) do IPCA do IBGE com base no m\u00eas de refer\u00eancia da data.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", reference_date='2024-03-18')\n0.0016  # 0.16%\n\n# Se o indicador n\u00e3o estiver dispon\u00edvel para a data de refer\u00eancia, o retorno ser\u00e1 nulo (None).\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", reference_date='2030-04-10')\nNone\n</code></pre>"},{"location":"articles/pyield_intro/#conclusao","title":"Conclus\u00e3o","text":"<p>Se voc\u00ea precisa obter e tratar dados de renda fixa, PYield pode ser uma ferramenta valiosa nesse processo. Com uma API simples, o seu c\u00f3digo pode se tornar mais limpo e eficiente, permitindo que voc\u00ea se concentre na an\u00e1lise dos dados em vez de se preocupar com a obten\u00e7\u00e3o e processamento deles.</p> <p>O c\u00f3digo da biblioteca pode ser acessado em: PYield</p> <p>Quem quiser contribuir com o desenvolvimento da ferramenta entre em contato comigo: cr.cj@outlook.com</p>"}]}