{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyield-brazilian-fixed-income-toolkit","title":"PYield: Brazilian Fixed Income Toolkit","text":"<p>PYield is a Python library designed for the analysis of Brazilian fixed income instruments. Leveraging the power of popular Python libraries like Polars, Pandas, Numpy and Requests, PYield simplifies the process of obtaining and processing data from key sources such as ANBIMA, BCB, IBGE and B3.</p>"},{"location":"#polars-migration-from-version-0400-onwards","title":"\u2705 Polars migration from version 0.40.0 onwards:","text":"<p>All public functions now return Polars DataFrames or Series as the canonical format. This provides stronger typing, faster execution and more reliable date/rate handling. The last version to return Pandas objects by default was 0.39.xx.</p> <p>Need Pandas? Convert explicitly: <pre><code>df_pandas = df.to_pandas(use_pyarrow_extension_array=True)\nseries_pandas = s.to_pandas(use_pyarrow_extension_array=True)\n</code></pre> The internal typing relies on PyArrow-backed dtypes for consistency across numeric and date operations.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Visit the full documentation for PYield.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Data Collection: Automated fetching of data from ANBIMA and B3.</li> <li>Data Processing: Efficient processing and normalization of fixed income data.</li> <li>Analysis Tools: Built-in functions for common analysis tasks in fixed income markets.</li> <li>Easy Integration: Seamless integration with pandas data analysis workflows.</li> <li>Type Hints: Full support for static type checking, enhancing development experience and code quality.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install PYield using pip: <pre><code>pip install pyield\n</code></pre></p>"},{"location":"#custom-types","title":"Custom Types","text":""},{"location":"#datescalar","title":"DateScalar","text":"<p><code>DateScalar</code> and <code>DateArray</code> are internal type unions used across PYield to accept flexible date inputs. Supported scalar Python / library date types:</p> <ul> <li><code>str</code> (formats: <code>DD-MM-YYYY</code>, <code>DD/MM/YYYY</code>, <code>YYYY-MM-DD</code>)</li> <li><code>datetime.date</code></li> <li><code>datetime.datetime</code></li> <li><code>pandas.Timestamp</code></li> <li><code>numpy.datetime64</code></li> </ul>"},{"location":"#datearray","title":"DateArray","text":"<p>Accepted collection types (homogeneous date-like values):</p> <ul> <li><code>list[DateScalar]</code></li> <li><code>tuple[DateScalar, ...]</code></li> <li><code>pandas.Series</code></li> <li><code>pandas.DatetimeIndex</code></li> <li><code>numpy.ndarray</code></li> <li><code>polars.Series</code></li> </ul> <p>Other helper unions:</p> <p><code>FloatArray</code>: - <code>list[float]</code> | <code>tuple[float, ...]</code> | <code>numpy.ndarray</code> | <code>pandas.Series</code> | <code>polars.Series</code></p> <p><code>IntegerScalar</code>: - <code>int</code> | <code>numpy.integer</code></p> <p><code>IntegerArray</code>: - <code>list[int]</code> | <code>tuple[int, ...]</code> | <code>numpy.ndarray</code> | <code>pandas.Series</code> | <code>polars.Series</code></p> <p>Referencing these unions in function docstrings means you can pass any of the listed types interchangeably; conversion is handled internally.</p>"},{"location":"#date-string-formats","title":"Date String Formats","text":"<p>Accepted string date formats:</p> <ul> <li>Day-first (Brazilian): <code>DD-MM-YYYY</code> (e.g., <code>31-05-2024</code>)</li> <li>Day-first (slash): <code>DD/MM/YYYY</code> (e.g., <code>31/05/2024</code>)</li> <li>ISO: <code>YYYY-MM-DD</code> (e.g., <code>2024-05-31</code>)</li> </ul> <p>Rules: - No ambiguous autodetection: <code>2024-05-06</code> is always interpreted as ISO (<code>YYYY-MM-DD</code>). - A collection of strings must not mix different styles; the first non-null value defines the format. - Nulls are preserved; empty collections are not allowed.</p> <p>Recommendation: Always parse external inputs explicitly when constructing your own pipelines: <pre><code>import pandas as pd\ndt_val = pd.to_datetime(\"31-05-2024\", format=\"%d-%m-%Y\")\niso_val = pd.to_datetime(\"2024-05-31\", format=\"%Y-%m-%d\")\n</code></pre></p>"},{"location":"#null-empty-input-handling","title":"Null &amp; Empty Input Handling","text":"<p>PYield uses an internal helper (<code>has_null_args</code>) for early detection of missing inputs. The default propagation policy is: return <code>None</code> for missing scalar inputs and preserve nulls inside collections. This avoids implicit imputation and makes failure modes explicit.</p> <p>Summary: - Scalar functions (dates, prices, quotations, spreads, durations): return <code>None</code> when any required argument is missing or empty. - Collection (vectorized) functions: if the entire relevant input is missing/empty, return an empty Polars <code>DataFrame</code>/<code>Series</code> (or <code>None</code> for purely scalar semantics). Individual null elements propagate as <code>null</code> values in the resulting Polars Series/DataFrame. - Empty collections where a shape is mandatory (e.g. an empty date array for conversion) raise <code>ValueError</code> rather than returning a silently empty result. - Date string collections must share a single format; the first non-null defines it. - Numeric computations only produce <code>NaN</code> when an internal arithmetic step yields an undefined value (rare \u2014 typical missing input short-circuits to <code>None</code>).</p> <p>Examples: <pre><code>&gt;&gt;&gt; from pyield import ntnb, bday\n# Missing settlement -&gt; None\n&gt;&gt;&gt; ntnb.quotation(None, \"15-05-2035\", 0.06149)\nNone\n\n# Null start date in business day count -&gt; None\n&gt;&gt;&gt; bday.count(None, \"01-01-2025\")\nNone\n\n# Null in array input propagates element-wise\n&gt;&gt;&gt; bday.count([\"01-01-2024\", None], \"01-02-2024\")\nshape: (2,)\nSeries: 'bdays' [i64]\n[\n    22\n    null\n]\n</code></pre></p>"},{"location":"#how-to-use-pyield","title":"How to use PYield","text":""},{"location":"#brazilian-treasury-bonds-tools","title":"Brazilian Treasury Bonds Tools","text":"<pre><code>&gt;&gt;&gt; from pyield import ltn, ntnb, ntnf\n\n# Get ANBIMA LTN data for a given date\n&gt;&gt;&gt; ltn.data(\"23-08-2024\")\nshape: (13, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate\u2502 BondType\u2502 SelicCode\u2502 IssueBaseDate\u2502 \u2026 \u2502 BidRate \u2502 AskRate \u2502 IndicativeRate\u2502 DIRate \u2502\n\u2502 ---          \u2502 ---     \u2502 ---      \u2502 ---          \u2502   \u2502 ---     \u2502 ---     \u2502 ---           \u2502 ---    \u2502\n\u2502 date         \u2502 str     \u2502 i64      \u2502 date         \u2502   \u2502 f64     \u2502 f64     \u2502 f64           \u2502 f64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2024-08-23   \u2502 LTN     \u2502 100000   \u2502 2022-07-08   \u2502 \u2026 \u2502 0.10459 \u2502 0.104252\u2502 0.104416      \u2502 0.10472\u2502\n\u2502 2024-08-23   \u2502 LTN     \u2502 100000   \u2502 2018-02-01   \u2502 \u2026 \u2502 0.107366\u2502 0.107016\u2502 0.107171      \u2502 0.10823\u2502\n\u2502 2024-08-23   \u2502 LTN     \u2502 100000   \u2502 2023-01-06   \u2502 \u2026 \u2502 0.110992\u2502 0.110746\u2502 0.110866      \u2502 0.11179\u2502\n\u2502 \u2026            \u2502 \u2026       \u2502 \u2026        \u2502 \u2026            \u2502 \u2026 \u2502 \u2026       \u2502 \u2026       \u2502 \u2026             \u2502 \u2026      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n# Calculate the quotation of an NTN-B bond (base 100, truncated to 4 decimals)\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n\n# DI Spreads: IndicativeRate - SettlementRate (bps=True multiplies by 10_000)\n&gt;&gt;&gt; ntnf.di_spreads(\"30-05-2025\", bps=True)\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType\u2502 MaturityDate\u2502 DISpread \u2502\n\u2502 ---     \u2502 ---         \u2502 ---      \u2502\n\u2502 str     \u2502 date        \u2502 f64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 NTN-F   \u2502 2027-01-01  \u2502 -3.31    \u2502\n\u2502 NTN-F   \u2502 2029-01-01  \u2502 14.21    \u2502\n\u2502 NTN-F   \u2502 2031-01-01  \u2502 21.61    \u2502\n\u2502 NTN-F   \u2502 2033-01-01  \u2502 11.51    \u2502\n\u2502 NTN-F   \u2502 2035-01-01  \u2502 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#business-days-tools-brazilian-holidays-automatically-considered","title":"Business Days Tools (Brazilian holidays automatically considered)","text":"<pre><code>&gt;&gt;&gt; from pyield import bday\n# Count business days (start inclusive, end exclusive)\n&gt;&gt;&gt; bday.count(\"29-12-2023\", \"02-01-2024\")\n1\n\n# Next business day after given date (offset=1)\n&gt;&gt;&gt; bday.offset(\"29-12-2023\", 1)\ndatetime.date(2024, 1, 2)\n\n# Adjust to next business day when not a business day (offset=0)\n&gt;&gt;&gt; bday.offset(\"30-12-2023\", 0)\ndatetime.date(2024, 1, 2)\n\n# Returns same date if already business day (offset=0)\n&gt;&gt;&gt; bday.offset(\"29-12-2023\", 0)\ndatetime.date(2023, 12, 29)\n\n# Generate business day series\n&gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\nshape: (6,)\nSeries: '' [date]\n[\n    2023-12-22\n    2023-12-26\n    2023-12-27\n    2023-12-28\n    2023-12-29\n    2024-01-02\n]\n</code></pre>"},{"location":"#futures-data","title":"Futures Data","text":"<pre><code>&gt;&gt;&gt; from pyield.b3.futures import futures\n\n# Fetch DI1 futures (historical)\n&gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\nshape: (40, 20)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate\u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate\u2506 SettlementRate\u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---          \u2506 ---           \u2506 ---        \u2506   \u2506 ---          \u2506 ---      \u2506 ---           \u2506 ---         \u2502\n\u2502 date       \u2506 str          \u2506 date          \u2506 i64        \u2506   \u2506 f64          \u2506 f64      \u2506 f64           \u2506 f64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2024-05-31 \u2506 DI1M24       \u2506 2024-06-03    \u2506 1          \u2506 \u2026 \u2506 0.10404      \u2506 0.10404  \u2506 0.10399       \u2506 0.10399     \u2502\n\u2502 2024-05-31 \u2506 DI1N24       \u2506 2024-07-01    \u2506 21         \u2506 \u2026 \u2506 0.1039       \u2506 0.10386  \u2506 0.1039        \u2506 0.103896    \u2502\n\u2502 2024-05-31 \u2506 DI1Q24       \u2506 2024-08-01    \u2506 44         \u2506 \u2026 \u2506 0.10374      \u2506 0.10374  \u2506 0.1037        \u2506 0.103517    \u2502\n\u2502 \u2026          \u2506 \u2026            \u2506 \u2026             \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026        \u2506 \u2026             \u2506 \u2026           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#indicators-data","title":"Indicators Data","text":"<pre><code>&gt;&gt;&gt; from pyield import bc\n\n# SELIC Over series (no data on Sunday)\n&gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\").head(5)\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value  \u2502\n\u2502 ---        \u2506 ---    \u2502\n\u2502 date       \u2506 f64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2025-01-27 \u2506 0.1215 \u2502\n\u2502 2025-01-28 \u2506 0.1215 \u2502\n\u2502 2025-01-29 \u2506 0.1215 \u2502\n\u2502 2025-01-30 \u2506 0.1315 \u2502\n\u2502 2025-01-31 \u2506 0.1315 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n# SELIC Over for a single date\n&gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n0.104  # 10.40%\n</code></pre>"},{"location":"#projections-data","title":"Projections Data","text":"<pre><code>&gt;&gt;&gt; from pyield import ipca\n# Fetch current month projection for IPCA\n&gt;&gt;&gt; proj = ipca.projected_rate()\n&gt;&gt;&gt; proj\nIndicatorProjection(last_updated=..., reference_period=..., projected_value=...)\n&gt;&gt;&gt; proj.projected_value\n0.0035  # 0.35%\n</code></pre>"},{"location":"#interpolation-tools","title":"Interpolation Tools","text":"<p>Interpolate interest rates for specific business days using the Interpolator class. <pre><code>&gt;&gt;&gt; from pyield import Interpolator\n# Initialize the Interpolator with known business days and interest rates.\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n&gt;&gt;&gt; linear_interpolator = Interpolator(\"linear\", known_bdays, known_rates)\n&gt;&gt;&gt; linear_interpolator(45)  # Interpolate the interest rate for a given number of business days.\n0.0475\n\n# Use the flat forward method for interpolation.\n&gt;&gt;&gt; ff_interpolator = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; ff_interpolator(45)\n0.04833068080970859\n</code></pre></p>"},{"location":"anbima/","title":"Anbima Data","text":""},{"location":"anbima/#pyield.anbima.intraday_ettj","title":"<code>intraday_ettj()</code>","text":"<p>Retrieves and processes the intraday Brazilian yield curve data from ANBIMA.</p> <p>This function fetches the most recent intraday yield curve data published by ANBIMA, containing real rates (IPCA-indexed), nominal rates, and implied inflation at various vertices (time points). The curve is published at around 12:30 PM BRT.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the intraday ETTJ data.</p> DataFrame columns <ul> <li>date: Reference date of the yield curve</li> <li>vertex: Time point in business days</li> <li>nominal_rate: Zero-coupon nominal interest rate</li> <li>real_rate: Zero-coupon real interest rate (IPCA-indexed)</li> <li>implied_inflation: Implied inflation rate (break-even inflation)</li> </ul> Note <p>All rates are expressed in decimal format (e.g., 0.12 for 12%).</p> Source code in <code>pyield/anbima/ettj_intraday.py</code> <pre><code>def intraday_ettj() -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves and processes the intraday Brazilian yield curve data from ANBIMA.\n\n    This function fetches the most recent intraday yield curve data published by ANBIMA,\n    containing real rates (IPCA-indexed), nominal rates, and implied inflation\n    at various vertices (time points). The curve is published at around 12:30 PM BRT.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the intraday ETTJ data.\n\n    DataFrame columns:\n        - date: Reference date of the yield curve\n        - vertex: Time point in business days\n        - nominal_rate: Zero-coupon nominal interest rate\n        - real_rate: Zero-coupon real interest rate (IPCA-indexed)\n        - implied_inflation: Implied inflation rate (break-even inflation)\n\n    Note:\n        All rates are expressed in decimal format (e.g., 0.12 for 12%).\n    \"\"\"\n    api_text = _fetch_intraday_text()\n\n    # --- Extra\u00e7\u00e3o da Tabela 1: PREFIXADOS ---\n    data_ref, tabela_pre, tabela_ipca = _extract_date_and_tables(api_text)\n\n    df_pre = _parse_intraday_table(tabela_pre)\n    df_pre = df_pre.rename({\"D0\": \"nominal_rate\"})\n\n    df_ipca = _parse_intraday_table(tabela_ipca)\n    df_ipca = df_ipca.rename({\"D0\": \"real_rate\"})\n\n    df = df_pre.join(df_ipca, on=\"Vertices\", how=\"right\")\n    df = df.rename({\"Vertices\": \"vertex\"})\n\n    df = df.with_columns(\n        # convertendo de % para decimal e arredondando\n        (pl.col(\"real_rate\") / 100).round(ROUND_DIGITS),\n        (pl.col(\"nominal_rate\") / 100).round(ROUND_DIGITS),\n        pl.lit(data_ref).alias(\"date\"),\n    ).with_columns(\n        ((pl.col(\"nominal_rate\") + 1) / (pl.col(\"real_rate\") + 1) - 1)\n        .round(ROUND_DIGITS)\n        .alias(\"implied_inflation\"),\n    )\n    column_order = [\"date\", \"vertex\", \"nominal_rate\", \"real_rate\", \"implied_inflation\"]\n    return df.select(column_order)\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ettj","title":"<code>last_ettj()</code>","text":"<p>Retrieves and processes the latest Brazilian yield curve data from ANBIMA.</p> <p>This function fetches the most recent yield curve data published by ANBIMA, containing real rates (IPCA-indexed), nominal rates, and implied inflation at various vertices (time points).</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the latest ETTJ data.</p> DataFrame columns <ul> <li>date: Reference date of the yield curve</li> <li>vertex: Time point in business days</li> <li>nominal_rate: Zero-coupon nominal interest rate</li> <li>real_rate: Zero-coupon real interest rate (IPCA-indexed)</li> <li>implied_inflation: Implied inflation rate (break-even inflation)</li> </ul> Note <p>All rates are expressed in decimal format (e.g., 0.12 for 12%).</p> Source code in <code>pyield/anbima/ettj_last.py</code> <pre><code>def last_ettj() -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves and processes the latest Brazilian yield curve data from ANBIMA.\n\n    This function fetches the most recent yield curve data published by ANBIMA,\n    containing real rates (IPCA-indexed), nominal rates, and implied inflation\n    at various vertices (time points).\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the latest ETTJ data.\n\n    DataFrame columns:\n        - date: Reference date of the yield curve\n        - vertex: Time point in business days\n        - nominal_rate: Zero-coupon nominal interest rate\n        - real_rate: Zero-coupon real interest rate (IPCA-indexed)\n        - implied_inflation: Implied inflation rate (break-even inflation)\n\n    Note:\n        All rates are expressed in decimal format (e.g., 0.12 for 12%).\n    \"\"\"\n    text = _get_last_content_text()\n    reference_date = _get_reference_date(text)\n    text = _filter_ettf_text(text)\n    df = _convert_text_to_df(text, reference_date)\n    df = _process_df(df)\n    return df\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ima","title":"<code>last_ima(ima_type=None)</code>","text":"<p>Fetch and process the last IMA market data available from ANBIMA.</p> <p>This function processes the data into a structured DataFrame. It handles conversion of date formats, renames columns to English, and converts certain numeric columns to integer types. In the event of an error during data fetching or processing, an empty DataFrame is returned.</p> <p>Parameters:</p> Name Type Description Default <code>ima_type</code> <code>str</code> <p>Type of IMA index to filter the data. If None, all IMA indexes are returned. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the IMA data.</p> DataFrame columns <ul> <li>Date: reference date of the data.</li> <li>IMAType: type of IMA index.</li> <li>BondType: type of bond.</li> <li>Maturity: bond maturity date.</li> <li>SelicCode: bond code in the SELIC system.</li> <li>ISIN: international Securities Identification Number.</li> <li>BDToMat: business days to maturity.</li> <li>Duration: duration of the bond in business years (252 days/year).</li> <li>IndicativeRate: indicative rate.</li> <li>Price: bond price.</li> <li>InterestPrice: interest price.</li> <li>DV01: DV01 in R$.</li> <li>PMR: average repurchase term.</li> <li>Weight: weight of the bond in the index.</li> <li>Convexity: convexity of the bond.</li> <li>TheoreticalQuantity: theoretical quantity.</li> <li>NumberOfOperations: number of operations.</li> <li>NegotiatedQuantity: negotiated quantity.</li> <li>NegotiatedValue: negotiated value.</li> <li>MarketQuantity: market quantity.</li> <li>MarketDV01: market DV01 in R$.</li> <li>MarketValue: market value in R$.</li> </ul> <p>Raises:</p> Type Description <code>Exception</code> <p>Logs error and returns an empty DataFrame if any error occurs during fetching or processing.</p> Source code in <code>pyield/anbima/ima.py</code> <pre><code>def last_ima(ima_type: ima_types | None = None) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch and process the last IMA market data available from ANBIMA.\n\n    This function processes the data into a structured DataFrame.\n    It handles conversion of date formats, renames columns to English, and converts\n    certain numeric columns to integer types. In the event of an error during data\n    fetching or processing, an empty DataFrame is returned.\n\n    Args:\n        ima_type (str, optional): Type of IMA index to filter the data. If None, all\n            IMA indexes are returned. Defaults to None.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the IMA data.\n\n    DataFrame columns:\n        - Date: reference date of the data.\n        - IMAType: type of IMA index.\n        - BondType: type of bond.\n        - Maturity: bond maturity date.\n        - SelicCode: bond code in the SELIC system.\n        - ISIN: international Securities Identification Number.\n        - BDToMat: business days to maturity.\n        - Duration: duration of the bond in business years (252 days/year).\n        - IndicativeRate: indicative rate.\n        - Price: bond price.\n        - InterestPrice: interest price.\n        - DV01: DV01 in R$.\n        - PMR: average repurchase term.\n        - Weight: weight of the bond in the index.\n        - Convexity: convexity of the bond.\n        - TheoreticalQuantity: theoretical quantity.\n        - NumberOfOperations: number of operations.\n        - NegotiatedQuantity: negotiated quantity.\n        - NegotiatedValue: negotiated value.\n        - MarketQuantity: market quantity.\n        - MarketDV01: market DV01 in R$.\n        - MarketValue: market value in R$.\n\n    Raises:\n        Exception: Logs error and returns an empty DataFrame if any error occurs during\n            fetching or processing.\n    \"\"\"\n    try:\n        ima_text = _fetch_last_ima_text()\n        df = _parse_df(ima_text)\n        df = _process_df(df)\n        df = _reorder_columns(df)\n        if ima_type is not None:\n            df = df.filter(pl.col(\"IMAType\") == ima_type)\n        df = df.sort([\"IMAType\", \"BondType\", \"Maturity\"])\n        return df\n    except Exception as e:\n        logger.exception(f\"Error fetching or processing the last IMA data: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_data","title":"<code>tpf_data(date, bond_type=None, fetch_from_source=False)</code>","text":"<p>Recupera os dados do mercado secund\u00e1rio de TPF da ANBIMA.</p> <p>Esta fun\u00e7\u00e3o busca taxas indicativas e outros dados de t\u00edtulos p\u00fablicos brasileiros. A obten\u00e7\u00e3o dos dados segue uma hierarquia de fontes para otimizar o desempenho e o acesso.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>A data de refer\u00eancia para os dados (ex: '2024-06-14').</p> required <code>bond_type</code> <code>str</code> <p>Filtra os resultados por um tipo de t\u00edtulo espec\u00edfico (ex: 'LTN', 'NTN-B'). Por padr\u00e3o, retorna todos os tipos.</p> <code>None</code> <code>fetch_from_source</code> <code>bool</code> <p>Se True, for\u00e7a a fun\u00e7\u00e3o a ignorar o cache e buscar os dados diretamente da fonte (ANBIMA). Padr\u00e3o \u00e9 False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo os dados solicitados. Retorna um DataFrame vazio se n\u00e3o houver dados para a data especificada (ex: finais de semana, feriados ou datas futuras).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; anbima.tpf_data(date=\"22-08-2025\")\nshape: (49, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000198  \u2506 0.0001    \u2506 0.000165       \u2506 0.14906  \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000156 \u2506 -0.000116      \u2506 0.14843  \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000143 \u2506 -0.000107      \u2506 0.1436   \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000309  \u2506 0.000292  \u2506 0.000302       \u2506 0.138189 \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000421  \u2506 0.000399  \u2506 0.000411       \u2506 0.134548 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.139379  \u2506 0.139163  \u2506 0.139268       \u2506 0.13959  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.134252  \u2506 0.134018  \u2506 0.13414        \u2506 0.1327   \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.13846   \u2506 0.138355  \u2506 0.13841        \u2506 0.13626  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.139503  \u2506 0.139321  \u2506 0.139398       \u2506 0.13807  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.140673  \u2506 0.140566  \u2506 0.140633       \u2506 0.13845  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Data columns <ul> <li>BondType: Tipo do t\u00edtulo p\u00fablico (e.g., 'LTN', 'NTN-B').</li> <li>ReferenceDate: Data de refer\u00eancia dos dados.</li> <li>SelicCode: C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate: Data base ou de emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate: Data de vencimento do t\u00edtulo.</li> <li>BDToMat: N\u00famero de dias \u00fateis entre a data de refer\u00eancia e o vencimento.</li> <li>Duration: Macaulay Duration do t\u00edtulo em anos.</li> <li>DV01: Varia\u00e7\u00e3o financeira no pre\u00e7o do t\u00edtulo (em BRL) para uma     mudan\u00e7a de 1 basis point (0,01%) na taxa de juros.</li> <li>DV01USD: O mesmo que DV01, mas convertido para USD pela PTAX do dia.</li> <li>Price: Pre\u00e7o Unit\u00e1rio (PU) do t\u00edtulo na data de refer\u00eancia.</li> <li>BidRate: Taxa de compra em formato decimal (e.g., 0.10 para 10%).</li> <li>AskRate: Taxa de venda em formato decimal.</li> <li>IndicativeRate: Taxa indicativa em formato decimal.</li> <li>DIRate: Taxa DI interpolada (flatforward) no vencimento do t\u00edtulo.</li> <li>StdDev: Desvio padr\u00e3o da taxa indicativa.</li> <li>LowerBoundRateD0: Limite inferior do intervalo indicativo para D+0.</li> <li>UpperBoundRateD0: Limite superior do intervalo indicativo para D+0.</li> <li>LowerBoundRateD1: Limite inferior do intervalo indicativo para D+1.</li> <li>UpperBoundRateD1: Limite superior do intervalo indicativo para D+1.</li> <li>Criteria: Crit\u00e9rio utilizado pela ANBIMA para o c\u00e1lculo.</li> </ul> Notes <p>A fonte dos dados segue a seguinte hierarquia:</p> <ol> <li>Cache Local (Padr\u00e3o): Fornece acesso r\u00e1pido a dados hist\u00f3ricos     desde 01/01/2020. \u00c9 utilizado por padr\u00e3o (<code>fetch_from_source=False</code>).</li> <li>Site P\u00fablico da ANBIMA: Acessado quando <code>fetch_from_source=True</code>,     disponibiliza os dados dos \u00faltimos 5 dias \u00fateis.</li> <li>Rede RTM da ANBIMA: Acessada quando <code>fetch_from_source=True</code> para     datas com mais de 5 dias \u00fateis. O acesso ao hist\u00f3rico completo     requer uma conex\u00e3o \u00e0 rede RTM. Sem ela, a consulta para datas     antigas retornar\u00e1 um DataFrame vazio.</li> </ol> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_data(\n    date: DateScalar,\n    bond_type: BOND_TYPES | None = None,\n    fetch_from_source: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"Recupera os dados do mercado secund\u00e1rio de TPF da ANBIMA.\n\n    Esta fun\u00e7\u00e3o busca taxas indicativas e outros dados de t\u00edtulos p\u00fablicos\n    brasileiros. A obten\u00e7\u00e3o dos dados segue uma hierarquia de fontes para\n    otimizar o desempenho e o acesso.\n\n    Args:\n        date (DateScalar): A data de refer\u00eancia para os dados (ex: '2024-06-14').\n        bond_type (str, optional): Filtra os resultados por um tipo de t\u00edtulo\n            espec\u00edfico (ex: 'LTN', 'NTN-B'). Por padr\u00e3o, retorna todos os tipos.\n        fetch_from_source (bool, optional): Se True, for\u00e7a a fun\u00e7\u00e3o a ignorar o\n            cache e buscar os dados diretamente da fonte (ANBIMA).\n            Padr\u00e3o \u00e9 False.\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo os dados solicitados.\n            Retorna um DataFrame vazio se n\u00e3o houver dados para a data especificada (ex:\n            finais de semana, feriados ou datas futuras).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; anbima.tpf_data(date=\"22-08-2025\")\n        shape: (49, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000198  \u2506 0.0001    \u2506 0.000165       \u2506 0.14906  \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000156 \u2506 -0.000116      \u2506 0.14843  \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000143 \u2506 -0.000107      \u2506 0.1436   \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000309  \u2506 0.000292  \u2506 0.000302       \u2506 0.138189 \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000421  \u2506 0.000399  \u2506 0.000411       \u2506 0.134548 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.139379  \u2506 0.139163  \u2506 0.139268       \u2506 0.13959  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.134252  \u2506 0.134018  \u2506 0.13414        \u2506 0.1327   \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.13846   \u2506 0.138355  \u2506 0.13841        \u2506 0.13626  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.139503  \u2506 0.139321  \u2506 0.139398       \u2506 0.13807  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.140673  \u2506 0.140566  \u2506 0.140633       \u2506 0.13845  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Data columns:\n        - BondType: Tipo do t\u00edtulo p\u00fablico (e.g., 'LTN', 'NTN-B').\n        - ReferenceDate: Data de refer\u00eancia dos dados.\n        - SelicCode: C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate: Data base ou de emiss\u00e3o do t\u00edtulo.\n        - MaturityDate: Data de vencimento do t\u00edtulo.\n        - BDToMat: N\u00famero de dias \u00fateis entre a data de refer\u00eancia e o vencimento.\n        - Duration: Macaulay Duration do t\u00edtulo em anos.\n        - DV01: Varia\u00e7\u00e3o financeira no pre\u00e7o do t\u00edtulo (em BRL) para uma\n            mudan\u00e7a de 1 basis point (0,01%) na taxa de juros.\n        - DV01USD: O mesmo que DV01, mas convertido para USD pela PTAX do dia.\n        - Price: Pre\u00e7o Unit\u00e1rio (PU) do t\u00edtulo na data de refer\u00eancia.\n        - BidRate: Taxa de compra em formato decimal (e.g., 0.10 para 10%).\n        - AskRate: Taxa de venda em formato decimal.\n        - IndicativeRate: Taxa indicativa em formato decimal.\n        - DIRate: Taxa DI interpolada (flatforward) no vencimento do t\u00edtulo.\n        - StdDev: Desvio padr\u00e3o da taxa indicativa.\n        - LowerBoundRateD0: Limite inferior do intervalo indicativo para D+0.\n        - UpperBoundRateD0: Limite superior do intervalo indicativo para D+0.\n        - LowerBoundRateD1: Limite inferior do intervalo indicativo para D+1.\n        - UpperBoundRateD1: Limite superior do intervalo indicativo para D+1.\n        - Criteria: Crit\u00e9rio utilizado pela ANBIMA para o c\u00e1lculo.\n\n    Notes:\n        A fonte dos dados segue a seguinte hierarquia:\n\n        1.  **Cache Local (Padr\u00e3o):** Fornece acesso r\u00e1pido a dados hist\u00f3ricos\n            desde 01/01/2020. \u00c9 utilizado por padr\u00e3o (`fetch_from_source=False`).\n        2.  **Site P\u00fablico da ANBIMA:** Acessado quando `fetch_from_source=True`,\n            disponibiliza os dados dos \u00faltimos 5 dias \u00fateis.\n        3.  **Rede RTM da ANBIMA:** Acessada quando `fetch_from_source=True` para\n            datas com mais de 5 dias \u00fateis. O acesso ao hist\u00f3rico completo\n            requer uma conex\u00e3o \u00e0 rede RTM. Sem ela, a consulta para datas\n            antigas retornar\u00e1 um DataFrame vazio.\n    \"\"\"  # noqa\n    if has_null_args(date):\n        return pl.DataFrame()\n    date = convert_dates(date)\n    _validate_not_future_date(date)\n\n    if fetch_from_source:\n        # Try to fetch the data directly from the source (ANBIMA)\n        df = _fetch_tpf_data(date)\n    else:\n        # Otherwise, get the data from the local cache\n        df = get_cached_dataset(\"tpf\").filter(pl.col(\"ReferenceDate\") == date)\n\n    if df.is_empty():\n        return pl.DataFrame()\n\n    if bond_type:\n        norm_bond_type = _bond_type_mapping(bond_type)\n        df = df.filter(pl.col(\"BondType\").is_in(norm_bond_type))\n\n    return df.sort([\"ReferenceDate\", \"BondType\", \"MaturityDate\"])\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_difusao","title":"<code>tpf_difusao(data_referencia)</code>","text":"<p>Obt\u00e9m a TPF Difus\u00e3o da Anbima para uma data de refer\u00eancia espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>data_referencia</code> <code>str | date | datetime</code> <p>Data de refer\u00eancia (ex: \"DD/MM/AAAA\").</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com os dados. Retorna um DataFrame vazio se n\u00e3o houver dados ou em caso de erro.</p> Output Columns <ul> <li>data_hora_referencia (datetime): Data e hora de refer\u00eancia da taxa.</li> <li>provedor (string): Provedor dos dados.</li> <li>titulo (string): Nome do t\u00edtulo (ex: LFT, LTN).</li> <li>data_vencimento (date): Data de vencimento do t\u00edtulo.</li> <li>codigo_isin (string): C\u00f3digo ISIN do t\u00edtulo.</li> <li>dias_uteis (int): Dias \u00fateis entre a data de refer\u00eancia e o vencimento.</li> <li>taxa_indicativa_anterior (float): Taxa indicativa de fechamento D-1 (decimal).</li> <li>taxa_venda (float): Taxa de oferta de venda (Ask rate) (decimal).</li> <li>taxa_compra (float): Taxa de oferta de compra (Bid rate) (decimal).</li> <li>taxa_media (float): M\u00e9dia entre a taxa de compra e venda (decimal).</li> <li>taxa_ultima (float): \u00daltima taxa negociada (decimal).</li> </ul> Source code in <code>pyield/anbima/difusao.py</code> <pre><code>def tpf_difusao(data_referencia: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Obt\u00e9m a TPF Difus\u00e3o da Anbima para uma data de refer\u00eancia espec\u00edfica.\n\n    Args:\n        data_referencia (str | dt.date | dt.datetime):\n            Data de refer\u00eancia (ex: \"DD/MM/AAAA\").\n\n    Returns:\n        pl.DataFrame: DataFrame com os dados. Retorna um DataFrame vazio se\n            n\u00e3o houver dados ou em caso de erro.\n\n    Output Columns:\n        * data_hora_referencia (datetime): Data e hora de refer\u00eancia da taxa.\n        * provedor (string): Provedor dos dados.\n        * titulo (string): Nome do t\u00edtulo (ex: LFT, LTN).\n        * data_vencimento (date): Data de vencimento do t\u00edtulo.\n        * codigo_isin (string): C\u00f3digo ISIN do t\u00edtulo.\n        * dias_uteis (int): Dias \u00fateis entre a data de refer\u00eancia e o vencimento.\n        * taxa_indicativa_anterior (float): Taxa indicativa de fechamento D-1 (decimal).\n        * taxa_venda (float): Taxa de oferta de venda (Ask rate) (decimal).\n        * taxa_compra (float): Taxa de oferta de compra (Bid rate) (decimal).\n        * taxa_media (float): M\u00e9dia entre a taxa de compra e venda (decimal).\n        * taxa_ultima (float): \u00daltima taxa negociada (decimal).\n    \"\"\"\n    if has_null_args(data_referencia):\n        logger.warning(\"Nenhuma data fornecida. Retornando DataFrame vazio.\")\n        return pl.DataFrame()\n    data_str = cv.convert_dates(data_referencia)\n    csv_data = _fetch_url_data(data_str)\n\n    if csv_data is None:\n        logger.warning(\"Nenhum dado foi retornado para a data '%s'.\", data_str)\n        return pl.DataFrame()\n\n    try:\n        df = _process_csv_data(csv_data)\n        return df\n    except Exception as e:\n        logger.error(\"Falha ao processar o CSV para a data '%s': %s\", data_str, e)\n        return pl.DataFrame()\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_maturities","title":"<code>tpf_maturities(date, bond_type)</code>","text":"<p>Retrieve existing maturity dates for a given bond type on a specific date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for maturity dates.</p> required <code>bond_type</code> <code>str</code> <p>The bond type to filter by (e.g., 'PRE' for both 'LTN' and 'NTN-F', or specify 'LTN' or 'NTN-F' directly).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series containing unique maturity dates for the specified bond type(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; anbima.tpf_maturities(date=\"22-08-2025\", bond_type=\"PRE\")\nshape: (18,)\nSeries: 'MaturityDate' [date]\n[\n    2025-10-01\n    2026-01-01\n    2026-04-01\n    2026-07-01\n    2026-10-01\n    \u2026\n    2030-01-01\n    2031-01-01\n    2032-01-01\n    2033-01-01\n    2035-01-01\n]\n</code></pre> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_maturities(\n    date: DateScalar,\n    bond_type: str,\n) -&gt; pl.Series:\n    \"\"\"Retrieve existing maturity dates for a given bond type on a specific date.\n\n    Args:\n        date (DateScalar): The reference date for maturity dates.\n        bond_type (str): The bond type to filter by (e.g., 'PRE' for both 'LTN'\n            and 'NTN-F', or specify 'LTN' or 'NTN-F' directly).\n\n    Returns:\n        pl.Series: A Series containing unique maturity dates for the\n            specified bond type(s).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; anbima.tpf_maturities(date=\"22-08-2025\", bond_type=\"PRE\")\n        shape: (18,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-10-01\n            2026-01-01\n            2026-04-01\n            2026-07-01\n            2026-10-01\n            \u2026\n            2030-01-01\n            2031-01-01\n            2032-01-01\n            2033-01-01\n            2035-01-01\n        ]\n\n    \"\"\"\n    return tpf_data(date, bond_type).get_column(\"MaturityDate\").unique().sort()\n</code></pre>"},{"location":"bc/","title":"BC Data","text":""},{"location":"bc/#pyield.bc.auctions","title":"<code>auctions(start=None, end=None, auction_type=None)</code>","text":"<p>Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.</p> <p>Consultas de Per\u00edodo: - Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>.   Exemplo: <code>auctions(start='2024-10-20', end='2024-10-27')</code> - Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir   da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel.   Exemplo: <code>auctions(start='2024-10-20')</code> - Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o desde a   data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>.   Exemplo: <code>auctions(end='2024-10-27')</code></p> <p>S\u00e9rie Hist\u00f3rica Completa: - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o   \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>.   Exemplo: <code>auctions()</code></p> <p>Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas, filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado. O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros <code>start</code> e <code>end</code> segue o padr\u00e3o da API do Banco Central: - Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim. - Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>. - Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</p> <p>Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\"). Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado. Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateScalar, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateScalar, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>auction_type</code> <code>(Literal['sell', 'buy'], opcional)</code> <p>O tipo de leil\u00e3o para filtrar diretamente na API. Padr\u00e3o \u00e9 <code>None</code> (retorna todos os tipos de leil\u00e3o).</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo especificados. Em caso de erro ao buscar os dados, um DataFrame vazio \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.auctions(start=\"19-08-2025\", end=\"19-08-2025\")\nshape: (5, 30)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Settlement \u2506 AuctionType \u2506 Ordinance \u2506 \u2026 \u2506 AcceptedQuantity \u2506 ValueFR     \u2506 ValueSR  \u2506 Value       \u2502\n\u2502 ---        \u2506 ---        \u2506 ---         \u2506 ---       \u2506   \u2506 ---              \u2506 ---         \u2506 ---      \u2506 ---         \u2502\n\u2502 date       \u2506 date       \u2506 str         \u2506 i64       \u2506   \u2506 i64              \u2506 i64         \u2506 i64      \u2506 i64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 150000           \u2506 2572400000  \u2506 0        \u2506 2572400000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 751003           \u2506 12804476147 \u2506 17123853 \u2506 12821600000 \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 193       \u2506 \u2026 \u2506 300759           \u2506 1289936461  \u2506 3263539  \u2506 1293200000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500542           \u2506 2071654327  \u2506 2245673  \u2506 2073900000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500000           \u2506 2010700000  \u2506 0        \u2506 2010700000  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>FR = First Round (Primeira Rodada) SR = Second Round (Segunda Rodada)</p> DataFrame Columns <ul> <li>Date: Data do leil\u00e3o.</li> <li>Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.</li> <li>AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").</li> <li>Ordinance: Edital normativo associado ao leil\u00e3o.</li> <li>Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").</li> <li>BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").</li> <li>SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.</li> <li>Maturity: Data de vencimento do t\u00edtulo.</li> <li>BDToMat: Dias \u00fateis entre a liquida\u00e7\u00e3o da 1R e a data de vencimento do t\u00edtulo.</li> <li>Duration: Duration (Dura\u00e7\u00e3o) calculada com base na data de     liquida\u00e7\u00e3o da 1R e na data de vencimento do t\u00edtulo.</li> <li>AvgMaturity: Maturidade m\u00e9dia do t\u00edtulo (em anos).</li> <li>AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.</li> <li>CutPrice: Pre\u00e7o de corte.</li> <li>AvgRate: Taxa de juros m\u00e9dia.</li> <li>CutRate: Taxa de corte.</li> <li>DV01FR: DV01 da Primeira Rodada (FR) em R$.</li> <li>DV01SR: DV01 da Segunda Rodada (SR) em R$.</li> <li>DV01: Valor do DV01 total do leil\u00e3o em R$.</li> <li>DV01FRUSD: DV01 da Primeira Rodada (FR) em d\u00f3lares (USD).</li> <li>DV01SRUSD: DV01 da Segunda Rodada (SR) em d\u00f3lares (USD).</li> <li>DV01USD: DV01 total do leil\u00e3o em d\u00f3lares (USD).</li> <li>OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).</li> <li>OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).</li> <li>OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).</li> <li>AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).</li> <li>AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).</li> <li>AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).</li> <li>ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.</li> <li>ValueSR: Valor da segunda rodada (SR) em R$.</li> <li>Value: Valor total do leil\u00e3o em R$ (FR + SR).</li> </ul> Source code in <code>pyield/bc/auction.py</code> <pre><code>def auctions(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n    auction_type: Literal[\"sell\", \"buy\"] | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.\n\n    **Consultas de Per\u00edodo:**\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n      Exemplo: `auctions(start='2024-10-20', end='2024-10-27')`\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir\n      da data de `start` **at\u00e9 a data mais recente dispon\u00edvel**.\n      Exemplo: `auctions(start='2024-10-20')`\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o **desde a\n      data mais antiga dispon\u00edvel at\u00e9 a data de `end`**.\n      Exemplo: `auctions(end='2024-10-27')`\n\n    **S\u00e9rie Hist\u00f3rica Completa:**\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o\n      \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n      Exemplo: `auctions()`\n\n    Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas,\n    filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado.\n    O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros `start` e `end` segue o padr\u00e3o\n    da API do Banco Central:\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\").\n    Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado.\n    Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.\n\n    Args:\n        start (DateScalar, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateScalar, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        auction_type (Literal[\"sell\", \"buy\"], opcional): O tipo de leil\u00e3o para filtrar\n            diretamente na API. Padr\u00e3o \u00e9 `None` (retorna todos os tipos de leil\u00e3o).\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo\n            especificados. Em caso de erro ao buscar os dados, um DataFrame vazio\n            \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.auctions(start=\"19-08-2025\", end=\"19-08-2025\")\n        shape: (5, 30)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Settlement \u2506 AuctionType \u2506 Ordinance \u2506 \u2026 \u2506 AcceptedQuantity \u2506 ValueFR     \u2506 ValueSR  \u2506 Value       \u2502\n        \u2502 ---        \u2506 ---        \u2506 ---         \u2506 ---       \u2506   \u2506 ---              \u2506 ---         \u2506 ---      \u2506 ---         \u2502\n        \u2502 date       \u2506 date       \u2506 str         \u2506 i64       \u2506   \u2506 i64              \u2506 i64         \u2506 i64      \u2506 i64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 150000           \u2506 2572400000  \u2506 0        \u2506 2572400000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 751003           \u2506 12804476147 \u2506 17123853 \u2506 12821600000 \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 193       \u2506 \u2026 \u2506 300759           \u2506 1289936461  \u2506 3263539  \u2506 1293200000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500542           \u2506 2071654327  \u2506 2245673  \u2506 2073900000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500000           \u2506 2010700000  \u2506 0        \u2506 2010700000  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        FR = First Round (Primeira Rodada)\n        SR = Second Round (Segunda Rodada)\n\n    DataFrame Columns:\n        - Date: Data do leil\u00e3o.\n        - Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.\n        - AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").\n        - Ordinance: Edital normativo associado ao leil\u00e3o.\n        - Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").\n        - BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").\n        - SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.\n        - Maturity: Data de vencimento do t\u00edtulo.\n        - BDToMat: Dias \u00fateis entre a liquida\u00e7\u00e3o da 1R e a data de vencimento do t\u00edtulo.\n        - Duration: Duration (Dura\u00e7\u00e3o) calculada com base na data de\n            liquida\u00e7\u00e3o da 1R e na data de vencimento do t\u00edtulo.\n        - AvgMaturity: Maturidade m\u00e9dia do t\u00edtulo (em anos).\n        - AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.\n        - CutPrice: Pre\u00e7o de corte.\n        - AvgRate: Taxa de juros m\u00e9dia.\n        - CutRate: Taxa de corte.\n        - DV01FR: DV01 da Primeira Rodada (FR) em R$.\n        - DV01SR: DV01 da Segunda Rodada (SR) em R$.\n        - DV01: Valor do DV01 total do leil\u00e3o em R$.\n        - DV01FRUSD: DV01 da Primeira Rodada (FR) em d\u00f3lares (USD).\n        - DV01SRUSD: DV01 da Segunda Rodada (SR) em d\u00f3lares (USD).\n        - DV01USD: DV01 total do leil\u00e3o em d\u00f3lares (USD).\n        - OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).\n        - OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).\n        - OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).\n        - AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).\n        - AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).\n        - AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).\n        - ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.\n        - ValueSR: Valor da segunda rodada (SR) em R$.\n        - Value: Valor total do leil\u00e3o em R$ (FR + SR).\n    \"\"\"  # noqa: E501\n    try:\n        url = _build_url(start=start, end=end, auction_type=auction_type)\n        api_csv_text = _get_api_csv(url)\n        df = _parse_csv(api_csv_text)\n        if df.is_empty():\n            logger.warning(\"No auction data found after parsing the API response.\")\n            return pl.DataFrame()\n        df = _format_df(df)\n        df = _process_df(df)\n        df = _adjust_values_without_auction(df)\n        df = _add_duration(df)\n        df = _add_dv01(df)\n        df = _add_usd_dv01(df)\n        df = _add_avg_maturity(df)\n        df = _sort_and_reorder_columns(df)\n        return df\n    except Exception as e:\n        logger.exception(f\"Error fetching auction data from BC API: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.di_over","title":"<code>di_over(date, annualized=True)</code>","text":"<p>Fetches the DI Over rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the DI Over rate for.</p> required <code>annualized</code> <code>bool</code> <p>If True, returns the annualized rate (252 trading days per year), otherwise returns the daily rate.</p> <code>True</code> <p>Returns:</p> Type Description <code>float | None</code> <p>The DI Over rate as a float or None if not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n0.104\n</code></pre> <pre><code>&gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n0.00045513\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def di_over(date: DateScalar, annualized: bool = True) -&gt; float | None:\n    \"\"\"\n    Fetches the DI Over rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the DI Over rate for.\n        annualized: If True, returns the annualized rate (252 trading\n            days per year), otherwise returns the daily rate.\n\n    Returns:\n        The DI Over rate as a float or None if not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n        0.104\n\n        &gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n        0.00045513\n    \"\"\"\n    if has_null_args(date):\n        return None\n    df = di_over_series(date, date, annualized)\n    if df.is_empty():\n        return None\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.di_over_series","title":"<code>di_over_series(start, end=None, annualized=True)</code>","text":"<p>Fetches the DI (Interbank Deposit) rate from the Brazilian Central Bank.</p> <p>The DI rate represents the average interest rate of interbank loans.</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024 https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> required <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <code>annualized</code> <code>bool</code> <p>If True, returns the annualized rate (252 trading days per year), otherwise returns the daily rate.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the DI rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Returns all data since 29-01-2025\n&gt;&gt;&gt; bc.di_over_series(\"29-01-2025\").head(5)  # Showing only first 5 rows\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value  \u2502\n\u2502 ---        \u2506 ---    \u2502\n\u2502 date       \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-29 \u2506 0.1215 \u2502\n\u2502 2025-01-30 \u2506 0.1315 \u2502\n\u2502 2025-01-31 \u2506 0.1315 \u2502\n\u2502 2025-02-03 \u2506 0.1315 \u2502\n\u2502 2025-02-04 \u2506 0.1315 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def di_over_series(\n    start: DateScalar,\n    end: DateScalar | None = None,\n    annualized: bool = True,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches the DI (Interbank Deposit) rate from the Brazilian Central Bank.\n\n    The DI rate represents the average interest rate of interbank loans.\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n        annualized: If True, returns the annualized rate (252 trading\n            days per year), otherwise returns the daily rate.\n\n    Returns:\n        DataFrame containing Date and Value columns with the DI rate,\n        or empty DataFrame if data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Returns all data since 29-01-2025\n        &gt;&gt;&gt; bc.di_over_series(\"29-01-2025\").head(5)  # Showing only first 5 rows\n        shape: (5, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value  \u2502\n        \u2502 ---        \u2506 ---    \u2502\n        \u2502 date       \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-29 \u2506 0.1215 \u2502\n        \u2502 2025-01-30 \u2506 0.1315 \u2502\n        \u2502 2025-01-31 \u2506 0.1315 \u2502\n        \u2502 2025-02-03 \u2506 0.1315 \u2502\n        \u2502 2025-02-04 \u2506 0.1315 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(start):\n        return pl.DataFrame()\n    df = _fetch_data_from_url(BCSerie.DI_OVER, start, end)\n    if annualized:\n        df = df.with_columns(\n            (((pl.col(\"Value\") + 1).pow(252)) - 1)\n            .round(DECIMAL_PLACES_ANNUALIZED)\n            .alias(\"Value\")\n        )\n\n    else:\n        df = df.with_columns(pl.col(\"Value\").round(DECIMAL_PLACES_DAILY))\n\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.ptax","title":"<code>ptax(date)</code>","text":"<p>Busca a cota\u00e7\u00e3o PTAX m\u00e9dia de fechamento para uma data espec\u00edfica.</p> <p>Esta fun\u00e7\u00e3o \u00e9 um wrapper para a fun\u00e7\u00e3o <code>ptax_series</code>, otimizada para buscar o valor de um \u00fanico dia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>A data para a qual a cota\u00e7\u00e3o PTAX \u00e9 desejada. Pode ser uma string no formato \"dd-mm-aaaa\" ou um objeto date/datetime.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float | None</code> <p>O valor da PTAX (taxa m\u00e9dia) para a data especificada.    Retorna None se n\u00e3o houver cota\u00e7\u00e3o para a data    (ex: feriado, fim de semana ou data futura).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Busca a PTAX para um dia \u00fatil\n&gt;&gt;&gt; bc.ptax(\"22-08-2025\")\n5.4389\n</code></pre> <pre><code>&gt;&gt;&gt; # Busca a PTAX para um fim de semana (sem dados)\n&gt;&gt;&gt; bc.ptax(\"23-08-2025\") is None\nTrue\n</code></pre> Source code in <code>pyield/bc/ptax_api.py</code> <pre><code>def ptax(date: DateScalar) -&gt; float | None:\n    \"\"\"Busca a cota\u00e7\u00e3o PTAX m\u00e9dia de fechamento para uma data espec\u00edfica.\n\n    Esta fun\u00e7\u00e3o \u00e9 um wrapper para a fun\u00e7\u00e3o `ptax_series`, otimizada para\n    buscar o valor de um \u00fanico dia.\n\n    Args:\n        date (DateScalar): A data para a qual a cota\u00e7\u00e3o PTAX \u00e9 desejada.\n            Pode ser uma string no formato \"dd-mm-aaaa\" ou um objeto date/datetime.\n\n    Returns:\n        float: O valor da PTAX (taxa m\u00e9dia) para a data especificada.\n               Retorna None se n\u00e3o houver cota\u00e7\u00e3o para a data\n               (ex: feriado, fim de semana ou data futura).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Busca a PTAX para um dia \u00fatil\n        &gt;&gt;&gt; bc.ptax(\"22-08-2025\")\n        5.4389\n\n        &gt;&gt;&gt; # Busca a PTAX para um fim de semana (sem dados)\n        &gt;&gt;&gt; bc.ptax(\"23-08-2025\") is None\n        True\n    \"\"\"\n    # Reutiliza a fun\u00e7\u00e3o ptax_series para buscar os dados para o dia espec\u00edfico.\n    # Definir start e end com a mesma data busca a cota\u00e7\u00e3o para aquele dia.\n    df_ptax = ptax_series(start=date, end=date)\n\n    # Se o DataFrame estiver vazio, significa que n\u00e3o h\u00e1 cota\u00e7\u00e3o para a data.\n    # Isso ocorre em fins de semana, feriados ou datas futuras.\n    if df_ptax.is_empty():\n        logger.warning(f\"No PTAX data found for date: {date}\")\n        return None\n\n    # A API retorna uma \u00fanica linha para a cota\u00e7\u00e3o de fechamento de um dia.\n    # A coluna \"MidRate\" representa a PTAX de fechamento.\n    return df_ptax[\"MidRate\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.ptax_series","title":"<code>ptax_series(start=None, end=None)</code>","text":"<p>Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio) - Fonte: Banco Central do Brasil (BCB) - Frequ\u00eancia: Di\u00e1ria - Unidade: R$</p> <p>Documenta\u00e7\u00e3o da API do BCB:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n</code></pre> <p>Exemplo de chamada \u00e0 API:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n</code></pre> <p>Consultas de Per\u00edodo:</p> <ul> <li> <p>Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>. Exemplo:</p> <pre><code>`ptax_series(start='20-10-2024', end='27-10-2024')`\n</code></pre> </li> <li> <p>Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados a partir da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Exemplo:</p> <pre><code>`ptax_series(start='20-10-2024')`\n</code></pre> </li> <li> <p>Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Exemplo:</p> <p><code>ptax_series(end='27-10-2024')</code></p> </li> </ul> <p>S\u00e9rie Hist\u00f3rica Completa:</p> <ul> <li>Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984 at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>. Exemplo:<pre><code>`ptax_series()`\n</code></pre> </li> </ul> <p>Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:</p> <ul> <li>Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim.</li> <li>Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>.</li> <li>Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateScalar, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateScalar, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.</p> <code>DataFrame</code> <p>Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio</p> <code>DataFrame</code> <p>ser\u00e1 retornado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.ptax_series(start=\"20-04-2025\", end=\"25-04-2025\")\nshape: (4, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 DateTime                \u2506 BuyRate \u2506 SellRate \u2506 MidRate \u2502\n\u2502 ---        \u2506 ---                     \u2506 ---     \u2506 ---      \u2506 ---     \u2502\n\u2502 date       \u2506 datetime[ms]            \u2506 f64     \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-04-22 \u2506 2025-04-22 13:09:35.629 \u2506 5.749   \u2506 5.7496   \u2506 5.7493  \u2502\n\u2502 2025-04-23 \u2506 2025-04-23 13:06:30.443 \u2506 5.6874  \u2506 5.688    \u2506 5.6877  \u2502\n\u2502 2025-04-24 \u2506 2025-04-24 13:04:29.639 \u2506 5.6732  \u2506 5.6738   \u2506 5.6735  \u2502\n\u2502 2025-04-25 \u2506 2025-04-25 13:09:26.592 \u2506 5.684   \u2506 5.6846   \u2506 5.6843  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990 e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992, essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de 2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de 1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta; o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos boletins do dia.</p> <ul> <li>Primeira data dispon\u00edvel: 28.11.1984</li> <li>\u00daltima data dispon\u00edvel: data atual</li> </ul> <p>O DataFrame possui as seguintes colunas:</p> <ul> <li>Date: Data da cota\u00e7\u00e3o.</li> <li>DateTime: Data e hora da cota\u00e7\u00e3o.</li> <li>BuyRate: Taxa de compra.</li> <li>SellRate: Taxa de venda.</li> <li>MidRate: Taxa m\u00e9dia entre a compra/venda arredondada para 5 casas decimais.</li> </ul> Source code in <code>pyield/bc/ptax_api.py</code> <pre><code>def ptax_series(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio)\n    - Fonte: Banco Central do Brasil (BCB)\n    - Frequ\u00eancia: Di\u00e1ria\n    - Unidade: R$\n\n    Documenta\u00e7\u00e3o da API do BCB:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n\n    Exemplo de chamada \u00e0 API:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n\n    Consultas de Per\u00edodo:\n\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n    Exemplo:\n\n            `ptax_series(start='20-10-2024', end='27-10-2024')`\n\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados a partir\n    da data de `start` at\u00e9 a data mais recente dispon\u00edvel. Exemplo:\n\n            `ptax_series(start='20-10-2024')`\n\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados desde a data mais\n    antiga dispon\u00edvel at\u00e9 a data de `end`. Exemplo:\n\n        `ptax_series(end='27-10-2024')`\n\n    S\u00e9rie Hist\u00f3rica Completa:\n\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984\n    at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n    Exemplo:\n\n            `ptax_series()`\n\n    Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:\n\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start (DateScalar, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateScalar, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.\n        Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio\n        ser\u00e1 retornado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.ptax_series(start=\"20-04-2025\", end=\"25-04-2025\")\n        shape: (4, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 DateTime                \u2506 BuyRate \u2506 SellRate \u2506 MidRate \u2502\n        \u2502 ---        \u2506 ---                     \u2506 ---     \u2506 ---      \u2506 ---     \u2502\n        \u2502 date       \u2506 datetime[ms]            \u2506 f64     \u2506 f64      \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-04-22 \u2506 2025-04-22 13:09:35.629 \u2506 5.749   \u2506 5.7496   \u2506 5.7493  \u2502\n        \u2502 2025-04-23 \u2506 2025-04-23 13:06:30.443 \u2506 5.6874  \u2506 5.688    \u2506 5.6877  \u2502\n        \u2502 2025-04-24 \u2506 2025-04-24 13:04:29.639 \u2506 5.6732  \u2506 5.6738   \u2506 5.6735  \u2502\n        \u2502 2025-04-25 \u2506 2025-04-25 13:09:26.592 \u2506 5.684   \u2506 5.6846   \u2506 5.6843  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990\n        e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas\n        administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992,\n        essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de\n        2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no\n        mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de\n        1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder\n        \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de\n        c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta;\n        o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos\n        boletins do dia.\n\n        - Primeira data dispon\u00edvel: 28.11.1984\n        - \u00daltima data dispon\u00edvel: data atual\n\n        O DataFrame possui as seguintes colunas:\n\n        - Date: Data da cota\u00e7\u00e3o.\n        - DateTime: Data e hora da cota\u00e7\u00e3o.\n        - BuyRate: Taxa de compra.\n        - SellRate: Taxa de venda.\n        - MidRate: Taxa m\u00e9dia entre a compra/venda arredondada para 5 casas decimais.\n    \"\"\"\n    if start:\n        start = cv.convert_dates(start)\n    else:\n        start = dt.date(1984, 11, 28)  # Primeira data dispon\u00edvel na API\n\n    if end:\n        end = cv.convert_dates(end)\n    else:\n        end = dt.datetime.now(TIMEZONE_BZ).date()\n\n    try:\n        url = _build_api_url(start, end)\n        text = _fetch_text_from_api(url)\n        df = _parse_csv(text)\n        if df.is_empty():\n            logging.warning(\"No data found for the specified period.\")\n            return pl.DataFrame()\n        df = _process_df(df)\n        return df\n    except requests.exceptions.HTTPError as http_err:\n        logger.error(f\"HTTP error occurred: {http_err}\")\n        return pl.DataFrame()\n    except Exception as e:\n        logger.exception(\"Error fetching PTAX data from BC API: %s\", e)\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.repos","title":"<code>repos(start=None, end=None)</code>","text":"<p>Consulta e retorna leil\u00f5es de opera\u00e7\u00f5es compromissadas (repos) do BCB.</p> <p>Sem\u00e2ntica dos par\u00e2metros de per\u00edodo (API OData):     - start somente: dados de start at\u00e9 o fim da s\u00e9rie.     - end somente: dados do in\u00edcio da s\u00e9rie at\u00e9 end.     - ambos omitidos: s\u00e9rie hist\u00f3rica completa.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | None</code> <p>Data inicial (inclusive) ou None.</p> <code>None</code> <code>end</code> <code>DateScalar | None</code> <p>Data final (inclusive) ou None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame com colunas normalizadas em portugu\u00eas e tipos</p> <code>DataFrame</code> <p>enriquecidos (fra\u00e7\u00f5es decimais, inteiros, datas). Em caso de erro</p> <code>DataFrame</code> <p>retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.</p> DataFrame columns <ul> <li>data_leilao: data de ocorr\u00eancia do leil\u00e3o.</li> <li>data_liquidacao: data de liquida\u00e7\u00e3o (in\u00edcio da opera\u00e7\u00e3o).</li> <li>data_retorno: data de recompra / t\u00e9rmino da opera\u00e7\u00e3o.</li> <li>hora_inicio: hor\u00e1rio de in\u00edcio do leil\u00e3o.</li> <li>prazo_dias_corridos: dias corridos at\u00e9 a data de retorno.</li> <li>prazo_dias_uteis: dias \u00fateis entre liquida\u00e7\u00e3o e retorno (bday.count).</li> <li>numero_comunicado: n\u00famero do comunicado/aviso do BC (pode ser nulo).</li> <li>tipo_oferta: classif. do tipo de oferta (ex: Tomador, Compromissada 1047).</li> <li>publico_permitido: escopo de participantes (SomenteDealer, TodoMercado).</li> <li>volume_aceito: volume aceito no leil\u00e3o em reais (convertido de milhares).</li> <li>taxa_corte: taxa de corte (ex. 0.1490 = 14,90%). Nula se volume_aceito = 0.</li> <li>percentual_aceito: percentual do volume ofertado efetivamente aceito (0-100).   100 = nenhuma rejei\u00e7\u00e3o. 0 indica nada aceito (volume_aceito = 0).</li> </ul> Notes <ul> <li>Dados ordenados por: data_leilao, hora_inicio, tipo_oferta.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.repos(start=\"21-08-2025\", end=\"21-08-2025\")\nshape: (2, 12)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 data_leilao \u2506 data_liquidacao \u2506 data_retorno \u2506 hora_inicio \u2506 \u2026 \u2506 publico_permitido \u2506 volume_aceito \u2506 taxa_corte \u2506 percentual_aceito \u2502\n\u2502 ---         \u2506 ---             \u2506 ---          \u2506 ---         \u2506   \u2506 ---               \u2506 ---           \u2506 ---        \u2506 ---               \u2502\n\u2502 date        \u2506 date            \u2506 date         \u2506 time        \u2506   \u2506 str               \u2506 i64           \u2506 f64        \u2506 f64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-21  \u2506 2025-08-21      \u2506 2025-08-22   \u2506 09:00:00    \u2506 \u2026 \u2506 SomenteDealer     \u2506 647707406000  \u2506 0.149      \u2506 100.0             \u2502\n\u2502 2025-08-21  \u2506 2025-08-22      \u2506 2025-11-21   \u2506 12:00:00    \u2506 \u2026 \u2506 TodoMercado       \u2506 5000000000    \u2506 0.9978     \u2506 35.87             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/repo.py</code> <pre><code>def repos(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"Consulta e retorna leil\u00f5es de opera\u00e7\u00f5es compromissadas (repos) do BCB.\n\n    Sem\u00e2ntica dos par\u00e2metros de per\u00edodo (API OData):\n        - start somente: dados de start at\u00e9 o fim da s\u00e9rie.\n        - end somente: dados do in\u00edcio da s\u00e9rie at\u00e9 end.\n        - ambos omitidos: s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start: Data inicial (inclusive) ou None.\n        end: Data final (inclusive) ou None.\n\n    Returns:\n        DataFrame com colunas normalizadas em portugu\u00eas e tipos\n        enriquecidos (fra\u00e7\u00f5es decimais, inteiros, datas). Em caso de erro\n        retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.\n\n    DataFrame columns:\n        - data_leilao: data de ocorr\u00eancia do leil\u00e3o.\n        - data_liquidacao: data de liquida\u00e7\u00e3o (in\u00edcio da opera\u00e7\u00e3o).\n        - data_retorno: data de recompra / t\u00e9rmino da opera\u00e7\u00e3o.\n        - hora_inicio: hor\u00e1rio de in\u00edcio do leil\u00e3o.\n        - prazo_dias_corridos: dias corridos at\u00e9 a data de retorno.\n        - prazo_dias_uteis: dias \u00fateis entre liquida\u00e7\u00e3o e retorno (bday.count).\n        - numero_comunicado: n\u00famero do comunicado/aviso do BC (pode ser nulo).\n        - tipo_oferta: classif. do tipo de oferta (ex: Tomador, Compromissada 1047).\n        - publico_permitido: escopo de participantes (SomenteDealer, TodoMercado).\n        - volume_aceito: volume aceito no leil\u00e3o em reais (convertido de milhares).\n        - taxa_corte: taxa de corte (ex. 0.1490 = 14,90%). Nula se volume_aceito = 0.\n        - percentual_aceito: percentual do volume ofertado efetivamente aceito (0-100).\n          100 = nenhuma rejei\u00e7\u00e3o. 0 indica nada aceito (volume_aceito = 0).\n\n    Notes:\n        - Dados ordenados por: data_leilao, hora_inicio, tipo_oferta.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.repos(start=\"21-08-2025\", end=\"21-08-2025\")\n        shape: (2, 12)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 data_leilao \u2506 data_liquidacao \u2506 data_retorno \u2506 hora_inicio \u2506 \u2026 \u2506 publico_permitido \u2506 volume_aceito \u2506 taxa_corte \u2506 percentual_aceito \u2502\n        \u2502 ---         \u2506 ---             \u2506 ---          \u2506 ---         \u2506   \u2506 ---               \u2506 ---           \u2506 ---        \u2506 ---               \u2502\n        \u2502 date        \u2506 date            \u2506 date         \u2506 time        \u2506   \u2506 str               \u2506 i64           \u2506 f64        \u2506 f64               \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-21  \u2506 2025-08-21      \u2506 2025-08-22   \u2506 09:00:00    \u2506 \u2026 \u2506 SomenteDealer     \u2506 647707406000  \u2506 0.149      \u2506 100.0             \u2502\n        \u2502 2025-08-21  \u2506 2025-08-22      \u2506 2025-11-21   \u2506 12:00:00    \u2506 \u2026 \u2506 TodoMercado       \u2506 5000000000    \u2506 0.9978     \u2506 35.87             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    try:\n        url = _build_url(start=start, end=end)\n        logger.debug(f\"Consultando API do BC: {url}\")\n        api_csv = _fetch_api_csv(url)\n        df = _read_csv_data(api_csv)\n        if df.is_empty():\n            logger.warning(\"Sem dados de leil\u00f5es para o per\u00edodo especificado.\")\n            return pl.DataFrame()\n        df = _process_df(df)\n        df = _handle_zero_volume(df)\n        df = _sort_and_select_columns(df)\n        return df\n    except Exception as e:\n        logger.exception(f\"Erro ao buscar dados de leil\u00f5es na API do BC: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over","title":"<code>selic_over(date)</code>","text":"<p>Fetches the SELIC Over rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the SELIC Over rate for.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>The SELIC Over rate as a float or None if not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n0.104\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_over(date: DateScalar) -&gt; float | None:\n    \"\"\"\n    Fetches the SELIC Over rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the SELIC Over rate for.\n\n    Returns:\n        The SELIC Over rate as a float or None if not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n        0.104\n    \"\"\"\n    if has_null_args(date):\n        return None\n    df = selic_over_series(date, date)\n    if df.is_empty():\n        return None\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over_series","title":"<code>selic_over_series(start, end=None)</code>","text":"<p>Fetches the SELIC Over rate from the Brazilian Central Bank.</p> <p>The SELIC Over rate is the daily average interest rate effectively practiced between banks in the interbank market, using public securities as collateral.</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> required <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the SELIC Over rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # No data on 26-01-2025 (sunday). Selic changed due to Copom meeting.\n&gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\").head(5)  # Showing first 5 rows\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value  \u2502\n\u2502 ---        \u2506 ---    \u2502\n\u2502 date       \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-27 \u2506 0.1215 \u2502\n\u2502 2025-01-28 \u2506 0.1215 \u2502\n\u2502 2025-01-29 \u2506 0.1215 \u2502\n\u2502 2025-01-30 \u2506 0.1315 \u2502\n\u2502 2025-01-31 \u2506 0.1315 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; # Fetching data for a specific date range\n&gt;&gt;&gt; bc.selic_over_series(\"14-09-2025\", \"17-09-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value \u2502\n\u2502 ---        \u2506 ---   \u2502\n\u2502 date       \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-09-15 \u2506 0.149 \u2502\n\u2502 2025-09-16 \u2506 0.149 \u2502\n\u2502 2025-09-17 \u2506 0.149 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_over_series(\n    start: DateScalar,\n    end: DateScalar | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches the SELIC Over rate from the Brazilian Central Bank.\n\n    The SELIC Over rate is the daily average interest rate effectively practiced\n    between banks in the interbank market, using public securities as collateral.\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n\n    Returns:\n        DataFrame containing Date and Value columns with the SELIC Over rate,\n        or empty DataFrame if data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # No data on 26-01-2025 (sunday). Selic changed due to Copom meeting.\n        &gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\").head(5)  # Showing first 5 rows\n        shape: (5, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value  \u2502\n        \u2502 ---        \u2506 ---    \u2502\n        \u2502 date       \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-27 \u2506 0.1215 \u2502\n        \u2502 2025-01-28 \u2506 0.1215 \u2502\n        \u2502 2025-01-29 \u2506 0.1215 \u2502\n        \u2502 2025-01-30 \u2506 0.1315 \u2502\n        \u2502 2025-01-31 \u2506 0.1315 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; # Fetching data for a specific date range\n        &gt;&gt;&gt; bc.selic_over_series(\"14-09-2025\", \"17-09-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value \u2502\n        \u2502 ---        \u2506 ---   \u2502\n        \u2502 date       \u2506 f64   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-09-15 \u2506 0.149 \u2502\n        \u2502 2025-09-16 \u2506 0.149 \u2502\n        \u2502 2025-09-17 \u2506 0.149 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(start):  # Start must be provided\n        return pl.DataFrame()\n    df = _fetch_data_from_url(BCSerie.SELIC_OVER, start, end)\n    return df.with_columns(pl.col(\"Value\").round(DECIMAL_PLACES_ANNUALIZED))\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target","title":"<code>selic_target(date)</code>","text":"<p>Fetches the SELIC Target rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the SELIC Target rate for.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>The SELIC Target rate as a float or None if not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n0.105\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_target(date: DateScalar) -&gt; float | None:\n    \"\"\"\n    Fetches the SELIC Target rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the SELIC Target rate for.\n\n    Returns:\n        The SELIC Target rate as a float or None if not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n        0.105\n    \"\"\"\n    if has_null_args(date):\n        return None\n    df = selic_target_series(date, date)\n    if df.is_empty():\n        return None\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target_series","title":"<code>selic_target_series(start, end=None)</code>","text":"<p>Fetches the SELIC Target rate from the Brazilian Central Bank.</p> <p>The SELIC Target rate is the official interest rate set by the Central Bank of Brazil's Monetary Policy Committee (COPOM).</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date for the data to fetch.</p> required <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the SELIC Target rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value \u2502\n\u2502 ---        \u2506 ---   \u2502\n\u2502 date       \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 0.105 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_target_series(\n    start: DateScalar,\n    end: DateScalar | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches the SELIC Target rate from the Brazilian Central Bank.\n\n    The SELIC Target rate is the official interest rate set by the\n    Central Bank of Brazil's Monetary Policy Committee (COPOM).\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n\n    Returns:\n        DataFrame containing Date and Value columns with the SELIC Target rate,\n        or empty DataFrame if data is not available\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\n        shape: (1, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value \u2502\n        \u2502 ---        \u2506 ---   \u2502\n        \u2502 date       \u2506 f64   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 0.105 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(start):  # Start must be provided\n        return pl.DataFrame()\n    df = _fetch_data_from_url(BCSerie.SELIC_TARGET, start, end)\n    df = df.with_columns(pl.col(\"Value\").round(DECIMAL_PLACES_ANNUALIZED))\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_intraday_trades","title":"<code>tpf_intraday_trades()</code>","text":"<p>Fetches real-time secondary trading data for domestic Federal Public Debt (TPF - t\u00edtulos p\u00fablicos federais) from the Central Bank of Brazil (BCB).</p> <p>This function checks if the SELIC market is currently open based on Brazil/Sao_Paulo timezone business days and trading hours (defined by REALTIME_START_TIME and REALTIME_END_TIME). If the market is closed, or if no data is available from the source, or if an error occurs during fetching or processing, an empty DataFrame is returned. Otherwise, it retrieves, cleans, and processes the intraday trade data provided by BCB for Brazilian government bonds.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the latest intraday trades for FPD securities. Returns an empty DataFrame if the market is closed, no data is found, or an error occurs. The DataFrame includes the following columns:</p> DataFrame Columns <ul> <li><code>CollectedAt</code>: Timestamp indicating when the data was collected     (in Brazil/Sao_Paulo timezone).</li> <li><code>SettlementDate</code>: The reference date for the spot market     trading activity reported in this dataset (the current     business day). Forward trades listed have future settlement dates     not specified here.</li> <li><code>BondType</code>: Abbreviation/ticker for the bond type (e.g., LFT,     LTN, NTN-B).</li> <li><code>SelicCode</code>: The unique SELIC code identifying the specific bond issue.</li> <li><code>MaturityDate</code>: The maturity date of the bond.</li> <li><code>MinPrice</code>: Minimum traded price.</li> <li><code>AvgPrice</code>: Average traded price.</li> <li><code>MaxPrice</code>: Maximum traded price.</li> <li><code>LastPrice</code>: Last traded price.</li> <li><code>MinRate</code>: Minimum traded yield/rate (as a decimal, e.g., 0.11 for 11%).</li> <li><code>AvgRate</code>: Average traded yield/rate (as a decimal).</li> <li><code>MaxRate</code>: Maximum traded yield/rate (as a decimal).</li> <li><code>LastRate</code>: Last traded yield/rate (as a decimal).</li> <li><code>Trades</code>: Total number of trades settled.</li> <li><code>Quantity</code>: Total number of bonds traded (quantity).</li> <li><code>Value</code>: Total financial value traded (in BRL).</li> <li><code>BrokeredTrades</code>: Number of brokered trades settled.</li> <li><code>BrokeredQuantity</code>: Quantity of bonds traded via brokers.</li> <li><code>FwdMinPrice</code>: Forward minimum traded price.</li> <li><code>FwdAvgPrice</code>: Forward average traded price.</li> <li><code>FwdMaxPrice</code>: Forward maximum traded price.</li> <li><code>FwdLastPrice</code>: Forward last traded price.</li> <li><code>FwdMinRate</code>: Forward minimum traded yield/rate (decimal).</li> <li><code>FwdAvgRate</code>: Forward average traded yield/rate (decimal).</li> <li><code>FwdMaxRate</code>: Forward maximum traded yield/rate (decimal).</li> <li><code>FwdLastRate</code>: Forward last traded yield/rate (decimal).</li> <li><code>FwdTrades</code>: Forward total number of trades contracted.</li> <li><code>FwdQuantity</code>: Forward total number of bonds traded (quantity).</li> <li><code>FwdValue</code>: Forward total financial value traded (in BRL).</li> <li><code>FwdBrokeredTrades</code>: Forward number of brokered trades contracted.</li> <li><code>FwdBrokeredQuantity</code>: Forward quantity of bonds traded via brokers.</li> </ul> Notes <ul> <li>The DataFrame returned by this function may be empty if the market is closed,   no data is found, or an error occurs.</li> <li>Arrow data types are used for better performance and compatibility with other   libraries.</li> </ul> Source code in <code>pyield/bc/trades_intraday.py</code> <pre><code>def tpf_intraday_trades() -&gt; pl.DataFrame:\n    \"\"\"Fetches real-time secondary trading data for domestic Federal Public Debt\n    (TPF - t\u00edtulos p\u00fablicos federais) from the Central Bank of Brazil (BCB).\n\n    This function checks if the SELIC market is currently open based on Brazil/Sao_Paulo\n    timezone business days and trading hours (defined by REALTIME_START_TIME and\n    REALTIME_END_TIME). If the market is closed, or if no data is available from the\n    source, or if an error occurs during fetching or processing, an empty DataFrame\n    is returned. Otherwise, it retrieves, cleans, and processes the intraday trade\n    data provided by BCB for Brazilian government bonds.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the latest intraday trades for FPD\n            securities. Returns an empty DataFrame if the market is closed, no data\n            is found, or an error occurs. The DataFrame includes the following columns:\n\n    DataFrame Columns:\n        - `CollectedAt`: Timestamp indicating when the data was collected\n            (in Brazil/Sao_Paulo timezone).\n        - `SettlementDate`: The reference date for the spot market\n            trading activity reported in this dataset (the current\n            business day). Forward trades listed have future settlement dates\n            not specified here.\n        - `BondType`: Abbreviation/ticker for the bond type (e.g., LFT,\n            LTN, NTN-B).\n        - `SelicCode`: The unique SELIC code identifying the specific bond issue.\n        - `MaturityDate`: The maturity date of the bond.\n        - `MinPrice`: Minimum traded price.\n        - `AvgPrice`: Average traded price.\n        - `MaxPrice`: Maximum traded price.\n        - `LastPrice`: Last traded price.\n        - `MinRate`: Minimum traded yield/rate (as a decimal, e.g., 0.11 for 11%).\n        - `AvgRate`: Average traded yield/rate (as a decimal).\n        - `MaxRate`: Maximum traded yield/rate (as a decimal).\n        - `LastRate`: Last traded yield/rate (as a decimal).\n        - `Trades`: Total number of trades settled.\n        - `Quantity`: Total number of bonds traded (quantity).\n        - `Value`: Total financial value traded (in BRL).\n        - `BrokeredTrades`: Number of brokered trades settled.\n        - `BrokeredQuantity`: Quantity of bonds traded via brokers.\n        - `FwdMinPrice`: Forward minimum traded price.\n        - `FwdAvgPrice`: Forward average traded price.\n        - `FwdMaxPrice`: Forward maximum traded price.\n        - `FwdLastPrice`: Forward last traded price.\n        - `FwdMinRate`: Forward minimum traded yield/rate (decimal).\n        - `FwdAvgRate`: Forward average traded yield/rate (decimal).\n        - `FwdMaxRate`: Forward maximum traded yield/rate (decimal).\n        - `FwdLastRate`: Forward last traded yield/rate (decimal).\n        - `FwdTrades`: Forward total number of trades contracted.\n        - `FwdQuantity`: Forward total number of bonds traded (quantity).\n        - `FwdValue`: Forward total financial value traded (in BRL).\n        - `FwdBrokeredTrades`: Forward number of brokered trades contracted.\n        - `FwdBrokeredQuantity`: Forward quantity of bonds traded via brokers.\n\n    Notes:\n        - The DataFrame returned by this function may be empty if the market is closed,\n          no data is found, or an error occurs.\n        - Arrow data types are used for better performance and compatibility with other\n          libraries.\n    \"\"\"\n    if not is_selic_open():\n        logger.info(\"Market is closed. Returning empty DataFrame.\")\n        return pl.DataFrame()\n\n    try:\n        raw_text = _fetch_csv_from_url()\n        cleaned_text = _clean_csv(raw_text)\n        if not cleaned_text:\n            logger.warning(\"No data found in the FPD intraday trades.\")\n            return pl.DataFrame()\n\n        df = _convert_csv_to_df(cleaned_text)\n        df = _process_df(df)\n\n        value = df[\"Value\"].sum() / 10**9\n        logger.info(f\"Fetched {value:,.1f} billion BRL in FPD intraday trades.\")\n        return df\n    except Exception as e:\n        logger.exception(\n            f\"Error fetching data from BCB: {e}. Returning empty DataFrame.\"\n        )\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_monthly_trades","title":"<code>tpf_monthly_trades(target_date, extragroup=False)</code>","text":"<p>Fetches monthly secondary trading data for the domestic 'Federal Public Debt' (TPF - t\u00edtulos p\u00fablicos federais) registered in the Brazilian Central Bank (BCB) Selic system.</p> <p>Downloads the monthly bond trading data from the Brazilian Central Bank (BCB) website for the month corresponding to the provided date. The data is downloaded as a ZIP file, extracted, and loaded into a Pandas DataFrame. The data contains all trades executed during the month, separated by each 'SettlementDate'.</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>DateScalar</code> <p>The date for which the monthly trading data will be fetched. This date can be a string, datetime, or pandas Timestamp object. It will be converted to a date object. Only the year and month of this date will be used to download the corresponding monthly file.</p> required <code>extragroup</code> <code>bool</code> <p>If True, fetches only the trades that are considered 'extragroup' (between different economic groups)\". If False, fetches all trades. Default is False. Extragroup trades are those where the transferring counterparty's conglomerate is different from the receiving counterparty's conglomerate, or when at least one of the counterparties does not belong to a conglomerate. In the case of funds, the conglomerate considered is that of the administrator.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the bond trading data for the specified month.</p> DataFrame columns <ul> <li>SettlementDate: Date when the trade settled</li> <li>BondType: Security type abbreviation</li> <li>SelicCode: Unique code in the SELIC system</li> <li>ISIN: International Securities Identification Number</li> <li>IssueDate: Date when the security was issued</li> <li>MaturityDate: Security's maturity date</li> <li>Trades: Number of trades executed</li> <li>Quantity: Quantity traded</li> <li>Value: Value traded</li> <li>AvgPrice: Average price</li> <li>AvgRate: Average rate And additional trading metrics like min/max prices and rates.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Fetches all trades for Jan/2025\n&gt;&gt;&gt; bc.tpf_monthly_trades(\"07-01-2025\", extragroup=True)\nshape: (1_019, 19)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SettlementDate \u2506 BondType \u2506 SelicCode \u2506 ISIN         \u2506 \u2026 \u2506 AvgRate \u2506 MaxRate \u2506 BrokerageTrades \u2506 BrokerageQuantity \u2502\n\u2502 ---            \u2506 ---      \u2506 ---       \u2506 ---          \u2506   \u2506 ---     \u2506 ---     \u2506 ---             \u2506 ---               \u2502\n\u2502 date           \u2506 str      \u2506 i64       \u2506 str          \u2506   \u2506 f64     \u2506 f64     \u2506 i64             \u2506 i64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RC4 \u2506 \u2026 \u2506 0.0132  \u2506 0.0906  \u2506 2               \u2506 9581              \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RD2 \u2506 \u2026 \u2506 0.0561  \u2506 0.101   \u2506 11              \u2506 42823             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RE0 \u2506 \u2026 \u2506 0.0191  \u2506 0.0405  \u2506 19              \u2506 33330             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RF7 \u2506 \u2026 \u2506 0.0304  \u2506 0.05    \u2506 10              \u2506 14583             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RG5 \u2506 \u2026 \u2506 0.0697  \u2506 0.0935  \u2506 12              \u2506 51776             \u2502\n\u2502 \u2026              \u2506 \u2026        \u2506 \u2026         \u2506 \u2026            \u2506 \u2026 \u2506 \u2026       \u2506 \u2026       \u2506 \u2026               \u2506 \u2026                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1P8 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1Q6 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF204 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 12              \u2506 570000            \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF212 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF238 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 4               \u2506 115000            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/trades_monthly.py</code> <pre><code>def tpf_monthly_trades(\n    target_date: DateScalar, extragroup: bool = False\n) -&gt; pl.DataFrame:\n    \"\"\"Fetches monthly secondary trading data for the domestic 'Federal Public Debt'\n    (TPF - t\u00edtulos p\u00fablicos federais) registered in the Brazilian Central Bank (BCB)\n    Selic system.\n\n    Downloads the monthly bond trading data from the Brazilian Central Bank (BCB)\n    website for the month corresponding to the provided date. The data is downloaded\n    as a ZIP file, extracted, and loaded into a Pandas DataFrame. The data contains\n    all trades executed during the month, separated by each 'SettlementDate'.\n\n    Args:\n        target_date (DateScalar): The date for which the monthly trading data will be\n            fetched. This date can be a string, datetime, or pandas Timestamp object.\n            It will be converted to a date object. Only the year and month\n            of this date will be used to download the corresponding monthly file.\n        extragroup (bool): If True, fetches only the trades that are considered\n            'extragroup' (between different economic groups)\".\n            If False, fetches all trades. Default is False.\n            Extragroup trades are those where the transferring counterparty's\n            conglomerate is different from the receiving counterparty's conglomerate, or\n            when at least one of the counterparties does not belong to a conglomerate.\n            In the case of funds, the conglomerate considered is that of the\n            administrator.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the bond trading data for the specified\n            month.\n\n    DataFrame columns:\n        - SettlementDate: Date when the trade settled\n        - BondType: Security type abbreviation\n        - SelicCode: Unique code in the SELIC system\n        - ISIN: International Securities Identification Number\n        - IssueDate: Date when the security was issued\n        - MaturityDate: Security's maturity date\n        - Trades: Number of trades executed\n        - Quantity: Quantity traded\n        - Value: Value traded\n        - AvgPrice: Average price\n        - AvgRate: Average rate\n        And additional trading metrics like min/max prices and rates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Fetches all trades for Jan/2025\n        &gt;&gt;&gt; bc.tpf_monthly_trades(\"07-01-2025\", extragroup=True)\n        shape: (1_019, 19)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 SettlementDate \u2506 BondType \u2506 SelicCode \u2506 ISIN         \u2506 \u2026 \u2506 AvgRate \u2506 MaxRate \u2506 BrokerageTrades \u2506 BrokerageQuantity \u2502\n        \u2502 ---            \u2506 ---      \u2506 ---       \u2506 ---          \u2506   \u2506 ---     \u2506 ---     \u2506 ---             \u2506 ---               \u2502\n        \u2502 date           \u2506 str      \u2506 i64       \u2506 str          \u2506   \u2506 f64     \u2506 f64     \u2506 i64             \u2506 i64               \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RC4 \u2506 \u2026 \u2506 0.0132  \u2506 0.0906  \u2506 2               \u2506 9581              \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RD2 \u2506 \u2026 \u2506 0.0561  \u2506 0.101   \u2506 11              \u2506 42823             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RE0 \u2506 \u2026 \u2506 0.0191  \u2506 0.0405  \u2506 19              \u2506 33330             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RF7 \u2506 \u2026 \u2506 0.0304  \u2506 0.05    \u2506 10              \u2506 14583             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RG5 \u2506 \u2026 \u2506 0.0697  \u2506 0.0935  \u2506 12              \u2506 51776             \u2502\n        \u2502 \u2026              \u2506 \u2026        \u2506 \u2026         \u2506 \u2026            \u2506 \u2026 \u2506 \u2026       \u2506 \u2026       \u2506 \u2026               \u2506 \u2026                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1P8 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1Q6 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF204 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 12              \u2506 570000            \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF212 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF238 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 4               \u2506 115000            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if has_null_args(target_date):\n        logger.warning(\"No target_date provided. Returning an empty DataFrame.\")\n        return pl.DataFrame()\n    try:\n        target_date = convert_dates(target_date)\n        url = _build_file_url(target_date, extragroup)\n        zip_content = _fetch_zip_from_url(url)\n        extracted_file = _uncompress_zip(zip_content)\n        df = _read_dataframe_from_zip(extracted_file)\n        df = _process_df(df)\n\n    except HTTPError as e:\n        if e.response.status_code == 404:  # noqa\n            msg = f\"Resource not found (404) at {url}. Returning an empty DataFrame.\"\n            logger.warning(msg)\n            return pl.DataFrame()\n        else:\n            # Captures the full traceback for unexpected HTTP errors\n            msg = f\"Unexpected HTTP error ({e.code}) while accessing URL: {url}\"\n            logger.exception(msg)\n            raise e\n\n    except Exception:\n        # Captures the full traceback for any other errors\n        msg = f\"An unexpected error occurred while processing data from {url}.\"\n        logger.exception(msg)\n        raise\n\n    # LOG DE SUCESSO\n    msg = f\"Successfully processed data from {url}. Found {len(df)} records.\"\n    logger.info(msg)\n\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.vna_lft","title":"<code>vna_lft(date)</code>","text":"<p>Retrieves the VNA (Valor Nominal Atualizado) from the BCB for a given date.</p> <p>This function fetches daily data from the BCB website, extracts the VNA value from a specific table within the downloaded content, and returns this value.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The date for which to retrieve the VNA value. This argument accepts various date formats, including string and datetime objects, which are then standardized using the <code>convert_input_dates</code> function.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The VNA (Valor Nominal Atualizado) value for the specified date, or None if the date is invalid or data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n14903.01148\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the extracted VNA values from the BCB website are inconsistent (i.e., not all extracted values are identical), suggesting potential data discrepancies on the source website. The error message includes a link to the BCB website for manual verification.</p> <code>HTTPError</code> <p>If the HTTP request to the BCB website fails. This could be due to network issues, website unavailability, or the requested data not being found for the given date.</p> Source code in <code>pyield/bc/vna.py</code> <pre><code>def vna_lft(date: DateScalar) -&gt; float | None:\n    \"\"\"Retrieves the VNA (Valor Nominal Atualizado) from the BCB for a given date.\n\n    This function fetches daily data from the BCB website, extracts the\n    VNA value from a specific table within the downloaded content, and\n    returns this value.\n\n    Args:\n        date (DateScalar): The date for which to retrieve the VNA value.\n            This argument accepts various date formats, including string and\n            datetime objects, which are then standardized using the\n            `convert_input_dates` function.\n\n    Returns:\n        float | None: The VNA (Valor Nominal Atualizado) value for the specified date,\n            or None if the date is invalid or data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n        14903.01148\n\n    Raises:\n        ValueError: If the extracted VNA values from the BCB website are\n            inconsistent (i.e., not all extracted values are identical),\n            suggesting potential data discrepancies on the source website.\n            The error message includes a link to the BCB website for manual\n            verification.\n        requests.exceptions.HTTPError: If the HTTP request to the BCB website\n            fails. This could be due to network issues, website unavailability,\n            or the requested data not being found for the given date.\n    \"\"\"\n    if has_null_args(date):\n        logger.warning(\"No valid date provided. Returning NaN.\")\n        return None\n    text = _get_text(date)\n    table_text = _extract_vna_table_text(text)\n    table_lines = _parse_vna_table_lines(table_text)\n    vnas = _extract_vna_values_from_lines(table_lines)\n    vna_value = _validate_vna_values(vnas)\n    return vna_value\n</code></pre>"},{"location":"bday/","title":"Business Day Tools","text":""},{"location":"bday/#pyield.bday.count","title":"<code>count(start, end)</code>","text":"<p>Counts the number of business days between a <code>start</code> date (inclusive) and an <code>end</code> date (exclusive). The function can handle single dates, arrays of dates and mixed inputs, returning either a single integer or a series of integers depending on the inputs. It accounts for specified holidays, effectively excluding them from the business day count.</p> <p>Important Note: Each date in the <code>start</code> input is evaluated individually to determine which list of holidays (old or new) applies to the calculation. The transition date is 2023-12-26, which means: - Dates before 2023-12-26 use the old holiday list. - Dates on or after 2023-12-26 use the new holiday list.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | DateArray</code> <p>The start date(s) for counting (inclusive). Transition Handling: The holiday list used for the entire counting period between <code>start</code> and <code>end</code> is determined solely by the <code>start</code> date's relation to the holiday transition date (2023-12-26). If <code>start</code> is before this date, the old holiday list is used for the whole count, even if <code>end</code> is after it. If <code>start</code> is on or after this date, new holiday list is used.</p> required <code>end</code> <code>DateScalar | DateArray</code> <p>The end date(s) for counting (exclusive).</p> required <p>Returns:</p> Type Description <code>int | Series | None</code> <p>int | pl.Series | None: Returns an integer or None if <code>start</code> and <code>end</code> are single dates, or a Series if any of them is an array of dates.</p> Notes <ul> <li>This function is a wrapper around <code>numpy.busday_count</code>, adapted to work     directly with various Pandas and Numpy date formats.</li> <li>It supports flexible date inputs, including single dates, lists, Series, and     more, for both <code>start</code> and <code>end</code> parameters.</li> <li>The return type depends on the input types: single dates return an int, while     arrays of dates return a pl.Series with the count for each date range.</li> <li>The <code>start</code> date determines the holiday list, ensuring consistency with the     applicable calendar at the time.</li> <li>See <code>numpy.busday_count</code> documentation for more details on how holidays are     handled and how business day counts are calculated:     https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n10\n</code></pre> <p>Total business days in January and February since the start of the year</p> <pre><code>&gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\nshape: (2,)\nSeries: 'bdays' [i64]\n[\n    22\n    41\n]\n</code></pre> <p>The remaining business days from January/February until the end of the year</p> <pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\nshape: (2,)\nSeries: 'bdays' [i64]\n[\n    253\n    231\n]\n</code></pre> <p>The total business days in January and February of 2024</p> <pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\nshape: (2,)\nSeries: 'bdays' [i64]\n[\n    22\n    19\n]\n</code></pre> <p>Null values are propagated</p> <pre><code>&gt;&gt;&gt; bday.count(None, \"01-01-2024\")  # None start\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"01-01-2024\", None)  # None end\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"01-01-2024\", [\"01-02-2024\", None])  # None in end array\nshape: (2,)\nSeries: 'bdays' [i64]\n[\n    22\n    null\n]\n</code></pre> <pre><code>&gt;&gt;&gt; start_dates = [\"01-01-2024\", \"01-02-2024\", \"01-03-2024\"]\n&gt;&gt;&gt; bday.count(start_dates, \"01-01-2025\")\nshape: (3,)\nSeries: 'bdays' [i64]\n[\n    253\n    231\n    212\n]\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def count(\n    start: DateScalar | DateArray,\n    end: DateScalar | DateArray,\n) -&gt; int | pl.Series | None:\n    \"\"\"\n    Counts the number of business days between a `start` date (inclusive) and an `end`\n    date (exclusive). The function can handle single dates, arrays of dates and\n    mixed inputs, returning either a single integer or a series of integers depending\n    on the inputs. It accounts for specified holidays, effectively excluding them from\n    the business day count.\n\n    **Important Note:** Each date in the `start` input is evaluated individually to\n    determine which list of holidays (old or new) applies to the calculation. The\n    transition date is 2023-12-26, which means:\n    - Dates before 2023-12-26 use the old holiday list.\n    - Dates on or after 2023-12-26 use the new holiday list.\n\n    Args:\n        start (DateScalar | DateArray): The start date(s) for counting (inclusive).\n            **Transition Handling:** The holiday list used for the *entire* counting\n            period between `start` and `end` is determined solely by the `start` date's\n            relation to the holiday transition date (2023-12-26). If `start` is before\n            this date, the old holiday list is used for the whole count, even if `end`\n            is after it. If `start` is on or after this date, new holiday list is used.\n        end (DateScalar | DateArray): The end date(s) for counting (exclusive).\n\n    Returns:\n        int | pl.Series | None: Returns an integer or None if `start` and `end` are\n            single dates, or a Series if any of them is an array of dates.\n\n    Notes:\n        - This function is a wrapper around `numpy.busday_count`, adapted to work\n            directly with various Pandas and Numpy date formats.\n        - It supports flexible date inputs, including single dates, lists, Series, and\n            more, for both `start` and `end` parameters.\n        - The return type depends on the input types: single dates return an int, while\n            arrays of dates return a pl.Series with the count for each date range.\n        - The `start` date determines the holiday list, ensuring consistency with the\n            applicable calendar at the time.\n        - See `numpy.busday_count` documentation for more details on how holidays are\n            handled and how business day counts are calculated:\n            https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n        10\n\n        Total business days in January and February since the start of the year\n        &gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n        shape: (2,)\n        Series: 'bdays' [i64]\n        [\n            22\n            41\n        ]\n\n        The remaining business days from January/February until the end of the year\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n        shape: (2,)\n        Series: 'bdays' [i64]\n        [\n            253\n            231\n        ]\n\n        The total business days in January and February of 2024\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n        shape: (2,)\n        Series: 'bdays' [i64]\n        [\n            22\n            19\n        ]\n\n        Null values are propagated\n        &gt;&gt;&gt; bday.count(None, \"01-01-2024\")  # None start\n\n        &gt;&gt;&gt; bday.count(\"01-01-2024\", None)  # None end\n\n        &gt;&gt;&gt; bday.count(\"01-01-2024\", [\"01-02-2024\", None])  # None in end array\n        shape: (2,)\n        Series: 'bdays' [i64]\n        [\n            22\n            null\n        ]\n\n        &gt;&gt;&gt; start_dates = [\"01-01-2024\", \"01-02-2024\", \"01-03-2024\"]\n        &gt;&gt;&gt; bday.count(start_dates, \"01-01-2025\")\n        shape: (3,)\n        Series: 'bdays' [i64]\n        [\n            253\n            231\n            212\n        ]\n    \"\"\"\n    # Validate and normalize inputs\n    if has_null_args(start, end):\n        return None\n    start_pl = cv.convert_dates(start)\n    end_pl = cv.convert_dates(end)\n\n    # Coloca as s\u00e9ries em um DataFrame para trabalhar com express\u00f5es em colunas\n    df = pl.DataFrame(\n        {\"start\": start_pl, \"end\": end_pl},\n        schema={\"start\": pl.Date, \"end\": pl.Date},\n        nan_to_null=True,\n    )\n\n    result_expr = (\n        pl.when(pl.col(\"start\") &lt; TRANSITION_DATE)\n        .then(\n            pl.business_day_count(\n                start=pl.col(\"start\"), end=pl.col(\"end\"), holidays=OLD_HOLIDAYS_ARRAY\n            ),\n        )\n        .otherwise(\n            pl.business_day_count(\n                start=pl.col(\"start\"), end=pl.col(\"end\"), holidays=NEW_HOLIDAYS_ARRAY\n            )\n        )\n        .cast(pl.Int64)\n    )\n\n    s_bdays = df.select(result_expr.alias(\"bdays\"))[\"bdays\"]\n\n    # Se a entrada original era escalar, retorna o valor escalar\n    if len(s_bdays) == 1:\n        return s_bdays.item()\n\n    return s_bdays\n</code></pre>"},{"location":"bday/#pyield.bday.generate","title":"<code>generate(start=None, end=None, inclusive='both', holiday_option='new')</code>","text":"<p>Generates a Series of business days between a <code>start</code> and <code>end</code> date, considering the list of Brazilian holidays. It supports customization of holiday lists and inclusion options for start and end dates. It wraps <code>pandas.bdate_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | None</code> <p>The start date for generating the dates.  If None, the current date is used. Defaults to None.</p> <code>None</code> <code>end</code> <code>DateScalar | None</code> <p>The end date for generating business days. If None, the current date is used. Defaults to None.</p> <code>None</code> <code>inclusive</code> <code>Literal['both', 'neither', 'left', 'right']</code> <p>Determines which of the start and end dates are included in the result. Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.</p> <code>'both'</code> <code>holiday_option</code> <code>Literal['old', 'new', 'infer']</code> <p>Specifies the list of holidays to consider. Defaults to \"new\". - 'old': Uses the holiday list effective before the transition date of 2023-12-26. - 'new': Uses the holiday list effective on and after the transition date of 2023-12-26. - 'infer': Automatically selects the holiday list ('old' or 'new') based on the <code>start</code> date relative to the transition date (2023-12-26). If <code>start</code> is before the transition, 'old' is used; otherwise, 'new' is used.</p> <code>'new'</code> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series representing a range of business days between the specified start and end dates, considering the specified holidays.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\nshape: (6,)\nSeries: '' [date]\n[\n    2023-12-22\n    2023-12-26\n    2023-12-27\n    2023-12-28\n    2023-12-29\n    2024-01-02\n]\n</code></pre> Note <p>For detailed information on parameters and error handling, refer to <code>pandas.bdate_range</code> documentation: https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.</p> Source code in <code>pyield/bday/core.py</code> <pre><code>def generate(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n    inclusive: Literal[\"both\", \"neither\", \"left\", \"right\"] = \"both\",\n    holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"new\",\n) -&gt; pl.Series:\n    \"\"\"\n    Generates a Series of business days between a `start` and `end` date, considering\n    the list of Brazilian holidays. It supports customization of holiday lists and\n    inclusion options for start and end dates. It wraps `pandas.bdate_range`.\n\n    Args:\n        start (DateScalar | None, optional): The start date for generating the dates.\n             If None, the current date is used. Defaults to None.\n        end (DateScalar | None, optional): The end date for generating business days.\n            If None, the current date is used. Defaults to None.\n        inclusive (Literal[\"both\", \"neither\", \"left\", \"right\"], optional):\n            Determines which of the start and end dates are included in the result.\n            Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.\n        holiday_option (Literal[\"old\", \"new\", \"infer\"], optional):\n            Specifies the list of holidays to consider. Defaults to \"new\".\n            - **'old'**: Uses the holiday list effective *before* the transition date\n            of 2023-12-26.\n            - **'new'**: Uses the holiday list effective *on and after* the transition\n            date of 2023-12-26.\n            - **'infer'**: Automatically selects the holiday list ('old' or 'new') based\n            on the `start` date relative to the transition date (2023-12-26). If `start`\n            is before the transition, 'old' is used; otherwise, 'new' is used.\n\n    Returns:\n        pl.Series: A Series representing a range of business days between the specified\n            start and end dates, considering the specified holidays.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n        shape: (6,)\n        Series: '' [date]\n        [\n            2023-12-22\n            2023-12-26\n            2023-12-27\n            2023-12-28\n            2023-12-29\n            2024-01-02\n        ]\n\n    Note:\n        For detailed information on parameters and error handling, refer to\n        `pandas.bdate_range` documentation:\n        https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.\n    \"\"\"\n    if start:\n        start_pd = cv.convert_dates(start)\n    else:\n        start_pd = dt.datetime.now(TIMEZONE_BZ).date()\n\n    if end:\n        end_pd = cv.convert_dates(end)\n    else:\n        end_pd = dt.datetime.now(TIMEZONE_BZ).date()\n\n    applicable_holidays = br_holidays.get_holiday_series(\n        dates=start_pd, holiday_option=holiday_option\n    ).to_list()\n\n    # Get the result as a DatetimeIndex (dti)\n    result_dti = pd.bdate_range(\n        start=start_pd,\n        end=end_pd,\n        freq=\"C\",\n        inclusive=inclusive,\n        holidays=applicable_holidays,\n    )\n    s_pd = pd.Series(result_dti.values).astype(\"date32[pyarrow]\")\n    return pl.Series(s_pd)\n</code></pre>"},{"location":"bday/#pyield.bday.is_business_day","title":"<code>is_business_day(dates)</code>","text":"<p>Check if date(s) are business day(s) in Brazil.</p> <p>This function applies the correct holiday list (old vs. new) for EACH date relative to the transition date <code>2023-12-26</code>. Dates before the transition use the old holiday list; dates on/after the transition use the new holiday list.</p> <p>Behavior mirrors other functions in this module: if the resulting length is 1 (even if the user passed a single-element collection) a Python <code>bool</code> (or <code>None</code> for null input) is returned; otherwise a <code>polars.Series</code> of booleans is returned with nulls propagated.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar | DateArray</code> <p>A single date or a collection of dates (scalar, list/tuple/Series, numpy array, Polars/Pandas Series). Null scalar inputs return <code>None</code>.</p> required <p>Returns:</p> Type Description <code>bool | Series | None</code> <p>bool | pl.Series | None: <code>True</code> if business day, <code>False</code> if not, <code>None</code></p> <code>bool | Series | None</code> <p>for null scalar input, or a Polars boolean Series for array inputs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas (old calendar)\nFalse\n&gt;&gt;&gt; bday.is_business_day(\"20-11-2024\")  # National Zumbi Day (new holiday)\nFalse\n&gt;&gt;&gt; bday.is_business_day([\"22-12-2023\", \"26-12-2023\"])  # Mixed periods\nshape: (2,)\nSeries: 'is_bday' [bool]\n[\n    true\n    true\n]\n</code></pre> Notes <ul> <li>The transition date is defined in <code>TRANSITION_DATE</code>.</li> <li>Null elements in array inputs propagate as nulls.</li> <li>Weekends are never business days.</li> </ul> Source code in <code>pyield/bday/core.py</code> <pre><code>def is_business_day(dates: DateScalar | DateArray) -&gt; bool | pl.Series | None:\n    \"\"\"Check if date(s) are business day(s) in Brazil.\n\n    This function applies the correct holiday list (old vs. new) for EACH date\n    relative to the transition date ``2023-12-26``. Dates before the transition\n    use the *old* holiday list; dates on/after the transition use the *new*\n    holiday list.\n\n    Behavior mirrors other functions in this module: if the resulting length is 1\n    (even if the user passed a single-element collection) a Python ``bool`` (or\n    ``None`` for null input) is returned; otherwise a ``polars.Series`` of booleans\n    is returned with nulls propagated.\n\n    Args:\n        dates: A single date or a collection of dates (scalar, list/tuple/Series,\n            numpy array, Polars/Pandas Series). Null scalar inputs return ``None``.\n\n    Returns:\n        bool | pl.Series | None: ``True`` if business day, ``False`` if not, ``None``\n        for null scalar input, or a Polars boolean Series for array inputs.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas (old calendar)\n        False\n        &gt;&gt;&gt; bday.is_business_day(\"20-11-2024\")  # National Zumbi Day (new holiday)\n        False\n        &gt;&gt;&gt; bday.is_business_day([\"22-12-2023\", \"26-12-2023\"])  # Mixed periods\n        shape: (2,)\n        Series: 'is_bday' [bool]\n        [\n            true\n            true\n        ]\n\n    Notes:\n        - The transition date is defined in ``TRANSITION_DATE``.\n        - Null elements in array inputs propagate as nulls.\n        - Weekends are never business days.\n    \"\"\"\n    # Validate and normalize inputs\n    if has_null_args(dates):\n        return None\n    converted = cv.convert_dates(dates)\n\n    # Build DataFrame to allow conditional expression selecting the right holiday list\n    df = pl.DataFrame({\"dates\": converted}, schema={\"dates\": pl.Date}, nan_to_null=True)\n\n    result_expr = (\n        pl.when(pl.col(\"dates\") &lt; TRANSITION_DATE)\n        .then(\n            pl.col(\"dates\").dt.is_business_day(holidays=OLD_HOLIDAYS_ARRAY),\n        )\n        .otherwise(\n            pl.col(\"dates\").dt.is_business_day(holidays=NEW_HOLIDAYS_ARRAY),\n        )\n    )\n\n    s_result = df.select(result_expr.alias(\"is_bday\"))[\"is_bday\"]\n\n    if len(s_result) == 1:\n        return s_result.item()\n\n    return s_result\n</code></pre>"},{"location":"bday/#pyield.bday.last_business_day","title":"<code>last_business_day()</code>","text":"<p>Returns the last business day in Brazil. If the current date is a business day, it returns the current date. If it is a weekend or holiday, it returns the last business day before the current date.</p> <p>Returns:</p> Type Description <code>date</code> <p>dt.date: The last business day in Brazil.</p> Notes <ul> <li>The determination of the last business day considers the correct Brazilian holiday list (before or after the 2023-12-26 transition) applicable to the current date.</li> </ul> Source code in <code>pyield/bday/core.py</code> <pre><code>def last_business_day() -&gt; dt.date:\n    \"\"\"\n    Returns the last business day in Brazil. If the current date is a business day, it\n    returns the current date. If it is a weekend or holiday, it returns the last\n    business day before the current date.\n\n    Returns:\n        dt.date: The last business day in Brazil.\n\n    Notes:\n        - The determination of the last business day considers the correct Brazilian\n        holiday list (before or after the 2023-12-26 transition) applicable to\n        the current date.\n\n    \"\"\"\n    # Get the current date in Brazil without timezone information\n    bz_today = dt.datetime.now(TIMEZONE_BZ).date()\n    result = offset(bz_today, 0, roll=\"backward\")\n    assert isinstance(result, dt.date), (\n        \"Assumption violated: offset did not return a date for the current date.\"\n    )\n    return result\n</code></pre>"},{"location":"bday/#pyield.bday.offset","title":"<code>offset(dates, offset, roll='forward')</code>","text":"<p>First adjusts the date to fall on a valid day according to the roll rule, then applies offsets to the given dates to the next or previous business day, considering brazilian holidays. This function supports both single dates and collections of dates. It is a wrapper for <code>polars.Expr.dt.add_business_days</code>.</p> <p>Important Note: Each date in the <code>dates</code> input is evaluated individually to determine which list of holidays applies to the calculation. Transition date is 2023-12-26, which means: - Dates before 2023-12-26 use the old holiday list. - Dates on or after 2023-12-26 use the new holiday list.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar | DateArray</code> <p>The date(s) to offset. Can be a scalar date type or a collection of dates. Transition Handling: Due to a change in Brazilian national holidays effective from 2023-12-26 (<code>TRANSITION_DATE</code>), this function automatically selects the appropriate holiday list (old or new) based on each individual date in the <code>dates</code> input. Dates before 2023-12-26 use the old list for their offset calculation, while dates on or after 2023-12-26 use the new list.</p> required <code>offset</code> <code>int | Series | ndarray | list[int] | tuple[int]</code> <p>The number of business days to offset the dates. Positive for future dates, negative for past dates. Zero will return the same date if it's a business day, or the next/previous business day otherwise, according to <code>roll</code>.</p> required <code>roll</code> <code>Literal['forward', 'backward']</code> <p>Direction to roll the date if it falls on a holiday or weekend. 'forward' to the next business day, 'backward' to the previous. Defaults to 'forward'.</p> <code>'forward'</code> <p>Returns:</p> Type Description <code>date | Series | None</code> <p>dt.date | pl.Series | None: If a single date is provided, returns a single <code>date</code> of the offset date or None. If a series of dates is provided, returns a <code>polars.Series</code> of offset dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n</code></pre> <p>Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\ndatetime.date(2023, 12, 26)\n</code></pre> <p>Offset Friday before Christmas (no offset because it's a business day)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")</p> <p>No offset because it's a business day</p> <pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Offset to the first business day before \"23-12-2023\"</p> <pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Jump to the next business day (1 offset and roll=\"forward\")</p> <p>Offset Friday to the next business day (Friday is jumped -&gt; Monday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\ndatetime.date(2024, 9, 30)\n</code></pre> <p>Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\ndatetime.date(2024, 10, 1)\n</code></pre> <p>Jump to the previous business day (-1 offset and roll=\"backward\")</p> <p>Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\ndatetime.date(2024, 9, 26)\n</code></pre> <p>Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)</p> <pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\ndatetime.date(2024, 9, 26)\n</code></pre>"},{"location":"bday/#pyield.bday.offset--list-of-dates-and-offsets","title":"List of dates and offsets","text":"<pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)\nshape: (2,)\nSeries: 'result' [date]\n[\n    2024-09-20\n    2024-09-23\n]\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\nshape: (2,)\nSeries: 'result' [date]\n[\n    2024-09-20\n    2024-09-23\n]\n</code></pre>"},{"location":"bday/#pyield.bday.offset--null-values-are-propagated","title":"Null values are propagated","text":"<pre><code>&gt;&gt;&gt; print(bday.offset(None, 1))\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; print(bday.offset(None, [1, 2]))\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", None], 1)\nshape: (2,)\nSeries: 'result' [date]\n[\n    2024-09-20\n    null\n]\n</code></pre> <pre><code>&gt;&gt;&gt; dates = [\"19-09-2024\", \"20-09-2024\", \"21-09-2024\"]\n&gt;&gt;&gt; bday.offset(dates, 1)\nshape: (3,)\nSeries: 'result' [date]\n[\n    2024-09-20\n    2024-09-23\n    2024-09-24\n]\n</code></pre> Note <p>This function uses <code>polars.Expr.dt.add_business_days</code> under the hood. For detailed information, refer to the Polars documentation.</p> Source code in <code>pyield/bday/core.py</code> <pre><code>def offset(\n    dates: DateScalar | DateArray,\n    offset: IntegerScalar | IntegerArray,\n    roll: Literal[\"forward\", \"backward\"] = \"forward\",\n) -&gt; dt.date | pl.Series | None:\n    \"\"\"\n    First adjusts the date to fall on a valid day according to the roll rule, then\n    applies offsets to the given dates to the next or previous business day, considering\n    brazilian holidays. This function supports both single dates and collections of\n    dates. It is a wrapper for `polars.Expr.dt.add_business_days`.\n\n    **Important Note:** Each date in the `dates` input is evaluated individually to\n    determine which list of holidays applies to the calculation. Transition date\n    is 2023-12-26, which means:\n    - Dates before 2023-12-26 use the old holiday list.\n    - Dates on or after 2023-12-26 use the new holiday list.\n\n    Args:\n        dates (DateScalar | DateArray): The date(s) to offset. Can be a scalar date type\n            or a collection of dates. **Transition Handling:** Due to a change in\n            Brazilian national holidays effective from 2023-12-26 (`TRANSITION_DATE`),\n            this function automatically selects the appropriate holiday list\n            (old or new) based on **each individual date** in the `dates` input.\n            Dates before 2023-12-26 use the old list for their offset calculation,\n            while dates on or after 2023-12-26 use the new list.\n        offset (int | Series | np.ndarray | list[int] | tuple[int], optional):\n            The number of business days to offset the dates. Positive for future dates,\n            negative for past dates. Zero will return the same date if it's a business\n            day, or the next/previous business day otherwise, according to `roll`.\n        roll (Literal[\"forward\", \"backward\"], optional): Direction to roll the date if\n            it falls on a holiday or weekend. 'forward' to the next business day,\n            'backward' to the previous. Defaults to 'forward'.\n\n    Returns:\n        dt.date | pl.Series | None: If a single date is provided, returns a single\n            `date` of the offset date or None. If a series of dates is provided, returns\n            a `polars.Series` of offset dates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n\n        Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\n        datetime.date(2023, 12, 26)\n\n        Offset Friday before Christmas (no offset because it's a business day)\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\n        datetime.date(2023, 12, 22)\n\n        Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")\n\n        No offset because it's a business day\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\n        datetime.date(2023, 12, 22)\n\n        Offset to the first business day before \"23-12-2023\"\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\n        datetime.date(2023, 12, 22)\n\n        Jump to the next business day (1 offset and roll=\"forward\")\n\n        Offset Friday to the next business day (Friday is jumped -&gt; Monday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\n        datetime.date(2024, 9, 30)\n\n        Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\n        datetime.date(2024, 10, 1)\n\n        Jump to the previous business day (-1 offset and roll=\"backward\")\n\n        Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\n        datetime.date(2024, 9, 26)\n\n        Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\n        datetime.date(2024, 9, 26)\n\n        # List of dates and offsets\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)\n        shape: (2,)\n        Series: 'result' [date]\n        [\n            2024-09-20\n            2024-09-23\n        ]\n\n        &gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\n        shape: (2,)\n        Series: 'result' [date]\n        [\n            2024-09-20\n            2024-09-23\n        ]\n\n        # Null values are propagated\n        &gt;&gt;&gt; print(bday.offset(None, 1))\n        None\n\n        &gt;&gt;&gt; print(bday.offset(None, [1, 2]))\n        None\n\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", None], 1)\n        shape: (2,)\n        Series: 'result' [date]\n        [\n            2024-09-20\n            null\n        ]\n\n        &gt;&gt;&gt; dates = [\"19-09-2024\", \"20-09-2024\", \"21-09-2024\"]\n        &gt;&gt;&gt; bday.offset(dates, 1)\n        shape: (3,)\n        Series: 'result' [date]\n        [\n            2024-09-20\n            2024-09-23\n            2024-09-24\n        ]\n\n    Note:\n        This function uses `polars.Expr.dt.add_business_days` under the hood. For\n        detailed information, refer to the Polars documentation.\n    \"\"\"\n    # Validate and normalize inputs\n    if has_null_args(dates, offset):\n        return None\n    dates_pl = cv.convert_dates(dates)\n\n    # Coloca as entradas em um DataFrame para trabalhar com express\u00f5es em colunas\n    df = pl.DataFrame(\n        {\"dates\": dates_pl, \"offset\": offset},\n        schema={\"dates\": pl.Date, \"offset\": pl.Int64},\n        nan_to_null=True,\n    )\n\n    # Cria a express\u00e3o condicional para aplicar a lista de feriados correta\n    result_expr = (\n        pl.when(pl.col(\"dates\") &lt; TRANSITION_DATE)\n        .then(\n            pl.col(\"dates\").dt.add_business_days(\n                n=pl.col(\"offset\"),\n                roll=roll,\n                holidays=OLD_HOLIDAYS_ARRAY,\n            )\n        )\n        .otherwise(\n            pl.col(\"dates\").dt.add_business_days(\n                n=pl.col(\"offset\"),\n                roll=roll,\n                holidays=NEW_HOLIDAYS_ARRAY,\n            )\n        )\n    )\n\n    # Executa a express\u00e3o e obt\u00e9m a s\u00e9rie de resultados\n    result_series = df.select(result_expr.alias(\"result\"))[\"result\"]\n\n    # Se a entrada original era escalar, retorna o valor escalar\n    if len(result_series) == 1:\n        return result_series.item()\n\n    return result_series\n</code></pre>"},{"location":"di1/","title":"DI Futures Data","text":""},{"location":"di1/#pyield.b3.di1.available_trade_dates","title":"<code>available_trade_dates()</code>","text":"<p>Returns all available (completed) trading dates in the DI dataset.</p> <p>Retrieves distinct 'TradeDate' values present in the historical DI futures data cache, sorted chronologically.</p> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A sorted Series of unique trade dates (dt.date) for which DI data is available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # DI Futures series starts from 1995-01-02\n&gt;&gt;&gt; di1.available_trade_dates().head(5)\nshape: (5,)\nSeries: 'available_dates' [date]\n[\n    1995-01-02\n    1995-01-03\n    1995-01-04\n    1995-01-05\n    1995-01-06\n]\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def available_trade_dates() -&gt; pl.Series:\n    \"\"\"\n    Returns all available (completed) trading dates in the DI dataset.\n\n    Retrieves distinct 'TradeDate' values present in the\n    historical DI futures data cache, sorted chronologically.\n\n    Returns:\n        pl.Series: A sorted Series of unique trade dates (dt.date)\n            for which DI data is available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # DI Futures series starts from 1995-01-02\n        &gt;&gt;&gt; di1.available_trade_dates().head(5)\n        shape: (5,)\n        Series: 'available_dates' [date]\n        [\n            1995-01-02\n            1995-01-03\n            1995-01-04\n            1995-01-05\n            1995-01-06\n        ]\n    \"\"\"\n    available_dates = (\n        get_cached_dataset(\"di1\")\n        .get_column(\"TradeDate\")\n        .unique()\n        .sort()\n        .alias(\"available_dates\")\n    )\n    return available_dates\n</code></pre>"},{"location":"di1/#pyield.b3.di1.data","title":"<code>data(dates, month_start=False, pre_filter=False)</code>","text":"<p>Retrieves DI Futures contract data for a specific trade date.</p> <p>Provides access to DI futures data, allowing adjustments to expiration dates (to month start) and optional filtering based on LTN and NTN-F bond maturities.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar</code> <p>The trade dates for which to retrieve DI contract data.</p> required <code>month_start</code> <code>bool</code> <p>If True, adjusts all expiration dates to the first day of their respective month (e.g., 2025-02-01 becomes 2025-01-01). Defaults to False.</p> <code>False</code> <code>pre_filter</code> <code>bool</code> <p>If True, filters DI contracts to include only those whose expiration dates match known prefixed Treasury bond (LTN, NTN-F) maturities from the TPF dataset nearest to the given trade date. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the DI futures contract data for the specified dates, sorted by trade dates and expiration dates. Returns an empty DataFrame if no data is found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; df = di1.data(dates=\"16-10-2024\", month_start=True)\n&gt;&gt;&gt; df\nshape: (38, 19)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 ExpirationDate \u2506 TickerSymbol \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseAskRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---            \u2506 ---          \u2506 ---        \u2506   \u2506 ---          \u2506 ---          \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 date           \u2506 str          \u2506 i64        \u2506   \u2506 f64          \u2506 f64          \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-10-16 \u2506 2024-11-01     \u2506 DI1X24       \u2506 12         \u2506 \u2026 \u2506 0.10656      \u2506 0.10652      \u2506 0.10653        \u2506 0.10653     \u2502\n\u2502 2024-10-16 \u2506 2024-12-01     \u2506 DI1Z24       \u2506 31         \u2506 \u2026 \u2506 0.10914      \u2506 0.10912      \u2506 0.1091         \u2506 0.110726    \u2502\n\u2502 2024-10-16 \u2506 2025-01-01     \u2506 DI1F25       \u2506 52         \u2506 \u2026 \u2506 0.1117       \u2506 0.11164      \u2506 0.11164        \u2506 0.1154      \u2502\n\u2502 2024-10-16 \u2506 2025-02-01     \u2506 DI1G25       \u2506 74         \u2506 \u2026 \u2506 0.11375      \u2506 0.11355      \u2506 0.11362        \u2506 0.118314    \u2502\n\u2502 2024-10-16 \u2506 2025-03-01     \u2506 DI1H25       \u2506 94         \u2506 \u2026 \u2506 0.11595      \u2506 0.1157       \u2506 0.1157         \u2506 0.12343     \u2502\n\u2502 \u2026          \u2506 \u2026              \u2506 \u2026            \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026            \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-10-16 \u2506 2035-01-01     \u2506 DI1F35       \u2506 2556       \u2506 \u2026 \u2506 0.1265       \u2506 0.1264       \u2506 0.1265         \u2506 0.124455    \u2502\n\u2502 2024-10-16 \u2506 2036-01-01     \u2506 DI1F36       \u2506 2805       \u2506 \u2026 \u2506 null         \u2506 null         \u2506 0.1263         \u2506 0.124249    \u2502\n\u2502 2024-10-16 \u2506 2037-01-01     \u2506 DI1F37       \u2506 3058       \u2506 \u2026 \u2506 null         \u2506 null         \u2506 0.1263         \u2506 0.1263      \u2502\n\u2502 2024-10-16 \u2506 2038-01-01     \u2506 DI1F38       \u2506 3307       \u2506 \u2026 \u2506 null         \u2506 null         \u2506 0.1263         \u2506 0.1263      \u2502\n\u2502 2024-10-16 \u2506 2039-01-01     \u2506 DI1F39       \u2506 3558       \u2506 \u2026 \u2506 null         \u2506 null         \u2506 0.1263         \u2506 0.1263      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def data(\n    dates: DateScalar | DateArray,\n    month_start: bool = False,\n    pre_filter: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves DI Futures contract data for a specific trade date.\n\n    Provides access to DI futures data, allowing adjustments to expiration dates\n    (to month start) and optional filtering based on LTN and NTN-F bond maturities.\n\n    Args:\n        dates (DateScalar): The trade dates for which to retrieve DI contract data.\n        month_start (bool, optional): If True, adjusts all expiration dates to the\n            first day of their respective month (e.g., 2025-02-01 becomes\n            2025-01-01). Defaults to False.\n        pre_filter (bool, optional): If True, filters DI contracts to include only\n            those whose expiration dates match known prefixed Treasury bond (LTN, NTN-F)\n            maturities from the TPF dataset nearest to the given trade date.\n            Defaults to False.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the DI futures contract\n            data for the specified dates, sorted by trade dates and expiration dates.\n            Returns an empty DataFrame if no data is found\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; df = di1.data(dates=\"16-10-2024\", month_start=True)\n        &gt;&gt;&gt; df\n        shape: (38, 19)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 ExpirationDate \u2506 TickerSymbol \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseAskRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---            \u2506 ---          \u2506 ---        \u2506   \u2506 ---          \u2506 ---          \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 date           \u2506 str          \u2506 i64        \u2506   \u2506 f64          \u2506 f64          \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-10-16 \u2506 2024-11-01     \u2506 DI1X24       \u2506 12         \u2506 \u2026 \u2506 0.10656      \u2506 0.10652      \u2506 0.10653        \u2506 0.10653     \u2502\n        \u2502 2024-10-16 \u2506 2024-12-01     \u2506 DI1Z24       \u2506 31         \u2506 \u2026 \u2506 0.10914      \u2506 0.10912      \u2506 0.1091         \u2506 0.110726    \u2502\n        \u2502 2024-10-16 \u2506 2025-01-01     \u2506 DI1F25       \u2506 52         \u2506 \u2026 \u2506 0.1117       \u2506 0.11164      \u2506 0.11164        \u2506 0.1154      \u2502\n        \u2502 2024-10-16 \u2506 2025-02-01     \u2506 DI1G25       \u2506 74         \u2506 \u2026 \u2506 0.11375      \u2506 0.11355      \u2506 0.11362        \u2506 0.118314    \u2502\n        \u2502 2024-10-16 \u2506 2025-03-01     \u2506 DI1H25       \u2506 94         \u2506 \u2026 \u2506 0.11595      \u2506 0.1157       \u2506 0.1157         \u2506 0.12343     \u2502\n        \u2502 \u2026          \u2506 \u2026              \u2506 \u2026            \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026            \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-10-16 \u2506 2035-01-01     \u2506 DI1F35       \u2506 2556       \u2506 \u2026 \u2506 0.1265       \u2506 0.1264       \u2506 0.1265         \u2506 0.124455    \u2502\n        \u2502 2024-10-16 \u2506 2036-01-01     \u2506 DI1F36       \u2506 2805       \u2506 \u2026 \u2506 null         \u2506 null         \u2506 0.1263         \u2506 0.124249    \u2502\n        \u2502 2024-10-16 \u2506 2037-01-01     \u2506 DI1F37       \u2506 3058       \u2506 \u2026 \u2506 null         \u2506 null         \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2502 2024-10-16 \u2506 2038-01-01     \u2506 DI1F38       \u2506 3307       \u2506 \u2026 \u2506 null         \u2506 null         \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2502 2024-10-16 \u2506 2039-01-01     \u2506 DI1F39       \u2506 3558       \u2506 \u2026 \u2506 null         \u2506 null         \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if has_null_args(dates):\n        logger.warning(\"No valid 'dates' provided. Returning empty DataFrame.\")\n        return pl.DataFrame()\n    df = _get_data(dates=dates)\n\n    if month_start:\n        df = df.with_columns(pl.col(\"ExpirationDate\").dt.truncate(\"1mo\"))\n\n    if pre_filter:\n        df_pre = (\n            get_cached_dataset(\"tpf\")\n            .filter(pl.col(\"BondType\").is_in([\"LTN\", \"NTN-F\"]))\n            .unique(subset=[\"ReferenceDate\", \"MaturityDate\"])\n            .select(\n                pl.col(\"ReferenceDate\").alias(\"TradeDate\"),\n                pl.col(\"MaturityDate\").alias(\"ExpirationDate\"),\n            )\n        )\n\n        # garante que os dois lados est\u00e3o ordenados pelas chaves necess\u00e1rias\n        df = df.sort([\"TradeDate\", \"ExpirationDate\"])\n        df_pre = df_pre.sort([\"TradeDate\", \"ExpirationDate\"])\n\n        df = df.join_asof(\n            df_pre,\n            left_on=\"TradeDate\",\n            right_on=\"TradeDate\",\n            by=\"ExpirationDate\",  # garante matching por v\u00e9rtice\n            strategy=\"backward\",  # pega a data anterior se n\u00e3o tiver exata\n            check_sortedness=False,  # j\u00e1 garantimos a ordena\u00e7\u00e3o\n        )\n\n    return df\n</code></pre>"},{"location":"di1/#pyield.b3.di1.interpolate_rate","title":"<code>interpolate_rate(date, expiration, extrapolate=False)</code>","text":"<p>Interpolates or retrieves the DI rate for a single expiration date.</p> <p>Fetches DI contract data for the specified trade <code>date</code> and determines the settlement rate for the given <code>expiration</code>. If an exact match for the expiration date exists, its rate is returned. Otherwise, the rate is interpolated using the flat-forward method based on the rates of surrounding contracts.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The trade date for which to retrieve DI data.</p> required <code>expiration</code> <code>DateScalar</code> <p>The target expiration date for the rate.</p> required <code>extrapolate</code> <code>bool</code> <p>If True, allows extrapolation if the <code>expiration</code> date falls outside the range of available contract expirations for the given <code>date</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The exact or interpolated DI settlement rate for the specified date and expiration. Returns <code>None</code> if:     - No DI data is found for the <code>date</code>.     - The <code>expiration</code> is outside range and <code>extrapolate</code> is False.     - An interpolation calculation fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # Get rate for an existing contract expiration\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2027\")\n0.13901\n</code></pre> <pre><code>&gt;&gt;&gt; # Get rate for a non-existing contract expiration\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-11-2027\")\n0.13576348733268917\n</code></pre> <pre><code>&gt;&gt;&gt; # Extrapolate rate for a future expiration date\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2050\", extrapolate=True)\n0.13881\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def interpolate_rate(\n    date: DateScalar,\n    expiration: DateScalar,\n    extrapolate: bool = False,\n) -&gt; float | None:\n    \"\"\"\n    Interpolates or retrieves the DI rate for a single expiration date.\n\n    Fetches DI contract data for the specified trade `date` and determines the\n    settlement rate for the given `expiration`. If an exact match for the\n    expiration date exists, its rate is returned. Otherwise, the rate is\n    interpolated using the flat-forward method based on the rates of surrounding\n    contracts.\n\n    Args:\n        date (DateScalar): The trade date for which to retrieve DI data.\n        expiration (DateScalar): The target expiration date for the rate.\n        extrapolate (bool, optional): If True, allows extrapolation if the\n            `expiration` date falls outside the range of available contract\n            expirations for the given `date`. Defaults to False.\n\n    Returns:\n        float | None: The exact or interpolated DI settlement rate for the specified\n            date and expiration. Returns `None` if:\n                - No DI data is found for the `date`.\n                - The `expiration` is outside range and `extrapolate` is False.\n                - An interpolation calculation fails.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # Get rate for an existing contract expiration\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2027\")\n        0.13901\n\n        &gt;&gt;&gt; # Get rate for a non-existing contract expiration\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-11-2027\")\n        0.13576348733268917\n\n        &gt;&gt;&gt; # Extrapolate rate for a future expiration date\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2050\", extrapolate=True)\n        0.13881\n    \"\"\"\n    if has_null_args(date, expiration):\n        logger.warning(\"Both 'date' and 'expiration' must be provided. Returning NaN.\")\n        return None\n\n    converted_date = cv.convert_dates(date)\n    converted_expiration = cv.convert_dates(expiration)\n\n    if not isinstance(converted_date, dt.date) or not isinstance(\n        converted_expiration, dt.date\n    ):\n        raise ValueError(\"Both 'date' and 'expiration' must be single date values.\")\n\n    # Get the DI contract DataFrame\n    df = _get_data(dates=converted_date)\n\n    if df.is_empty():\n        return None\n\n    ff_interp = interpolator.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=df[\"BDaysToExp\"],\n        known_rates=df[\"SettlementRate\"],\n        extrapolate=extrapolate,\n    )\n\n    bd = bday.count(converted_date, converted_expiration)\n    return ff_interp(bd)\n</code></pre>"},{"location":"di1/#pyield.b3.di1.interpolate_rates","title":"<code>interpolate_rates(dates, expirations, extrapolate=True)</code>","text":"<p>Interpolates DI rates for specified trade dates and expiration dates.</p> <p>Calculates interpolated DI rates using the flat-forward method for given sets of trade dates and expiration dates. This function is well-suited for vectorized calculations across multiple date pairs.</p> <p>If DI rates are unavailable for a given trade date, the corresponding interpolated rate(s) will be NaN.</p> <p>Handles broadcasting: If one argument is a scalar and the other is an array, the scalar value is applied to all elements of the array.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar | DateArray</code> <p>The trade date(s) for the rates.</p> required <code>expirations</code> <code>DateScalar | DateArray</code> <p>The corresponding expiration date(s). Must be compatible in length with <code>dates</code> if both are arrays.</p> required <code>extrapolate</code> <code>bool</code> <p>Whether to allow extrapolation beyond the range of known DI rates for a given trade date. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series containing the interpolated DI rates (as floats). Values will be NaN where interpolation is not possible (e.g., no DI data for the trade date).</p> <p>Examples:</p> <ul> <li>Interpolate rates for multiple trade and expiration dates</li> </ul> <pre><code>&gt;&gt;&gt; # For contract with expiration 01-01-2027 in 08-05-2025\n&gt;&gt;&gt; # The rate is not interpolated (settlement rate is used)\n&gt;&gt;&gt; # There is no contract with expiration 25-11-2027 in 09-05-2025\n&gt;&gt;&gt; # The rate is interpolated (flat-forward method)\n&gt;&gt;&gt; # There is no data for trade date 10-05-2025 (Saturday) -&gt; NaN\n&gt;&gt;&gt; # Note: 0.13461282461562996 is shown as 0.134613\n&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=[\"08-05-2025\", \"09-05-2025\", \"10-05-2025\"],\n...     expirations=[\"01-01-2027\", \"25-11-2027\", \"01-01-2030\"],\n... )\nshape: (3,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.13972\n    0.134613\n    null\n]\n</code></pre> <ul> <li>Interpolate rates for a single trade date and multiple expiration dates</li> </ul> <pre><code>&gt;&gt;&gt; # There is no DI Contract in 09-05-2025 with expiration 01-01-2050\n&gt;&gt;&gt; # The longest available contract is used to extrapolate the rate\n&gt;&gt;&gt; # Note: extrapolation is allowed by default\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=\"25-04-2025\",\n...     expirations=[\"01-01-2027\", \"01-01-2050\"],\n... )\nshape: (2,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.13901\n    0.13881\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # With extrapolation set to False, the second rate will be null\n&gt;&gt;&gt; # Note: 0.13576348733268917 is shown as 0.135763\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=\"25-04-2025\",\n...     expirations=[\"01-11-2027\", \"01-01-2050\"],\n...     extrapolate=False,\n... )\nshape: (2,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.135763\n    null\n]\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dates</code> and <code>expirations</code> are both array-like but have different lengths.</p> Notes <ul> <li>All available settlement rates are used for the flat-forward interpolation.</li> <li>The function handles broadcasting of scalar and array-like inputs.</li> </ul> Source code in <code>pyield/b3/di1.py</code> <pre><code>def interpolate_rates(\n    dates: DateScalar | DateArray,\n    expirations: DateScalar | DateArray,\n    extrapolate: bool = True,\n) -&gt; pl.Series:\n    \"\"\"\n    Interpolates DI rates for specified trade dates and expiration dates.\n\n    Calculates interpolated DI rates using the **flat-forward** method for given\n    sets of trade dates and expiration dates. This function is well-suited\n    for vectorized calculations across multiple date pairs.\n\n    If DI rates are unavailable for a given trade date, the corresponding\n    interpolated rate(s) will be NaN.\n\n    Handles broadcasting: If one argument is a scalar and the other is an array,\n    the scalar value is applied to all elements of the array.\n\n    Args:\n        dates (DateScalar | DateArray): The trade date(s) for the rates.\n        expirations (DateScalar | DateArray): The corresponding expiration date(s).\n            Must be compatible in length with `dates` if both are arrays.\n        extrapolate (bool, optional): Whether to allow extrapolation beyond the\n            range of known DI rates for a given trade date. Defaults to True.\n\n    Returns:\n        pl.Series: A Series containing the interpolated DI rates (as floats).\n            Values will be NaN where interpolation is not possible\n            (e.g., no DI data for the trade date).\n\n    Examples:\n        - Interpolate rates for multiple trade and expiration dates\n        &gt;&gt;&gt; # For contract with expiration 01-01-2027 in 08-05-2025\n        &gt;&gt;&gt; # The rate is not interpolated (settlement rate is used)\n        &gt;&gt;&gt; # There is no contract with expiration 25-11-2027 in 09-05-2025\n        &gt;&gt;&gt; # The rate is interpolated (flat-forward method)\n        &gt;&gt;&gt; # There is no data for trade date 10-05-2025 (Saturday) -&gt; NaN\n        &gt;&gt;&gt; # Note: 0.13461282461562996 is shown as 0.134613\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=[\"08-05-2025\", \"09-05-2025\", \"10-05-2025\"],\n        ...     expirations=[\"01-01-2027\", \"25-11-2027\", \"01-01-2030\"],\n        ... )\n        shape: (3,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.13972\n            0.134613\n            null\n        ]\n\n        - Interpolate rates for a single trade date and multiple expiration dates\n        &gt;&gt;&gt; # There is no DI Contract in 09-05-2025 with expiration 01-01-2050\n        &gt;&gt;&gt; # The longest available contract is used to extrapolate the rate\n        &gt;&gt;&gt; # Note: extrapolation is allowed by default\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=\"25-04-2025\",\n        ...     expirations=[\"01-01-2027\", \"01-01-2050\"],\n        ... )\n        shape: (2,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.13901\n            0.13881\n        ]\n\n        &gt;&gt;&gt; # With extrapolation set to False, the second rate will be null\n        &gt;&gt;&gt; # Note: 0.13576348733268917 is shown as 0.135763\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=\"25-04-2025\",\n        ...     expirations=[\"01-11-2027\", \"01-01-2050\"],\n        ...     extrapolate=False,\n        ... )\n        shape: (2,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.135763\n            null\n        ]\n\n    Raises:\n        ValueError: If `dates` and `expirations` are both array-like but have\n            different lengths.\n\n    Notes:\n        - All available settlement rates are used for the flat-forward interpolation.\n        - The function handles broadcasting of scalar and array-like inputs.\n    \"\"\"\n    if has_null_args(dates, expirations):\n        logger.warning(\n            \"Both 'dates' and 'expirations' must be provided. Returning empty Series.\"\n        )\n        return pl.Series(dtype=pl.Float64)\n\n    dfi = _build_input_dataframe(dates, expirations)\n    # 2. Se a helper retornou um DataFrame vazio, retornar uma Series vazia\n    if dfi.is_empty():\n        logger.warning(\"Invalid inputs provided. Returning empty Series.\")\n        return pl.Series(dtype=pl.Float64)\n\n    s_bdays = bday.count(dfi[\"TradeDate\"], dfi[\"ExpirationDate\"])\n    dfi = dfi.with_columns(BDaysToExp=s_bdays, FlatFwdRate=None)\n\n    # Load DI rates dataset filtered by the provided reference dates\n    dfr = _get_data(dates=dates)\n\n    # Return an empty DataFrame if no rates are found\n    if dfr.is_empty():\n        return pl.Series(dtype=pl.Float64)\n\n    # Iterate over each unique reference date\n    for date in dfi.get_column(\"TradeDate\").unique().to_list():\n        # Filter DI rates for the current reference date\n        dfr_subset = dfr.filter(pl.col(\"TradeDate\") == date)\n\n        # Skip processing if no rates are available for the current date\n        if dfr_subset.is_empty():\n            continue\n\n        # Initialize the interpolator with known rates and business days\n        interp = interpolator.Interpolator(\n            method=\"flat_forward\",\n            known_bdays=dfr_subset[\"BDaysToExp\"],\n            known_rates=dfr_subset[\"SettlementRate\"],\n            extrapolate=extrapolate,\n        )\n\n        dfi = dfi.with_columns(\n            pl.when(pl.col(\"TradeDate\") == date)\n            .then(pl.col(\"BDaysToExp\").map_elements(interp, return_dtype=pl.Float64))\n            .otherwise(pl.col(\"FlatFwdRate\"))\n            .alias(\"FlatFwdRate\")\n        )\n\n    # Return the series with interpolated rates\n    return dfi.get_column(\"FlatFwdRate\")\n</code></pre>"},{"location":"forwards/","title":"Forwards","text":""},{"location":"forwards/#pyield.fwd.forward","title":"<code>forward(bday1, bday2, rate1, rate2)</code>","text":"<p>Calcula a taxa a termo (forward rate) entre dois prazos (dias \u00fateis).</p> Utiliza a f\u00f3rmula <p>f\u2081\u2192\u2082 = ((1 + r\u2082)^(du\u2082/252) / (1 + r\u2081)^(du\u2081/252))^(252/(du\u2082 - du\u2081)) - 1</p> Onde <ul> <li>r\u2081 \u00e9 a taxa zero para o primeiro prazo (du\u2081).</li> <li>r\u2082 \u00e9 a taxa zero para o segundo prazo (du\u2082).</li> <li>du\u2081 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a primeira data.</li> <li>du\u2082 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a segunda data.</li> <li>A constante 252 representa o n\u00famero de dias \u00fateis no ano.</li> </ul> <p>Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:</p> <pre><code>f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>bday1</code> <code>int</code> <p>N\u00famero de dias \u00fateis do primeiro ponto (prazo menor).</p> required <code>bday2</code> <code>int</code> <p>N\u00famero de dias \u00fateis do segundo ponto (prazo maior).</p> required <code>rate1</code> <code>float</code> <p>Taxa zero (spot rate) para o prazo <code>bday1</code>.</p> required <code>rate2</code> <code>float</code> <p>Taxa zero (spot rate) para o prazo <code>bday2</code>.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: A taxa a termo calculada entre <code>bday1</code> e <code>bday2</code>. Retorna <code>None</code> se <code>bday1 &gt;= bday2</code> ou se qualquer um dos argumentos de entrada for float('nan') ou None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Exemplo v\u00e1lido: bday2 &gt; bday1\n&gt;&gt;&gt; yd.forward(10, 20, 0.05, 0.06)\n0.0700952380952371\n&gt;&gt;&gt; # Exemplo inv\u00e1lido: bday1 &gt;= bday2\n&gt;&gt;&gt; print(yd.forward(20, 10, 0.06, 0.05))\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; # Argumentos nulos retornam None\n&gt;&gt;&gt; print(yd.forward(10, 20, 0.05, None))\nNone\n</code></pre> Note <p><code>bday2</code> precisa ser necessariamente maior que <code>bday1</code> para que o c\u00e1lculo da taxa a termo seja matematicamente v\u00e1lido.</p> <p>A f\u00f3rmula utilizada \u00e9 derivada da rela\u00e7\u00e3o entre taxas zero (spot rates) \u00e9: $$ f_{1 \\rightarrow 2} = \\left( \\frac{(1 + r_2)^{t_2}}{(1 + r_1)^{t_1}} \\right)^{\\frac{1}{t_2 - t_1}} - 1 $$</p> Source code in <code>pyield/fwd.py</code> <pre><code>def forward(\n    bday1: int,\n    bday2: int,\n    rate1: float,\n    rate2: float,\n) -&gt; float | None:\n    r\"\"\"\n    Calcula a taxa a termo (forward rate) entre dois prazos (dias \u00fateis).\n\n    Utiliza a f\u00f3rmula:\n        f\u2081\u2192\u2082 = ((1 + r\u2082)^(du\u2082/252) / (1 + r\u2081)^(du\u2081/252))^(252/(du\u2082 - du\u2081)) - 1\n\n    Onde:\n        - r\u2081 \u00e9 a taxa zero para o primeiro prazo (du\u2081).\n        - r\u2082 \u00e9 a taxa zero para o segundo prazo (du\u2082).\n        - du\u2081 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a primeira data.\n        - du\u2082 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a segunda data.\n        - A constante 252 representa o n\u00famero de dias \u00fateis no ano.\n\n    Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:\n\n        f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n\n    Args:\n        bday1 (int): N\u00famero de dias \u00fateis do primeiro ponto (prazo menor).\n        bday2 (int): N\u00famero de dias \u00fateis do segundo ponto (prazo maior).\n        rate1 (float): Taxa zero (spot rate) para o prazo `bday1`.\n        rate2 (float): Taxa zero (spot rate) para o prazo `bday2`.\n\n    Returns:\n        float | None: A taxa a termo calculada entre `bday1` e `bday2`. Retorna\n            `None` se `bday1 &gt;= bday2` ou se qualquer um dos\n            argumentos de entrada for float('nan') ou None.\n\n    Examples:\n        &gt;&gt;&gt; # Exemplo v\u00e1lido: bday2 &gt; bday1\n        &gt;&gt;&gt; yd.forward(10, 20, 0.05, 0.06)\n        0.0700952380952371\n        &gt;&gt;&gt; # Exemplo inv\u00e1lido: bday1 &gt;= bday2\n        &gt;&gt;&gt; print(yd.forward(20, 10, 0.06, 0.05))\n        None\n\n        &gt;&gt;&gt; # Argumentos nulos retornam None\n        &gt;&gt;&gt; print(yd.forward(10, 20, 0.05, None))\n        None\n\n    Note:\n        `bday2` precisa ser necessariamente maior que `bday1` para que\n        o c\u00e1lculo da taxa a termo seja matematicamente v\u00e1lido.\n\n    A f\u00f3rmula utilizada \u00e9 derivada da rela\u00e7\u00e3o entre taxas zero (spot rates) \u00e9:\n    $$\n    f_{1 \\rightarrow 2} = \\left( \\frac{(1 + r_2)^{t_2}}{(1 + r_1)^{t_1}} \\right)^{\\frac{1}{t_2 - t_1}} - 1\n    $$\n    \"\"\"  # noqa: E501\n    if has_null_args(rate1, rate2, bday1, bday2):\n        # If any of the inputs are nullable, return None\n        return None\n\n    # Handle the case where the two dates are the same\n    if bday2 &lt;= bday1:\n        return None\n\n    # Convert business days to business years\n    t1 = bday1 / 252\n    t2 = bday2 / 252\n\n    # f\u2081\u2192\u2082 = ((1 + r\u2082)^t\u2082 / (1 + r\u2081)^t\u2081)^(1/(t\u2082 - t\u2081)) - 1\n    return ((1 + rate2) ** t2 / (1 + rate1) ** t1) ** (1 / (t2 - t1)) - 1\n</code></pre>"},{"location":"forwards/#pyield.fwd.forwards","title":"<code>forwards(bdays, rates, group_by=None)</code>","text":"<p>Calcula taxas a termo (forward rates) a partir de taxas zero (spot rates).</p> <p>A taxa a termo no v\u00e9rtice 'n' \u00e9 definida como:     fwd\u2096 = fwd\u2c7c\u2192\u2096 (a taxa a termo de j para k)</p> A f\u00f3rmula utilizada \u00e9 <p>fwd\u2096 = ((1 + r\u2096)^(du\u2096/252) / (1 + r\u2c7c)^(du\u2c7c/252))^(252/(du\u2096 - du\u2c7c)) - 1</p> <p>Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:</p> <pre><code>fwd\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c)^(1/(t\u2096 - t\u2c7c)) - 1\n</code></pre> <p>Em LaTeX, a f\u00f3rmula \u00e9 representada como: $$ fwd_k = \\left( \\frac{(1 + r_k)^{t_k}}{(1 + r_j)^{t_j}} \\right)^{\\frac{1}{t_k - t_j}} - 1 $$</p> Onde <ul> <li>r\u2c7c \u00e9 a taxa zero para o v\u00e9rtice anterior.</li> <li>r\u2096 \u00e9 a taxa zero para o v\u00e9rtice atual.</li> <li>t\u2c7c \u00e9 o prazo em anos para o v\u00e9rtice anterior (calculado como du\u2c7c/252).</li> <li>t\u2096 \u00e9 o prazo em anos para o v\u00e9rtice atual (calculado como du\u2096/252).</li> <li>A constante 252 representa o n\u00famero de dias \u00fateis no ano.</li> </ul> <p>A primeira taxa a termo de cada grupo \u00e9 definida como a taxa zero desse primeiro v\u00e9rtice (fwd\u2081 = r\u2081), dado que n\u00e3o existe um v\u00e9rtice anterior a r\u2081 para se calcular a taxa a termo no primeiro ponto.</p> <p>Valores nulos nas taxas ou prazos de entrada resultar\u00e3o em valores nulos nas taxas a termo calculadas. A fun\u00e7\u00e3o tamb\u00e9m lida com agrupamentos opcionais, permitindo calcular taxas a termo para diferentes grupos de datas. O agrupamento \u00e9 feito com base em <code>group_by</code>. Se este argumento for None, todos os dados ser\u00e3o tratados como um \u00fanico grupo. A fun\u00e7\u00e3o calcula as taxas a termo para todos os pontos, exceto o primeiro de cada grupo, que \u00e9 tratado separadamente.</p> <p>Args:     bdays (IntegerArray): N\u00famero de dias \u00fateis para cada taxa zero.     rates (FloatArray): Taxas zero correspondentes aos dias \u00fateis.     group_by (GroupingCriteria, optional):         Crit\u00e9rio de agrupamento para os c\u00e1lculos (ex: datas de refer\u00eancia,         tickers de t\u00edtulos). Pode ser uma lista/s\u00e9rie de strings, inteiros         ou datas. Se None, todos os dados s\u00e3o tratados como um \u00fanico grupo.         Default None.</p> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie contendo as taxas a termo calculadas (tipo Float64). A primeira taxa de cada grupo corresponde \u00e0 taxa zero inicial.</p> <p>Raises:     polars.exceptions.ShapeError: Se os comprimentos de <code>bdays</code>, <code>rates</code>         e <code>group_by</code> (quando fornecido) n\u00e3o forem iguais.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bdays = [10, 20, 30]\n&gt;&gt;&gt; rates = [0.05, 0.06, 0.07]\n&gt;&gt;&gt; yd.forwards(bdays, rates)\nshape: (3,)\nSeries: 'fwd' [f64]\n[\n    0.05\n    0.070095\n    0.090284\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Exemplo com agrupamento (a \u00faltima est\u00e1 isolada em outro grupo)\n&gt;&gt;&gt; group_by = [\"LTN\", \"LTN\", \"NTN-F\"]\n&gt;&gt;&gt; yd.forwards(bdays, rates, group_by)\nshape: (3,)\nSeries: 'fwd' [f64]\n[\n    0.05\n    0.070095\n    0.07\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Exemplo com taxas indicativas de NTN-B em 16-09-2025\n&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; df = ntnb.data(\"16-09-2025\")\n&gt;&gt;&gt; yd.forwards(df[\"BDToMat\"], df[\"IndicativeRate\"])\nshape: (13,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.071549\n    0.072439\n    0.069558\n    0.076614\n    \u2026\n    0.068105\n    0.071278\n    0.069117\n    0.070373\n    0.073286\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Valores nulos s\u00e3o descartados no c\u00e1lculo e retornados como nulos\n&gt;&gt;&gt; du = [230, 415, 730, None, 914]\n&gt;&gt;&gt; tx = [0.0943, 0.084099, 0.079052, 0.1, 0.077134]\n&gt;&gt;&gt; yd.forwards(du, tx)\nshape: (5,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.071549\n    0.072439\n    null\n    0.069558\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # O algoritmo ordena os dados de entrada antes do c\u00e1lculo e retorna\n&gt;&gt;&gt; # os resultados na ordem original. Valores duplicados s\u00e3o tratados\n&gt;&gt;&gt; # como um \u00fanico ponto no c\u00e1lculo da taxa a termo (\u00faltimo valor \u00e9 mantido).\n&gt;&gt;&gt; du = [230, 730, 415, 230]\n&gt;&gt;&gt; tx = [0.1, 0.079052, 0.084099, 0.0943]\n&gt;&gt;&gt; yd.forwards(du, tx)\nshape: (4,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.072439\n    0.071549\n    0.0943\n]\n</code></pre> Note <ul> <li>A fun\u00e7\u00e3o ordena os dados de entrada primeiro por <code>group_by</code>, se for fornecido, e depois por <code>bdays</code> para garantir a ordem cronol\u00f3gica correta no c\u00e1lculo das taxas a termo.</li> <li>Os resultados s\u00e3o retornados na mesma ordem dos dados de entrada.</li> </ul> Source code in <code>pyield/fwd.py</code> <pre><code>def forwards(\n    bdays: IntegerArray,\n    rates: FloatArray,\n    group_by: Sequence[str | int | dt.date] | pl.Series | None = None,\n) -&gt; pl.Series:\n    r\"\"\"\n    Calcula taxas a termo (forward rates) a partir de taxas zero (spot rates).\n\n    A taxa a termo no v\u00e9rtice 'n' \u00e9 definida como:\n        fwd\u2096 = fwd\u2c7c\u2192\u2096 (a taxa a termo de j para k)\n\n    A f\u00f3rmula utilizada \u00e9:\n        fwd\u2096 = ((1 + r\u2096)^(du\u2096/252) / (1 + r\u2c7c)^(du\u2c7c/252))^(252/(du\u2096 - du\u2c7c)) - 1\n\n    Como du/252 = t (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:\n\n        fwd\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c)^(1/(t\u2096 - t\u2c7c)) - 1\n\n    Em LaTeX, a f\u00f3rmula \u00e9 representada como:\n    $$\n    fwd_k = \\left( \\frac{(1 + r_k)^{t_k}}{(1 + r_j)^{t_j}} \\right)^{\\frac{1}{t_k - t_j}} - 1\n    $$\n\n    Onde:\n        - r\u2c7c \u00e9 a taxa zero para o v\u00e9rtice anterior.\n        - r\u2096 \u00e9 a taxa zero para o v\u00e9rtice atual.\n        - t\u2c7c \u00e9 o prazo em anos para o v\u00e9rtice anterior (calculado como du\u2c7c/252).\n        - t\u2096 \u00e9 o prazo em anos para o v\u00e9rtice atual (calculado como du\u2096/252).\n        - A constante 252 representa o n\u00famero de dias \u00fateis no ano.\n\n    A primeira taxa a termo de cada grupo \u00e9 definida como a\n    taxa zero desse primeiro v\u00e9rtice (fwd\u2081 = r\u2081), dado que n\u00e3o existe um v\u00e9rtice\n    anterior a r\u2081 para se calcular a taxa a termo no primeiro ponto.\n\n    Valores nulos nas taxas ou prazos de entrada resultar\u00e3o em valores nulos\n    nas taxas a termo calculadas. A fun\u00e7\u00e3o tamb\u00e9m lida com agrupamentos\n    opcionais, permitindo calcular taxas a termo para diferentes grupos de\n    datas. O agrupamento \u00e9 feito com base em `group_by`. Se este\n    argumento for None, todos os dados ser\u00e3o tratados como um \u00fanico grupo.\n    A fun\u00e7\u00e3o calcula as taxas a termo para todos os pontos, exceto o primeiro\n    de cada grupo, que \u00e9 tratado separadamente.\n\n     Args:\n        bdays (IntegerArray): N\u00famero de dias \u00fateis para cada taxa zero.\n        rates (FloatArray): Taxas zero correspondentes aos dias \u00fateis.\n        group_by (GroupingCriteria, optional):\n            Crit\u00e9rio de agrupamento para os c\u00e1lculos (ex: datas de refer\u00eancia,\n            tickers de t\u00edtulos). Pode ser uma lista/s\u00e9rie de strings, inteiros\n            ou datas. Se None, todos os dados s\u00e3o tratados como um \u00fanico grupo.\n            Default None.\n\n    Returns:\n        pl.Series: S\u00e9rie contendo as taxas a termo calculadas (tipo Float64).\n            A primeira taxa de cada grupo corresponde \u00e0 taxa zero inicial.\n\n     Raises:\n        polars.exceptions.ShapeError: Se os comprimentos de `bdays`, `rates`\n            e `group_by` (quando fornecido) n\u00e3o forem iguais.\n\n    Examples:\n        &gt;&gt;&gt; bdays = [10, 20, 30]\n        &gt;&gt;&gt; rates = [0.05, 0.06, 0.07]\n        &gt;&gt;&gt; yd.forwards(bdays, rates)\n        shape: (3,)\n        Series: 'fwd' [f64]\n        [\n            0.05\n            0.070095\n            0.090284\n        ]\n\n        &gt;&gt;&gt; # Exemplo com agrupamento (a \u00faltima est\u00e1 isolada em outro grupo)\n        &gt;&gt;&gt; group_by = [\"LTN\", \"LTN\", \"NTN-F\"]\n        &gt;&gt;&gt; yd.forwards(bdays, rates, group_by)\n        shape: (3,)\n        Series: 'fwd' [f64]\n        [\n            0.05\n            0.070095\n            0.07\n        ]\n\n        &gt;&gt;&gt; # Exemplo com taxas indicativas de NTN-B em 16-09-2025\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; df = ntnb.data(\"16-09-2025\")\n        &gt;&gt;&gt; yd.forwards(df[\"BDToMat\"], df[\"IndicativeRate\"])\n        shape: (13,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.071549\n            0.072439\n            0.069558\n            0.076614\n            \u2026\n            0.068105\n            0.071278\n            0.069117\n            0.070373\n            0.073286\n        ]\n\n        &gt;&gt;&gt; # Valores nulos s\u00e3o descartados no c\u00e1lculo e retornados como nulos\n        &gt;&gt;&gt; du = [230, 415, 730, None, 914]\n        &gt;&gt;&gt; tx = [0.0943, 0.084099, 0.079052, 0.1, 0.077134]\n        &gt;&gt;&gt; yd.forwards(du, tx)\n        shape: (5,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.071549\n            0.072439\n            null\n            0.069558\n        ]\n\n        &gt;&gt;&gt; # O algoritmo ordena os dados de entrada antes do c\u00e1lculo e retorna\n        &gt;&gt;&gt; # os resultados na ordem original. Valores duplicados s\u00e3o tratados\n        &gt;&gt;&gt; # como um \u00fanico ponto no c\u00e1lculo da taxa a termo (\u00faltimo valor \u00e9 mantido).\n        &gt;&gt;&gt; du = [230, 730, 415, 230]\n        &gt;&gt;&gt; tx = [0.1, 0.079052, 0.084099, 0.0943]\n        &gt;&gt;&gt; yd.forwards(du, tx)\n        shape: (4,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.072439\n            0.071549\n            0.0943\n        ]\n\n    Note:\n        - A fun\u00e7\u00e3o ordena os dados de entrada primeiro por `group_by`,\n        se for fornecido, e depois por `bdays` para garantir a ordem cronol\u00f3gica\n        correta no c\u00e1lculo das taxas a termo.\n        - Os resultados s\u00e3o retornados na mesma ordem dos dados de entrada.\n    \"\"\"  # noqa: E501\n    # Valida\u00e7\u00f5es iniciais\n    if has_null_args(bdays, rates):\n        return pl.Series(dtype=pl.Float64)\n    # 1. Montar o DataFrame\n    # Criar coluna de agrupamento dummy se n\u00e3o for fornecida\n    group_by_exp = pl.Series(group_by) if group_by is not None else 0\n    df_orig = pl.DataFrame(\n        {\n            \"du_k\": bdays,\n            \"rate_k\": rates,\n            \"group_by\": group_by_exp,\n        }\n    )\n\n    # 3. Definir a f\u00f3rmula da taxa a termo\n    # f\u2096 = f\u2c7c\u2192\u2096 = ((1 + r\u2096)^t\u2096 / (1 + r\u2c7c)^t\u2c7c) ^ (1/(t\u2096 - t\u2c7c)) - 1\n    exp1 = (1 + pl.col(\"rate_k\")) ** pl.col(\"time_k\")  # (1 + r\u2096)^t\u2096\n    exp2 = (1 + pl.col(\"rate_j\")) ** pl.col(\"time_j\")  # (1 + r\u2c7c)^t\u2c7c\n    exp3 = 1 / (pl.col(\"time_k\") - pl.col(\"time_j\"))  # 1/(t\u2096 - t\u2c7c)\n    fwd_formula = (exp1 / exp2) ** exp3 - 1\n\n    # --- In\u00edcio da L\u00f3gica com Express\u00f5es (Lazy API) ---\n    df_fwd = (\n        df_orig.drop_nans()\n        .drop_nulls()\n        .unique(subset=[\"du_k\", \"group_by\"], keep=\"last\")\n        .sort([\"group_by\", \"du_k\"])\n        .with_columns(time_k=pl.col(\"du_k\") / 252)  # Criar coluna de tempo em anos\n        .with_columns(\n            # Calcular os valores deslocados (shift) dentro de cada grupo\n            rate_j=pl.col(\"rate_k\").shift(1).over(\"group_by\"),\n            time_j=pl.col(\"time_k\").shift(1).over(\"group_by\"),\n        )\n        .with_columns(fwd=fwd_formula)\n        .with_columns(\n            # Usar a taxa spot para a primeira entrada de cada grupo\n            fwd=pl.when(pl.col(\"time_j\").is_null())\n            .then(pl.col(\"rate_k\"))\n            .otherwise(pl.col(\"fwd\"))\n        )\n    )\n    s_fwd = df_orig.join(\n        df_fwd,\n        on=[\"du_k\", \"group_by\"],\n        how=\"left\",\n        maintain_order=\"left\",\n    ).get_column(\"fwd\")\n\n    return s_fwd\n</code></pre>"},{"location":"futures/","title":"Futures Data","text":""},{"location":"futures/#pyield.futures.futures","title":"<code>futures(contract_code, date)</code>","text":"<p>Fetches data for a specified futures contract based on type and reference date.</p> <p>Parameters:</p> Name Type Description Default <code>contract_code</code> <code>str</code> <p>The B3 futures contract code identifying the derivative. Supported contract codes are: - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3. - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3. - \"FRC\": Forward Rate Agreement (FRA) from B3. - \"DAP\": DI x IPCA Spread Futures. - \"DOL\": U.S. Dollar Futures from B3. - \"WDO\": Mini U.S. Dollar Futures from B3. - \"IND\": Ibovespa Futures from B3. - \"WIN\": Mini Ibovespa Futures from B3.</p> required <code>date</code> <code>DateScalar</code> <p>The date for which to fetch the data. If the reference date is a string, it should be in 'DD-MM-YYYY' format.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame containing the fetched data for the specified futures contract.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the futures contract code is not recognized or supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\nshape: (40, 20)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 DI1M24       \u2506 2024-06-03     \u2506 1          \u2506 \u2026 \u2506 0.10404      \u2506 0.10404   \u2506 0.10399        \u2506 0.10399     \u2502\n\u2502 2024-05-31 \u2506 DI1N24       \u2506 2024-07-01     \u2506 21         \u2506 \u2026 \u2506 0.1039       \u2506 0.10386   \u2506 0.1039         \u2506 0.103896    \u2502\n\u2502 2024-05-31 \u2506 DI1Q24       \u2506 2024-08-01     \u2506 44         \u2506 \u2026 \u2506 0.10374      \u2506 0.10374   \u2506 0.1037         \u2506 0.103517    \u2502\n\u2502 2024-05-31 \u2506 DI1U24       \u2506 2024-09-02     \u2506 66         \u2506 \u2026 \u2506 0.10365      \u2506 0.10355   \u2506 0.1036         \u2506 0.1034      \u2502\n\u2502 2024-05-31 \u2506 DI1V24       \u2506 2024-10-01     \u2506 87         \u2506 \u2026 \u2506 0.1036       \u2506 0.10355   \u2506 0.1036         \u2506 0.1036      \u2502\n\u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-05-31 \u2506 DI1F35       \u2506 2035-01-02     \u2506 2654       \u2506 \u2026 \u2506 0.1193       \u2506 0.1192    \u2506 0.11907        \u2506 0.12179     \u2502\n\u2502 2024-05-31 \u2506 DI1F36       \u2506 2036-01-02     \u2506 2903       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11674     \u2502\n\u2502 2024-05-31 \u2506 DI1F37       \u2506 2037-01-02     \u2506 3156       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2502 2024-05-31 \u2506 DI1F38       \u2506 2038-01-04     \u2506 3405       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2502 2024-05-31 \u2506 DI1F39       \u2506 2039-01-03     \u2506 3656       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\nshape: (22, 19)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 DAPM24       \u2506 2024-06-17     \u2506 11         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.0555         \u2506 0.0555      \u2502\n\u2502 2024-05-31 \u2506 DAPN24       \u2506 2024-07-15     \u2506 31         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07524        \u2506 0.086254    \u2502\n\u2502 2024-05-31 \u2506 DAPQ24       \u2506 2024-08-15     \u2506 54         \u2506 \u2026 \u2506 null         \u2506 0.0885    \u2506 0.0885         \u2506 0.106631    \u2502\n\u2502 2024-05-31 \u2506 DAPU24       \u2506 2024-09-16     \u2506 76         \u2506 \u2026 \u2506 null         \u2506 0.0865    \u2506 0.0855         \u2506 0.078171    \u2502\n\u2502 2024-05-31 \u2506 DAPV24       \u2506 2024-10-15     \u2506 97         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07932        \u2506 0.057247    \u2502\n\u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-05-31 \u2506 DAPQ40       \u2506 2040-08-15     \u2506 4064       \u2506 \u2026 \u2506 null         \u2506 0.0609    \u2506 0.06099        \u2506 0.060553    \u2502\n\u2502 2024-05-31 \u2506 DAPK45       \u2506 2045-05-15     \u2506 5251       \u2506 \u2026 \u2506 null         \u2506 0.0619    \u2506 0.0588         \u2506 0.051336    \u2502\n\u2502 2024-05-31 \u2506 DAPQ50       \u2506 2050-08-15     \u2506 6566       \u2506 \u2026 \u2506 null         \u2506 0.0605    \u2506 0.06086        \u2506 0.069126    \u2502\n\u2502 2024-05-31 \u2506 DAPK55       \u2506 2055-05-17     \u2506 7755       \u2506 \u2026 \u2506 null         \u2506 0.0646    \u2506 0.06022        \u2506 0.056693    \u2502\n\u2502 2024-05-31 \u2506 DAPQ60       \u2506 2060-08-16     \u2506 9072       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.05821        \u2506 0.046451    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/b3/futures/__init__.py</code> <pre><code>def futures(\n    contract_code: ContractOptions | str,\n    date: DateScalar,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches data for a specified futures contract based on type and reference date.\n\n    Args:\n        contract_code (str): The B3 futures contract code identifying the derivative.\n            Supported contract codes are:\n            - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3.\n            - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3.\n            - \"FRC\": Forward Rate Agreement (FRA) from B3.\n            - \"DAP\": DI x IPCA Spread Futures.\n            - \"DOL\": U.S. Dollar Futures from B3.\n            - \"WDO\": Mini U.S. Dollar Futures from B3.\n            - \"IND\": Ibovespa Futures from B3.\n            - \"WIN\": Mini Ibovespa Futures from B3.\n        date (DateScalar): The date for which to fetch the data.\n            If the reference date is a string, it should be in 'DD-MM-YYYY' format.\n\n    Returns:\n        pl.DataFrame: DataFrame containing the fetched data for the specified futures\n            contract.\n\n    Raises:\n        ValueError: If the futures contract code is not recognized or supported.\n\n    Examples:\n        &gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n        shape: (40, 20)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 DI1M24       \u2506 2024-06-03     \u2506 1          \u2506 \u2026 \u2506 0.10404      \u2506 0.10404   \u2506 0.10399        \u2506 0.10399     \u2502\n        \u2502 2024-05-31 \u2506 DI1N24       \u2506 2024-07-01     \u2506 21         \u2506 \u2026 \u2506 0.1039       \u2506 0.10386   \u2506 0.1039         \u2506 0.103896    \u2502\n        \u2502 2024-05-31 \u2506 DI1Q24       \u2506 2024-08-01     \u2506 44         \u2506 \u2026 \u2506 0.10374      \u2506 0.10374   \u2506 0.1037         \u2506 0.103517    \u2502\n        \u2502 2024-05-31 \u2506 DI1U24       \u2506 2024-09-02     \u2506 66         \u2506 \u2026 \u2506 0.10365      \u2506 0.10355   \u2506 0.1036         \u2506 0.1034      \u2502\n        \u2502 2024-05-31 \u2506 DI1V24       \u2506 2024-10-01     \u2506 87         \u2506 \u2026 \u2506 0.1036       \u2506 0.10355   \u2506 0.1036         \u2506 0.1036      \u2502\n        \u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-05-31 \u2506 DI1F35       \u2506 2035-01-02     \u2506 2654       \u2506 \u2026 \u2506 0.1193       \u2506 0.1192    \u2506 0.11907        \u2506 0.12179     \u2502\n        \u2502 2024-05-31 \u2506 DI1F36       \u2506 2036-01-02     \u2506 2903       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11674     \u2502\n        \u2502 2024-05-31 \u2506 DI1F37       \u2506 2037-01-02     \u2506 3156       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2502 2024-05-31 \u2506 DI1F38       \u2506 2038-01-04     \u2506 3405       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2502 2024-05-31 \u2506 DI1F39       \u2506 2039-01-03     \u2506 3656       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n        shape: (22, 19)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 DAPM24       \u2506 2024-06-17     \u2506 11         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.0555         \u2506 0.0555      \u2502\n        \u2502 2024-05-31 \u2506 DAPN24       \u2506 2024-07-15     \u2506 31         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07524        \u2506 0.086254    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ24       \u2506 2024-08-15     \u2506 54         \u2506 \u2026 \u2506 null         \u2506 0.0885    \u2506 0.0885         \u2506 0.106631    \u2502\n        \u2502 2024-05-31 \u2506 DAPU24       \u2506 2024-09-16     \u2506 76         \u2506 \u2026 \u2506 null         \u2506 0.0865    \u2506 0.0855         \u2506 0.078171    \u2502\n        \u2502 2024-05-31 \u2506 DAPV24       \u2506 2024-10-15     \u2506 97         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07932        \u2506 0.057247    \u2502\n        \u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-05-31 \u2506 DAPQ40       \u2506 2040-08-15     \u2506 4064       \u2506 \u2026 \u2506 null         \u2506 0.0609    \u2506 0.06099        \u2506 0.060553    \u2502\n        \u2502 2024-05-31 \u2506 DAPK45       \u2506 2045-05-15     \u2506 5251       \u2506 \u2026 \u2506 null         \u2506 0.0619    \u2506 0.0588         \u2506 0.051336    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ50       \u2506 2050-08-15     \u2506 6566       \u2506 \u2026 \u2506 null         \u2506 0.0605    \u2506 0.06086        \u2506 0.069126    \u2502\n        \u2502 2024-05-31 \u2506 DAPK55       \u2506 2055-05-17     \u2506 7755       \u2506 \u2026 \u2506 null         \u2506 0.0646    \u2506 0.06022        \u2506 0.056693    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ60       \u2506 2060-08-16     \u2506 9072       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.05821        \u2506 0.046451    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if has_null_args(contract_code, date):\n        return pl.DataFrame()\n    trade_date = cv.convert_dates(date)\n\n    # Valida\u00e7\u00e3o centralizada (evita chamadas desnecess\u00e1rias \u00e0s APIs B3)\n    if not _validate_reference_date(trade_date):\n        return pl.DataFrame()\n\n    selected_contract = str(contract_code).upper()\n\n    if _is_trading_day(trade_date):\n        # \u00c9 um dia de negocia\u00e7\u00e3o intraday\n        time = dt.datetime.now(TIMEZONE_BZ).time()\n        if time &lt; INTRADAY_START_TIME:  # Mercado n\u00e3o est\u00e1 aberto ainda\n            logger.warning(\"Market is not open yet. Returning an empty DataFrame. \")\n            return pl.DataFrame()\n\n        # Existe a chance de que os dados consolidados estejam dispon\u00edveis ap\u00f3s as 20h\n        if time &gt;= HISTORICAL_START_TIME:\n            df_hist = _get_historical_data(selected_contract, trade_date)\n            if not df_hist.is_empty():\n                logger.info(\"Consolidated data is already available and will be used.\")\n                return df_hist\n\n        # Mercado est\u00e1 aberto e n\u00e3o h\u00e1 dados consolidados dispon\u00edveis ainda\n        return fetch_intraday_df(selected_contract)\n\n    else:  # \u00c9 um dia hist\u00f3rico\n        return _get_historical_data(selected_contract, trade_date)\n</code></pre>"},{"location":"interpolator/","title":"Interpolator","text":""},{"location":"interpolator/#pyield.interpolator.Interpolator","title":"<code>Interpolator(method, known_bdays, known_rates, extrapolate=False)</code>","text":"<p>Interpolator class for interest rate interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['flat_forward', 'linear']</code> <p>The interpolation method to use.</p> required <code>known_bdays</code> <code>IntegerArray</code> <p>The known business days sequence.</p> required <code>known_rates</code> <code>FloatArray</code> <p>The known interest rates sequence.</p> required <code>extrapolate</code> <code>bool</code> <p>If True, extrapolates beyond known business days using the last available rate. Defaults to False, returning NaN for out-of-range values.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If known_bdays and known_rates do not have the same length.</p> <code>ValueError</code> <p>If the interpolation method is not recognized</p> Note <ul> <li>This class uses a 252 business days per year convention.</li> <li>Instances of this class are immutable. To modify the interpolation   settings, create a new instance.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import Interpolator\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n</code></pre> <p>Linear interpolation example:</p> <pre><code>&gt;&gt;&gt; linear = Interpolator(\"linear\", known_bdays, known_rates)\n&gt;&gt;&gt; linear(45)\n0.0475\n</code></pre> <p>Flat forward interpolation example:</p> <pre><code>&gt;&gt;&gt; fforward = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; fforward(45)\n0.04833068080970859\n</code></pre> <pre><code>&gt;&gt;&gt; print(fforward(100))  # Extrapolation disabled by default\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; print(fforward(-10))\nNone\n</code></pre> Source code in <code>pyield/interpolator.py</code> <pre><code>def __init__(\n    self,\n    method: Literal[\"flat_forward\", \"linear\"],\n    known_bdays: IntegerArray,\n    known_rates: FloatArray,\n    extrapolate: bool = False,\n):\n    df = (\n        pl.DataFrame({\"bday\": known_bdays, \"rate\": known_rates})\n        .with_columns(pl.col(\"bday\").cast(pl.Int64))\n        .with_columns(pl.col(\"rate\").cast(pl.Float64))\n        .drop_nulls()\n        .drop_nans()\n        .unique(subset=\"bday\", keep=\"last\")\n        .sort(\"bday\")\n    )\n    self._df = df\n    self._method = str(method)\n    self._known_bdays = tuple(df.get_column(\"bday\"))\n    self._known_rates = tuple(df.get_column(\"rate\"))\n    self._extrapolate = bool(extrapolate)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__call__","title":"<code>__call__(bday)</code>","text":"<p>Allows the instance to be called as a function to perform interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The interest rate interpolated by the specified method for the given number of business days. If the input is out of range and extrapolation is disabled, returns None.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __call__(self, bday: int) -&gt; float | None:\n    \"\"\"\n    Allows the instance to be called as a function to perform interpolation.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float | None: The interest rate interpolated by the specified method for\n            the given number of business days. If the input is out of range and\n            extrapolation is disabled, returns None.\n    \"\"\"\n    return self.interpolate(bday)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of known business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the number of known business days.\"\"\"\n    return len(self._df)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__repr__","title":"<code>__repr__()</code>","text":"<p>Textual representation, used in terminal or scripts.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Textual representation, used in terminal or scripts.\"\"\"\n    return repr(self._df)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.flat_forward","title":"<code>flat_forward(bday, k)</code>","text":"<p>Performs the interest rate interpolation using the flat forward method.</p> <p>This method calculates the interpolated interest rate for a given number of business days (<code>bday</code>) using the flat forward methodology, based on two known points: the current point (<code>k</code>) and the previous point (<code>j</code>).</p> <p>Assuming interest rates are in decimal form, the interpolated rate is calculated. Time is measured in years based on a 252-business-day year.</p> <p>The interpolated rate is given by the formula:</p> \\[ \\left(f_j*\\left(\\frac{f_k}{f_j}\\right)^{f_t}\\right)^{\\frac{1}{time}}-1 \\] <p>Where the factors used in the formula are defined as:</p> <ul> <li><code>f\u2c7c = (1 + rate\u2c7c)^time\u2c7c</code> is the compounding factor at point <code>j</code>.</li> <li><code>f\u2096 = (1 + rate\u2096)^time\u2096</code> is the compounding factor at point <code>k</code>.</li> <li><code>f\u209c = (time - time\u2c7c)/(time\u2096 - time\u2c7c)</code> is the time factor.</li> </ul> <p>And the variables are defined as:</p> <ul> <li><code>time = bday/252</code> is the time in years for the interpolated point. <code>bday</code> is  the number of business days for the interpolated point (input to this method).</li> <li><code>k</code> is the index of the current known point.</li> <li><code>time\u2096 = bday\u2096/252</code> is the time in years of point <code>k</code>.</li> <li><code>rate\u2096</code> is the interest rate (decimal) at point <code>k</code>.</li> <li><code>j</code> is the index of the previous known point (<code>k - 1</code>).</li> <li><code>time\u2c7c = bday\u2c7c/252</code> is the time in years of point <code>j</code>.</li> <li><code>rate\u2c7c</code> is the interest rate (decimal) at point <code>j</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of bus. days for which the rate is to be interpolated.</p> required <code>k</code> <code>int</code> <p>The index in the known_bdays and known_rates arrays such that      known_bdays[k-1] &lt; bday &lt; known_bdays[k]. This <code>k</code> corresponds      to the index of the next known point after <code>bday</code>.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interpolated interest rate in decimal form.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def flat_forward(self, bday: int, k: int) -&gt; float:\n    r\"\"\"\n    Performs the interest rate interpolation using the flat forward method.\n\n    This method calculates the interpolated interest rate for a given\n    number of business days (`bday`) using the flat forward methodology,\n    based on two known points: the current point (`k`) and the previous point (`j`).\n\n    Assuming interest rates are in decimal form, the interpolated rate\n    is calculated. Time is measured in years based on a 252-business-day year.\n\n    The interpolated rate is given by the formula:\n\n    $$\n    \\left(f_j*\\left(\\frac{f_k}{f_j}\\right)^{f_t}\\right)^{\\frac{1}{time}}-1\n    $$\n\n    Where the factors used in the formula are defined as:\n\n    * `f\u2c7c = (1 + rate\u2c7c)^time\u2c7c` is the compounding factor at point `j`.\n    * `f\u2096 = (1 + rate\u2096)^time\u2096` is the compounding factor at point `k`.\n    * `f\u209c = (time - time\u2c7c)/(time\u2096 - time\u2c7c)` is the time factor.\n\n    And the variables are defined as:\n\n    * `time = bday/252` is the time in years for the interpolated point. `bday` is\n     the number of business days for the interpolated point (input to this method).\n    * `k` is the index of the current known point.\n    * `time\u2096 = bday\u2096/252` is the time in years of point `k`.\n    * `rate\u2096` is the interest rate (decimal) at point `k`.\n    * `j` is the index of the previous known point (`k - 1`).\n    * `time\u2c7c = bday\u2c7c/252` is the time in years of point `j`.\n    * `rate\u2c7c` is the interest rate (decimal) at point `j`.\n\n    Args:\n        bday (int): Number of bus. days for which the rate is to be interpolated.\n        k (int): The index in the known_bdays and known_rates arrays such that\n                 known_bdays[k-1] &lt; bday &lt; known_bdays[k]. This `k` corresponds\n                 to the index of the next known point after `bday`.\n\n    Returns:\n        float: The interpolated interest rate in decimal form.\n    \"\"\"\n    rate_j = self._known_rates[k - 1]\n    time_j = self._known_bdays[k - 1] / 252\n    rate_k = self._known_rates[k]\n    time_k = self._known_bdays[k] / 252\n    time = bday / 252\n\n    # Perform flat forward interpolation\n    f_j = (1 + rate_j) ** time_j\n    f_k = (1 + rate_k) ** time_k\n    f_t = (time - time_j) / (time_k - time_j)\n    return (f_j * (f_k / f_j) ** f_t) ** (1 / time) - 1\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.interpolate","title":"<code>interpolate(bday)</code>","text":"<p>Finds the appropriate interpolation point and returns the interest rate interpolated by the specified method from that point.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The interest rate interpolated by the specified method for the given number of business days. If the input is out of range and extrapolation is disabled, returns None.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bday: int) -&gt; float | None:\n    \"\"\"\n    Finds the appropriate interpolation point and returns the interest rate\n    interpolated by the specified method from that point.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float | None: The interest rate interpolated by the specified method for\n            the given number of business days. If the input is out of range and\n            extrapolation is disabled, returns None.\n    \"\"\"\n    # Validate input\n    if not isinstance(bday, int) or bday &lt; 0:\n        return None\n\n    # Create local references to facilitate code readability\n    known_bdays = self._known_bdays\n    known_rates = self._known_rates\n    extrapolate = self._extrapolate\n    method = self._method\n\n    # Lower bound extrapolation is always the first known rate\n    if bday &lt; known_bdays[0]:\n        return known_rates[0]\n    # Upper bound extrapolation depends on the extrapolate flag\n    elif bday &gt; known_bdays[-1]:\n        return known_rates[-1] if extrapolate else None\n\n    # Find k such that known_bdays[k-1] &lt; bday &lt; known_bdays[k]\n    k = bisect.bisect_left(known_bdays, bday)\n\n    # If bday is one of the known points, return its rate directly\n    if k &lt; len(known_bdays) and known_bdays[k] == bday:\n        return known_rates[k]\n\n    if method == \"linear\":\n        return self.linear(bday, k)\n    elif method == \"flat_forward\":\n        return self.flat_forward(bday, k)\n\n    raise ValueError(f\"Interpolation method '{method}' not recognized.\")\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.linear","title":"<code>linear(bday, k)</code>","text":"<p>Performs the interest rate interpolation using the linear method.</p> <p>The interpolated rate is given by the formula: y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)</p> <p>Where: - (x, y) is the point to be interpolated (bday, interpolated_rate). - (x1, y1) is the previous known point (bday_j, rate_j). - (x2, y2) is the next known point (bday_k, rate_k).</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of bus. days for which the rate is to be interpolated.</p> required <code>k</code> <code>int</code> <p>The index such that known_bdays[k-1] &lt; bday &lt; known_bdays[k].</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interpolated interest rate in decimal form.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def linear(self, bday: int, k: int) -&gt; float:\n    \"\"\"\n    Performs the interest rate interpolation using the linear method.\n\n    The interpolated rate is given by the formula:\n    y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)\n\n    Where:\n    - (x, y) is the point to be interpolated (bday, interpolated_rate).\n    - (x1, y1) is the previous known point (bday_j, rate_j).\n    - (x2, y2) is the next known point (bday_k, rate_k).\n\n    Args:\n        bday (int): Number of bus. days for which the rate is to be interpolated.\n        k (int): The index such that known_bdays[k-1] &lt; bday &lt; known_bdays[k].\n\n    Returns:\n        float: The interpolated interest rate in decimal form.\n    \"\"\"\n    # Get the bracketing points for interpolation\n    bday_j, rate_j = self._known_bdays[k - 1], self._known_rates[k - 1]\n    bday_k, rate_k = self._known_bdays[k], self._known_rates[k]\n\n    # Perform linear interpolation\n    return rate_j + (bday - bday_j) * (rate_k - rate_j) / (bday_k - bday_j)\n</code></pre>"},{"location":"ipca/","title":"IPCA Data","text":""},{"location":"ipca/#pyield.ipca.indexes","title":"<code>indexes(start, end)</code>","text":"<p>Retrieves the IPCA index values for a specified date range.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]</p> <p>Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date of the date range</p> required <code>end</code> <code>DateScalar</code> <p>The end date of the date range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Get the IPCA indexes for the first quarter of 2025\n&gt;&gt;&gt; ipca.indexes(start=\"01-01-2025\", end=\"01-03-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Period \u2506 Value   \u2502\n\u2502 ---    \u2506 ---     \u2502\n\u2502 i64    \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 202501 \u2506 7111.86 \u2502\n\u2502 202502 \u2506 7205.03 \u2502\n\u2502 202503 \u2506 7245.38 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def indexes(start: DateScalar, end: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves the IPCA index values for a specified date range.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]\n\n    Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]\n\n    Args:\n        start (DateScalar): The start date of the date range\n        end (DateScalar): The end date of the date range\n\n    Returns:\n        pl.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Get the IPCA indexes for the first quarter of 2025\n        &gt;&gt;&gt; ipca.indexes(start=\"01-01-2025\", end=\"01-03-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Period \u2506 Value   \u2502\n        \u2502 ---    \u2506 ---     \u2502\n        \u2502 i64    \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 202501 \u2506 7111.86 \u2502\n        \u2502 202502 \u2506 7205.03 \u2502\n        \u2502 202503 \u2506 7245.38 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(start, end):\n        return pl.DataFrame()\n    start = convert_dates(start)\n    end = convert_dates(end)\n\n    start_date = start.strftime(\"%Y%m\")\n    end_date = end.strftime(\"%Y%m\")\n    api_url = f\"{IPCA_URL}{start_date}-{end_date}/variaveis/2266?localidades=N1[all]\"\n    data_dict = _fetch_api_data(api_url)\n\n    return _process_ipca_dataframe(data_dict)\n</code></pre>"},{"location":"ipca/#pyield.ipca.last_indexes","title":"<code>last_indexes(num_months=1)</code>","text":"<p>Retrieves the last IPCA index values for a specified number of months.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]</p> <p>Example: For the last 2 months, the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>Number of months to retrieve. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Get the last month's IPCA index\n&gt;&gt;&gt; df = ipca.last_indexes(1)\n&gt;&gt;&gt; # Get the last 3 months' IPCA indexes\n&gt;&gt;&gt; df = ipca.last_indexes(3)\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def last_indexes(num_months: int = 1) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves the last IPCA index values for a specified number of months.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]\n\n    Example: For the last 2 months, the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]\n\n    Args:\n        num_months (int, optional): Number of months to retrieve. Defaults to 1.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Get the last month's IPCA index\n        &gt;&gt;&gt; df = ipca.last_indexes(1)\n        &gt;&gt;&gt; # Get the last 3 months' IPCA indexes\n        &gt;&gt;&gt; df = ipca.last_indexes(3)\n    \"\"\"\n    num_months = abs(num_months)\n    if num_months == 0:\n        return pl.DataFrame()\n\n    api_url = f\"{IPCA_URL}-{num_months}/variaveis/2266?localidades=N1[all]\"\n    data_dict = _fetch_api_data(api_url)\n\n    return _process_ipca_dataframe(data_dict)\n</code></pre>"},{"location":"ipca/#pyield.ipca.last_rates","title":"<code>last_rates(num_months=1)</code>","text":"<p>Retrieves the last IPCA monthly rates for a specified number of months.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]</p> <p>Example: For the last 2 months, the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>Number of months to retrieve. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If num_months is 0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Get the last month's IPCA rate\n&gt;&gt;&gt; df = ipca.last_rates(1)\n&gt;&gt;&gt; # Get the last 3 months' IPCA rates\n&gt;&gt;&gt; df = ipca.last_rates(3)\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def last_rates(num_months: int = 1) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves the last IPCA monthly rates for a specified number of months.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]\n\n    Example: For the last 2 months, the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]\n\n    Args:\n        num_months (int, optional): Number of months to retrieve. Defaults to 1.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Raises:\n        ValueError: If num_months is 0\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Get the last month's IPCA rate\n        &gt;&gt;&gt; df = ipca.last_rates(1)\n        &gt;&gt;&gt; # Get the last 3 months' IPCA rates\n        &gt;&gt;&gt; df = ipca.last_rates(3)\n    \"\"\"\n    num_months = abs(num_months)\n    if num_months == 0:\n        raise ValueError(\"The number of months must be greater than 0.\")\n\n    api_url = f\"{IPCA_URL}-{num_months}/variaveis/63?localidades=N1[all]\"\n    data_dict = _fetch_api_data(api_url)\n\n    return _process_ipca_dataframe(data_dict, is_in_pct=True)\n</code></pre>"},{"location":"ipca/#pyield.ipca.projected_rate","title":"<code>projected_rate()</code>","text":"<p>Retrieves the current IPCA projection from the ANBIMA website.</p> <p>This function makes an HTTP request to the ANBIMA website, extracts HTML tables containing economic indicators, and specifically processes the IPCA projection data.</p> Process <ol> <li>Accesses the ANBIMA indicators webpage</li> <li>Extracts the third table that contains the IPCA projection</li> <li>Locates the row labeled as \"IPCA1\"</li> <li>Extracts the projection value and converts it to decimal format</li> <li>Extracts and formats the reference month of the projection</li> <li>Extracts the date and time of the last update</li> </ol> <p>Returns:</p> Name Type Description <code>IndicatorProjection</code> <code>IndicatorProjection</code> <p>An object containing: - last_updated (dt.datetime): Date and time of the last data update - reference_period (str): Reference period of the projection as a string in   \"MMM/YY\" brazilian format (e.g., \"set/25\") - projected_value (float): Projected IPCA value as a decimal number</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If there are connection issues with the ANBIMA site</p> <code>ValueError</code> <p>If the expected data is not found in the page structure</p> Example <p>from pyield import ipca</p> Notes <ul> <li>The function requires internet connection to access the ANBIMA website</li> <li>The structure of the ANBIMA page may change, which could affect the function</li> </ul> Source code in <code>pyield/ipca/projected.py</code> <pre><code>def projected_rate() -&gt; IndicatorProjection:\n    \"\"\"\n    Retrieves the current IPCA projection from the ANBIMA website.\n\n    This function makes an HTTP request to the ANBIMA website, extracts HTML tables\n    containing economic indicators, and specifically processes the IPCA projection data.\n\n    Process:\n        1. Accesses the ANBIMA indicators webpage\n        2. Extracts the third table that contains the IPCA projection\n        3. Locates the row labeled as \"IPCA1\"\n        4. Extracts the projection value and converts it to decimal format\n        5. Extracts and formats the reference month of the projection\n        6. Extracts the date and time of the last update\n\n    Returns:\n        IndicatorProjection: An object containing:\n            - last_updated (dt.datetime): Date and time of the last data update\n            - reference_period (str): Reference period of the projection as a string in\n              \"MMM/YY\" brazilian format (e.g., \"set/25\")\n            - projected_value (float): Projected IPCA value as a decimal number\n\n    Raises:\n        requests.RequestException: If there are connection issues with the ANBIMA site\n        ValueError: If the expected data is not found in the page structure\n\n    Example:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Retrieve the current IPCA projection from ANBIMA\n        &gt;&gt;&gt; ipca.projected_rate()\n        IndicatorProjection(last_updated=..., reference_period=..., projected_value=...)\n\n    Notes:\n        - The function requires internet connection to access the ANBIMA website\n        - The structure of the ANBIMA page may change, which could affect the function\n    \"\"\"\n    page_text = _get_page_text()\n    df = _read_ipca_table(page_text)\n\n    last_update_str = df.iat[0, 0].split(\"Atualiza\u00e7\u00e3o:\")[-1].strip()\n    last_update = dt.datetime.strptime(last_update_str, \"%d/%m/%Y - %H:%M h\")\n\n    ipca_row = df.loc[df[0] == \"IPCA1\"]\n    ipca_value = ipca_row.iloc[0, 2]\n    ipca_value = float(ipca_value) / 100\n    ipca_value = round(ipca_value, 4)\n\n    # Extract and format the reference month\n    ipca_date = ipca_row.iloc[0, 1]\n    ipca_date = str(ipca_date)\n    ipca_date = ipca_date.split(\"(\")[-1].split(\")\")[0]\n\n    return IndicatorProjection(\n        last_updated=last_update,\n        reference_period=ipca_date,\n        projected_value=ipca_value,\n    )\n</code></pre>"},{"location":"ipca/#pyield.ipca.projected_rate--retrieve-the-current-ipca-projection-from-anbima","title":"Retrieve the current IPCA projection from ANBIMA","text":"<p>ipca.projected_rate() IndicatorProjection(last_updated=..., reference_period=..., projected_value=...)</p>"},{"location":"ipca/#pyield.ipca.rates","title":"<code>rates(start, end)</code>","text":"<p>Retrieves the IPCA monthly rates for a specified date range.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]</p> <p>Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date of the date range</p> required <code>end</code> <code>DateScalar</code> <p>The end date of the date range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns 'Period' and 'Rate'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Get the IPCA rates for the first quarter of 2025\n&gt;&gt;&gt; ipca.rates(\"01-01-2025\", \"01-03-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Period \u2506 Value  \u2502\n\u2502 ---    \u2506 ---    \u2502\n\u2502 i64    \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 202501 \u2506 0.0016 \u2502\n\u2502 202502 \u2506 0.0131 \u2502\n\u2502 202503 \u2506 0.0056 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def rates(start: DateScalar, end: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Retrieves the IPCA monthly rates for a specified date range.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]\n\n    Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]\n\n    Args:\n        start (DateScalar): The start date of the date range\n        end (DateScalar): The end date of the date range\n\n    Returns:\n        pl.DataFrame: DataFrame with columns 'Period' and 'Rate'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Get the IPCA rates for the first quarter of 2025\n        &gt;&gt;&gt; ipca.rates(\"01-01-2025\", \"01-03-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Period \u2506 Value  \u2502\n        \u2502 ---    \u2506 ---    \u2502\n        \u2502 i64    \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 202501 \u2506 0.0016 \u2502\n        \u2502 202502 \u2506 0.0131 \u2502\n        \u2502 202503 \u2506 0.0056 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(start, end):\n        return pl.DataFrame()\n    start = convert_dates(start)\n    end = convert_dates(end)\n\n    start_date = start.strftime(\"%Y%m\")\n    end_date = end.strftime(\"%Y%m\")\n    api_url = f\"{IPCA_URL}{start_date}-{end_date}/variaveis/63?localidades=N1[all]\"\n    data_dict = _fetch_api_data(api_url)\n\n    return _process_ipca_dataframe(data_dict, is_in_pct=True)\n</code></pre>"},{"location":"lft/","title":"LFT","text":""},{"location":"lft/#pyield.tn.lft.data","title":"<code>data(date)</code>","text":"<p>Fetch the LFT indicative rates for the given reference date from ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame containing the following columns: - ReferenceDate: The reference date for the data. - BondType: The type of bond. - MaturityDate: The maturity date of the LFT bond. - IndicativeRate: The Anbima indicative rate for the LFT bond. - Price: The price of the LFT bond.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.data(\"23-08-2024\")\nshape: (14, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000306  \u2506 0.000226  \u2506 0.000272       \u2506 0.10408  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000397 \u2506 -0.000481 \u2506 -0.000418      \u2506 0.11082  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000205 \u2506 -0.000258 \u2506 -0.00023       \u2506 0.114315 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000085  \u2506 0.00006   \u2506 0.000075       \u2506 0.114982 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000124  \u2506 0.000097  \u2506 0.000114       \u2506 0.114955 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001501  \u2506 0.001476  \u2506 0.001491       \u2506 0.11564  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001597  \u2506 0.001571  \u2506 0.001587       \u2506 0.115773 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001601  \u2506 0.001574  \u2506 0.001591       \u2506 0.115904 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001649  \u2506 0.001627  \u2506 0.001641       \u2506 0.115854 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001696  \u2506 0.00168   \u2506 0.001687       \u2506 0.115806 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def data(date: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the LFT indicative rates for the given reference date from ANBIMA.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame containing the following columns:\n            - ReferenceDate: The reference date for the data.\n            - BondType: The type of bond.\n            - MaturityDate: The maturity date of the LFT bond.\n            - IndicativeRate: The Anbima indicative rate for the LFT bond.\n            - Price: The price of the LFT bond.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.data(\"23-08-2024\")\n        shape: (14, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000306  \u2506 0.000226  \u2506 0.000272       \u2506 0.10408  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000397 \u2506 -0.000481 \u2506 -0.000418      \u2506 0.11082  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000205 \u2506 -0.000258 \u2506 -0.00023       \u2506 0.114315 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000085  \u2506 0.00006   \u2506 0.000075       \u2506 0.114982 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000124  \u2506 0.000097  \u2506 0.000114       \u2506 0.114955 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001501  \u2506 0.001476  \u2506 0.001491       \u2506 0.11564  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001597  \u2506 0.001571  \u2506 0.001587       \u2506 0.115773 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001601  \u2506 0.001574  \u2506 0.001591       \u2506 0.115904 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001649  \u2506 0.001627  \u2506 0.001641       \u2506 0.115854 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001696  \u2506 0.00168   \u2506 0.001687       \u2506 0.115806 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"LFT\")\n</code></pre>"},{"location":"lft/#pyield.tn.lft.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series of bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.maturities(\"22-08-2024\")\nshape: (14,)\nSeries: 'MaturityDate' [date]\n[\n    2024-09-01\n    2025-03-01\n    2025-09-01\n    2026-03-01\n    2026-09-01\n    \u2026\n    2029-03-01\n    2029-09-01\n    2030-03-01\n    2030-06-01\n    2030-09-01\n]\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pl.Series:\n    \"\"\"\n    Fetch the bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.Series: A Series of bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.maturities(\"22-08-2024\")\n        shape: (14,)\n        Series: 'MaturityDate' [date]\n        [\n            2024-09-01\n            2025-03-01\n            2025-09-01\n            2026-03-01\n            2026-09-01\n            \u2026\n            2029-03-01\n            2029-09-01\n            2030-03-01\n            2030-06-01\n            2030-09-01\n        ]\n    \"\"\"\n    df_rates = data(date)\n    return df_rates[\"MaturityDate\"]\n</code></pre>"},{"location":"lft/#pyield.tn.lft.premium","title":"<code>premium(lft_rate, di_rate)</code>","text":"<p>Calculate the premium of the LFT bond over the DI Futures rate.</p> <p>Parameters:</p> Name Type Description Default <code>lft_rate</code> <code>float</code> <p>The annualized trading rate over the selic rate for the bond.</p> required <code>di_rate</code> <code>float</code> <p>The DI Futures annualized yield rate (interpolated to the same maturity as the LFT).</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The premium of the LFT bond over the DI Futures rate.</p> <p>Examples:</p> <p>Calculate the premium of a LFT in 28/04/2025</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft_rate = 0.001124  # 0.1124%\n&gt;&gt;&gt; di_rate = 0.13967670224373396  # 13.967670224373396%\n&gt;&gt;&gt; lft.premium(lft_rate, di_rate)\n1.008594331960501\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def premium(lft_rate: float, di_rate: float) -&gt; float | None:\n    \"\"\"\n    Calculate the premium of the LFT bond over the DI Futures rate.\n\n    Args:\n        lft_rate (float): The annualized trading rate over the selic rate for the bond.\n        di_rate (float): The DI Futures annualized yield rate (interpolated to the same\n            maturity as the LFT).\n\n    Returns:\n        float | None: The premium of the LFT bond over the DI Futures rate.\n\n    Examples:\n        Calculate the premium of a LFT in 28/04/2025\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft_rate = 0.001124  # 0.1124%\n        &gt;&gt;&gt; di_rate = 0.13967670224373396  # 13.967670224373396%\n        &gt;&gt;&gt; lft.premium(lft_rate, di_rate)\n        1.008594331960501\n    \"\"\"\n    if has_null_args(lft_rate, di_rate):\n        return None\n    # daily rate\n    ltt_factor = (lft_rate + 1) ** (1 / 252)\n    di_factor = (di_rate + 1) ** (1 / 252)\n    return (ltt_factor * di_factor - 1) / (di_factor - 1)\n</code></pre>"},{"location":"lft/#pyield.tn.lft.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the quotation of a LFT bond using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the bond.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The annualized yield rate of the bond</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The quotation of the bond.</p> <p>Examples:</p> <p>Calculate the quotation of a LFT bond with a 0.02 yield rate:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.quotation(\n...     settlement=\"24-07-2024\",\n...     maturity=\"01-09-2030\",\n...     rate=0.001717,  # 0.1717%\n... )\n98.9645\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def quotation(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the quotation of a LFT bond using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date of the bond.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The annualized yield rate of the bond\n\n    Returns:\n        float | None: The quotation of the bond.\n\n    Examples:\n        Calculate the quotation of a LFT bond with a 0.02 yield rate:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.quotation(\n        ...     settlement=\"24-07-2024\",\n        ...     maturity=\"01-09-2030\",\n        ...     rate=0.001717,  # 0.1717%\n        ... )\n        98.9645\n    \"\"\"\n    # Validate and normalize dates\n    if has_null_args(settlement, maturity, rate):\n        return None\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # The number of bdays between settlement (inclusive) and the maturity (exclusive)\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = tools.truncate(bdays / 252, 14)\n\n    discount_factor = 1 / (1 + rate) ** num_of_years\n\n    return tools.truncate(100 * discount_factor, 4)\n</code></pre>"},{"location":"ltn/","title":"LTN","text":""},{"location":"ltn/#pyield.tn.ltn.data","title":"<code>data(date)</code>","text":"<p>Fetch the LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.data(\"23-08-2024\")\nshape: (13, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-07-08    \u2506 \u2026 \u2506 0.10459  \u2506 0.104252 \u2506 0.104416       \u2506 0.10472 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2018-02-01    \u2506 \u2026 \u2506 0.107366 \u2506 0.107016 \u2506 0.107171       \u2506 0.10823 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-01-06    \u2506 \u2026 \u2506 0.110992 \u2506 0.110746 \u2506 0.110866       \u2506 0.11179 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.11315  \u2506 0.112947 \u2506 0.113032       \u2506 0.11365 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.114494 \u2506 0.114277 \u2506 0.114374       \u2506 0.11463 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026       \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.115424 \u2506 0.115283 \u2506 0.115357       \u2506 0.11494 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.115452 \u2506 0.115247 \u2506 0.115335       \u2506 0.11498 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.115758 \u2506 0.115633 \u2506 0.115694       \u2506 0.11508 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.11647  \u2506 0.116341 \u2506 0.116417       \u2506 0.11554 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.117504 \u2506 0.11737  \u2506 0.117436       \u2506 0.11594 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def data(date: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.data(\"23-08-2024\")\n        shape: (13, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-07-08    \u2506 \u2026 \u2506 0.10459  \u2506 0.104252 \u2506 0.104416       \u2506 0.10472 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2018-02-01    \u2506 \u2026 \u2506 0.107366 \u2506 0.107016 \u2506 0.107171       \u2506 0.10823 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-01-06    \u2506 \u2026 \u2506 0.110992 \u2506 0.110746 \u2506 0.110866       \u2506 0.11179 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.11315  \u2506 0.112947 \u2506 0.113032       \u2506 0.11365 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.114494 \u2506 0.114277 \u2506 0.114374       \u2506 0.11463 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026       \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.115424 \u2506 0.115283 \u2506 0.115357       \u2506 0.11494 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.115452 \u2506 0.115247 \u2506 0.115335       \u2506 0.11498 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.115758 \u2506 0.115633 \u2506 0.115694       \u2506 0.11508 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.11647  \u2506 0.116341 \u2506 0.116417       \u2506 0.11554 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.117504 \u2506 0.11737  \u2506 0.117436       \u2506 0.11594 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>Defini\u00e7\u00e3o do spread (forma bruta):     DISpread_raw = IndicativeRate - SettlementRate</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - BondType - MaturityDate - DISpread (decimal ou bps conforme par\u00e2metro)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.di_spreads(\"30-05-2025\", bps=True)\nshape: (13, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 LTN      \u2506 2028-01-01   \u2506 0.55     \u2502\n\u2502 LTN      \u2506 2028-07-01   \u2506 1.5      \u2502\n\u2502 LTN      \u2506 2029-01-01   \u2506 10.77    \u2502\n\u2502 LTN      \u2506 2030-01-01   \u2506 11.0     \u2502\n\u2502 LTN      \u2506 2032-01-01   \u2506 11.24    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def di_spreads(date: DateScalar, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    Defini\u00e7\u00e3o do spread (forma bruta):\n        DISpread_raw = IndicativeRate - SettlementRate\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateScalar): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Default False.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - BondType\n            - MaturityDate\n            - DISpread (decimal ou bps conforme par\u00e2metro)\n\n    Raises:\n        ValueError: Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.di_spreads(\"30-05-2025\", bps=True)\n        shape: (13, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 LTN      \u2506 2028-01-01   \u2506 0.55     \u2502\n        \u2502 LTN      \u2506 2028-07-01   \u2506 1.5      \u2502\n        \u2502 LTN      \u2506 2029-01-01   \u2506 10.77    \u2502\n        \u2502 LTN      \u2506 2030-01-01   \u2506 11.0     \u2502\n        \u2502 LTN      \u2506 2032-01-01   \u2506 11.24    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return pre_di_spreads(date, bps=bps).filter(pl.col(\"BondType\") == \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.dv01","title":"<code>dv01(settlement, maturity, rate)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an LTN in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the LTN.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.dv01(\"26-03-2025\", \"01-01-2032\", 0.150970)\n0.2269059999999854\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def dv01(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an LTN in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a date-like object.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a date-like object.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the LTN.\n\n    Returns:\n        float | None: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.dv01(\"26-03-2025\", \"01-01-2032\", 0.150970)\n        0.2269059999999854\n    \"\"\"\n    if has_null_args(settlement, maturity, rate):\n        return None\n    price1 = price(settlement, maturity, rate)\n    price2 = price(settlement, maturity, rate + 0.0001)\n    return price1 - price2\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.forwards","title":"<code>forwards(date)</code>","text":"<p>Calcula as taxas forward da LTN para uma data de refer\u00eancia.</p> <p>As taxas indicativas da LTN j\u00e1 s\u00e3o spot (zero-coupon) por constru\u00e7\u00e3o, pois o t\u00edtulo n\u00e3o paga cupons. Portanto o c\u00e1lculo de forward \u00e9 direto usando a estrutura de vencimentos e suas taxas.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>Data de refer\u00eancia das taxas indicativas.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - MaturityDate - BDToMat - IndicativeRate (spot) - ForwardRate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.forwards(\"17-10-2025\")\nshape: (13, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n\u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2026-01-01   \u2506 52      \u2506 0.148307       \u2506 0.148307    \u2502\n\u2502 2026-04-01   \u2506 113     \u2506 0.147173       \u2506 0.146207    \u2502\n\u2502 2026-07-01   \u2506 174     \u2506 0.145206       \u2506 0.141571    \u2502\n\u2502 2026-10-01   \u2506 239     \u2506 0.142424       \u2506 0.13501     \u2502\n\u2502 2027-04-01   \u2506 361     \u2506 0.138155       \u2506 0.129838    \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2028-07-01   \u2506 676     \u2506 0.133411       \u2506 0.131654    \u2502\n\u2502 2029-01-01   \u2506 800     \u2506 0.134254       \u2506 0.138861    \u2502\n\u2502 2029-07-01   \u2506 924     \u2506 0.135264       \u2506 0.141802    \u2502\n\u2502 2030-01-01   \u2506 1049    \u2506 0.135967       \u2506 0.141177    \u2502\n\u2502 2032-01-01   \u2506 1553    \u2506 0.13883        \u2506 0.144812    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def forwards(date: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"Calcula as taxas forward da LTN para uma data de refer\u00eancia.\n\n    As taxas indicativas da LTN j\u00e1 s\u00e3o spot (zero-coupon) por constru\u00e7\u00e3o, pois o\n    t\u00edtulo n\u00e3o paga cupons. Portanto o c\u00e1lculo de forward \u00e9 direto usando a\n    estrutura de vencimentos e suas taxas.\n\n    Args:\n        date (DateScalar): Data de refer\u00eancia das taxas indicativas.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - MaturityDate\n            - BDToMat\n            - IndicativeRate (spot)\n            - ForwardRate\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.forwards(\"17-10-2025\")\n        shape: (13, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n        \u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2026-01-01   \u2506 52      \u2506 0.148307       \u2506 0.148307    \u2502\n        \u2502 2026-04-01   \u2506 113     \u2506 0.147173       \u2506 0.146207    \u2502\n        \u2502 2026-07-01   \u2506 174     \u2506 0.145206       \u2506 0.141571    \u2502\n        \u2502 2026-10-01   \u2506 239     \u2506 0.142424       \u2506 0.13501     \u2502\n        \u2502 2027-04-01   \u2506 361     \u2506 0.138155       \u2506 0.129838    \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2028-07-01   \u2506 676     \u2506 0.133411       \u2506 0.131654    \u2502\n        \u2502 2029-01-01   \u2506 800     \u2506 0.134254       \u2506 0.138861    \u2502\n        \u2502 2029-07-01   \u2506 924     \u2506 0.135264       \u2506 0.141802    \u2502\n        \u2502 2030-01-01   \u2506 1049    \u2506 0.135967       \u2506 0.141177    \u2502\n        \u2502 2032-01-01   \u2506 1553    \u2506 0.13883        \u2506 0.144812    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(date):\n        return pl.DataFrame()\n    df = data(date).select(\"MaturityDate\", \"BDToMat\", \"IndicativeRate\")\n    fwd_rates = fwd.forwards(bdays=df[\"BDToMat\"], rates=df[\"IndicativeRate\"])\n    return df.with_columns(ForwardRate=fwd_rates).sort(\"MaturityDate\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series of bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.maturities(\"22-08-2024\")\nshape: (13,)\nSeries: 'MaturityDate' [date]\n[\n    2024-10-01\n    2025-01-01\n    2025-04-01\n    2025-07-01\n    2025-10-01\n    \u2026\n    2026-10-01\n    2027-07-01\n    2028-01-01\n    2028-07-01\n    2030-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pl.Series:\n    \"\"\"\n    Fetch the bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.Series: A Series of bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.maturities(\"22-08-2024\")\n        shape: (13,)\n        Series: 'MaturityDate' [date]\n        [\n            2024-10-01\n            2025-01-01\n            2025-04-01\n            2025-07-01\n            2025-10-01\n            \u2026\n            2026-10-01\n            2027-07-01\n            2028-01-01\n            2028-07-01\n            2030-01-01\n        ]\n    \"\"\"\n    df_rates = data(date)\n    return df_rates[\"MaturityDate\"]\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.premium","title":"<code>premium(ltn_rate, di_rate)</code>","text":"<p>Calculate the premium of the LTN bond over the DI Future rate using provided rates.</p> <p>Parameters:</p> Name Type Description Default <code>ltn_rate</code> <code>float</code> <p>The annualized LTN rate.</p> required <code>di_rate</code> <code>float</code> <p>The annualized DI Future rate.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The premium of the LTN bond over the DI Future rate.</p> <p>Examples:</p> <p>Reference date: 22-08-2024 LTN rate for 01-01-2030: 0.118746 DI (JAN30) Settlement rate: 0.11725</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.premium(0.118746, 0.11725)\n1.0120718007994287\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def premium(ltn_rate: float, di_rate: float) -&gt; float | None:\n    \"\"\"\n    Calculate the premium of the LTN bond over the DI Future rate using provided rates.\n\n    Args:\n        ltn_rate (float): The annualized LTN rate.\n        di_rate (float): The annualized DI Future rate.\n\n    Returns:\n        float | None: The premium of the LTN bond over the DI Future rate.\n\n    Examples:\n        Reference date: 22-08-2024\n        LTN rate for 01-01-2030: 0.118746\n        DI (JAN30) Settlement rate: 0.11725\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.premium(0.118746, 0.11725)\n        1.0120718007994287\n    \"\"\"\n    if has_null_args(ltn_rate, di_rate):\n        return None\n    # C\u00e1lculo das taxas di\u00e1rias\n    ltn_daily_rate = (1 + ltn_rate) ** (1 / 252) - 1\n    di_daily_rate = (1 + di_rate) ** (1 / 252) - 1\n\n    # Retorno do c\u00e1lculo do pr\u00eamio\n    return ltn_daily_rate / di_daily_rate\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the LTN price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-F.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The LTN price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n535.279902\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def price(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the LTN price using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a date-like object.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a date-like object.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-F.\n\n    Returns:\n        float | None: The LTN price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n        535.279902\n    \"\"\"\n    # Validate and normalize inputs\n    if has_null_args(settlement, maturity, rate):\n        return None\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rule\n    num_of_years = tools.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Truncate the price to 6 decimal places as per Anbima rules\n    return tools.truncate(FACE_VALUE / discount_factor, 6)\n</code></pre>"},{"location":"ntnb/","title":"NTN-B","text":""},{"location":"ntnb/#pyield.tn.ntnb.bei_rates","title":"<code>bei_rates(settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates)</code>","text":"<p>Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real interest rates. The BEI represents the inflation rate that equalizes the real and nominal yields. The calculation is based on the spot rates for NTN-B bonds.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>ntnb_maturities</code> <code>DateArray</code> <p>The maturity dates for the NTN-B bonds.</p> required <code>ntnb_rates</code> <code>FloatArray</code> <p>The real interest rates (Yield to Maturity - YTM) corresponding to the given NTN-B maturities.</p> required <code>nominal_maturities</code> <code>DateArray</code> <p>The maturity dates to be used as reference for nominal rates.</p> required <code>nominal_rates</code> <code>FloatArray</code> <p>The nominal interest rates (e.g. DI Futures or  zero prefixed bonds rates) used as reference for the calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame containing the calculated breakeven inflation rates.</p> Returned columns <ul> <li>MaturityDate: The maturity date of the bonds.</li> <li>BDToMat: The number of business days from the settlement to the maturity.</li> <li>RIR: The calculated Real Interest Rates based on the spot rates.</li> <li>NIR: The Nominal Interest Rates interpolated for the maturity date.</li> <li>BEI: The calculated Breakeven Inflation Rates.</li> </ul> Notes <p>The BEI is calculated by comparing the nominal and real interest rates, indicating the market's inflation expectations over the period from the settlement date to the bond's maturity.</p> <p>Examples:</p> <p>Get the NTN-B rates for a specific reference date. These are YTM rates and the spot rates are calculated based on them</p> <pre><code>&gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n</code></pre> <p>Get the DI Futures settlement rates for the same reference date to be used as reference for the nominal rates:</p> <pre><code>&gt;&gt;&gt; df_di = yd.di1.data(\"05-09-2024\")\n</code></pre> <p>Calculate the BEI rates considering the settlement at the reference date:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.bei_rates(\n...     settlement=\"05-09-2024\",\n...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n...     nominal_maturities=df_di[\"ExpirationDate\"],\n...     nominal_rates=df_di[\"SettlementRate\"],\n... )\nshape: (14, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 RIR      \u2506 NIR      \u2506 BEI      \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2506 ---      \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-05-15   \u2506 171     \u2506 0.061748 \u2506 0.113836 \u2506 0.049059 \u2502\n\u2502 2026-08-15   \u2506 488     \u2506 0.066133 \u2506 0.117126 \u2506 0.04783  \u2502\n\u2502 2027-05-15   \u2506 673     \u2506 0.063816 \u2506 0.117169 \u2506 0.050152 \u2502\n\u2502 2028-08-15   \u2506 988     \u2506 0.063635 \u2506 0.11828  \u2506 0.051376 \u2502\n\u2502 2029-05-15   \u2506 1172    \u2506 0.062532 \u2506 0.11838  \u2506 0.052561 \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2506 \u2026        \u2506 \u2026        \u2502\n\u2502 2040-08-15   \u2506 3995    \u2506 0.060468 \u2506 0.11759  \u2506 0.053865 \u2502\n\u2502 2045-05-15   \u2506 5182    \u2506 0.0625   \u2506 0.11759  \u2506 0.05185  \u2502\n\u2502 2050-08-15   \u2506 6497    \u2506 0.063016 \u2506 0.11759  \u2506 0.051339 \u2502\n\u2502 2055-05-15   \u2506 7686    \u2506 0.062252 \u2506 0.11759  \u2506 0.052095 \u2502\n\u2502 2060-08-15   \u2506 9003    \u2506 0.063001 \u2506 0.11759  \u2506 0.051354 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def bei_rates(\n    settlement: DateScalar,\n    ntnb_maturities: DateArray,\n    ntnb_rates: FloatArray,\n    nominal_maturities: DateArray,\n    nominal_rates: FloatArray,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real\n    interest rates. The BEI represents the inflation rate that equalizes the real and\n    nominal yields. The calculation is based on the spot rates for NTN-B bonds.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        ntnb_maturities (DateArray): The maturity dates for the NTN-B bonds.\n        ntnb_rates (FloatArray): The real interest rates (Yield to Maturity - YTM)\n            corresponding to the given NTN-B maturities.\n        nominal_maturities (DateArray): The maturity dates to be used as reference for\n            nominal rates.\n        nominal_rates (FloatArray): The nominal interest rates (e.g. DI Futures or\n             zero prefixed bonds rates) used as reference for the calculation.\n\n    Returns:\n        pl.DataFrame: DataFrame containing the calculated breakeven inflation rates.\n\n    Returned columns:\n        - MaturityDate: The maturity date of the bonds.\n        - BDToMat: The number of business days from the settlement to the maturity.\n        - RIR: The calculated Real Interest Rates based on the spot rates.\n        - NIR: The Nominal Interest Rates interpolated for the maturity date.\n        - BEI: The calculated Breakeven Inflation Rates.\n\n    Notes:\n        The BEI is calculated by comparing the nominal and real interest rates,\n        indicating the market's inflation expectations over the period from the\n        settlement date to the bond's maturity.\n\n    Examples:\n        Get the NTN-B rates for a specific reference date.\n        These are YTM rates and the spot rates are calculated based on them\n        &gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n\n        Get the DI Futures settlement rates for the same reference date to be used as\n        reference for the nominal rates:\n        &gt;&gt;&gt; df_di = yd.di1.data(\"05-09-2024\")\n\n        Calculate the BEI rates considering the settlement at the reference date:\n        &gt;&gt;&gt; yd.ntnb.bei_rates(\n        ...     settlement=\"05-09-2024\",\n        ...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n        ...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n        ...     nominal_maturities=df_di[\"ExpirationDate\"],\n        ...     nominal_rates=df_di[\"SettlementRate\"],\n        ... )\n        shape: (14, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 RIR      \u2506 NIR      \u2506 BEI      \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2506 ---      \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2506 f64      \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-05-15   \u2506 171     \u2506 0.061748 \u2506 0.113836 \u2506 0.049059 \u2502\n        \u2502 2026-08-15   \u2506 488     \u2506 0.066133 \u2506 0.117126 \u2506 0.04783  \u2502\n        \u2502 2027-05-15   \u2506 673     \u2506 0.063816 \u2506 0.117169 \u2506 0.050152 \u2502\n        \u2502 2028-08-15   \u2506 988     \u2506 0.063635 \u2506 0.11828  \u2506 0.051376 \u2502\n        \u2502 2029-05-15   \u2506 1172    \u2506 0.062532 \u2506 0.11838  \u2506 0.052561 \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2506 \u2026        \u2506 \u2026        \u2502\n        \u2502 2040-08-15   \u2506 3995    \u2506 0.060468 \u2506 0.11759  \u2506 0.053865 \u2502\n        \u2502 2045-05-15   \u2506 5182    \u2506 0.0625   \u2506 0.11759  \u2506 0.05185  \u2502\n        \u2502 2050-08-15   \u2506 6497    \u2506 0.063016 \u2506 0.11759  \u2506 0.051339 \u2502\n        \u2502 2055-05-15   \u2506 7686    \u2506 0.062252 \u2506 0.11759  \u2506 0.052095 \u2502\n        \u2502 2060-08-15   \u2506 9003    \u2506 0.063001 \u2506 0.11759  \u2506 0.051354 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(\n        settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates\n    ):\n        return pl.DataFrame()\n    # Normalize input dates\n    settlement = cv.convert_dates(settlement)\n    ntnb_maturities = cv.convert_dates(ntnb_maturities)\n\n    nir_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, nominal_maturities),\n        known_rates=nominal_rates,\n        extrapolate=True,\n    )\n\n    df = (\n        spot_rates(settlement, ntnb_maturities, ntnb_rates)\n        .rename({\"SpotRate\": \"RIR\"})\n        .with_columns(\n            NIR=pl.col(\"BDToMat\").map_elements(\n                nir_interpolator, return_dtype=pl.Float64\n            )\n        )\n        .with_columns(\n            BEI=((pl.col(\"NIR\") + 1) / (pl.col(\"RIR\") + 1)) - 1,\n        )\n        .select(\"MaturityDate\", \"BDToMat\", \"RIR\", \"NIR\", \"BEI\")\n    )\n\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Generate the cash flows for NTN-B bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exclusive) to start generating the cash flows.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-15  \u2506 2.956301   \u2502\n\u2502 2024-11-15  \u2506 2.956301   \u2502\n\u2502 2025-05-15  \u2506 102.956301 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def cash_flows(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-B bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (DateScalar): The settlement date (exclusive) to start generating\n            the cash flows.\n        maturity (DateScalar): The maturity date of the bond.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-15  \u2506 2.956301   \u2502\n        \u2502 2024-11-15  \u2506 2.956301   \u2502\n        \u2502 2025-05-15  \u2506 102.956301 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(settlement, maturity):\n        return pl.DataFrame()\n    # Normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Get the coupon dates between the settlement and maturity dates\n    p_dates = payment_dates(settlement, maturity)\n\n    df = pl.DataFrame({\"PaymentDate\": p_dates}).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == maturity)\n        .then(FINAL_PMT)\n        .otherwise(COUPON_PMT)\n        .alias(\"CashFlow\")\n    )\n\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.data","title":"<code>data(date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> Returned columns <ul> <li>ReferenceDate: The reference date of the data.</li> <li>BondType: The type of the bond (NTN-B).</li> <li>SelicCode: The SELIC code of the bond.</li> <li>IssueBaseDate: The issue base date of the bond.</li> <li>MaturityDate: The maturity date of the bond.</li> <li>BDToMat: The number of business days to maturity.</li> <li>Duration: The duration of the bond.</li> <li>DV01: The DV01 of the bond.</li> <li>DV01USD: The DV01 in USD of the bond.</li> <li>Price: The price of the bond.</li> <li>BidRate: The bid rate of the bond.</li> <li>AskRate: The ask rate of the bond.</li> <li>IndicativeRate: The indicative rate for the bond.</li> <li>DIRate: The interpolated DI rate for the bond.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.data(\"23-08-2024\")\nshape: (14, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063961 \u2506 0.063667 \u2506 0.063804       \u2506 0.112749 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.06594  \u2506 0.065635 \u2506 0.065795       \u2506 0.114963 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063925 \u2506 0.063601 \u2506 0.063794       \u2506 0.114888 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063217 \u2506 0.062905 \u2506 0.063094       \u2506 0.115595 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.062245 \u2506 0.061954 \u2506 0.0621         \u2506 0.115665 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.060005 \u2506 0.059574 \u2506 0.059797       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061107 \u2506 0.060733 \u2506 0.060923       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061304 \u2506 0.060931 \u2506 0.06114        \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061053 \u2506 0.06074  \u2506 0.060892       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061211 \u2506 0.0608   \u2506 0.061005       \u2506 0.11511  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def data(date: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Returned columns:\n        - ReferenceDate: The reference date of the data.\n        - BondType: The type of the bond (NTN-B).\n        - SelicCode: The SELIC code of the bond.\n        - IssueBaseDate: The issue base date of the bond.\n        - MaturityDate: The maturity date of the bond.\n        - BDToMat: The number of business days to maturity.\n        - Duration: The duration of the bond.\n        - DV01: The DV01 of the bond.\n        - DV01USD: The DV01 in USD of the bond.\n        - Price: The price of the bond.\n        - BidRate: The bid rate of the bond.\n        - AskRate: The ask rate of the bond.\n        - IndicativeRate: The indicative rate for the bond.\n        - DIRate: The interpolated DI rate for the bond.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.data(\"23-08-2024\")\n        shape: (14, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063961 \u2506 0.063667 \u2506 0.063804       \u2506 0.112749 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.06594  \u2506 0.065635 \u2506 0.065795       \u2506 0.114963 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063925 \u2506 0.063601 \u2506 0.063794       \u2506 0.114888 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063217 \u2506 0.062905 \u2506 0.063094       \u2506 0.115595 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.062245 \u2506 0.061954 \u2506 0.0621         \u2506 0.115665 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.060005 \u2506 0.059574 \u2506 0.059797       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061107 \u2506 0.060733 \u2506 0.060923       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061304 \u2506 0.060931 \u2506 0.06114        \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061053 \u2506 0.06074  \u2506 0.060892       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061211 \u2506 0.0608   \u2506 0.061005       \u2506 0.11511  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"NTN-B\")\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration of the NTN-B bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the duration.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The Macaulay duration of the NTN-B bond in business years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.duration(\"23-08-2024\", \"15-08-2060\", 0.061005)\n15.08305431313046\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def duration(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the Macaulay duration of the NTN-B bond in business years.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-B bond.\n        rate (float): The discount rate used to calculate the duration.\n\n    Returns:\n        float | None: The Macaulay duration of the NTN-B bond in business years.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.duration(\"23-08-2024\", \"15-08-2060\", 0.061005)\n        15.08305431313046\n    \"\"\"\n    # Return NaN if any input is nullable\n    if has_null_args(settlement, maturity, rate):\n        return None\n\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    df = cash_flows(settlement, maturity)\n    byears = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** byears\n    duration = (dcf * byears).sum() / dcf.sum()\n    # Truncar para 14 casas decimais para repetibilidade dos resultados\n    return tl.truncate(duration, 14)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.dv01","title":"<code>dv01(settlement, maturity, rate, vna)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an NTN-B in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.dv01(\"26-03-2025\", \"15-08-2060\", 0.074358, 4470.979474)\n4.640875999999935\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def dv01(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n    vna: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an NTN-B in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a date-like object.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a date-like object.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n\n    Returns:\n        float | None: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.dv01(\"26-03-2025\", \"15-08-2060\", 0.074358, 4470.979474)\n        4.640875999999935\n    \"\"\"\n    if has_null_args(settlement, maturity, rate, vna):\n        return None\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n    quotation1 = quotation(settlement, maturity, rate)\n    quotation2 = quotation(settlement, maturity, rate + 0.0001)\n    price1 = price(vna, quotation1)\n    price2 = price(vna, quotation2)\n    return price1 - price2\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.forwards","title":"<code>forwards(date, zero_coupon=True)</code>","text":"<p>Calculate the NTN-B forward rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <code>zero_coupon</code> <code>bool</code> <p>If True, use zero-coupon rates for forward rate calculation. Defaults to True. If False, the yield to maturity rates are used instead.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A DataFrame containing the forward rates.</p> Columns returned <ul> <li>MaturityDate: The maturity date of the bond.</li> <li>BDToMat: The number of business days to maturity.</li> <li>IndicativeRate: The indicative rate for the bond.</li> <li>ForwardRate: The calculated forward rate for the bond.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.forwards(\"17-10-2025\", zero_coupon=True)\nshape: (13, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n\u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2026-08-15   \u2506 207     \u2506 0.10089        \u2506 0.10089     \u2502\n\u2502 2027-05-15   \u2506 392     \u2506 0.088776       \u2506 0.074793    \u2502\n\u2502 2028-08-15   \u2506 707     \u2506 0.083615       \u2506 0.076598    \u2502\n\u2502 2029-05-15   \u2506 891     \u2506 0.0818         \u2506 0.074148    \u2502\n\u2502 2030-08-15   \u2506 1205    \u2506 0.080902       \u2506 0.077857    \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2040-08-15   \u2506 3714    \u2506 0.076067       \u2506 0.070587    \u2502\n\u2502 2045-05-15   \u2506 4901    \u2506 0.075195       \u2506 0.069811    \u2502\n\u2502 2050-08-15   \u2506 6216    \u2506 0.074087       \u2506 0.064348    \u2502\n\u2502 2055-05-15   \u2506 7405    \u2506 0.073702       \u2506 0.067551    \u2502\n\u2502 2060-08-15   \u2506 8722    \u2506 0.073795       \u2506 0.074505    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def forwards(\n    date: DateScalar,\n    zero_coupon: bool = True,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate the NTN-B forward rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n        zero_coupon (bool, optional): If True, use zero-coupon rates for\n            forward rate calculation. Defaults to True. If False, the\n            yield to maturity rates are used instead.\n\n    Returns:\n        pl.DataFrame: A DataFrame containing the forward rates.\n\n    Columns returned:\n        - MaturityDate: The maturity date of the bond.\n        - BDToMat: The number of business days to maturity.\n        - IndicativeRate: The indicative rate for the bond.\n        - ForwardRate: The calculated forward rate for the bond.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.forwards(\"17-10-2025\", zero_coupon=True)\n        shape: (13, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n        \u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2026-08-15   \u2506 207     \u2506 0.10089        \u2506 0.10089     \u2502\n        \u2502 2027-05-15   \u2506 392     \u2506 0.088776       \u2506 0.074793    \u2502\n        \u2502 2028-08-15   \u2506 707     \u2506 0.083615       \u2506 0.076598    \u2502\n        \u2502 2029-05-15   \u2506 891     \u2506 0.0818         \u2506 0.074148    \u2502\n        \u2502 2030-08-15   \u2506 1205    \u2506 0.080902       \u2506 0.077857    \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2040-08-15   \u2506 3714    \u2506 0.076067       \u2506 0.070587    \u2502\n        \u2502 2045-05-15   \u2506 4901    \u2506 0.075195       \u2506 0.069811    \u2502\n        \u2502 2050-08-15   \u2506 6216    \u2506 0.074087       \u2506 0.064348    \u2502\n        \u2502 2055-05-15   \u2506 7405    \u2506 0.073702       \u2506 0.067551    \u2502\n        \u2502 2060-08-15   \u2506 8722    \u2506 0.073795       \u2506 0.074505    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Validate and normalize the date\n    df = data(date).select(\"MaturityDate\", \"BDToMat\", \"IndicativeRate\")\n    if zero_coupon:\n        df_ref = spot_rates(\n            settlement=date,\n            maturities=df[\"MaturityDate\"],\n            rates=df[\"IndicativeRate\"],\n        ).rename({\"SpotRate\": \"ReferenceRate\"})\n    else:\n        df_ref = df.rename({\"IndicativeRate\": \"ReferenceRate\"})\n    fwd_rates = fwd.forwards(bdays=df_ref[\"BDToMat\"], rates=df_ref[\"ReferenceRate\"])\n    df_ref = df_ref.with_columns(ForwardRate=fwd_rates)\n    df = df.join(\n        df_ref.select(\"MaturityDate\", \"ForwardRate\"),\n        on=\"MaturityDate\",\n        how=\"inner\",\n    ).sort(\"MaturityDate\")\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.maturities","title":"<code>maturities(date)</code>","text":"<p>Get the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Series containing the maturity dates for the NTN-B bonds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.maturities(\"16-08-2024\")\nshape: (14,)\nSeries: 'MaturityDate' [date]\n[\n    2025-05-15\n    2026-08-15\n    2027-05-15\n    2028-08-15\n    2029-05-15\n    \u2026\n    2040-08-15\n    2045-05-15\n    2050-08-15\n    2055-05-15\n    2060-08-15\n]\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pl.Series:\n    \"\"\"\n    Get the bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.Series: Series containing the maturity dates for the NTN-B bonds.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.maturities(\"16-08-2024\")\n        shape: (14,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-05-15\n            2026-08-15\n            2027-05-15\n            2028-08-15\n            2029-05-15\n            \u2026\n            2040-08-15\n            2045-05-15\n            2050-08-15\n            2055-05-15\n            2060-08-15\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. Coupon payments are made on the 15th of February, May, August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exlusive) to start generating the coupon dates.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Series of coupon dates within the specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\nshape: (3,)\nSeries: '' [date]\n[\n    2024-05-15\n    2024-11-15\n    2025-05-15\n]\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def payment_dates(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pl.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. Coupon payments are made on the 15th of February, May,\n    August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B\n    bond is determined by its maturity date.\n\n    Args:\n        settlement (DateScalar): The settlement date (exlusive) to start generating\n            the coupon dates.\n        maturity (DateScalar): The maturity date.\n\n    Returns:\n        pl.Series: Series of coupon dates within the specified range.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n        shape: (3,)\n        Series: '' [date]\n        [\n            2024-05-15\n            2024-11-15\n            2025-05-15\n        ]\n    \"\"\"\n    if has_null_args(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    if maturity &lt;= settlement:\n        raise ValueError(\"Maturity date must be after the settlement date.\")\n\n    coupon_date = maturity\n    coupon_dates = []\n\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        coupon_date -= pd.DateOffset(months=6)\n        coupon_date = coupon_date.date()\n\n    return pl.Series(coupon_dates).sort()\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-B price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-B bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-B quotation in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float | None</code> <p>The NTN-B price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n4271.864805\n&gt;&gt;&gt; ntnb.price(4315.498383, 100.6409)\n4343.156412\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the NTN-B price using Anbima rules.\n\n    Args:\n        vna (float): The nominal value of the NTN-B bond.\n        quotation (float): The NTN-B quotation in base 100.\n\n    Returns:\n        float: The NTN-B price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n        4271.864805\n        &gt;&gt;&gt; ntnb.price(4315.498383, 100.6409)\n        4343.156412\n    \"\"\"\n    if has_null_args(vna, quotation):\n        return None\n    return tl.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-B quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The NTN-B quotation truncated to 4 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n&gt;&gt;&gt; ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n100.6409\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def quotation(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the NTN-B quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-B bond.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n\n    Returns:\n        float | None: The NTN-B quotation truncated to 4 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n        99.3651\n        &gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n        99.5341\n        &gt;&gt;&gt; ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n        100.6409\n    \"\"\"\n    if has_null_args(settlement, maturity, rate):\n        return None\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    cf_df = cash_flows(settlement, maturity)\n    cf_dates = cf_df[\"PaymentDate\"]\n    cf_values = cf_df[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = tl.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return tl.truncate(cf_present_value.sum(), 4)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.spot_rates","title":"<code>spot_rates(settlement, maturities, rates, show_coupons=False)</code>","text":"<p>Calculate the spot rates for NTN-B bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The reference date for settlement.</p> required <code>maturities</code> <code>DateArray</code> <p>Series of maturity dates for the bonds.</p> required <code>rates</code> <code>FloatArray</code> <p>Series of yield to maturity rates.</p> required <code>show_coupons</code> <code>bool</code> <p>If True, the result will include the intermediate coupon dates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; # Get the NTN-B rates for a specific reference date\n&gt;&gt;&gt; df = ntnb.data(\"16-08-2024\")\n&gt;&gt;&gt; # Calculate the spot rates considering the settlement at the reference date\n&gt;&gt;&gt; ntnb.spot_rates(\n...     settlement=\"16-08-2024\",\n...     maturities=df[\"MaturityDate\"],\n...     rates=df[\"IndicativeRate\"],\n... )\nshape: (14, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-05-15   \u2506 185     \u2506 0.063893 \u2502\n\u2502 2026-08-15   \u2506 502     \u2506 0.066141 \u2502\n\u2502 2027-05-15   \u2506 687     \u2506 0.064087 \u2502\n\u2502 2028-08-15   \u2506 1002    \u2506 0.063057 \u2502\n\u2502 2029-05-15   \u2506 1186    \u2506 0.061458 \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n\u2502 2040-08-15   \u2506 4009    \u2506 0.058326 \u2502\n\u2502 2045-05-15   \u2506 5196    \u2506 0.060371 \u2502\n\u2502 2050-08-15   \u2506 6511    \u2506 0.060772 \u2502\n\u2502 2055-05-15   \u2506 7700    \u2506 0.059909 \u2502\n\u2502 2060-08-15   \u2506 9017    \u2506 0.060652 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>The calculation of the spot rates for NTN-B bonds considers the following steps:     - Map all all possible payment dates up to the longest maturity date.     - Interpolate the YTM rates in the intermediate payment dates.     - Calculate the NTN-B quotation for each maturity date.     - Calculate the real spot rates for each maturity date.</p> Columns returned <ul> <li>MaturityDate: The maturity date of the bond.</li> <li>BDToMat: The number of business days from settlement to maturities.</li> <li>SpotRate: The real spot rate for the bond.</li> </ul> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def spot_rates(\n    settlement: DateScalar,\n    maturities: DateArray,\n    rates: FloatArray,\n    show_coupons: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate the spot rates for NTN-B bonds using the bootstrap method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price.\n\n    Args:\n        settlement (DateScalar): The reference date for settlement.\n        maturities (DateArray): Series of maturity dates for the bonds.\n        rates (FloatArray): Series of yield to maturity rates.\n        show_coupons (bool, optional): If True, the result will include the\n            intermediate coupon dates. Defaults to False.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; # Get the NTN-B rates for a specific reference date\n        &gt;&gt;&gt; df = ntnb.data(\"16-08-2024\")\n        &gt;&gt;&gt; # Calculate the spot rates considering the settlement at the reference date\n        &gt;&gt;&gt; ntnb.spot_rates(\n        ...     settlement=\"16-08-2024\",\n        ...     maturities=df[\"MaturityDate\"],\n        ...     rates=df[\"IndicativeRate\"],\n        ... )\n        shape: (14, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-05-15   \u2506 185     \u2506 0.063893 \u2502\n        \u2502 2026-08-15   \u2506 502     \u2506 0.066141 \u2502\n        \u2502 2027-05-15   \u2506 687     \u2506 0.064087 \u2502\n        \u2502 2028-08-15   \u2506 1002    \u2506 0.063057 \u2502\n        \u2502 2029-05-15   \u2506 1186    \u2506 0.061458 \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n        \u2502 2040-08-15   \u2506 4009    \u2506 0.058326 \u2502\n        \u2502 2045-05-15   \u2506 5196    \u2506 0.060371 \u2502\n        \u2502 2050-08-15   \u2506 6511    \u2506 0.060772 \u2502\n        \u2502 2055-05-15   \u2506 7700    \u2506 0.059909 \u2502\n        \u2502 2060-08-15   \u2506 9017    \u2506 0.060652 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        The calculation of the spot rates for NTN-B bonds considers the following steps:\n            - Map all all possible payment dates up to the longest maturity date.\n            - Interpolate the YTM rates in the intermediate payment dates.\n            - Calculate the NTN-B quotation for each maturity date.\n            - Calculate the real spot rates for each maturity date.\n\n    Columns returned:\n        - MaturityDate: The maturity date of the bond.\n        - BDToMat: The number of business days from settlement to maturities.\n        - SpotRate: The real spot rate for the bond.\n    \"\"\"\n    if has_null_args(settlement, maturities, rates):\n        return pl.DataFrame()\n    # Process and validate the input data\n    settlement = cv.convert_dates(settlement)\n    maturities = cv.convert_dates(maturities)\n\n    # Create the interpolator to calculate the YTM rates for intermediate dates\n    flat_fwd = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, maturities),\n        known_rates=rates,\n    )\n\n    # Generate coupon dates up to the longest maturity date\n    all_coupon_dates = _generate_all_coupon_dates(settlement, maturities.max())\n    bdays_to_mat = bday.count(settlement, all_coupon_dates)\n\n    df = (\n        pl.DataFrame({\"MaturityDate\": all_coupon_dates, \"BDToMat\": bdays_to_mat})\n        .with_columns(\n            BYears=pl.col(\"BDToMat\") / 252,\n            YTM=pl.col(\"BDToMat\").map_elements(flat_fwd, return_dtype=pl.Float64),\n            Coupon=COUPON_PMT,\n            SpotRate=pl.lit(None, dtype=pl.Float64),\n        )\n        .sort(\"MaturityDate\")\n    )\n\n    def _update_spot_rate(\n        df: pl.DataFrame, maturity: dt.date, spot_rate: float\n    ) -&gt; pl.DataFrame:\n        \"\"\"Helper function to update the spot rate inside the bootstrap loop.\"\"\"\n        return df.with_columns(\n            pl.when(pl.col(\"MaturityDate\") == maturity)\n            .then(spot_rate)\n            .otherwise(pl.col(\"SpotRate\"))\n            .alias(\"SpotRate\")\n        )\n\n    # Bootstrap method to calculate spot rates iteratively\n    df_dicts = df.to_dicts()\n    first_maturity = maturities.min()\n    for row in df_dicts:\n        maturity = row[\"MaturityDate\"]\n\n        # Spot rates &lt;= first maturity are YTM rates by definition\n        if maturity &lt;= first_maturity:\n            spot_rate = row[\"YTM\"]\n            df = _update_spot_rate(df, maturity, spot_rate)\n            continue\n\n        # Get results for all previous cash flows already calculated\n        prev_cf_dates = payment_dates(settlement, maturity).to_list()[:-1]\n        df_temp = df.filter(pl.col(\"MaturityDate\").is_in(prev_cf_dates))\n\n        # Calculate the spot rate for the current maturity\n        present_value = tl.calculate_present_value(\n            df_temp[\"Coupon\"],\n            df_temp[\"SpotRate\"],\n            df_temp[\"BYears\"],\n        )\n        bond_price = quotation(settlement, maturity, row[\"YTM\"])\n        price_factor = FINAL_PMT / (bond_price - present_value)\n        spot_rate = price_factor ** (1 / row[\"BYears\"]) - 1\n\n        df = _update_spot_rate(df, maturity, spot_rate)\n\n    if not show_coupons:\n        df = df.filter(pl.col(\"MaturityDate\").is_in(maturities.to_list()))\n    return df.select([\"MaturityDate\", \"BDToMat\", \"SpotRate\"])\n</code></pre>"},{"location":"ntnc/","title":"NTN-C","text":""},{"location":"ntnc/#pyield.tn.ntnc.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Generate the cash flows for NTN-C bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exclusive) to start generating the cash flows.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.cash_flows(\"21-03-2025\", \"01-01-2031\")\nshape: (12, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-07-01  \u2506 5.830052   \u2502\n\u2502 2026-01-01  \u2506 5.830052   \u2502\n\u2502 2026-07-01  \u2506 5.830052   \u2502\n\u2502 2027-01-01  \u2506 5.830052   \u2502\n\u2502 2027-07-01  \u2506 5.830052   \u2502\n\u2502 \u2026           \u2506 \u2026          \u2502\n\u2502 2029-01-01  \u2506 5.830052   \u2502\n\u2502 2029-07-01  \u2506 5.830052   \u2502\n\u2502 2030-01-01  \u2506 5.830052   \u2502\n\u2502 2030-07-01  \u2506 5.830052   \u2502\n\u2502 2031-01-01  \u2506 105.830052 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def cash_flows(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-C bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (DateScalar): The settlement date (exclusive) to start generating\n            the cash flows.\n        maturity (DateScalar): The maturity date of the bond.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.cash_flows(\"21-03-2025\", \"01-01-2031\")\n        shape: (12, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-07-01  \u2506 5.830052   \u2502\n        \u2502 2026-01-01  \u2506 5.830052   \u2502\n        \u2502 2026-07-01  \u2506 5.830052   \u2502\n        \u2502 2027-01-01  \u2506 5.830052   \u2502\n        \u2502 2027-07-01  \u2506 5.830052   \u2502\n        \u2502 \u2026           \u2506 \u2026          \u2502\n        \u2502 2029-01-01  \u2506 5.830052   \u2502\n        \u2502 2029-07-01  \u2506 5.830052   \u2502\n        \u2502 2030-01-01  \u2506 5.830052   \u2502\n        \u2502 2030-07-01  \u2506 5.830052   \u2502\n        \u2502 2031-01-01  \u2506 105.830052 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(settlement, maturity):\n        return pl.DataFrame()\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Get the coupon dates between the settlement and maturity dates\n    pay_dates = payment_dates(settlement, maturity)\n\n    # Get the right coupon payment and final payment values\n    coupon_pmt = _get_coupon_pmt(maturity)\n    final_pmt = _get_final_pmt(maturity)\n\n    # Build dataframe and assign cash flows using Polars expression (avoid NumPy)\n    df = pl.DataFrame({\"PaymentDate\": pay_dates}).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == maturity)\n        .then(final_pmt)\n        .otherwise(coupon_pmt)\n        .alias(\"CashFlow\")\n    )\n    return df\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.data","title":"<code>data(date)</code>","text":"<p>Fetch the LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.data(\"23-08-2024\")\nshape: (1, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-C    \u2506 770100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.061591 \u2506 0.057587 \u2506 0.059617       \u2506 0.11575 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def data(date: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.data(\"23-08-2024\")\n        shape: (1, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-C    \u2506 770100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.061591 \u2506 0.057587 \u2506 0.059617       \u2506 0.11575 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"NTN-C\")\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration of the NTN-C bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-C bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the duration.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The Macaulay duration of the NTN-C bond in business years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.duration(\"21-03-2025\", \"01-01-2031\", 0.067626)\n4.405363320448003\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def duration(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the Macaulay duration of the NTN-C bond in business years.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-C bond.\n        rate (float): The discount rate used to calculate the duration.\n\n    Returns:\n        float | None: The Macaulay duration of the NTN-C bond in business years.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.duration(\"21-03-2025\", \"01-01-2031\", 0.067626)\n        4.405363320448003\n    \"\"\"\n    # Validate and normalize inputs\n    if has_null_args(settlement, maturity, rate):\n        return None\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    df = cash_flows(settlement, maturity)\n    b_years = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** b_years\n    duration = (dcf * b_years).sum() / dcf.sum()\n    return duration\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. The NTN-C bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exlusive) to start generating the coupon dates.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Series of coupon dates within the specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.payment_dates(\"21-03-2025\", \"01-01-2031\")\nshape: (12,)\nSeries: '' [date]\n[\n    2025-07-01\n    2026-01-01\n    2026-07-01\n    2027-01-01\n    2027-07-01\n    \u2026\n    2029-01-01\n    2029-07-01\n    2030-01-01\n    2030-07-01\n    2031-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def payment_dates(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pl.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. The NTN-C bond is determined by its maturity date.\n\n    Args:\n        settlement (DateScalar): The settlement date (exlusive) to start generating\n            the coupon dates.\n        maturity (DateScalar): The maturity date.\n\n    Returns:\n        pl.Series: Series of coupon dates within the specified range.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.payment_dates(\"21-03-2025\", \"01-01-2031\")\n        shape: (12,)\n        Series: '' [date]\n        [\n            2025-07-01\n            2026-01-01\n            2026-07-01\n            2027-01-01\n            2027-07-01\n            \u2026\n            2029-01-01\n            2029-07-01\n            2030-01-01\n            2030-07-01\n            2031-01-01\n        ]\n    \"\"\"\n    if has_null_args(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n    # Validate and normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt; settlement:\n        raise ValueError(\"Maturity date must be after the start date.\")\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= pd.DateOffset(months=6)\n        coupon_date = coupon_date.date()  # DateOffset returns a Timestamp\n\n    return pl.Series(coupon_dates).sort()\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-C price using Anbima rules.</p> <p>price = VNA * quotation / 100</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-C bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-C quotation in base 100.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The NTN-C price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.price(6598.913723, 126.4958)\n8347.348705\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the NTN-C price using Anbima rules.\n\n    price = VNA * quotation / 100\n\n    Args:\n        vna (float): The nominal value of the NTN-C bond.\n        quotation (float): The NTN-C quotation in base 100.\n\n    Returns:\n        float | None: The NTN-C price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.price(6598.913723, 126.4958)\n        8347.348705\n    \"\"\"\n    if has_null_args(vna, quotation):\n        return None\n    return tl.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-C quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-C bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-C.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The NTN-C quotation truncated to 4 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.quotation(\"21-03-2025\", \"01-01-2031\", 0.067626)\n126.4958\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def quotation(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the NTN-C quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-C bond.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-C.\n\n    Returns:\n        float | None: The NTN-C quotation truncated to 4 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.quotation(\"21-03-2025\", \"01-01-2031\", 0.067626)\n        126.4958\n    \"\"\"\n    # Validate and normalize inputs\n    if has_null_args(settlement, maturity, rate):\n        return None\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    cf_df = cash_flows(settlement, maturity)\n    cf_dates = cf_df[\"PaymentDate\"]\n    cf_values = cf_df[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = tl.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return tl.truncate(cf_present_value.sum(), 4)\n</code></pre>"},{"location":"ntnf/","title":"NTN-F","text":""},{"location":"ntnf/#pyield.tn.ntnf.cash_flows","title":"<code>cash_flows(settlement, maturity, adj_payment_dates=False)</code>","text":"<p>Generate the cash flows for the NTN-F bond between the settlement (exclusive) and maturity dates (inclusive). The cash flows are the coupon payments and the final payment at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The date (exclusive) for starting the cash flows.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>adj_payment_dates</code> <code>bool</code> <p>If True, adjust the payment dates to the next business day.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.cash_flows(\"15-05-2024\", \"01-01-2027\")\nshape: (6, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-07-01  \u2506 48.80885   \u2502\n\u2502 2025-01-01  \u2506 48.80885   \u2502\n\u2502 2025-07-01  \u2506 48.80885   \u2502\n\u2502 2026-01-01  \u2506 48.80885   \u2502\n\u2502 2026-07-01  \u2506 48.80885   \u2502\n\u2502 2027-01-01  \u2506 1048.80885 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def cash_flows(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    adj_payment_dates: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Generate the cash flows for the NTN-F bond between the settlement (exclusive) and\n    maturity dates (inclusive). The cash flows are the coupon payments and the final\n    payment at maturity.\n\n    Args:\n        settlement (DateScalar): The date (exclusive) for starting the cash flows.\n        maturity (DateScalar): The maturity date of the bond.\n        adj_payment_dates (bool): If True, adjust the payment dates to the next\n            business day.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.cash_flows(\"15-05-2024\", \"01-01-2027\")\n        shape: (6, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-07-01  \u2506 48.80885   \u2502\n        \u2502 2025-01-01  \u2506 48.80885   \u2502\n        \u2502 2025-07-01  \u2506 48.80885   \u2502\n        \u2502 2026-01-01  \u2506 48.80885   \u2502\n        \u2502 2026-07-01  \u2506 48.80885   \u2502\n        \u2502 2027-01-01  \u2506 1048.80885 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(settlement, maturity):\n        return pl.DataFrame()\n    # Normalize input dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Get the payment dates between the settlement and maturity dates\n    pay_dates = payment_dates(settlement, maturity)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    df = pl.DataFrame(data={\"PaymentDate\": pay_dates}).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == maturity)\n        .then(FINAL_PMT)\n        .otherwise(COUPON_PMT)\n        .alias(\"CashFlow\")\n    )\n\n    if adj_payment_dates:\n        adj_pay_dates = bday.offset(pay_dates, 0)\n        df = df.with_columns(PaymentDate=adj_pay_dates)\n    return df\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.data","title":"<code>data(date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.data(\"23-08-2024\")\nshape: (6, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2014-01-10    \u2506 \u2026 \u2506 0.107864 \u2506 0.107524 \u2506 0.107692       \u2506 0.10823 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.11527  \u2506 0.114948 \u2506 0.115109       \u2506 0.11467 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.116468 \u2506 0.11621  \u2506 0.116337       \u2506 0.1156  \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.117072 \u2506 0.116958 \u2506 0.117008       \u2506 0.11575 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.116473 \u2506 0.116164 \u2506 0.116307       \u2506 0.11554 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.116662 \u2506 0.116523 \u2506 0.116586       \u2506 0.11531 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def data(date: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.data(\"23-08-2024\")\n        shape: (6, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2014-01-10    \u2506 \u2026 \u2506 0.107864 \u2506 0.107524 \u2506 0.107692       \u2506 0.10823 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.11527  \u2506 0.114948 \u2506 0.115109       \u2506 0.11467 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.116468 \u2506 0.11621  \u2506 0.116337       \u2506 0.1156  \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.117072 \u2506 0.116958 \u2506 0.117008       \u2506 0.11575 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.116473 \u2506 0.116164 \u2506 0.116307       \u2506 0.11554 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.116662 \u2506 0.116523 \u2506 0.116586       \u2506 0.11531 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa\n    return anbima.tpf_data(date, \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.di_net_spread","title":"<code>di_net_spread(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates, initial_guess=None)</code>","text":"<p>Calculate the net DI spread for a bond given the YTM and the DI rates.</p> <p>This function determines the spread over the DI curve that equates the present value of the bond's cash flows to its market price. It interpolates the DI rates to match the bond's cash flow payment dates and uses the Brent method to find the spread (in bps) that zeroes the difference between the bond's market price and its discounted cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the spread.</p> required <code>ntnf_maturity</code> <code>DateScalar</code> <p>The bond maturity date.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the bond.</p> required <code>di_rates</code> <code>FloatArray</code> <p>A Series of DI rates.</p> required <code>di_expirations</code> <code>DateArray</code> <p>A list or Series of DI expiration dates.</p> required <code>initial_guess</code> <code>float</code> <p>An initial guess for the spread. Defaults to None. A good initial guess is the DI gross spread for the bond.</p> <code>None</code> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The net DI spread in decimal format (e.g., 0.0012 for 12 bps).</p> <p>Examples:</p>"},{"location":"ntnf/#pyield.tn.ntnf.di_net_spread--obs-only-some-of-the-di-rates-will-be-used-in-the-example","title":"Obs: only some of the DI rates will be used in the example.","text":"<pre><code>&gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n&gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n&gt;&gt;&gt; spread = di_net_spread(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n&gt;&gt;&gt; round(spread * 10_000, 2)  # Convert to bps for display\n12.13\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def di_net_spread(  # noqa\n    settlement: DateScalar,\n    ntnf_maturity: DateScalar,\n    ntnf_rate: float,\n    di_expirations: DateScalar,\n    di_rates: FloatArray,\n    initial_guess: float | None = None,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the net DI spread for a bond given the YTM and the DI rates.\n\n    This function determines the spread over the DI curve that equates the present value\n    of the bond's cash flows to its market price. It interpolates the DI rates to match\n    the bond's cash flow payment dates and uses the Brent method to find the spread\n    (in bps) that zeroes the difference between the bond's market price and its\n    discounted cash flows.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the spread.\n        ntnf_maturity (DateScalar): The bond maturity date.\n        ntnf_rate (float): The yield to maturity (YTM) of the bond.\n        di_rates (FloatArray): A Series of DI rates.\n        di_expirations (DateArray): A list or Series of DI expiration dates.\n        initial_guess (float, optional): An initial guess for the spread. Defaults to\n            None. A good initial guess is the DI gross spread for the bond.\n\n    Returns:\n        float | None: The net DI spread in decimal format (e.g., 0.0012 for 12 bps).\n\n    Examples:\n        # Obs: only some of the DI rates will be used in the example.\n        &gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n        &gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n        &gt;&gt;&gt; spread = di_net_spread(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        &gt;&gt;&gt; round(spread * 10_000, 2)  # Convert to bps for display\n        12.13\n    \"\"\"\n    # 1. Valida\u00e7\u00e3o e convers\u00e3o de inputs\n    if has_null_args(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates):\n        return None\n    settlement = cv.convert_dates(settlement)\n    ntnf_maturity = cv.convert_dates(ntnf_maturity)\n    di_expirations = cv.convert_dates(di_expirations)\n\n    # Force di_rates to be a Polars Series\n    if not isinstance(di_rates, pl.Series):\n        di_rates = pl.Series(di_rates)\n\n    # 2. Valida\u00e7\u00e3o dos inputs de DI\n    if len(di_rates) != len(di_expirations):\n        raise ValueError(\"di_rates and di_expirations must have the same length.\")\n\n    # 3. Cria\u00e7\u00e3o do interpolador\n    ff_interpolator = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    # 4. Gera\u00e7\u00e3o dos fluxos de caixa do NTN-F\n    df = cash_flows(settlement, ntnf_maturity)\n\n    bdays_to_payment = bday.count(settlement, df[\"PaymentDate\"])\n    byears_to_payment = bdays_to_payment / 252\n\n    df = df.with_columns(\n        BDaysToPayment=bdays_to_payment,\n    ).with_columns(\n        DIRateInterp=pl.col(\"BDaysToPayment\").map_elements(\n            ff_interpolator, return_dtype=pl.Float64\n        ),\n    )\n\n    # 5. Extra\u00e7\u00e3o dos dados para o c\u00e1lculo num\u00e9rico\n    bond_price = price(settlement, ntnf_maturity, ntnf_rate)\n    bond_cash_flows = df[\"CashFlow\"]\n    di_interp = df[\"DIRateInterp\"]\n\n    # 6. Fun\u00e7\u00e3o de diferen\u00e7a de pre\u00e7o para o solver\n    def price_difference(p: float) -&gt; float:\n        discounted_cf = bond_cash_flows / (1 + di_interp + p) ** byears_to_payment\n        return discounted_cf.sum() - bond_price\n\n    # 7. Resolver para o spread\n    return _solve_spread(price_difference, initial_guess)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>Defini\u00e7\u00e3o do spread (forma bruta):     DISpread_raw = IndicativeRate - SettlementRate</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - BondType - MaturityDate - DISpread (decimal ou bps conforme par\u00e2metro)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.di_spreads(\"30-05-2025\", bps=True)\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def di_spreads(date: DateScalar, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    Defini\u00e7\u00e3o do spread (forma bruta):\n        DISpread_raw = IndicativeRate - SettlementRate\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateScalar): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Default False.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - BondType\n            - MaturityDate\n            - DISpread (decimal ou bps conforme par\u00e2metro)\n\n    Raises:\n        ValueError: Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.di_spreads(\"30-05-2025\", bps=True)\n        shape: (5, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return pre_di_spreads(date, bps=bps).filter(pl.col(\"BondType\") == \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration for an NTN-F bond in business years.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the duration.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The yield to maturity (YTM) used to discount the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration in business business years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n6.32854218039796\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def duration(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration for an NTN-F bond in business years.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the duration.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The yield to maturity (YTM) used to discount the cash flows.\n\n    Returns:\n        float: The Macaulay duration in business business years.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n        6.32854218039796\n    \"\"\"\n    if has_null_args(settlement, maturity, rate):\n        return None\n    # Normalize inputs\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    df = cash_flows(settlement, maturity)\n    byears = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** byears\n    duration = (dcf * byears).sum() / dcf.sum()\n    return duration\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.dv01","title":"<code>dv01(settlement, maturity, rate)</code>","text":"<p>Calculate the DV01 (Dollar Value of 01) for an NTN-F in R$.</p> <p>Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a date-like object.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-F.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The DV01 value, representing the price change for a 1 basis point increase in yield.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.dv01(\"26-03-2025\", \"01-01-2035\", 0.151375)\n0.39025200000003224\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def dv01(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the DV01 (Dollar Value of 01) for an NTN-F in R$.\n\n    Represents the price change in R$ for a 1 basis point (0.01%) increase in yield.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a date-like object.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a date-like object.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-F.\n\n    Returns:\n        float | None: The DV01 value, representing the price change for a 1 basis point\n            increase in yield.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.dv01(\"26-03-2025\", \"01-01-2035\", 0.151375)\n        0.39025200000003224\n    \"\"\"\n    if has_null_args(settlement, maturity, rate):\n        return None\n    price1 = price(settlement, maturity, rate)\n    price2 = price(settlement, maturity, rate + 0.0001)\n    return price1 - price2\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the NTN-F bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series of NTN-F bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.maturities(\"23-08-2024\")\nshape: (6,)\nSeries: 'MaturityDate' [date]\n[\n    2025-01-01\n    2027-01-01\n    2029-01-01\n    2031-01-01\n    2033-01-01\n    2035-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pl.Series:\n    \"\"\"\n    Fetch the NTN-F bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pl.Series: A Series of NTN-F bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.maturities(\"23-08-2024\")\n        shape: (6,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-01-01\n            2027-01-01\n            2029-01-01\n            2031-01-01\n            2033-01-01\n            2035-01-01\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a settlement date and a maturity date. The dates are exclusive for the settlement date and inclusive for the maturity date. Coupon payments are made on the 1st of January and July. The NTN-F bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: A Series containing the coupon dates between the settlement (exclusive) and maturity (inclusive) dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.payment_dates(\"15-05-2024\", \"01-01-2027\")\nshape: (6,)\nSeries: '' [date]\n[\n    2024-07-01\n    2025-01-01\n    2025-07-01\n    2026-01-01\n    2026-07-01\n    2027-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def payment_dates(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pl.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a settlement date and a maturity date.\n    The dates are exclusive for the settlement date and inclusive for the maturity date.\n    Coupon payments are made on the 1st of January and July.\n    The NTN-F bond is determined by its maturity date.\n\n    Args:\n        settlement (DateScalar): The settlement date.\n        maturity (DateScalar): The maturity date.\n\n    Returns:\n        pl.Series: A Series containing the coupon dates between the settlement\n            (exclusive) and maturity (inclusive) dates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.payment_dates(\"15-05-2024\", \"01-01-2027\")\n        shape: (6,)\n        Series: '' [date]\n        [\n            2024-07-01\n            2025-01-01\n            2025-07-01\n            2026-01-01\n            2026-07-01\n            2027-01-01\n        ]\n    \"\"\"\n    if has_null_args(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n    # Normalize dates\n    settlement = cv.convert_dates(settlement)\n    maturity = cv.convert_dates(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt;= settlement:\n        raise ValueError(\"Maturity date must be after the settlement date.\")\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= pd.DateOffset(months=6)\n        coupon_date = coupon_date.date()  # DateOffset returns a Timestamp\n\n    return pl.Series(coupon_dates).sort()\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.premium","title":"<code>premium(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates)</code>","text":"<p>Calculate the premium of an NTN-F bond over DI rates.</p> <p>This function computes the premium of an NTN-F bond by comparing its implied discount factor with that of the DI curve. It determines the net premium based on the difference between the discount factors of the bond's yield-to-maturity (YTM) and the interpolated DI rates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the premium.</p> required <code>ntnf_maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-F bond.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the NTN-F bond.</p> required <code>di_expirations</code> <code>DateScalar</code> <p>Series with the expiration dates for the DI.</p> required <code>di_rates</code> <code>FloatArray</code> <p>Series containing the DI rates corresponding to the expiration dates.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The premium of the NTN-F bond over the DI curve, expressed as a</p> <code>float | None</code> <p>factor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Obs: only some of the DI rates will be used in the example.\n&gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n&gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n&gt;&gt;&gt; premium(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n1.0099602136954626\n</code></pre> Notes <ul> <li>The function adjusts coupon payment dates to business days and calculates   the present value of cash flows for the NTN-F bond using DI rates.</li> </ul> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def premium(\n    settlement: DateScalar,\n    ntnf_maturity: DateScalar,\n    ntnf_rate: float,\n    di_expirations: DateScalar,\n    di_rates: FloatArray,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the premium of an NTN-F bond over DI rates.\n\n    This function computes the premium of an NTN-F bond by comparing its implied\n    discount factor with that of the DI curve. It determines the net premium based\n    on the difference between the discount factors of the bond's yield-to-maturity\n    (YTM) and the interpolated DI rates.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the premium.\n        ntnf_maturity (DateScalar): The maturity date of the NTN-F bond.\n        ntnf_rate (float): The yield to maturity (YTM) of the NTN-F bond.\n        di_expirations (DateScalar): Series with the expiration dates for the DI.\n        di_rates (FloatArray): Series containing the DI rates corresponding to\n            the expiration dates.\n\n    Returns:\n        float | None: The premium of the NTN-F bond over the DI curve, expressed as a\n        factor.\n\n    Examples:\n        &gt;&gt;&gt; # Obs: only some of the DI rates will be used in the example.\n        &gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n        &gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n        &gt;&gt;&gt; premium(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        1.0099602136954626\n\n    Notes:\n        - The function adjusts coupon payment dates to business days and calculates\n          the present value of cash flows for the NTN-F bond using DI rates.\n\n    \"\"\"\n    if has_null_args(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates):\n        return None\n    # 1. Valida\u00e7\u00e3o e convers\u00e3o de datas (padr\u00e3o consistente)\n    settlement = cv.convert_dates(settlement)\n    ntnf_maturity = cv.convert_dates(ntnf_maturity)\n    di_expirations = cv.convert_dates(di_expirations)\n    if not isinstance(di_rates, pl.Series):\n        di_rates = pl.Series(di_rates)\n\n    # 2. Prepara\u00e7\u00e3o do DataFrame de fluxo de caixa e interpolador\n    df_cf = cash_flows(settlement, ntnf_maturity, adj_payment_dates=True)\n\n    ff_interpolator = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    # 3. Calcular dados externos (dias \u00fateis) antes de usar no with_columns\n    bdays_to_payment = bday.count(settlement, df_cf.get_column(\"PaymentDate\"))\n\n    # 4. Construir o DataFrame final com todas as colunas necess\u00e1rias\n    df = df_cf.with_columns(BDToMat=bdays_to_payment).with_columns(\n        BYears=pl.col(\"BDToMat\") / 252,\n        DIRate=pl.col(\"BDToMat\").map_elements(ff_interpolator, return_dtype=pl.Float64),\n    )\n\n    # 5. Calcular o pre\u00e7o do t\u00edtulo usando as taxas DI interpoladas\n    bond_price = tools.calculate_present_value(\n        cash_flows=df[\"CashFlow\"],\n        rates=df[\"DIRate\"],\n        periods=df[\"BYears\"],\n    )\n\n    def price_difference(ytm: float) -&gt; float:\n        # A YTM que zera a diferen\u00e7a de pre\u00e7o\n        discounted_cf = df[\"CashFlow\"] / (1 + ytm) ** df[\"BYears\"]\n        return discounted_cf.sum() - bond_price\n\n    # 7. Resolver para a YTM impl\u00edcita\n    di_ytm = _solve_spread(price_difference, ntnf_rate)\n\n    if math.isnan(di_ytm):\n        return float(\"nan\")\n\n    # 8. Calcular o pr\u00eamio final\n    factor_ntnf = (1 + ntnf_rate) ** (1 / 252)\n    factor_di = (1 + di_ytm) ** (1 / 252)\n\n    # Evitar divis\u00e3o por zero se o fator DI for 1\n    if factor_di == 1:\n        return float(\"inf\") if factor_ntnf &gt; 1 else 0.0\n\n    premium_val = (factor_ntnf - 1) / (factor_di - 1)\n    return premium_val\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-F price using Anbima rules, which corresponds to the present     value of the cash flows discounted at the given yield to maturity rate (YTM).</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the price.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) used to calculate the present value of the cash flows.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The NTN-F price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 48.81, which represents a 10% annual   coupon rate compounded semi-annually and rounded to 5 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n895.359254\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def price(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float | None:\n    \"\"\"\n    Calculate the NTN-F price using Anbima rules, which corresponds to the present\n        value of the cash flows discounted at the given yield to maturity rate (YTM).\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the price.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The discount rate (yield to maturity) used to calculate the\n            present value of the cash flows.\n\n    Returns:\n        float | None: The NTN-F price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 48.81, which represents a 10% annual\n          coupon rate compounded semi-annually and rounded to 5 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n        895.359254\n    \"\"\"\n    if has_null_args(settlement, maturity, rate):\n        return None\n    cf_df = cash_flows(settlement, maturity)\n    cf_values = cf_df[\"CashFlow\"]\n    bdays = bday.count(settlement, cf_df[\"PaymentDate\"])\n    byears = tools.truncate(bdays / 252, 14)\n    discount_factors = (1 + rate) ** byears\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    dcf = (cf_values / discount_factors).round(9)\n    # Return the sum of the discounted cash flows truncated as per Anbima rules\n    return tools.truncate(dcf.sum(), 6)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.spot_rates","title":"<code>spot_rates(settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates, show_coupons=False)</code>","text":"<p>Calculate the spot rates (zero coupon rates) for NTN-F bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price. It uses the LTN rates, which are zero coupon bonds, up to the last LTN maturity available. For maturities after the last LTN maturity, it calculates the spot rates using the bootstrap method.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date for the spot rates calculation.</p> required <code>ltn_maturities</code> <code>DateArray</code> <p>The LTN known maturities.</p> required <code>ltn_rates</code> <code>FloatArray</code> <p>The LTN known rates.</p> required <code>ntnf_maturities</code> <code>DateArray</code> <p>The NTN-F known maturities.</p> required <code>ntnf_rates</code> <code>FloatArray</code> <p>The NTN-F known rates.</p> required <code>show_coupons</code> <code>bool</code> <p>If True, show also July rates corresponding to the coupon payments. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\" and \"SpotRate\". \"BDToMat\" is the business days from the settlement date to the maturities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf, ltn\n&gt;&gt;&gt; df_ltn = ltn.data(\"03-09-2024\")\n&gt;&gt;&gt; df_ntnf = ntnf.data(\"03-09-2024\")\n&gt;&gt;&gt; ntnf.spot_rates(\n...     settlement=\"03-09-2024\",\n...     ltn_maturities=df_ltn[\"MaturityDate\"],\n...     ltn_rates=df_ltn[\"IndicativeRate\"],\n...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n... )\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-01   \u2506 83      \u2506 0.108837 \u2502\n\u2502 2027-01-01   \u2506 584     \u2506 0.119981 \u2502\n\u2502 2029-01-01   \u2506 1083    \u2506 0.122113 \u2502\n\u2502 2031-01-01   \u2506 1584    \u2506 0.122231 \u2502\n\u2502 2033-01-01   \u2506 2088    \u2506 0.121355 \u2502\n\u2502 2035-01-01   \u2506 2587    \u2506 0.121398 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def spot_rates(  # noqa\n    settlement: DateScalar,\n    ltn_maturities: DateArray,\n    ltn_rates: FloatArray,\n    ntnf_maturities: DateArray,\n    ntnf_rates: FloatArray,\n    show_coupons: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate the spot rates (zero coupon rates) for NTN-F bonds using the bootstrap\n    method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price. It uses the LTN rates, which are zero coupon bonds, up to the\n    last LTN maturity available. For maturities after the last LTN maturity,\n    it calculates the spot rates using the bootstrap method.\n\n\n    Args:\n        settlement (DateScalar): The settlement date for the spot rates calculation.\n        ltn_maturities (DateArray): The LTN known maturities.\n        ltn_rates (FloatArray): The LTN known rates.\n        ntnf_maturities (DateArray): The NTN-F known maturities.\n        ntnf_rates (FloatArray): The NTN-F known rates.\n        show_coupons (bool): If True, show also July rates corresponding to the\n            coupon payments. Defaults to False.\n\n    Returns:\n        pl.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\" and\n            \"SpotRate\". \"BDToMat\" is the business days from the settlement date\n            to the maturities.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf, ltn\n        &gt;&gt;&gt; df_ltn = ltn.data(\"03-09-2024\")\n        &gt;&gt;&gt; df_ntnf = ntnf.data(\"03-09-2024\")\n        &gt;&gt;&gt; ntnf.spot_rates(\n        ...     settlement=\"03-09-2024\",\n        ...     ltn_maturities=df_ltn[\"MaturityDate\"],\n        ...     ltn_rates=df_ltn[\"IndicativeRate\"],\n        ...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n        ...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n        ... )\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-01   \u2506 83      \u2506 0.108837 \u2502\n        \u2502 2027-01-01   \u2506 584     \u2506 0.119981 \u2502\n        \u2502 2029-01-01   \u2506 1083    \u2506 0.122113 \u2502\n        \u2502 2031-01-01   \u2506 1584    \u2506 0.122231 \u2502\n        \u2502 2033-01-01   \u2506 2088    \u2506 0.121355 \u2502\n        \u2502 2035-01-01   \u2506 2587    \u2506 0.121398 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if has_null_args(\n        settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates\n    ):\n        return pl.DataFrame()\n    # 1. Converter e normalizar inputs para Polars\n    settlement = cv.convert_dates(settlement)\n    ltn_maturities = cv.convert_dates(ltn_maturities)\n    ntnf_maturities = cv.convert_dates(ntnf_maturities)\n    if not isinstance(ltn_rates, pl.Series):\n        ltn_rates = pl.Series(ltn_rates).cast(pl.Float64)\n    if not isinstance(ntnf_rates, pl.Series):\n        ntnf_rates = pl.Series(ntnf_rates).cast(pl.Float64)\n\n    # 2. Criar interpoladores (aceitam pl.Series diretamente)\n    ltn_rate_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ltn_maturities),\n        known_rates=ltn_rates,\n    )\n    ntnf_rate_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ntnf_maturities),\n        known_rates=ntnf_rates,\n    )\n\n    # 3. Gerar todas as datas de cupom at\u00e9 o \u00faltimo vencimento NTN-F\n    last_maturity = ntnf_maturities.max()\n    all_coupon_dates = payment_dates(settlement, last_maturity)\n\n    # 4. Construir DataFrame inicial\n    bdays_to_mat = bday.count(settlement, all_coupon_dates)\n    df = pl.DataFrame(\n        {\n            \"MaturityDate\": all_coupon_dates,\n            \"BDToMat\": bdays_to_mat,\n        }\n    ).with_columns(\n        BYears=pl.col(\"BDToMat\") / 252,\n        Coupon=COUPON_PMT,\n        YTM=pl.col(\"BDToMat\").map_elements(\n            ntnf_rate_interpolator, return_dtype=pl.Float64\n        ),\n    )\n\n    # 5. Loop de bootstrap (iterativo por depend\u00eancia sequencial)\n    last_ltn_maturity = ltn_maturities.max()\n    maturities_list = df[\"MaturityDate\"]\n    bdays_list = df[\"BDToMat\"]\n    byears_list = df[\"BYears\"]\n    ytm_list = df[\"YTM\"]\n\n    solved_spot_rates: list[float] = []\n    spot_map: dict[pl.Date, float] = {}\n\n    for i in range(len(df)):\n        mat_date = maturities_list[i]\n        bdays_val = int(bdays_list[i])\n        byears_val = float(byears_list[i])\n        ytm_val = float(ytm_list[i])\n\n        # Caso esteja antes (ou igual) ao \u00faltimo vencimento LTN: usar interpolador LTN\n        if mat_date &lt;= last_ltn_maturity:\n            spot_rate = ltn_rate_interpolator(bdays_val)\n            solved_spot_rates.append(spot_rate)\n            spot_map[mat_date] = spot_rate\n            continue\n\n        # Datas de cupom (exclui \u00faltimo pagamento) para este vencimento\n        cf_dates = payment_dates(settlement, mat_date)[:-1]\n        if len(cf_dates) == 0:\n            # Caso improv\u00e1vel, mas protege contra divis\u00e3o por zero mais adiante\n            spot_rate = None\n            solved_spot_rates.append(spot_rate)\n            spot_map[mat_date] = spot_rate\n            continue\n\n        # Recuperar SpotRates j\u00e1 solucionadas para estes cupons\n        cf_spot_rates = [spot_map[d] for d in cf_dates]\n        cf_periods = bday.count(settlement, cf_dates) / 252\n        cf_cash_flows = [COUPON_PMT] * len(cf_dates)\n\n        cf_present_value = tools.calculate_present_value(\n            cash_flows=pl.Series(cf_cash_flows),\n            rates=pl.Series(cf_spot_rates),\n            periods=cf_periods,\n        )\n\n        bond_price = price(settlement, mat_date, ytm_val)\n        price_factor = FINAL_PMT / (bond_price - cf_present_value)\n        spot_rate = price_factor ** (1 / byears_val) - 1\n\n        solved_spot_rates.append(spot_rate)\n        spot_map[mat_date] = spot_rate\n\n    # 6. Anexar coluna SpotRate\n    df = df.with_columns(SpotRate=pl.Series(solved_spot_rates, dtype=pl.Float64))\n\n    # 7. Selecionar colunas finais\n    df = df.select([\"MaturityDate\", \"BDToMat\", \"SpotRate\"])\n\n    # 8. Remover cupons (Julho) se n\u00e3o solicitado\n    if not show_coupons:\n        df = df.filter(pl.col(\"MaturityDate\").is_in(ntnf_maturities.implode()))\n\n    return df\n</code></pre>"},{"location":"pre/","title":"PRE","text":""},{"location":"pre/#pyield.tn.pre.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>spread = taxa indicativa do PRE - taxa de ajuste do DI</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - BondType - MaturityDate - DISpread (decimal ou bps conforme par\u00e2metro)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\nshape: (18, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def di_spreads(date: DateScalar, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    spread = taxa indicativa do PRE - taxa de ajuste do DI\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateScalar): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Default False.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - BondType\n            - MaturityDate\n            - DISpread (decimal ou bps conforme par\u00e2metro)\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\n        shape: (18, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Fetch bond rates, filtering for LTN and NTN-F types\n    df = (\n        tpf.tpf_data(date, \"PRE\")\n        .with_columns(DISpread=pl.col(\"IndicativeRate\") - pl.col(\"DIRate\"))\n        .select(\"BondType\", \"MaturityDate\", \"DISpread\")\n        .sort(\"BondType\", \"MaturityDate\")\n    )\n\n    if bps:\n        df = df.with_columns(pl.col(\"DISpread\") * 10_000)\n\n    return df\n</code></pre>"},{"location":"pre/#pyield.tn.pre.spot_rates","title":"<code>spot_rates(date)</code>","text":"<p>Create the PRE curve (zero coupon rates) for Brazilian fixed rate bonds.</p> <p>This function combines LTN rates (which are already zero coupon) with spot rates derived from NTN-F bonds using the bootstrap method.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\", and \"SpotRate\".          Contains zero coupon rates for all available maturities.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any maturity date cannot be processed or business days cannot be calculated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.spot_rates(\"18-06-2025\")\n   MaturityDate  BDToMat  SpotRate\n0    2025-07-01        8   0.14835\n1    2025-10-01       74  0.147463\n2    2026-01-01      138  0.147752\n3    2026-04-01      199  0.147947\n4    2026-07-01      260  0.147069\n5    2026-10-01      325  0.144733\n6    2027-01-01      387  0.142496\n7    2027-04-01      447  0.140924\n8    2027-07-01      510  0.139024\n9    2028-01-01      638  0.136595\n10   2028-07-01      762  0.135664\n11   2029-01-01      886  0.136484\n12   2030-01-01     1135  0.137279\n13   2031-01-01     1387  0.138154\n14   2032-01-01     1639   0.13876\n15   2033-01-01     1891    0.1393\n16   2035-01-01     2390  0.141068\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def spot_rates(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Create the PRE curve (zero coupon rates) for Brazilian fixed rate bonds.\n\n    This function combines LTN rates (which are already zero coupon) with\n    spot rates derived from NTN-F bonds using the bootstrap method.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\", \"BDToMat\", and \"SpotRate\".\n                     Contains zero coupon rates for all available maturities.\n\n    Raises:\n        ValueError: If any maturity date cannot be processed or business days cannot be\n            calculated.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.spot_rates(\"18-06-2025\")\n           MaturityDate  BDToMat  SpotRate\n        0    2025-07-01        8   0.14835\n        1    2025-10-01       74  0.147463\n        2    2026-01-01      138  0.147752\n        3    2026-04-01      199  0.147947\n        4    2026-07-01      260  0.147069\n        5    2026-10-01      325  0.144733\n        6    2027-01-01      387  0.142496\n        7    2027-04-01      447  0.140924\n        8    2027-07-01      510  0.139024\n        9    2028-01-01      638  0.136595\n        10   2028-07-01      762  0.135664\n        11   2029-01-01      886  0.136484\n        12   2030-01-01     1135  0.137279\n        13   2031-01-01     1387  0.138154\n        14   2032-01-01     1639   0.13876\n        15   2033-01-01     1891    0.1393\n        16   2035-01-01     2390  0.141068\n    \"\"\"\n    # Fetch LTN data (zero coupon bonds)\n    df_ltn = anbima.tpf_data(date, \"LTN\").to_pandas(use_pyarrow_extension_array=True)\n\n    # Fetch NTN-F data (coupon bonds)\n    df_ntnf = anbima.tpf_data(date, \"NTN-F\").to_pandas(use_pyarrow_extension_array=True)\n\n    # Check if we have data for both bond types\n    if df_ltn.empty and df_ntnf.empty:\n        return pd.DataFrame(columns=[\"MaturityDate\", \"BDToMat\", \"SpotRate\"])\n\n    # If we only have LTN data, return it directly\n    if df_ntnf.empty:\n        pass\n        # return _process_ltn_only(date, df_ltn)\n\n    # If we only have NTN-F data, we can't bootstrap without LTN rates\n    if df_ltn.empty:\n        raise ValueError(\n            \"Cannot construct PRE curve without LTN rates for bootstrapping\"\n        )\n\n    # Use the existing spot_rates function to calculate zero coupon rates\n    df_spots = ntnf.spot_rates(\n        settlement=date,\n        ltn_maturities=df_ltn[\"MaturityDate\"],\n        ltn_rates=df_ltn[\"IndicativeRate\"],\n        ntnf_maturities=df_ntnf[\"MaturityDate\"],\n        ntnf_rates=df_ntnf[\"IndicativeRate\"],\n        show_coupons=False,\n    ).to_pandas(use_pyarrow_extension_array=True)\n\n    # Find LTN maturities that are not in the NTN-F result\n    ltn_mask = ~df_ltn[\"MaturityDate\"].isin(df_spots[\"MaturityDate\"])\n    ltn_not_in_ntnf = df_ltn.loc[ltn_mask].copy()\n\n    if not ltn_not_in_ntnf.empty:\n        # Process additional LTN maturities\n        ltn_subset = _process_additional_ltn(date, ltn_not_in_ntnf)\n\n        # Ensure consistent data types\n        ltn_subset[\"BDToMat\"] = ltn_subset[\"BDToMat\"].astype(\"int64[pyarrow]\")\n        df_spots[\"BDToMat\"] = df_spots[\"BDToMat\"].astype(\"int64[pyarrow]\")\n\n        # Combine LTN and NTN-F derived spot rates\n        df_combined = pd.concat([df_spots, ltn_subset], ignore_index=True)\n    else:\n        df_combined = df_spots.copy()\n        df_combined[\"BDToMat\"] = df_combined[\"BDToMat\"].astype(\"int64[pyarrow]\")\n\n    # Final validation - ensure no NaN values in the result\n    _validate_final_result(df_combined)\n\n    # Sort by maturity date and return\n    return df_combined.sort_values(\"MaturityDate\").reset_index(drop=True)\n</code></pre>"},{"location":"tn/","title":"Tesouro Data","text":""},{"location":"tn/#pyield.tn.auction","title":"<code>auction(auction_date)</code>","text":"<p>Fetches and processes Brazilian Treasury auction data for a given date.</p> <p>This function queries the Tesouro Nacional API to retrieve auction results for a specific date. It then processes the JSON response using the Polars library to create a well-structured and typed DataFrame.</p> <p>Exemplo de resposta da API de leil\u00f5es do Tesouro: https://apiapex.tesouro.gov.br/aria/v1/api-leiloes-pub/custom/resultados?dataleilao=30/09/2025</p> <pre><code>{\n\"registros\": [\n    {...},\n    {\n    \"quantidade_bcb\": 0,\n    \"liquidacao_segunda_volta\": \"2025-10-01T00:00:00.000Z\",\n    \"oferta_segunda_volta\": 37499,\n    \"data_leilao\": \"30/09/2025\",\n    \"oferta\": 150000,\n    \"titulo\": \"LFT\",\n    \"liquidacao\": \"01/10/2025\",\n    \"financeiro_aceito_segunda_volta\": 0,\n    \"quantidade_aceita\": 150000,\n    \"prazo\": 1067,\n    \"vencimento\": \"01/09/2028\",\n    \"benchmark\": \"LFT 3 anos\",\n    \"pu_medio\": 17434.81182753125,\n    \"taxa_media\": 0.0669,\n    \"financeiro_aceito\": 2615194916.22,\n    \"pu_minimo\": 17434.632775,\n    \"numero_edital\": 230,\n    \"taxa_maxima\": 0.0669,\n    \"tipo_leilao\": \"Venda\",\n    \"financeiro_bcb\": 0,\n    \"quantidade_aceita_segunda_volta\": 0\n    },\n    {...},\n],\n\"status\": \"ok\"\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>auction_date</code> <code>DateScalar</code> <p>The date of the auction in the format accepted by PYield DateScalar (e.g., \"DD-MM-YYYY\", datetime.date, etc.).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Um DataFrame do Polars contendo os dados processados do leil\u00e3o. As colunas s\u00e3o:</p> <code>DataFrame</code> <ul> <li>data_1v: Data de realiza\u00e7\u00e3o do leil\u00e3o (1\u00aa volta).</li> </ul> <code>DataFrame</code> <ul> <li>data_liquidacao_1v: Data de liquida\u00e7\u00e3o financeira da 1\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>data_liquidacao_2v: Data de liquida\u00e7\u00e3o financeira da 2\u00aa volta (se houver).</li> </ul> <code>DataFrame</code> <ul> <li>numero_edital: N\u00famero do edital que rege o leil\u00e3o.</li> </ul> <code>DataFrame</code> <ul> <li>tipo_leilao: Tipo da opera\u00e7\u00e3o (ex: \"Venda\", \"Compra\").</li> </ul> <code>DataFrame</code> <ul> <li>titulo: C\u00f3digo do t\u00edtulo p\u00fablico leiloado (ex: \"NTN-B\", \"LFT\").</li> </ul> <code>DataFrame</code> <ul> <li>benchmark: Descri\u00e7\u00e3o de refer\u00eancia do t\u00edtulo (ex: \"NTN-B 3 anos\").</li> </ul> <code>DataFrame</code> <ul> <li>data_vencimento: Data de vencimento do t\u00edtulo.</li> </ul> <code>DataFrame</code> <ul> <li>dias_uteis: N\u00famero de dias \u00fateis entre a liquida\u00e7\u00e3o (1v) e o vencimento.</li> </ul> <code>DataFrame</code> <ul> <li>dias_corridos: Prazo em dias corridos do t\u00edtulo, conforme informado pela API.</li> </ul> <code>DataFrame</code> <ul> <li>duration: A Dura\u00e7\u00e3o de Macaulay do t\u00edtulo em anos, calculada entre a liquida\u00e7\u00e3o da 1\u00aa volta e o vencimento do t\u00edtulo.</li> </ul> <code>DataFrame</code> <ul> <li>prazo_medio: A maturidade m\u00e9dia do t\u00edtulo em anos, conforme metodologia do Tesouro, calculada entre a liquida\u00e7\u00e3o da 1\u00aa volta e o vencimento do t\u00edtulo.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_ofertada_1v: Quantidade de t\u00edtulos ofertados na 1\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_ofertada_2v: Quantidade de t\u00edtulos ofertados na 2\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_aceita_1v: Quantidade de t\u00edtulos com propostas aceitas na 1\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_aceita_2v: Quantidade de t\u00edtulos aceitos na 2\u00aa volta.</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_aceita_total: Soma das quantidades aceitas nas duas voltas.</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_ofertado_1v: Financeiro ofertado total na 1\u00aa volta (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_ofertado_2v: Financeiro ofertado total na 2\u00aa volta (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_ofertado_total: Financeiro total ofertado nas duas voltas (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_aceito_1v: Financeiro aceito total na 1\u00aa volta (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_aceito_2v: Financeiro aceito total na 2\u00aa volta (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_aceito_total: Soma do financeiro aceito nas duas voltas (em BRL).</li> </ul> <code>DataFrame</code> <ul> <li>quantidade_bcb: Quantidade de t\u00edtulos adquirida pelo Banco Central.</li> </ul> <code>DataFrame</code> <ul> <li>financeiro_bcb: Financeiro adquirido pelo Banco Central.</li> </ul> <code>DataFrame</code> <ul> <li>colocacao_1v: Taxa de coloca\u00e7\u00e3o da 1\u00aa volta (quantidade aceita / ofertada).</li> </ul> <code>DataFrame</code> <ul> <li>colocacao_2v: Taxa de coloca\u00e7\u00e3o da 2\u00aa volta (quantidade aceita / ofertada).</li> </ul> <code>DataFrame</code> <ul> <li>colocacao_total: Taxa de coloca\u00e7\u00e3o total (quantidade aceita / ofertada).</li> </ul> <code>DataFrame</code> <ul> <li>dv01_1v: DV01 da 1\u00aa volta em BRL.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_2v: DV01 da 2\u00aa volta em BRL.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_total: DV01 total do leil\u00e3o em BRL.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_1v_usd: DV01 da 1\u00aa volta em USD usando a PTAX do dia.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_2v_usd: DV01 da 2\u00aa volta em USD usando a PTAX do dia.</li> </ul> <code>DataFrame</code> <ul> <li>dv01_total_usd: DV01 total das duas voltas em USD usando a PTAX do dia.</li> </ul> <code>DataFrame</code> <ul> <li>pu_minimo: Pre\u00e7o Unit\u00e1rio m\u00ednimo aceito no leil\u00e3o.</li> </ul> <code>DataFrame</code> <ul> <li>pu_medio: Pre\u00e7o Unit\u00e1rio m\u00e9dio ponderado das propostas aceitas.</li> </ul> <code>DataFrame</code> <ul> <li>tipo_pu_medio: Indica se o PU m\u00e9dio \u00e9 \"original\" (fornecido pela API) ou \"calculado\" (recalculado pela fun\u00e7\u00e3o).</li> </ul> <code>DataFrame</code> <ul> <li>taxa_media: Taxa de juros m\u00e9dia das propostas aceitas (em formato decimal).</li> </ul> <code>DataFrame</code> <ul> <li>taxa_maxima: Taxa de juros m\u00e1xima aceita no leil\u00e3o (taxa de corte, em formato decimal).</li> </ul> <p>Retorna um DataFrame do Pandas vazio se ocorrer um erro na requisi\u00e7\u00e3o, no processamento, ou se n\u00e3o houver dados para a data especificada.</p> Source code in <code>pyield/tn/auctions.py</code> <pre><code>def auction(auction_date: DateScalar) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches and processes Brazilian Treasury auction data for a given date.\n\n    This function queries the Tesouro Nacional API to retrieve auction results\n    for a specific date. It then processes the JSON response using the Polars\n    library to create a well-structured and typed DataFrame.\n\n    Exemplo de resposta da API de leil\u00f5es do Tesouro:\n    https://apiapex.tesouro.gov.br/aria/v1/api-leiloes-pub/custom/resultados?dataleilao=30/09/2025\n\n        {\n        \"registros\": [\n            {...},\n            {\n            \"quantidade_bcb\": 0,\n            \"liquidacao_segunda_volta\": \"2025-10-01T00:00:00.000Z\",\n            \"oferta_segunda_volta\": 37499,\n            \"data_leilao\": \"30/09/2025\",\n            \"oferta\": 150000,\n            \"titulo\": \"LFT\",\n            \"liquidacao\": \"01/10/2025\",\n            \"financeiro_aceito_segunda_volta\": 0,\n            \"quantidade_aceita\": 150000,\n            \"prazo\": 1067,\n            \"vencimento\": \"01/09/2028\",\n            \"benchmark\": \"LFT 3 anos\",\n            \"pu_medio\": 17434.81182753125,\n            \"taxa_media\": 0.0669,\n            \"financeiro_aceito\": 2615194916.22,\n            \"pu_minimo\": 17434.632775,\n            \"numero_edital\": 230,\n            \"taxa_maxima\": 0.0669,\n            \"tipo_leilao\": \"Venda\",\n            \"financeiro_bcb\": 0,\n            \"quantidade_aceita_segunda_volta\": 0\n            },\n            {...},\n        ],\n        \"status\": \"ok\"\n        }\n\n    Args:\n        auction_date: The date of the auction in the format accepted by PYield\n            DateScalar (e.g., \"DD-MM-YYYY\", datetime.date, etc.).\n\n    Returns:\n        Um DataFrame do Polars contendo os dados processados do leil\u00e3o. As colunas s\u00e3o:\n        - data_1v: Data de realiza\u00e7\u00e3o do leil\u00e3o (1\u00aa volta).\n        - data_liquidacao_1v: Data de liquida\u00e7\u00e3o financeira da 1\u00aa volta.\n        - data_liquidacao_2v: Data de liquida\u00e7\u00e3o financeira da 2\u00aa volta (se houver).\n        - numero_edital: N\u00famero do edital que rege o leil\u00e3o.\n        - tipo_leilao: Tipo da opera\u00e7\u00e3o (ex: \"Venda\", \"Compra\").\n        - titulo: C\u00f3digo do t\u00edtulo p\u00fablico leiloado (ex: \"NTN-B\", \"LFT\").\n        - benchmark: Descri\u00e7\u00e3o de refer\u00eancia do t\u00edtulo (ex: \"NTN-B 3 anos\").\n        - data_vencimento: Data de vencimento do t\u00edtulo.\n        - dias_uteis: N\u00famero de dias \u00fateis entre a liquida\u00e7\u00e3o (1v) e o vencimento.\n        - dias_corridos: Prazo em dias corridos do t\u00edtulo, conforme informado pela API.\n        - duration: A Dura\u00e7\u00e3o de Macaulay do t\u00edtulo em anos, calculada entre a\n            liquida\u00e7\u00e3o da 1\u00aa volta e o vencimento do t\u00edtulo.\n        - prazo_medio: A maturidade m\u00e9dia do t\u00edtulo em anos, conforme metodologia do\n            Tesouro, calculada entre a liquida\u00e7\u00e3o da 1\u00aa volta e o vencimento do t\u00edtulo.\n        - quantidade_ofertada_1v: Quantidade de t\u00edtulos ofertados na 1\u00aa volta.\n        - quantidade_ofertada_2v: Quantidade de t\u00edtulos ofertados na 2\u00aa volta.\n        - quantidade_aceita_1v: Quantidade de t\u00edtulos com propostas aceitas na 1\u00aa volta.\n        - quantidade_aceita_2v: Quantidade de t\u00edtulos aceitos na 2\u00aa volta.\n        - quantidade_aceita_total: Soma das quantidades aceitas nas duas voltas.\n        - financeiro_ofertado_1v: Financeiro ofertado total na 1\u00aa volta (em BRL).\n        - financeiro_ofertado_2v: Financeiro ofertado total na 2\u00aa volta (em BRL).\n        - financeiro_ofertado_total: Financeiro total ofertado nas duas voltas (em BRL).\n        - financeiro_aceito_1v: Financeiro aceito total na 1\u00aa volta (em BRL).\n        - financeiro_aceito_2v: Financeiro aceito total na 2\u00aa volta (em BRL).\n        - financeiro_aceito_total: Soma do financeiro aceito nas duas voltas (em BRL).\n        - quantidade_bcb: Quantidade de t\u00edtulos adquirida pelo Banco Central.\n        - financeiro_bcb: Financeiro adquirido pelo Banco Central.\n        - colocacao_1v: Taxa de coloca\u00e7\u00e3o da 1\u00aa volta (quantidade aceita / ofertada).\n        - colocacao_2v: Taxa de coloca\u00e7\u00e3o da 2\u00aa volta (quantidade aceita / ofertada).\n        - colocacao_total: Taxa de coloca\u00e7\u00e3o total (quantidade aceita / ofertada).\n        - dv01_1v: DV01 da 1\u00aa volta em BRL.\n        - dv01_2v: DV01 da 2\u00aa volta em BRL.\n        - dv01_total: DV01 total do leil\u00e3o em BRL.\n        - dv01_1v_usd: DV01 da 1\u00aa volta em USD usando a PTAX do dia.\n        - dv01_2v_usd: DV01 da 2\u00aa volta em USD usando a PTAX do dia.\n        - dv01_total_usd: DV01 total das duas voltas em USD usando a PTAX do dia.\n        - pu_minimo: Pre\u00e7o Unit\u00e1rio m\u00ednimo aceito no leil\u00e3o.\n        - pu_medio: Pre\u00e7o Unit\u00e1rio m\u00e9dio ponderado das propostas aceitas.\n        - tipo_pu_medio: Indica se o PU m\u00e9dio \u00e9 \"original\" (fornecido pela API) ou\n            \"calculado\" (recalculado pela fun\u00e7\u00e3o).\n        - taxa_media: Taxa de juros m\u00e9dia das propostas aceitas (em formato decimal).\n        - taxa_maxima: Taxa de juros m\u00e1xima aceita no leil\u00e3o (taxa de corte, em formato\n            decimal).\n\n    Retorna um DataFrame do Pandas vazio se ocorrer um erro na requisi\u00e7\u00e3o, no\n    processamento, ou se n\u00e3o houver dados para a data especificada.\n    \"\"\"\n    if has_null_args(auction_date):\n        logger.info(\"No auction date provided.\")\n        return pl.DataFrame()\n    try:\n        auction_date = cv.convert_dates(auction_date)\n        data = _fetch_auction_data(auction_date)\n        if not data:\n            logger.info(f\"No auction data available for {auction_date}.\")\n            return pl.DataFrame()\n        df = _transform_raw_data(data)\n        df = _add_duration(df)\n        df = _add_dv01(df)\n        df = _add_dv01_usd(df)\n        df = _add_avg_maturity(df)\n        df = df.select(FINAL_COLUMN_ORDER)\n        return df\n\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"An error occurred during the API request: {e}\")\n        return pl.DataFrame()\n    except ValueError as e:\n        logger.error(f\"An error occurred while parsing the JSON response: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"tn/#pyield.tn.benchmarks","title":"<code>benchmarks(bond_type=None, include_history=False)</code>","text":"<p>Fetches benchmark data for Brazilian Treasury Bonds from the TN API.</p> <p>This function retrieves current or historical benchmark data for various Brazilian Treasury bond types (e.g., LTN, LFT, NTN-B). The data is sourced directly from the official Tesouro Nacional API.</p> <p>Parameters:</p> Name Type Description Default <code>include_history</code> <code>bool</code> <p>If <code>True</code>, includes historical benchmark data. If <code>False</code> (default), only current benchmarks are returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: A Polars DataFrame containing the benchmark data. The DataFrame includes the following columns: *   <code>BondType</code> (str): The type of the bond (e.g., 'LTN', 'LFT', 'NTN-B'). *   <code>MaturityDate</code> (datetime.date): The maturity date of the benchmark. *   <code>Benchmark</code> (str): The name or identifier of the benchmark     (e.g., 'LFT 3 anos'). *   <code>StartDate</code> (datetime.date): The start date for the benchmark's period. *   <code>EndDate</code> (datetime.date): The end date for the benchmark's period.</p> Notes <ul> <li>Data is sourced from the official Tesouro Nacional (Brazilian Treasury) API.</li> <li>An retry mechanism is implemented for SSL certificate verification errors.</li> <li>The API documentation can be found at:     https://portal-conhecimento.tesouro.gov.br/catalogo-componentes/api-leil%C3%B5es</li> <li>Rows with any <code>NaN</code> values are dropped before returning the DataFrame.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import tn\n&gt;&gt;&gt; df_current = tn.benchmarks()\n&gt;&gt;&gt; # Get historical benchmarks\n&gt;&gt;&gt; tn.benchmarks(bond_type=\"LFT\", include_history=True).head()\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 Benchmark  \u2506 StartDate  \u2506 EndDate    \u2502\n\u2502 ---      \u2506 ---          \u2506 ---        \u2506 ---        \u2506 ---        \u2502\n\u2502 str      \u2506 date         \u2506 str        \u2506 date       \u2506 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LFT      \u2506 2020-03-01   \u2506 LFT 6 anos \u2506 2014-01-01 \u2506 2014-06-30 \u2502\n\u2502 LFT      \u2506 2020-09-01   \u2506 LFT 6 anos \u2506 2014-07-01 \u2506 2014-12-31 \u2502\n\u2502 LFT      \u2506 2021-03-01   \u2506 LFT 6 anos \u2506 2015-01-01 \u2506 2015-04-30 \u2502\n\u2502 LFT      \u2506 2021-09-01   \u2506 LFT 6 anos \u2506 2015-05-01 \u2506 2015-12-31 \u2502\n\u2502 LFT      \u2506 2022-03-01   \u2506 LFT 6 anos \u2506 2016-01-01 \u2506 2016-06-30 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/benchmark.py</code> <pre><code>def benchmarks(bond_type: str = None, include_history: bool = False) -&gt; pl.DataFrame:\n    \"\"\"Fetches benchmark data for Brazilian Treasury Bonds from the TN API.\n\n    This function retrieves current or historical benchmark data for various Brazilian\n    Treasury bond types (e.g., LTN, LFT, NTN-B). The data is sourced directly from the\n    official Tesouro Nacional API.\n\n    Args:\n        include_history (bool, optional): If `True`, includes historical benchmark data.\n            If `False` (default), only current benchmarks are returned.\n\n    Returns:\n        pl.DataFrame: A Polars DataFrame containing the benchmark data.\n            The DataFrame includes the following columns:\n            *   `BondType` (str): The type of the bond (e.g., 'LTN', 'LFT', 'NTN-B').\n            *   `MaturityDate` (datetime.date): The maturity date of the benchmark.\n            *   `Benchmark` (str): The name or identifier of the benchmark\n                (e.g., 'LFT 3 anos').\n            *   `StartDate` (datetime.date): The start date for the benchmark's period.\n            *   `EndDate` (datetime.date): The end date for the benchmark's period.\n\n    Notes:\n        *   Data is sourced from the official Tesouro Nacional (Brazilian Treasury) API.\n        *   An retry mechanism is implemented for SSL certificate verification errors.\n        *   The API documentation can be found at:\n            https://portal-conhecimento.tesouro.gov.br/catalogo-componentes/api-leil%C3%B5es\n        *   Rows with any `NaN` values are dropped before returning the DataFrame.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import tn\n        &gt;&gt;&gt; df_current = tn.benchmarks()\n        &gt;&gt;&gt; # Get historical benchmarks\n        &gt;&gt;&gt; tn.benchmarks(bond_type=\"LFT\", include_history=True).head()\n        shape: (5, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 Benchmark  \u2506 StartDate  \u2506 EndDate    \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---        \u2506 ---        \u2506 ---        \u2502\n        \u2502 str      \u2506 date         \u2506 str        \u2506 date       \u2506 date       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LFT      \u2506 2020-03-01   \u2506 LFT 6 anos \u2506 2014-01-01 \u2506 2014-06-30 \u2502\n        \u2502 LFT      \u2506 2020-09-01   \u2506 LFT 6 anos \u2506 2014-07-01 \u2506 2014-12-31 \u2502\n        \u2502 LFT      \u2506 2021-03-01   \u2506 LFT 6 anos \u2506 2015-01-01 \u2506 2015-04-30 \u2502\n        \u2502 LFT      \u2506 2021-09-01   \u2506 LFT 6 anos \u2506 2015-05-01 \u2506 2015-12-31 \u2502\n        \u2502 LFT      \u2506 2022-03-01   \u2506 LFT 6 anos \u2506 2016-01-01 \u2506 2016-06-30 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    api_data = _fetch_raw_benchmarks(include_history=include_history)\n    df = _process_api_data(api_data)\n\n    # Definir a ordena\u00e7\u00e3o final com base no caso de uso\n    if include_history:\n        # Para dados hist\u00f3ricos, a ordem cronol\u00f3gica \u00e9 mais \u00fatil\n        sort_columns = [\"StartDate\", \"BondType\", \"MaturityDate\"]\n    else:\n        # Para dados atuais, agrupar por tipo de t\u00edtulo \u00e9 mais \u00fatil\n        sort_columns = [\"BondType\", \"MaturityDate\"]\n        # Filtrar apenas os dados atuais\n        today = dt.now(TIMEZONE_BZ).date()\n        df = df.filter(pl.lit(today).is_between(pl.col(\"StartDate\"), pl.col(\"EndDate\")))\n\n    if bond_type:\n        df = df.filter(pl.col(\"BondType\") == bond_type)\n\n    return df.select(FINAL_COLUMN_ORDER).sort(sort_columns)\n</code></pre>"},{"location":"tn/#pyield.tn.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>spread = taxa indicativa do PRE - taxa de ajuste do DI</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame com colunas: - BondType - MaturityDate - DISpread (decimal ou bps conforme par\u00e2metro)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\nshape: (18, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def di_spreads(date: DateScalar, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    spread = taxa indicativa do PRE - taxa de ajuste do DI\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateScalar): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Default False.\n\n    Returns:\n        pl.DataFrame com colunas:\n            - BondType\n            - MaturityDate\n            - DISpread (decimal ou bps conforme par\u00e2metro)\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\n        shape: (18, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Fetch bond rates, filtering for LTN and NTN-F types\n    df = (\n        tpf.tpf_data(date, \"PRE\")\n        .with_columns(DISpread=pl.col(\"IndicativeRate\") - pl.col(\"DIRate\"))\n        .select(\"BondType\", \"MaturityDate\", \"DISpread\")\n        .sort(\"BondType\", \"MaturityDate\")\n    )\n\n    if bps:\n        df = df.with_columns(pl.col(\"DISpread\") * 10_000)\n\n    return df\n</code></pre>"},{"location":"articles/pyield_intro/","title":"Introdu\u00e7\u00e3o a PYield","text":""},{"location":"articles/pyield_intro/#uma-biblioteca-em-python-para-obtecao-de-dados-de-instrumentos-de-renda-fixa-brasileira","title":"Uma biblioteca em Python para obte\u00e7\u00e3o de dados de instrumentos de Renda Fixa brasileira","text":"<p>Se voc\u00ea \u00e9 um entusiasta de VBA e Excel, pode pular esse artigo que aqui n\u00e3o \u00e9 lugar para voc\u00ea! Brincadeira, voc\u00ea \u00e9 bem-vindo tamb\u00e9m. Afinal, essa pode ser uma \u00f3tima desculpa para voc\u00ea finalmente aprender Python \ud83d\ude02</p> <p>Brincadeiras \u00e0 parte, qualquer um que trabalhe com an\u00e1lise de renda fixa no sabe que a obten\u00e7\u00e3o de dados de fontes como ANBIMA e B3 pode ser uma tarefa complicada. Outro ponto refere-se ao tratamento dos feriados e dias \u00fateis, um verdadeiro pesadelo para quem precisa calcular prazos e vencimentos, ainda mais depois que criaram um novo feriado nacional no final do ano passado. Sim, agora temos que considerar duas listas de feriados nacionais, uma para dados ateriores a 26-12-2023 e outra para depois.</p> <p>Claro que para os afortunados com acesso a servi\u00e7os pagos como Bloomberg, a obten\u00e7\u00e3o desse tipo de dados j\u00e1 \u00e9 bem f\u00e1cil. Mas para a maioria dos analistas financeiros, pesquisadores e entusiastas do mercado, a obten\u00e7\u00e3o e processamento desses dados pode ser um desafio. Afinal, voc\u00ea ter\u00e1 que lidar com chamadas para diversas APIs como a do IBGE, do BACEN, da ANBIMA, da B3, e por a\u00ed vai. Em alguns casos, o dado tem que ser extra\u00eddo diretamente de sites, o que pode ser ainda mais complicado.</p>"},{"location":"articles/pyield_intro/#o-que-e-pyield","title":"O que \u00e9 PYield?","text":"<p>A biblioteca Python foi projetada especificamente para a obten\u00e7\u00e3o e tratamento de dados de instrumentos de renda fixa. Ou seja, \u00e9 uma tentativa de  simplificar a obten\u00e7\u00e3o e processamento de dados de fontes prim\u00e1rias como ANBIMA e B3, fornecendo uma API de f\u00e1cil utiliza\u00e7\u00e3o.</p> <p>Utilizando a robustez de bibliotecas populares de Python, como Pandas, Requests e Numpy, PYield pode ser usada como backend de aplica\u00e7\u00f5es mais complexas, removendo a parte pesada relacionada a obten\u00e7\u00e3o e processamento de dados de fontes e formatos diversos.</p>"},{"location":"articles/pyield_intro/#caracteristicas-principais","title":"Caracter\u00edsticas Principais","text":"<ul> <li>Coleta de Dados: Obtenha dados diretamente de fontes prim\u00e1rias como ANBIMA e B3 de forma simples e r\u00e1pida.</li> <li>Processamento de Dados: Os dados s\u00e3o processados e entregues em formatos f\u00e1ceis de usar, como DataFrames do Pandas.</li> <li>Ferramentas de An\u00e1lise: Acesse fun\u00e7\u00f5es para tarefas comuns de an\u00e1lise do mercado de renda fixa, como c\u00e1lculos de dias \u00fateis e feriados.</li> </ul>"},{"location":"articles/pyield_intro/#como-instalar-o-pyield","title":"Como Instalar o PYield","text":"<p>A instala\u00e7\u00e3o do PYield \u00e9 r\u00e1pida e f\u00e1cil atrav\u00e9s do pip, o gerenciador de pacotes do Python. Basta abrir o terminal e executar o seguinte comando no seu ambiente virtual:</p> <p><pre><code>pip install pyield\n</code></pre> Este comando instala a \u00faltima vers\u00e3o do PYield, deixando voc\u00ea pronto para come\u00e7ar a utilizar a biblioteca em seus projetos.</p> <p>Exemplos Pr\u00e1ticos de Uso:</p>"},{"location":"articles/pyield_intro/#ferramentas-de-dias-uteis-feriados-brasileiros-sao-automaticamente-considerados","title":"Ferramentas de Dias \u00dateis (Feriados brasileiros s\u00e3o automaticamente considerados)","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n\n# Contar o n\u00famero de dias \u00fateis entre duas datas.\n# A data de in\u00edcio \u00e9 inclusiva, a data de t\u00e9rmino \u00e9 exclusiva.\n&gt;&gt;&gt; yd.bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Obtenha o pr\u00f3ximo dia \u00fatil ap\u00f3s uma determinada data (offset=1).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=1)\nTimestamp('2024-01-02 00:00:00')\n\n# Obtenha o pr\u00f3ximo dia \u00fatil se n\u00e3o for um dia \u00fatil (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"30-12-2023\", offset=0)\nTimestamp('2024-01-02 00:00:00')\n\n# Como 2023-12-29 j\u00e1 \u00e9 um dia \u00fatil, a fun\u00e7\u00e3o retorna a mesma data (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=0)\nTimestamp('2023-12-29 00:00:00')\n\n# Gerar uma s\u00e9rie de dias \u00fateis entre duas datas.\n&gt;&gt;&gt; yd.bday.generate(start='2023-12-29', end='2024-01-03')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\ndtype: datetime64[ns]\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-futuro-de-di","title":"Dados de Futuro de DI","text":"<pre><code># Obtenha um DataFrame com os dados dos Futuros de DI da B3 de uma data espec\u00edfica.\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", date='2024-03-08')\n\nTradeDate  ExpirationCode ExpirationDate BDaysToExp  ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08 J24            2024-04-01     15              ... 10.952   10.952      10.956      10.956\n2024-03-08 K24            2024-05-02     37              ... 10.776   10.774      10.780      10.777\n2024-03-08 M24            2024-06-03     58              ... 10.604   10.602      10.604      10.608\n...        ...            ...            ...             ... ...      ...         ...         ...\n2024-03-08 F37            2037-01-02     3213            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F38            2038-01-04     3462            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F39            2039-01-03     3713            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.85\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-titulos-do-tesouro","title":"Dados de T\u00edtulos do Tesouro","text":"<pre><code># Obtenha um DataFrame com os dados dos t\u00edtulos NTN-B da ANBIMA.\n# Os dados da Anbima est\u00e3o dispon\u00edveis para os \u00faltimos 5 dias \u00fateis.\n# Obs: Para quem \u00e9 membro da Anbima, o acesso ao hist\u00f3rico \u00e9 liberado automaticamente pela biblioteca.\n&gt;&gt;&gt; yd.anbima(bond_type=\"NTN-B\", date='2024-04-12')\n\nBondType ReferenceDate MaturityDate BidRate AskRate IndicativeRate Price\nNTN-B    2024-04-12    2024-08-15   0.07540 0.07504 0.07523        4,271.43565\nNTN-B    2024-04-12    2025-05-15   0.05945 0.05913 0.05930        4,361.34391\nNTN-B    2024-04-12    2026-08-15   0.05927 0.05897 0.05910        4,301.40082\n...      ...           ...          ...     ...     ...            ...\nNTN-B    2024-04-12    2050-08-15   0.06039 0.06006 0.06023        4,299.28233\nNTN-B    2024-04-12    2055-05-15   0.06035 0.05998 0.06017        4,367.13360\nNTN-B    2024-04-12    2060-08-15   0.06057 0.06016 0.06036        4,292.26323\n</code></pre>"},{"location":"articles/pyield_intro/#calculo-de-spreads","title":"C\u00e1lculo de spreads","text":"<pre><code># Calcule o spread entre o futuro de DI e os t\u00edtulos pr\u00e9-fixados do Tesouro.\n&gt;&gt;&gt; yd.spreads(spread_type=\"DI_PRE\", date=\"2024-4-11\")\n\nBondType ReferenceDate MaturityDate  DISpread\nLTN      2024-04-11    2024-07-01    -20.28\nLTN      2024-04-11    2024-10-01    -10.19\nLTN      2024-04-11    2025-01-01    -15.05\n...      ...           ...           ...\nNTN-F    2024-04-11    2031-01-01    -0.66\nNTN-F    2024-04-11    2033-01-01    -5.69\nNTN-F    2024-04-11    2035-01-01    -1.27\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-indicadores","title":"Dados de Indicadores","text":"<pre><code># Obtenha a taxa SELIC meta do BCB em um determinado dia.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"SELIC\", date='2024-04-12')\n0.1075  # 10.75%\n\n# Obtenha a taxa mensal (Monthly Rate) do IPCA do IBGE com base no m\u00eas de refer\u00eancia da data.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", date='2024-03-18')\n0.0016  # 0.16%\n\n# Se o indicador n\u00e3o estiver dispon\u00edvel para a data de refer\u00eancia, o retorno ser\u00e1 nulo (None).\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", date='2030-04-10')\nNone\n</code></pre>"},{"location":"articles/pyield_intro/#conclusao","title":"Conclus\u00e3o","text":"<p>Se voc\u00ea precisa obter e tratar dados de renda fixa, PYield pode ser uma ferramenta valiosa nesse processo. Com uma API simples, o seu c\u00f3digo pode se tornar mais limpo e eficiente, permitindo que voc\u00ea se concentre na an\u00e1lise dos dados em vez de se preocupar com a obten\u00e7\u00e3o e processamento deles.</p> <p>O c\u00f3digo da biblioteca pode ser acessado em: PYield</p> <p>Quem quiser contribuir com o desenvolvimento da ferramenta entre em contato comigo: cr.cj@outlook.com</p>"}]}