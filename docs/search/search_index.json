{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"In\u00edcio","text":""},{"location":"#pyield-toolkit-de-renda-fixa-brasileira","title":"PYield: Toolkit de Renda Fixa Brasileira","text":"<p>Portugu\u00eas | English</p> <p>PYield \u00e9 uma biblioteca Python voltada para an\u00e1lise de t\u00edtulos p\u00fablicos brasileiros. Ela busca e processa dados da ANBIMA, BCB, IBGE, B3 e Tesouro Nacional, retornando DataFrames do Polars para pipelines r\u00e1pidos e com tipagem consistente.</p> <p>Embora inclua dados e ferramentas de outros mercados (como DI1, DAP e PTAX), esses recursos s\u00e3o auxiliares para o objetivo central: an\u00e1lise, precifica\u00e7\u00e3o e acompanhamento de t\u00edtulos p\u00fablicos.</p>"},{"location":"#instalacao","title":"Instala\u00e7\u00e3o","text":"<pre><code>pip install pyield\n</code></pre>"},{"location":"#inicio-rapido","title":"In\u00edcio R\u00e1pido","text":"<pre><code>import pyield as yd\n\n# Dias \u00fateis (base de todos os c\u00e1lculos)\nyd.bday.count(\"02-01-2025\", \"15-01-2025\")  # -&gt; 9\nyd.bday.offset(\"29-12-2023\", 1)            # -&gt; datetime.date(2024, 1, 2)\n\n# Curva de DI Futuro\ndf = yd.futures(\"31-05-2024\", \"DI1\")\n# Columns: TradeDate, TickerSymbol, ExpirationDate, BDaysToExp, SettlementRate, ...\n\n# Interpola\u00e7\u00e3o de taxas (flat forward, conven\u00e7\u00e3o 252 dias \u00fateis/ano)\ninterp = yd.Interpolator(\"flat_forward\", df[\"BDaysToExp\"], df[\"SettlementRate\"])\ninterp(45)       # -&gt; 0.04833...\ninterp([30, 60]) # -&gt; pl.Series with interpolated rates\n\n# Precifica\u00e7\u00e3o de t\u00edtulos p\u00fablicos\nyd.ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)  # -&gt; 99.3651\n\n# Indicadores do BCB\nyd.bc.selic_over(\"31-05-2024\")  # -&gt; 0.000414...\n</code></pre> <p>Um notebook no Colab com mais exemplos:</p> <p></p>"},{"location":"#blocos-principais","title":"Blocos Principais","text":""},{"location":"#dias-uteis-bday","title":"Dias \u00dateis (<code>bday</code>)","text":"<p>O m\u00f3dulo <code>bday</code> \u00e9 a base do PYield. Todos os c\u00e1lculos com datas (pre\u00e7o, duration, taxas a termo) dependem da contagem correta de dias \u00fateis com feriados brasileiros.</p> <pre><code>from pyield import bday\n\n# Conta dias \u00fateis (in\u00edcio inclusivo, fim exclusivo)\nbday.count(\"29-12-2023\", \"02-01-2024\")  # -&gt; 1\n\n# Avan\u00e7a N dias \u00fateis\nbday.offset(\"29-12-2023\", 1)  # -&gt; datetime.date(2024, 1, 2)\n\n# Ajusta dia n\u00e3o \u00fatil para o pr\u00f3ximo dia \u00fatil\nbday.offset(\"30-12-2023\", 0)  # -&gt; datetime.date(2024, 1, 2)\n\n# Gera intervalo de dias \u00fateis\nbday.generate(\"22-12-2023\", \"02-01-2024\")\n# -&gt; Series: [2023-12-22, 2023-12-26, 2023-12-27, 2023-12-28, 2023-12-29, 2024-01-02]\n\n# Verifica se a data \u00e9 dia \u00fatil\nbday.is_business_day(\"25-12-2023\")  # -&gt; False (Christmas)\n</code></pre> <p>Todas as fun\u00e7\u00f5es suportam opera\u00e7\u00f5es vetorizadas com listas, Series ou arrays.</p>"},{"location":"#interpolacao-de-taxas-interpolator","title":"Interpola\u00e7\u00e3o de Taxas (<code>Interpolator</code>)","text":"<p>A classe <code>Interpolator</code> interpola taxas usando a conven\u00e7\u00e3o de 252 dias \u00fateis/ano, padr\u00e3o no mercado brasileiro.</p> <pre><code>from pyield import Interpolator\n\nknown_bdays = [30, 60, 90]\nknown_rates = [0.045, 0.05, 0.055]\n\n# Interpola\u00e7\u00e3o flat forward (padr\u00e3o de mercado)\ninterp = Interpolator(\"flat_forward\", known_bdays, known_rates)\ninterp(45)  # -&gt; 0.04833...\n\n# Interpola\u00e7\u00e3o linear\nlinear = Interpolator(\"linear\", known_bdays, known_rates)\nlinear(45)  # -&gt; 0.0475\n\n# Vetorizado\ninterp([15, 45, 75])  # -&gt; pl.Series with 3 rates\n\n# Extrapola\u00e7\u00e3o (desabilitada por padr\u00e3o, retorna NaN)\ninterp(100)  # -&gt; nan\nInterpolator(\"flat_forward\", known_bdays, known_rates, extrapolate=True)(100)  # -&gt; 0.055\n</code></pre>"},{"location":"#taxas-a-termo-forward-forwards","title":"Taxas a Termo (<code>forward</code>, <code>forwards</code>)","text":"<p>Calcula taxas a termo a partir de curvas spot:</p> <p>Conven\u00e7\u00e3o utilizada:</p> <ul> <li><code>fwd_k = fwd_{j-&gt;k}</code> (forward do v\u00e9rtice <code>j</code> para <code>k</code>)</li> <li><code>f_k = 1 + tx_k</code> (fator de capitaliza\u00e7\u00e3o no v\u00e9rtice <code>k</code>)</li> <li><code>fwd_k = (f_k^au_k / f_j^au_j)^(1 / (au_k - au_j)) - 1</code>, com <code>au = du / 252</code></li> </ul> <pre><code>from pyield import forward, forwards\n\n# Taxa a termo \u00fanica entre dois pontos\nforward(bday1=10, bday2=20, rate1=0.05, rate2=0.06)  # -&gt; 0.0700952...\n\n# Curva a termo vetorizada a partir de taxas spot\nbdays = [10, 20, 30]\nrates = [0.05, 0.06, 0.07]\nforwards(bdays, rates)  # -&gt; Series: [0.05, 0.070095, 0.090284]\n</code></pre>"},{"location":"#visao-geral-dos-modulos","title":"Vis\u00e3o Geral dos M\u00f3dulos","text":"M\u00f3dulo Finalidade <code>bday</code> Calend\u00e1rio de dias \u00fateis com feriados brasileiros <code>futures</code> Dados de futuros da B3 (DI1, DDI, FRC, DAP, DOL, WDO, IND, WIN) <code>Interpolator</code> Interpola\u00e7\u00e3o de taxas (flat_forward, linear) <code>forward</code> / <code>forwards</code> C\u00e1lculo de taxas a termo <code>ltn</code>, <code>ntnb</code>, <code>ntnf</code>, <code>lft</code>, <code>ntnc</code> Precifica\u00e7\u00e3o e an\u00e1lise de t\u00edtulos p\u00fablicos <code>anbima</code> Dados da ANBIMA (pre\u00e7os de TPF, curvas de juros, \u00edndices IMA) <code>bc</code> Indicadores do BCB (SELIC, PTAX, repos, VNA) <code>ipca</code> Dados de infla\u00e7\u00e3o (hist\u00f3rico e proje\u00e7\u00f5es) <code>today</code> / <code>now</code> Data/hora atual no Brasil (America/Sao_Paulo)"},{"location":"#titulos-publicos","title":"T\u00edtulos P\u00fablicos","text":"<pre><code>from pyield import ltn, ntnb, ntnf\n\n# Busca taxas indicativas da ANBIMA\nltn.data(\"23-08-2024\")   # -&gt; DataFrame with LTN bonds\nntnb.data(\"23-08-2024\")  # -&gt; DataFrame with NTN-B bonds\n\n# Calcula cota\u00e7\u00e3o do t\u00edtulo (base 100)\nntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)  # -&gt; 99.3651\nntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)  # -&gt; 99.5341\n\n# Spreads de DI (bps=True multiplica por 10.000)\nntnf.di_spreads(\"30-05-2025\", bps=True)\n# -&gt; DataFrame: BondType, MaturityDate, DISpread\n</code></pre>"},{"location":"#dados-de-futuros","title":"Dados de Futuros","text":"<pre><code>from pyield import futures\n\n# DI1 (Futuro de Dep\u00f3sito Interfinanceiro)\nfutures(\"31-05-2024\", \"DI1\")\n\n# Outros contratos: DDI, FRC, DAP, DOL, WDO, IND, WIN\nfutures(\"31-05-2024\", \"DAP\")\n\n# Dados intradi\u00e1rios (quando o mercado estiver aberto)\nfutures(\"16-01-2025\", \"DI1\")  # Retorna dados ao vivo durante o hor\u00e1rio de negocia\u00e7\u00e3o\n</code></pre>"},{"location":"#tratamento-de-datas","title":"Tratamento de Datas","text":"<p>PYield aceita entradas de data flex\u00edveis (<code>DateLike</code>): - Strings: <code>\"31-05-2024\"</code>, <code>\"31/05/2024\"</code>, <code>\"2024-05-31\"</code> - <code>datetime.date</code>, <code>datetime.datetime</code> - <code>pandas.Timestamp</code>, <code>numpy.datetime64</code></p> <p>Fun\u00e7\u00f5es escalares retornam <code>datetime.date</code>. Fun\u00e7\u00f5es vetorizadas retornam <code>polars.Series</code>.</p> <p>O parsing de strings \u00e9 elemento a elemento entre os formatos aceitos. Strings inv\u00e1lidas s\u00e3o convertidas para valores nulos (<code>None</code> em sa\u00eddas escalares e <code>null</code> em sa\u00eddas vetorizadas).</p> <p>Tratamento de nulos: fun\u00e7\u00f5es escalares retornam <code>float('nan')</code> para entradas ausentes (propaga nos c\u00e1lculos). Fun\u00e7\u00f5es vetorizadas propagam <code>null</code> elemento a elemento.</p> <pre><code>from pyield import ntnb, bday\n\nntnb.quotation(None, \"15-05-2035\", 0.06149)  # -&gt; nan\nbday.count([\"01-01-2024\", None], \"01-02-2024\")  # -&gt; Series: [22, null]\n</code></pre>"},{"location":"#migracao-para-polars-v0400","title":"Migra\u00e7\u00e3o para Polars (v0.40.0+)","text":"<p>Todas as fun\u00e7\u00f5es retornam DataFrames/Series do Polars. Para converter para Pandas:</p> <pre><code>df_pandas = df.to_pandas(use_pyarrow_extension_array=True)\n</code></pre>"},{"location":"#documentacao","title":"Documenta\u00e7\u00e3o","text":"<p>Documenta\u00e7\u00e3o completa: crdcj.github.io/PYield</p>"},{"location":"#testes","title":"Testes","text":"<pre><code>pytest pyield --doctest-modules\n</code></pre>"},{"location":"anbima/","title":"Anbima","text":""},{"location":"anbima/#pyield.anbima.intraday_ettj","title":"<code>intraday_ettj()</code>","text":"<p>Obt\u00e9m e processa a curva de juros intradi\u00e1ria da ANBIMA.</p> <p>Busca os dados mais recentes da curva de juros intradi\u00e1ria publicada pela ANBIMA, contendo taxas reais (indexadas ao IPCA), taxas nominais e infla\u00e7\u00e3o impl\u00edcita em diversos v\u00e9rtices. A curva \u00e9 publicada por volta das 12h30 BRT.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com os dados intradi\u00e1rios da ETTJ.</p> Output Columns <ul> <li>date (Date): data de refer\u00eancia da curva de juros.</li> <li>vertex (Int64): v\u00e9rtice em dias \u00fateis.</li> <li>nominal_rate (Float64): taxa de juros nominal zero-cupom.</li> <li>real_rate (Float64): taxa de juros real zero-cupom (indexada ao IPCA).</li> <li>implied_inflation (Float64): taxa de infla\u00e7\u00e3o impl\u00edcita (breakeven).</li> </ul> Note <p>Todas as taxas s\u00e3o expressas em formato decimal (ex: 0.12 para 12%).</p> Source code in <code>pyield/anbima/ettj_intraday.py</code> <pre><code>def intraday_ettj() -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m e processa a curva de juros intradi\u00e1ria da ANBIMA.\n\n    Busca os dados mais recentes da curva de juros intradi\u00e1ria publicada pela\n    ANBIMA, contendo taxas reais (indexadas ao IPCA), taxas nominais e infla\u00e7\u00e3o\n    impl\u00edcita em diversos v\u00e9rtices. A curva \u00e9 publicada por volta das 12h30 BRT.\n\n    Returns:\n        pl.DataFrame: DataFrame com os dados intradi\u00e1rios da ETTJ.\n\n    Output Columns:\n        - date (Date): data de refer\u00eancia da curva de juros.\n        - vertex (Int64): v\u00e9rtice em dias \u00fateis.\n        - nominal_rate (Float64): taxa de juros nominal zero-cupom.\n        - real_rate (Float64): taxa de juros real zero-cupom (indexada ao IPCA).\n        - implied_inflation (Float64): taxa de infla\u00e7\u00e3o impl\u00edcita (breakeven).\n\n    Note:\n        Todas as taxas s\u00e3o expressas em formato decimal (ex: 0.12 para 12%).\n    \"\"\"\n    texto_api = _buscar_texto_intraday()\n\n    # --- Extra\u00e7\u00e3o da Tabela 1: PREFIXADOS ---\n    data_ref, tabela_pre, tabela_ipca = _extrair_data_e_tabelas(texto_api)\n\n    df_pre = _parsear_tabela_intraday(tabela_pre)\n    df_pre = df_pre.rename({\"D0\": \"nominal_rate\"})\n\n    df_ipca = _parsear_tabela_intraday(tabela_ipca)\n    df_ipca = df_ipca.rename({\"D0\": \"real_rate\"})\n\n    df = df_pre.join(df_ipca, on=\"Vertices\", how=\"right\")\n    df = df.rename({\"Vertices\": \"vertex\"})\n\n    df = df.with_columns(\n        # convertendo de % para decimal e arredondando\n        pl.col(\"real_rate\").truediv(100).round(CASAS_DECIMAIS),\n        pl.col(\"nominal_rate\").truediv(100).round(CASAS_DECIMAIS),\n        date=data_ref,\n    ).with_columns(\n        ((pl.col(\"nominal_rate\") + 1) / (pl.col(\"real_rate\") + 1) - 1)\n        .round(CASAS_DECIMAIS)\n        .alias(\"implied_inflation\"),\n    )\n    ordem_colunas = [\"date\", \"vertex\", \"nominal_rate\", \"real_rate\", \"implied_inflation\"]\n    return df.select(ordem_colunas)\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ettj","title":"<code>last_ettj()</code>","text":"<p>Obt\u00e9m e processa a \u00faltima curva de juros (ETTJ) publicada pela ANBIMA.</p> <p>Busca os dados mais recentes da curva de juros de fechamento publicada pela ANBIMA, contendo taxas reais (indexadas ao IPCA), taxas nominais e infla\u00e7\u00e3o impl\u00edcita em diversos v\u00e9rtices.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com os dados da ETTJ de fechamento.</p> Output Columns <ul> <li>date (Date): data de refer\u00eancia da curva de juros.</li> <li>vertex (Int64): v\u00e9rtice em dias \u00fateis.</li> <li>nominal_rate (Float64): taxa de juros nominal zero-cupom.</li> <li>real_rate (Float64): taxa de juros real zero-cupom (indexada ao IPCA).</li> <li>implied_inflation (Float64): taxa de infla\u00e7\u00e3o impl\u00edcita (breakeven).</li> </ul> Note <p>Todas as taxas s\u00e3o expressas em formato decimal (ex: 0.12 para 12%).</p> Source code in <code>pyield/anbima/ettj_last.py</code> <pre><code>def last_ettj() -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m e processa a \u00faltima curva de juros (ETTJ) publicada pela ANBIMA.\n\n    Busca os dados mais recentes da curva de juros de fechamento publicada pela\n    ANBIMA, contendo taxas reais (indexadas ao IPCA), taxas nominais e infla\u00e7\u00e3o\n    impl\u00edcita em diversos v\u00e9rtices.\n\n    Returns:\n        pl.DataFrame: DataFrame com os dados da ETTJ de fechamento.\n\n    Output Columns:\n        - date (Date): data de refer\u00eancia da curva de juros.\n        - vertex (Int64): v\u00e9rtice em dias \u00fateis.\n        - nominal_rate (Float64): taxa de juros nominal zero-cupom.\n        - real_rate (Float64): taxa de juros real zero-cupom (indexada ao IPCA).\n        - implied_inflation (Float64): taxa de infla\u00e7\u00e3o impl\u00edcita (breakeven).\n\n    Note:\n        Todas as taxas s\u00e3o expressas em formato decimal (ex: 0.12 para 12%).\n    \"\"\"\n    texto = _buscar_texto_ultima_ettj()\n    data_referencia = _obter_data_referencia(texto)\n    texto = _filtrar_texto_ettf(texto)\n    df = _converter_csv_para_df(texto)\n    df = _processar_df(df, data_referencia)\n    return df\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ima","title":"<code>last_ima(ima_type=None)</code>","text":"<p>Obt\u00e9m os \u00faltimos dados de composi\u00e7\u00e3o de carteira IMA dispon\u00edveis na ANBIMA.</p> <p>Busca e processa os dados do arquivo IMA completo publicado pela ANBIMA, retornando um DataFrame estruturado. Em caso de erro durante a busca ou processamento, retorna um DataFrame vazio.</p> <p>Parameters:</p> Name Type Description Default <code>ima_type</code> <code>str</code> <p>Tipo de \u00edndice IMA para filtrar os dados. Se None, retorna todos os \u00edndices. Padr\u00e3o \u00e9 None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com os dados do IMA. Retorna um DataFrame vazio em caso de erro.</p> Output Columns <ul> <li>Date (Date): data de refer\u00eancia.</li> <li>IMAType (String): tipo de \u00edndice IMA (ex: 'IMA-B', 'IRF-M').</li> <li>BondType (String): tipo de t\u00edtulo (ex: 'LTN', 'NTN-B').</li> <li>Maturity (Date): data de vencimento do t\u00edtulo.</li> <li>SelicCode (Int64): c\u00f3digo do t\u00edtulo no sistema SELIC.</li> <li>ISIN (String): c\u00f3digo ISIN (International Securities Identification Number).</li> <li>BDToMat (Int64): dias \u00fateis at\u00e9 o vencimento.</li> <li>Duration (Float64): duration do t\u00edtulo em anos \u00fateis (252 d.u./ano).</li> <li>IndicativeRate (Float64): taxa indicativa em decimal (ex: 0.10 para 10%).</li> <li>Price (Float64): pre\u00e7o unit\u00e1rio (PU) em R$.</li> <li>InterestPrice (Float64): PU de juros em R$.</li> <li>DV01 (Float64): DV01 em R$.</li> <li>PMR (Float64): prazo m\u00e9dio de repactua\u00e7\u00e3o.</li> <li>Weight (Float64): peso do t\u00edtulo no \u00edndice (%).</li> <li>Convexity (Float64): convexidade do t\u00edtulo.</li> <li>TheoreticalQuantity (Float64): quantidade te\u00f3rica (em 1.000 t\u00edtulos).</li> <li>NumberOfOperations (Int64): n\u00famero de opera\u00e7\u00f5es.</li> <li>NegotiatedQuantity (Int64): quantidade negociada (unidades).</li> <li>NegotiatedValue (Float64): valor negociado em R$.</li> <li>MarketDV01 (Float64): DV01 de mercado em R$.</li> <li>MarketQuantity (Int64): quantidade em carteira (unidades).</li> <li>MarketValue (Float64): valor de mercado em R$.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; df = anbima.last_ima()\n&gt;&gt;&gt; df.columns[:6]\n['Date', 'IMAType', 'BondType', 'Maturity', 'SelicCode', 'ISIN']\n&gt;&gt;&gt; df.shape[1]\n22\n&gt;&gt;&gt; df_imab = anbima.last_ima(\"IMA-B\")\n&gt;&gt;&gt; (df_imab[\"IMAType\"] == \"IMA-B\").all()\nTrue\n</code></pre> Source code in <code>pyield/anbima/ima.py</code> <pre><code>def last_ima(ima_type: TiposIMA | None = None) -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m os \u00faltimos dados de composi\u00e7\u00e3o de carteira IMA dispon\u00edveis na ANBIMA.\n\n    Busca e processa os dados do arquivo IMA completo publicado pela ANBIMA,\n    retornando um DataFrame estruturado. Em caso de erro durante a busca ou\n    processamento, retorna um DataFrame vazio.\n\n    Args:\n        ima_type (str, optional): Tipo de \u00edndice IMA para filtrar os dados.\n            Se None, retorna todos os \u00edndices. Padr\u00e3o \u00e9 None.\n\n    Returns:\n        pl.DataFrame: DataFrame com os dados do IMA. Retorna um DataFrame vazio\n            em caso de erro.\n\n    Output Columns:\n        - Date (Date): data de refer\u00eancia.\n        - IMAType (String): tipo de \u00edndice IMA (ex: 'IMA-B', 'IRF-M').\n        - BondType (String): tipo de t\u00edtulo (ex: 'LTN', 'NTN-B').\n        - Maturity (Date): data de vencimento do t\u00edtulo.\n        - SelicCode (Int64): c\u00f3digo do t\u00edtulo no sistema SELIC.\n        - ISIN (String): c\u00f3digo ISIN (International Securities Identification Number).\n        - BDToMat (Int64): dias \u00fateis at\u00e9 o vencimento.\n        - Duration (Float64): duration do t\u00edtulo em anos \u00fateis (252 d.u./ano).\n        - IndicativeRate (Float64): taxa indicativa em decimal (ex: 0.10 para 10%).\n        - Price (Float64): pre\u00e7o unit\u00e1rio (PU) em R$.\n        - InterestPrice (Float64): PU de juros em R$.\n        - DV01 (Float64): DV01 em R$.\n        - PMR (Float64): prazo m\u00e9dio de repactua\u00e7\u00e3o.\n        - Weight (Float64): peso do t\u00edtulo no \u00edndice (%).\n        - Convexity (Float64): convexidade do t\u00edtulo.\n        - TheoreticalQuantity (Float64): quantidade te\u00f3rica (em 1.000 t\u00edtulos).\n        - NumberOfOperations (Int64): n\u00famero de opera\u00e7\u00f5es.\n        - NegotiatedQuantity (Int64): quantidade negociada (unidades).\n        - NegotiatedValue (Float64): valor negociado em R$.\n        - MarketDV01 (Float64): DV01 de mercado em R$.\n        - MarketQuantity (Int64): quantidade em carteira (unidades).\n        - MarketValue (Float64): valor de mercado em R$.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; df = anbima.last_ima()\n        &gt;&gt;&gt; df.columns[:6]\n        ['Date', 'IMAType', 'BondType', 'Maturity', 'SelicCode', 'ISIN']\n        &gt;&gt;&gt; df.shape[1]\n        22\n        &gt;&gt;&gt; df_imab = anbima.last_ima(\"IMA-B\")\n        &gt;&gt;&gt; (df_imab[\"IMAType\"] == \"IMA-B\").all()\n        True\n    \"\"\"\n    try:\n        texto_ima = _buscar_texto_ultimo_ima()\n        df = _parsear_df(texto_ima)\n        df = _processar_df(df)\n        if ima_type:\n            df = df.filter(pl.col(\"IMAType\") == ima_type)\n        df = df.sort(\"IMAType\", \"BondType\", \"Maturity\")\n        return df\n    except Exception as e:\n        logger.exception(\n            \"Erro ao buscar ou processar os \u00faltimos dados de IMA: %s\",\n            e,\n        )\n        return pl.DataFrame()\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_data","title":"<code>tpf_data(date, bond_type=None, fetch_from_source=False)</code>","text":"<p>Recupera os dados do mercado secund\u00e1rio de TPF da ANBIMA.</p> <p>Esta fun\u00e7\u00e3o busca taxas indicativas e outros dados de t\u00edtulos p\u00fablicos brasileiros. A obten\u00e7\u00e3o dos dados segue uma hierarquia de fontes para otimizar o desempenho e o acesso.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>A data de refer\u00eancia para os dados (ex: '2024-06-14').</p> required <code>bond_type</code> <code>str</code> <p>Filtra os resultados por um tipo de t\u00edtulo espec\u00edfico (ex: 'LTN', 'NTN-B'). Por padr\u00e3o, retorna todos os tipos.</p> <code>None</code> <code>fetch_from_source</code> <code>bool</code> <p>Se True, for\u00e7a a fun\u00e7\u00e3o a ignorar o cache e buscar os dados diretamente da fonte (ANBIMA). Padr\u00e3o \u00e9 False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo os dados solicitados. Retorna um DataFrame vazio se n\u00e3o houver dados para a data especificada (ex: finais de semana, feriados ou datas futuras).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; anbima.tpf_data(date=\"22-08-2025\")\nshape: (49, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000198  \u2506 0.0001    \u2506 0.000165       \u2506 0.14906  \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000156 \u2506 -0.000116      \u2506 0.14843  \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000143 \u2506 -0.000107      \u2506 0.1436   \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000309  \u2506 0.000292  \u2506 0.000302       \u2506 0.138189 \u2502\n\u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000421  \u2506 0.000399  \u2506 0.000411       \u2506 0.134548 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.139379  \u2506 0.139163  \u2506 0.139268       \u2506 0.13959  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.134252  \u2506 0.134018  \u2506 0.13414        \u2506 0.1327   \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.13846   \u2506 0.138355  \u2506 0.13841        \u2506 0.13626  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.139503  \u2506 0.139321  \u2506 0.139398       \u2506 0.13807  \u2502\n\u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.140673  \u2506 0.140566  \u2506 0.140633       \u2506 0.13845  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Data columns <ul> <li>BondType: Tipo do t\u00edtulo p\u00fablico (e.g., 'LTN', 'NTN-B').</li> <li>ReferenceDate: Data de refer\u00eancia dos dados.</li> <li>SelicCode: C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate: Data base ou de emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate: Data de vencimento do t\u00edtulo.</li> <li>BDToMat: N\u00famero de dias \u00fateis entre a data de refer\u00eancia e o vencimento.</li> <li>Duration: Macaulay Duration do t\u00edtulo em anos.</li> <li>DV01: Varia\u00e7\u00e3o financeira no pre\u00e7o do t\u00edtulo (em BRL) para uma     mudan\u00e7a de 1 basis point (0,01%) na taxa de juros.</li> <li>DV01USD: O mesmo que DV01, mas convertido para USD pela PTAX do dia.</li> <li>Price: Pre\u00e7o Unit\u00e1rio (PU) do t\u00edtulo na data de refer\u00eancia.</li> <li>BidRate: Taxa de compra em formato decimal (e.g., 0.10 para 10%).</li> <li>AskRate: Taxa de venda em formato decimal.</li> <li>IndicativeRate: Taxa indicativa em formato decimal.</li> <li>DIRate: Taxa DI interpolada (flatforward) no vencimento do t\u00edtulo.</li> <li>StdDev: Desvio padr\u00e3o da taxa indicativa.</li> <li>LowerBoundRateD0: Limite inferior do intervalo indicativo para D+0.</li> <li>UpperBoundRateD0: Limite superior do intervalo indicativo para D+0.</li> <li>LowerBoundRateD1: Limite inferior do intervalo indicativo para D+1.</li> <li>UpperBoundRateD1: Limite superior do intervalo indicativo para D+1.</li> <li>Criteria: Crit\u00e9rio utilizado pela ANBIMA para o c\u00e1lculo.</li> </ul> Notes <p>A fonte dos dados segue a seguinte hierarquia:</p> <ol> <li>Cache Local (Padr\u00e3o): Fornece acesso r\u00e1pido a dados hist\u00f3ricos     desde 01/01/2020. \u00c9 utilizado por padr\u00e3o (<code>fetch_from_source=False</code>).</li> <li>Site P\u00fablico da ANBIMA: Acessado quando <code>fetch_from_source=True</code>,     disponibiliza os dados dos \u00faltimos 5 dias \u00fateis.</li> <li>Rede RTM da ANBIMA: Acessada quando <code>fetch_from_source=True</code> para     datas com mais de 5 dias \u00fateis. O acesso ao hist\u00f3rico completo     requer uma conex\u00e3o \u00e0 rede RTM. Sem ela, a consulta para datas     antigas retornar\u00e1 um DataFrame vazio.</li> </ol> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_data(\n    date: DateLike,\n    bond_type: BOND_TYPES | None = None,\n    fetch_from_source: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"Recupera os dados do mercado secund\u00e1rio de TPF da ANBIMA.\n\n    Esta fun\u00e7\u00e3o busca taxas indicativas e outros dados de t\u00edtulos p\u00fablicos\n    brasileiros. A obten\u00e7\u00e3o dos dados segue uma hierarquia de fontes para\n    otimizar o desempenho e o acesso.\n\n    Args:\n        date (DateLike): A data de refer\u00eancia para os dados (ex: '2024-06-14').\n        bond_type (str, optional): Filtra os resultados por um tipo de t\u00edtulo\n            espec\u00edfico (ex: 'LTN', 'NTN-B'). Por padr\u00e3o, retorna todos os tipos.\n        fetch_from_source (bool, optional): Se True, for\u00e7a a fun\u00e7\u00e3o a ignorar o\n            cache e buscar os dados diretamente da fonte (ANBIMA).\n            Padr\u00e3o \u00e9 False.\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo os dados solicitados.\n            Retorna um DataFrame vazio se n\u00e3o houver dados para a data especificada (ex:\n            finais de semana, feriados ou datas futuras).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; anbima.tpf_data(date=\"22-08-2025\")\n        shape: (49, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000198  \u2506 0.0001    \u2506 0.000165       \u2506 0.14906  \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000156 \u2506 -0.000116      \u2506 0.14843  \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000053 \u2506 -0.000143 \u2506 -0.000107      \u2506 0.1436   \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000309  \u2506 0.000292  \u2506 0.000302       \u2506 0.138189 \u2502\n        \u2502 2025-08-22    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000421  \u2506 0.000399  \u2506 0.000411       \u2506 0.134548 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.139379  \u2506 0.139163  \u2506 0.139268       \u2506 0.13959  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.134252  \u2506 0.134018  \u2506 0.13414        \u2506 0.1327   \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.13846   \u2506 0.138355  \u2506 0.13841        \u2506 0.13626  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.139503  \u2506 0.139321  \u2506 0.139398       \u2506 0.13807  \u2502\n        \u2502 2025-08-22    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.140673  \u2506 0.140566  \u2506 0.140633       \u2506 0.13845  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Data columns:\n        - BondType: Tipo do t\u00edtulo p\u00fablico (e.g., 'LTN', 'NTN-B').\n        - ReferenceDate: Data de refer\u00eancia dos dados.\n        - SelicCode: C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate: Data base ou de emiss\u00e3o do t\u00edtulo.\n        - MaturityDate: Data de vencimento do t\u00edtulo.\n        - BDToMat: N\u00famero de dias \u00fateis entre a data de refer\u00eancia e o vencimento.\n        - Duration: Macaulay Duration do t\u00edtulo em anos.\n        - DV01: Varia\u00e7\u00e3o financeira no pre\u00e7o do t\u00edtulo (em BRL) para uma\n            mudan\u00e7a de 1 basis point (0,01%) na taxa de juros.\n        - DV01USD: O mesmo que DV01, mas convertido para USD pela PTAX do dia.\n        - Price: Pre\u00e7o Unit\u00e1rio (PU) do t\u00edtulo na data de refer\u00eancia.\n        - BidRate: Taxa de compra em formato decimal (e.g., 0.10 para 10%).\n        - AskRate: Taxa de venda em formato decimal.\n        - IndicativeRate: Taxa indicativa em formato decimal.\n        - DIRate: Taxa DI interpolada (flatforward) no vencimento do t\u00edtulo.\n        - StdDev: Desvio padr\u00e3o da taxa indicativa.\n        - LowerBoundRateD0: Limite inferior do intervalo indicativo para D+0.\n        - UpperBoundRateD0: Limite superior do intervalo indicativo para D+0.\n        - LowerBoundRateD1: Limite inferior do intervalo indicativo para D+1.\n        - UpperBoundRateD1: Limite superior do intervalo indicativo para D+1.\n        - Criteria: Crit\u00e9rio utilizado pela ANBIMA para o c\u00e1lculo.\n\n    Notes:\n        A fonte dos dados segue a seguinte hierarquia:\n\n        1.  **Cache Local (Padr\u00e3o):** Fornece acesso r\u00e1pido a dados hist\u00f3ricos\n            desde 01/01/2020. \u00c9 utilizado por padr\u00e3o (`fetch_from_source=False`).\n        2.  **Site P\u00fablico da ANBIMA:** Acessado quando `fetch_from_source=True`,\n            disponibiliza os dados dos \u00faltimos 5 dias \u00fateis.\n        3.  **Rede RTM da ANBIMA:** Acessada quando `fetch_from_source=True` para\n            datas com mais de 5 dias \u00fateis. O acesso ao hist\u00f3rico completo\n            requer uma conex\u00e3o \u00e0 rede RTM. Sem ela, a consulta para datas\n            antigas retornar\u00e1 um DataFrame vazio.\n    \"\"\"  # noqa\n    if any_is_empty(date):\n        return pl.DataFrame()\n    date = converter_datas(date)\n    _validar_data_nao_futura(date)\n\n    if fetch_from_source:\n        # Tenta buscar os dados diretamente da fonte (ANBIMA)\n        df = _buscar_dados_tpf(date)\n    else:\n        # Caso contr\u00e1rio, obt\u00e9m os dados do cache local\n        df = obter_dataset_cacheado(\"tpf\").filter(pl.col(\"ReferenceDate\") == date)\n\n    if df.is_empty():\n        return pl.DataFrame()\n\n    if bond_type:\n        norm_bond_type = _mapear_tipo_titulo(bond_type)\n        df = df.filter(pl.col(\"BondType\").is_in(norm_bond_type))\n\n    return df.sort(\"ReferenceDate\", \"BondType\", \"MaturityDate\")\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_difusao","title":"<code>tpf_difusao(data_referencia)</code>","text":"<p>Obt\u00e9m a TPF Difus\u00e3o da Anbima para uma data de refer\u00eancia espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>data_referencia</code> <code>DateLike</code> <p>Data de refer\u00eancia.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com os dados. Retorna um DataFrame vazio se n\u00e3o houver dados ou em caso de erro.</p> Output Columns <ul> <li>data_hora_referencia (datetime): Data e hora de refer\u00eancia da taxa.</li> <li>provedor (string): Provedor dos dados.</li> <li>titulo (string): Nome do t\u00edtulo (ex: LFT, LTN).</li> <li>data_vencimento (date): Data de vencimento do t\u00edtulo.</li> <li>codigo_isin (string): C\u00f3digo ISIN do t\u00edtulo.</li> <li>dias_uteis (int): Dias \u00fateis entre a data de refer\u00eancia e o vencimento.</li> <li>taxa_indicativa_anterior (float): Taxa indicativa de fechamento D-1 (decimal).</li> <li>taxa_venda (float): Taxa de oferta de venda (Ask rate) (decimal).</li> <li>taxa_compra (float): Taxa de oferta de compra (Bid rate) (decimal).</li> <li>taxa_media (float): M\u00e9dia entre a taxa de compra e venda (decimal).</li> <li>taxa_ultima (float): \u00daltima taxa negociada (decimal).</li> </ul> Source code in <code>pyield/anbima/difusao.py</code> <pre><code>def tpf_difusao(data_referencia: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Obt\u00e9m a TPF Difus\u00e3o da Anbima para uma data de refer\u00eancia espec\u00edfica.\n\n    Args:\n        data_referencia (DateLike): Data de refer\u00eancia.\n\n    Returns:\n        pl.DataFrame: DataFrame com os dados. Retorna um DataFrame vazio se\n            n\u00e3o houver dados ou em caso de erro.\n\n    Output Columns:\n        - data_hora_referencia (datetime): Data e hora de refer\u00eancia da taxa.\n        - provedor (string): Provedor dos dados.\n        - titulo (string): Nome do t\u00edtulo (ex: LFT, LTN).\n        - data_vencimento (date): Data de vencimento do t\u00edtulo.\n        - codigo_isin (string): C\u00f3digo ISIN do t\u00edtulo.\n        - dias_uteis (int): Dias \u00fateis entre a data de refer\u00eancia e o vencimento.\n        - taxa_indicativa_anterior (float): Taxa indicativa de fechamento D-1 (decimal).\n        - taxa_venda (float): Taxa de oferta de venda (Ask rate) (decimal).\n        - taxa_compra (float): Taxa de oferta de compra (Bid rate) (decimal).\n        - taxa_media (float): M\u00e9dia entre a taxa de compra e venda (decimal).\n        - taxa_ultima (float): \u00daltima taxa negociada (decimal).\n    \"\"\"\n    if any_is_empty(data_referencia):\n        logger.warning(\"Nenhuma data fornecida. Retornando DataFrame vazio.\")\n        return pl.DataFrame()\n    data = cv.converter_datas(data_referencia)\n    data_str = data.strftime(\"%d/%m/%Y\")\n    csv_data = _buscar_dados_url(data_str)\n\n    if not csv_data:\n        logger.warning(\"Nenhum dado foi retornado para a data '%s'.\", data_str)\n        return pl.DataFrame()\n\n    try:\n        return _processar_csv(csv_data)\n    except Exception as e:\n        logger.error(\"Falha ao processar o CSV para a data '%s': %s\", data_str, e)\n        return pl.DataFrame()\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_maturities","title":"<code>tpf_maturities(date, bond_type)</code>","text":"<p>Recupera os vencimentos existentes para um tipo de t\u00edtulo na data especificada.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>A data de refer\u00eancia para os vencimentos.</p> required <code>bond_type</code> <code>BOND_TYPES</code> <p>O tipo de t\u00edtulo para filtrar (ex: 'PRE' para 'LTN' e 'NTN-F', ou especifique 'LTN' ou 'NTN-F' diretamente).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: Uma Series contendo as datas de vencimento \u00fanicas para o(s) tipo(s) de t\u00edtulo especificado(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import anbima\n&gt;&gt;&gt; anbima.tpf_maturities(date=\"22-08-2025\", bond_type=\"PRE\")\nshape: (18,)\nSeries: 'MaturityDate' [date]\n[\n    2025-10-01\n    2026-01-01\n    2026-04-01\n    2026-07-01\n    2026-10-01\n    \u2026\n    2030-01-01\n    2031-01-01\n    2032-01-01\n    2033-01-01\n    2035-01-01\n]\n</code></pre> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_maturities(\n    date: DateLike,\n    bond_type: BOND_TYPES,\n) -&gt; pl.Series:\n    \"\"\"Recupera os vencimentos existentes para um tipo de t\u00edtulo na data especificada.\n\n    Args:\n        date (DateLike): A data de refer\u00eancia para os vencimentos.\n        bond_type (BOND_TYPES): O tipo de t\u00edtulo para filtrar (ex: 'PRE' para 'LTN'\n            e 'NTN-F', ou especifique 'LTN' ou 'NTN-F' diretamente).\n\n    Returns:\n        pl.Series: Uma Series contendo as datas de vencimento \u00fanicas para o(s)\n            tipo(s) de t\u00edtulo especificado(s).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import anbima\n        &gt;&gt;&gt; anbima.tpf_maturities(date=\"22-08-2025\", bond_type=\"PRE\")\n        shape: (18,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-10-01\n            2026-01-01\n            2026-04-01\n            2026-07-01\n            2026-10-01\n            \u2026\n            2030-01-01\n            2031-01-01\n            2032-01-01\n            2033-01-01\n            2035-01-01\n        ]\n    \"\"\"\n    return tpf_data(date, bond_type)[\"MaturityDate\"].unique().sort()\n</code></pre>"},{"location":"b3/","title":"B3 - Bolsa de Valores do Brasil","text":"<p>Este m\u00f3dulo cont\u00e9m fun\u00e7\u00f5es para acessar dados de mercado da B3 (Brasil, Bolsa, Balc\u00e3o).</p>"},{"location":"b3/#pyield.b3.fetch_price_report","title":"<code>fetch_price_report(date, contract_code, source_type='SPR')</code>","text":"<p>Busca e processa o price report da B3 no site oficial.</p> <p>Faz o download do ZIP com XML, extrai os dados do contrato e devolve um DataFrame Polars com colunas padronizadas e m\u00e9tricas calculadas.</p> <p>A fun\u00e7\u00e3o decide o sufixo das colunas (Rate vs Price) conforme o contrato: - Contratos de taxa (DI1, DAP, DDI, FRC, FRO): \"OpenRate\", \"CloseRate\" - Contratos de pre\u00e7o (DOL, WDO, IND, WIN, etc.): \"OpenPrice\", \"ClosePrice\"</p> <p>M\u00e9tricas calculadas: - BDaysToExp: Dias \u00fateis at\u00e9 o vencimento - DaysToExp: Dias corridos at\u00e9 o vencimento - DV01: Valor de 1 bp (para DI1) - ForwardRate: Taxa forward (para DI1, DAP)</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de negocia\u00e7\u00e3o no formato 'DD-MM-YYYY', 'DD/MM/YYYY', 'YYYY-MM-DD' ou objeto datetime.date.</p> required <code>contract_code</code> <code>str</code> <p>C\u00f3digo B3 (ex.: 'DI1', 'DOL', 'DAP', 'FRC', 'DDI', 'WDO', 'IND', 'WIN'). Os 3 primeiros caracteres s\u00e3o usados no XML.</p> required <code>source_type</code> <code>Literal['PR', 'SPR']</code> <p>Tipo de arquivo. 'SPR' (default) para settlement price report e 'PR' para price report regular.</p> <code>'SPR'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com colunas ordenadas conforme COLUNAS_SAIDA,</p> <code>DataFrame</code> <p>filtrado para excluir contratos vencidos (DaysToExp &lt;= 0). Retorna</p> <code>DataFrame</code> <p>DataFrame vazio se n\u00e3o houver dados ou se a data for inv\u00e1lida.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se source_type for inv\u00e1lido.</p> <code>DadoIndisponivelError</code> <p>Se a data for v\u00e1lida mas n\u00e3o houver dados.</p> <code>HTTPError</code> <p>Se a requisi\u00e7\u00e3o HTTP falhar.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyield as yd\n&gt;&gt;&gt; df = yd.b3.fetch_price_report(\"26-04-2024\", \"DI1\")\n&gt;&gt;&gt; df.columns[:5]\n['TradeDate', 'TickerSymbol', 'ExpirationDate', 'BDaysToExp', 'DaysToExp']\n&gt;&gt;&gt; df.shape[0] &gt; 0\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; # Feriado ou fim de semana (retorna DataFrame vazio)\n&gt;&gt;&gt; df = yd.b3.fetch_price_report(\"25-12-2023\", \"DI1\")  # V\u00e9spera de Natal\n&gt;&gt;&gt; df.is_empty()\nTrue\n</code></pre> Source code in <code>pyield/b3/price_report.py</code> <pre><code>def fetch_price_report(\n    date: DateLike, contract_code: str, source_type: Literal[\"PR\", \"SPR\"] = \"SPR\"\n) -&gt; pl.DataFrame:\n    \"\"\"Busca e processa o price report da B3 no site oficial.\n\n    Faz o download do ZIP com XML, extrai os dados do contrato e devolve um\n    DataFrame Polars com colunas padronizadas e m\u00e9tricas calculadas.\n\n    A fun\u00e7\u00e3o decide o sufixo das colunas (Rate vs Price) conforme o contrato:\n    - Contratos de taxa (DI1, DAP, DDI, FRC, FRO): \"OpenRate\", \"CloseRate\"\n    - Contratos de pre\u00e7o (DOL, WDO, IND, WIN, etc.): \"OpenPrice\", \"ClosePrice\"\n\n    M\u00e9tricas calculadas:\n    - BDaysToExp: Dias \u00fateis at\u00e9 o vencimento\n    - DaysToExp: Dias corridos at\u00e9 o vencimento\n    - DV01: Valor de 1 bp (para DI1)\n    - ForwardRate: Taxa forward (para DI1, DAP)\n\n    Args:\n        date: Data de negocia\u00e7\u00e3o no formato 'DD-MM-YYYY', 'DD/MM/YYYY',\n            'YYYY-MM-DD' ou objeto datetime.date.\n        contract_code: C\u00f3digo B3 (ex.: 'DI1', 'DOL', 'DAP', 'FRC', 'DDI',\n            'WDO', 'IND', 'WIN'). Os 3 primeiros caracteres s\u00e3o usados no XML.\n        source_type: Tipo de arquivo. 'SPR' (default) para settlement price\n            report e 'PR' para price report regular.\n\n    Returns:\n        pl.DataFrame: DataFrame com colunas ordenadas conforme COLUNAS_SAIDA,\n        filtrado para excluir contratos vencidos (DaysToExp &lt;= 0). Retorna\n        DataFrame vazio se n\u00e3o houver dados ou se a data for inv\u00e1lida.\n\n    Raises:\n        ValueError: Se source_type for inv\u00e1lido.\n        DadoIndisponivelError: Se a data for v\u00e1lida mas n\u00e3o houver dados.\n        requests.HTTPError: Se a requisi\u00e7\u00e3o HTTP falhar.\n\n    Examples:\n        &gt;&gt;&gt; import pyield as yd\n        &gt;&gt;&gt; df = yd.b3.fetch_price_report(\"26-04-2024\", \"DI1\")\n        &gt;&gt;&gt; df.columns[:5]\n        ['TradeDate', 'TickerSymbol', 'ExpirationDate', 'BDaysToExp', 'DaysToExp']\n        &gt;&gt;&gt; df.shape[0] &gt; 0\n        True\n\n        &gt;&gt;&gt; # Feriado ou fim de semana (retorna DataFrame vazio)\n        &gt;&gt;&gt; df = yd.b3.fetch_price_report(\"25-12-2023\", \"DI1\")  # V\u00e9spera de Natal\n        &gt;&gt;&gt; df.is_empty()\n        True\n    \"\"\"\n    msg_vazia = f\"Sem dados para {contract_code} em {date}. Retornando DataFrame vazio.\"\n    if any_is_empty(date):\n        registro.warning(msg_vazia)\n        return pl.DataFrame()\n\n    date = cv.converter_datas(date)\n    # Valida\u00e7\u00e3o centralizada (evita chamadas desnecess\u00e1rias \u00e0s APIs B3)\n    if not cm.data_negociacao_valida(date):\n        registro.warning(f\"{date} n\u00e3o \u00e9 uma data v\u00e1lida. Retornando DataFrame vazio.\")\n        return pl.DataFrame()\n\n    try:\n        dados_zip = _baixar_zip_url(date, source_type)\n\n        if not dados_zip:\n            registro.warning(msg_vazia)\n            return pl.DataFrame()\n\n        df = _processar_zip(dados_zip, contract_code, source_type)\n\n        if df.is_empty():\n            registro.warning(msg_vazia)\n\n        return df\n\n    except (ValueError, DadoIndisponivelError, requests.HTTPError):\n        raise\n    except (zipfile.BadZipFile, etree.XMLSyntaxError):\n        registro.warning(\n            f\"Falha ao parsear o price report de {contract_code} em {date}.\"\n        )\n        return pl.DataFrame()\n    except Exception:\n        registro.exception(\n            f\"ERRO CR\u00cdTICO: Falha ao processar {contract_code} {source_type} em {date}\"\n        )\n        return pl.DataFrame()\n</code></pre>"},{"location":"b3/#pyield.b3.read_price_report","title":"<code>read_price_report(file_path, contract_code, source_type=None)</code>","text":"<p>L\u00ea e processa o price report da B3 a partir de um ZIP local.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Caminho do arquivo ZIP local.</p> required <code>contract_code</code> <code>str</code> <p>C\u00f3digo B3 do contrato.</p> required <code>source_type</code> <code>Literal['PR', 'SPR'] | None</code> <p>'SPR' ou 'PR'. Se None, infere pelo prefixo do arquivo.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame processado com colunas padronizadas.</p> Source code in <code>pyield/b3/price_report.py</code> <pre><code>def read_price_report(\n    file_path: Path,\n    contract_code: str,\n    source_type: Literal[\"PR\", \"SPR\"] | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"L\u00ea e processa o price report da B3 a partir de um ZIP local.\n\n    Args:\n        file_path: Caminho do arquivo ZIP local.\n        contract_code: C\u00f3digo B3 do contrato.\n        source_type: 'SPR' ou 'PR'. Se None, infere pelo prefixo do arquivo.\n\n    Returns:\n        pl.DataFrame: DataFrame processado com colunas padronizadas.\n    \"\"\"\n    if source_type is None:\n        filename = file_path.name\n        source_type = \"SPR\" if filename.startswith(\"SPRD\") else \"PR\"\n\n    dados_zip = _ler_zip_arquivo(file_path)\n    df = _processar_zip(dados_zip, contract_code, source_type)\n    return df\n</code></pre>"},{"location":"bc/","title":"Banco Central (BCB)","text":""},{"location":"bc/#pyield.bc.auctions","title":"<code>auctions(start=None, end=None, auction_type=None)</code>","text":"<p>Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.</p> <p>Consultas de per\u00edodo: - Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>.   Exemplo: <code>auctions(start='2024-10-20', end='2024-10-27')</code> - Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir   da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel.   Exemplo: <code>auctions(start='2024-10-20')</code> - Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o desde a   data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>.   Exemplo: <code>auctions(end='2024-10-27')</code></p> <p>S\u00e9rie hist\u00f3rica completa: - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o   \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>.   Exemplo: <code>auctions()</code></p> <p>Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas, filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado. O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros <code>start</code> e <code>end</code> segue o padr\u00e3o da API do Banco Central: - Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim. - Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>. - Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</p> <p>Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\"). Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado. Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateLike, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateLike, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>auction_type</code> <code>(Literal['sell', 'buy'], opcional)</code> <p>O tipo de leil\u00e3o para filtrar diretamente na API. Padr\u00e3o \u00e9 <code>None</code> (retorna todos os tipos de leil\u00e3o).</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo especificados. Em caso de erro ao buscar os dados, um DataFrame vazio \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.auctions(start=\"19-08-2025\", end=\"19-08-2025\")\nshape: (5, 33)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Settlement \u2506 AuctionType \u2506 Ordinance \u2506 \u2026 \u2506 AcceptedQuantity \u2506 ValueFR     \u2506 ValueSR  \u2506 Value       \u2502\n\u2502 ---        \u2506 ---        \u2506 ---         \u2506 ---       \u2506   \u2506 ---              \u2506 ---         \u2506 ---      \u2506 ---         \u2502\n\u2502 date       \u2506 date       \u2506 str         \u2506 i64       \u2506   \u2506 i64              \u2506 i64         \u2506 i64      \u2506 i64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 150000           \u2506 2572400000  \u2506 0        \u2506 2572400000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 751003           \u2506 12804476147 \u2506 17123853 \u2506 12821600000 \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 193       \u2506 \u2026 \u2506 300759           \u2506 1289936461  \u2506 3263539  \u2506 1293200000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500542           \u2506 2071654327  \u2506 2245673  \u2506 2073900000  \u2502\n\u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500000           \u2506 2010700000  \u2506 0        \u2506 2010700000  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>FR = Primeira Rodada SR = Segunda Rodada</p> Colunas do DataFrame <ul> <li>Date: Data do leil\u00e3o.</li> <li>Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.</li> <li>AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").</li> <li>Ordinance: Edital normativo associado ao leil\u00e3o.</li> <li>Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").</li> <li>BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").</li> <li>SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.</li> <li>Maturity: Data de vencimento do t\u00edtulo.</li> <li>BDToMat: Dias \u00fateis entre a liquida\u00e7\u00e3o da 1R e a data de vencimento do t\u00edtulo.</li> <li>Duration: Duration (dura\u00e7\u00e3o) calculada com base na data de     liquida\u00e7\u00e3o da 1R e na data de vencimento do t\u00edtulo.</li> <li>AvgMaturity: Prazo m\u00e9dio do t\u00edtulo (em anos).</li> <li>AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.</li> <li>CutPrice: Pre\u00e7o de corte.</li> <li>AvgRate: Taxa de juros m\u00e9dia.</li> <li>CutRate: Taxa de corte.</li> <li>DV01FR: DV01 da Primeira Rodada (FR) em R$.</li> <li>DV01SR: DV01 da Segunda Rodada (SR) em R$.</li> <li>DV01: Valor do DV01 total do leil\u00e3o em R$.</li> <li>DV01FRUSD: DV01 da Primeira Rodada (FR) em d\u00f3lares (USD).</li> <li>DV01SRUSD: DV01 da Segunda Rodada (SR) em d\u00f3lares (USD).</li> <li>DV01USD: DV01 total do leil\u00e3o em d\u00f3lares (USD).</li> <li>OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).</li> <li>OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).</li> <li>OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).</li> <li>AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).</li> <li>AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).</li> <li>AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).</li> <li>SettledQuantityFR: Quantidade liquidada na primeira rodada (FR).</li> <li>SettledQuantitySR: Quantidade liquidada na segunda rodada (SR).</li> <li>SettledQuantity: Quantidade total liquidada no leil\u00e3o (FR + SR).</li> <li>ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.</li> <li>ValueSR: Valor da segunda rodada (SR) em R$.</li> <li>Value: Valor total do leil\u00e3o em R$ (FR + SR).</li> </ul> Source code in <code>pyield/bc/auction.py</code> <pre><code>def auctions(\n    start: DateLike | None = None,\n    end: DateLike | None = None,\n    auction_type: Literal[\"sell\", \"buy\"] | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.\n\n    **Consultas de per\u00edodo:**\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n      Exemplo: `auctions(start='2024-10-20', end='2024-10-27')`\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir\n      da data de `start` **at\u00e9 a data mais recente dispon\u00edvel**.\n      Exemplo: `auctions(start='2024-10-20')`\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o **desde a\n      data mais antiga dispon\u00edvel at\u00e9 a data de `end`**.\n      Exemplo: `auctions(end='2024-10-27')`\n\n    **S\u00e9rie hist\u00f3rica completa:**\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o\n      \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n      Exemplo: `auctions()`\n\n    Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas,\n    filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado.\n    O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros `start` e `end` segue o padr\u00e3o\n    da API do Banco Central:\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\").\n    Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado.\n    Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.\n\n    Args:\n        start (DateLike, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateLike, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        auction_type (Literal[\"sell\", \"buy\"], opcional): O tipo de leil\u00e3o para filtrar\n            diretamente na API. Padr\u00e3o \u00e9 `None` (retorna todos os tipos de leil\u00e3o).\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo\n            especificados. Em caso de erro ao buscar os dados, um DataFrame vazio\n            \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.auctions(start=\"19-08-2025\", end=\"19-08-2025\")\n        shape: (5, 33)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Settlement \u2506 AuctionType \u2506 Ordinance \u2506 \u2026 \u2506 AcceptedQuantity \u2506 ValueFR     \u2506 ValueSR  \u2506 Value       \u2502\n        \u2502 ---        \u2506 ---        \u2506 ---         \u2506 ---       \u2506   \u2506 ---              \u2506 ---         \u2506 ---      \u2506 ---         \u2502\n        \u2502 date       \u2506 date       \u2506 str         \u2506 i64       \u2506   \u2506 i64              \u2506 i64         \u2506 i64      \u2506 i64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 150000           \u2506 2572400000  \u2506 0        \u2506 2572400000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 192       \u2506 \u2026 \u2506 751003           \u2506 12804476147 \u2506 17123853 \u2506 12821600000 \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 193       \u2506 \u2026 \u2506 300759           \u2506 1289936461  \u2506 3263539  \u2506 1293200000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500542           \u2506 2071654327  \u2506 2245673  \u2506 2073900000  \u2502\n        \u2502 2025-08-19 \u2506 2025-08-20 \u2506 Venda       \u2506 194       \u2506 \u2026 \u2506 500000           \u2506 2010700000  \u2506 0        \u2506 2010700000  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        FR = Primeira Rodada\n        SR = Segunda Rodada\n\n    Colunas do DataFrame:\n        - Date: Data do leil\u00e3o.\n        - Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.\n        - AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").\n        - Ordinance: Edital normativo associado ao leil\u00e3o.\n        - Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").\n        - BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").\n        - SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.\n        - Maturity: Data de vencimento do t\u00edtulo.\n        - BDToMat: Dias \u00fateis entre a liquida\u00e7\u00e3o da 1R e a data de vencimento do t\u00edtulo.\n        - Duration: Duration (dura\u00e7\u00e3o) calculada com base na data de\n            liquida\u00e7\u00e3o da 1R e na data de vencimento do t\u00edtulo.\n        - AvgMaturity: Prazo m\u00e9dio do t\u00edtulo (em anos).\n        - AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.\n        - CutPrice: Pre\u00e7o de corte.\n        - AvgRate: Taxa de juros m\u00e9dia.\n        - CutRate: Taxa de corte.\n        - DV01FR: DV01 da Primeira Rodada (FR) em R$.\n        - DV01SR: DV01 da Segunda Rodada (SR) em R$.\n        - DV01: Valor do DV01 total do leil\u00e3o em R$.\n        - DV01FRUSD: DV01 da Primeira Rodada (FR) em d\u00f3lares (USD).\n        - DV01SRUSD: DV01 da Segunda Rodada (SR) em d\u00f3lares (USD).\n        - DV01USD: DV01 total do leil\u00e3o em d\u00f3lares (USD).\n        - OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).\n        - OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).\n        - OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).\n        - AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).\n        - AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).\n        - AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).\n        - SettledQuantityFR: Quantidade liquidada na primeira rodada (FR).\n        - SettledQuantitySR: Quantidade liquidada na segunda rodada (SR).\n        - SettledQuantity: Quantidade total liquidada no leil\u00e3o (FR + SR).\n        - ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.\n        - ValueSR: Valor da segunda rodada (SR) em R$.\n        - Value: Valor total do leil\u00e3o em R$ (FR + SR).\n    \"\"\"  # noqa: E501\n    try:\n        url = _montar_url(inicio=start, fim=end, tipo_leilao=auction_type)\n        texto_csv_api = _buscar_csv_api(url)\n        df = _parsear_csv(texto_csv_api)\n        if df.is_empty():\n            registro.warning(\"Nenhum dado de leil\u00e3o encontrado ap\u00f3s o parse da API.\")\n            return pl.DataFrame()\n        df = _formatar_df(df)\n        df = _processar_df(df)\n        df = _ajustar_valores_sem_leilao(df)\n        df = _adicionar_duracao(df)\n        df = _adicionar_dv01(df)\n        df_ptax = _obter_df_ptax(df)\n        df = _adicionar_dv01_usd(df, df_ptax)\n        df = _adicionar_prazo_medio(df)\n        df = _ordenar_reordenar_colunas(df)\n        # Substituir eventuais NaNs por None para compatibilidade com bancos de dados\n        df = df.with_columns(cs.float().fill_nan(None))\n\n        return df\n    except Exception as e:\n        registro.exception(f\"Erro ao buscar dados de leil\u00f5es na API do BC: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.di_over","title":"<code>di_over(date, annualized=True)</code>","text":"<p>Busca o valor da taxa DI Over para uma data espec\u00edfica.</p> <p>Fun\u00e7\u00e3o de conveni\u00eancia que retorna apenas o valor (n\u00e3o o DataFrame) para a data especificada.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar a taxa DI Over.</p> required <code>annualized</code> <code>bool</code> <p>Se True, retorna a taxa anualizada (252 dias \u00fateis por ano), caso contr\u00e1rio retorna a taxa di\u00e1ria.</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>Taxa DI Over como float ou NaN se n\u00e3o dispon\u00edvel.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n0.104\n</code></pre> <pre><code>&gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n0.00045513\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def di_over(date: DateLike, annualized: bool = True) -&gt; float:\n    \"\"\"Busca o valor da taxa DI Over para uma data espec\u00edfica.\n\n    Fun\u00e7\u00e3o de conveni\u00eancia que retorna apenas o valor (n\u00e3o o DataFrame) para a\n    data especificada.\n\n    Args:\n        date: Data de refer\u00eancia para buscar a taxa DI Over.\n        annualized: Se True, retorna a taxa anualizada (252 dias \u00fateis por ano),\n            caso contr\u00e1rio retorna a taxa di\u00e1ria.\n\n    Returns:\n        Taxa DI Over como float ou NaN se n\u00e3o dispon\u00edvel.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n        0.104\n\n        &gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n        0.00045513\n    \"\"\"\n    if any_is_empty(date):\n        return float(\"nan\")\n    df = di_over_series(date, date, annualized)\n    if df.is_empty():\n        return float(\"nan\")\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.di_over_series","title":"<code>di_over_series(start, end=None, annualized=True)</code>","text":"<p>Busca a taxa DI (Dep\u00f3sito Interbanc\u00e1rio) do Banco Central do Brasil.</p> <p>A taxa DI representa a taxa de juros m\u00e9dia dos empr\u00e9stimos interbanc\u00e1rios.</p> Exemplo de URL da API <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>Data inicial para buscar os dados. Se None, retorna dados desde a data mais antiga dispon\u00edvel.</p> required <code>end</code> <code>DateLike | None</code> <p>Data final para buscar os dados. Se None, retorna dados at\u00e9 a data mais recente dispon\u00edvel.</p> <code>None</code> <code>annualized</code> <code>bool</code> <p>Se True, retorna a taxa anualizada (252 dias \u00fateis por ano), caso contr\u00e1rio retorna a taxa di\u00e1ria.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame contendo colunas Date e Value com a taxa DI, ou DataFrame</p> <code>DataFrame</code> <p>vazio se dados n\u00e3o estiverem dispon\u00edveis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Retorna todos os dados desde 29-01-2025\n&gt;&gt;&gt; bc.di_over_series(\"29-01-2025\").head(5)  # Primeiras 5 linhas\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value  \u2502\n\u2502 ---        \u2506 ---    \u2502\n\u2502 date       \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-29 \u2506 0.1215 \u2502\n\u2502 2025-01-30 \u2506 0.1315 \u2502\n\u2502 2025-01-31 \u2506 0.1315 \u2502\n\u2502 2025-02-03 \u2506 0.1315 \u2502\n\u2502 2025-02-04 \u2506 0.1315 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def di_over_series(\n    start: DateLike,\n    end: DateLike | None = None,\n    annualized: bool = True,\n) -&gt; pl.DataFrame:\n    \"\"\"Busca a taxa DI (Dep\u00f3sito Interbanc\u00e1rio) do Banco Central do Brasil.\n\n    A taxa DI representa a taxa de juros m\u00e9dia dos empr\u00e9stimos interbanc\u00e1rios.\n\n    Exemplo de URL da API:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: Data inicial para buscar os dados. Se None, retorna dados desde\n            a data mais antiga dispon\u00edvel.\n        end: Data final para buscar os dados. Se None, retorna dados at\u00e9 a\n            data mais recente dispon\u00edvel.\n        annualized: Se True, retorna a taxa anualizada (252 dias \u00fateis por ano),\n            caso contr\u00e1rio retorna a taxa di\u00e1ria.\n\n    Returns:\n        DataFrame contendo colunas Date e Value com a taxa DI, ou DataFrame\n        vazio se dados n\u00e3o estiverem dispon\u00edveis.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Retorna todos os dados desde 29-01-2025\n        &gt;&gt;&gt; bc.di_over_series(\"29-01-2025\").head(5)  # Primeiras 5 linhas\n        shape: (5, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value  \u2502\n        \u2502 ---        \u2506 ---    \u2502\n        \u2502 date       \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-29 \u2506 0.1215 \u2502\n        \u2502 2025-01-30 \u2506 0.1315 \u2502\n        \u2502 2025-01-31 \u2506 0.1315 \u2502\n        \u2502 2025-02-03 \u2506 0.1315 \u2502\n        \u2502 2025-02-04 \u2506 0.1315 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(start):\n        return pl.DataFrame()\n    df = _buscar_dados_url(SerieBC.DI_OVER, start, end)\n    if annualized:\n        df = df.with_columns(\n            (((pl.col(\"Value\") + 1).pow(252)) - 1)\n            .round(CASAS_DECIMAIS_ANUALIZADA)\n            .alias(\"Value\")\n        )\n\n    else:\n        df = df.with_columns(pl.col(\"Value\").round(CASAS_DECIMAIS_DIARIA))\n\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.ptax","title":"<code>ptax(date)</code>","text":"<p>Busca a cota\u00e7\u00e3o PTAX m\u00e9dia de fechamento para uma data espec\u00edfica.</p> <p>Esta fun\u00e7\u00e3o \u00e9 um wrapper para a fun\u00e7\u00e3o <code>ptax_series</code>, otimizada para buscar o valor de um \u00fanico dia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>A data para a qual a cota\u00e7\u00e3o PTAX \u00e9 desejada. Pode ser uma string no formato \"dd-mm-aaaa\" ou um objeto date/datetime.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>O valor da PTAX (taxa m\u00e9dia) para a data especificada.    Retorna nan se n\u00e3o houver cota\u00e7\u00e3o para a data    (ex: feriado, fim de semana ou data futura).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Busca a PTAX para um dia \u00fatil\n&gt;&gt;&gt; bc.ptax(\"22-08-2025\")\n5.4389\n</code></pre> <pre><code>&gt;&gt;&gt; # Busca a PTAX para um fim de semana (sem dados)\n&gt;&gt;&gt; bc.ptax(\"23-08-2025\")\nnan\n</code></pre> Source code in <code>pyield/bc/ptax_api.py</code> <pre><code>def ptax(date: DateLike) -&gt; float:\n    \"\"\"Busca a cota\u00e7\u00e3o PTAX m\u00e9dia de fechamento para uma data espec\u00edfica.\n\n    Esta fun\u00e7\u00e3o \u00e9 um wrapper para a fun\u00e7\u00e3o `ptax_series`, otimizada para\n    buscar o valor de um \u00fanico dia.\n\n    Args:\n        date (DateLike): A data para a qual a cota\u00e7\u00e3o PTAX \u00e9 desejada.\n            Pode ser uma string no formato \"dd-mm-aaaa\" ou um objeto date/datetime.\n\n    Returns:\n        float: O valor da PTAX (taxa m\u00e9dia) para a data especificada.\n               Retorna nan se n\u00e3o houver cota\u00e7\u00e3o para a data\n               (ex: feriado, fim de semana ou data futura).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Busca a PTAX para um dia \u00fatil\n        &gt;&gt;&gt; bc.ptax(\"22-08-2025\")\n        5.4389\n\n        &gt;&gt;&gt; # Busca a PTAX para um fim de semana (sem dados)\n        &gt;&gt;&gt; bc.ptax(\"23-08-2025\")\n        nan\n    \"\"\"\n    # Reutiliza ptax_series para buscar os dados do dia espec\u00edfico.\n    # Definir start e end com a mesma data busca a cota\u00e7\u00e3o daquele dia.\n    dados_ptax = ptax_series(start=date, end=date)\n\n    # Se o DataFrame estiver vazio, n\u00e3o h\u00e1 cota\u00e7\u00e3o para a data.\n    # Isso ocorre em fins de semana, feriados ou datas futuras.\n    if dados_ptax.is_empty():\n        registro.warning(f\"Sem dados de PTAX para a data: {date}\")\n        return float(\"nan\")\n\n    # A API retorna uma \u00fanica linha para a cota\u00e7\u00e3o de fechamento do dia.\n    # A coluna \"MidRate\" representa a PTAX de fechamento.\n    return dados_ptax[\"MidRate\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.ptax_series","title":"<code>ptax_series(start=None, end=None)</code>","text":"<p>Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio) - Fonte: Banco Central do Brasil (BCB) - Frequ\u00eancia: Di\u00e1ria - Unidade: R$</p> <p>Documenta\u00e7\u00e3o da API do BCB:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n</code></pre> <p>Exemplo de chamada \u00e0 API:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n</code></pre> <p>Consultas de Per\u00edodo: - Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>. Exemplo:</p> <pre><code>    `ptax_series(start='20-10-2024', end='27-10-2024')`\n</code></pre> <ul> <li> <p>Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados a partir da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Exemplo:</p> <pre><code>`ptax_series(start='20-10-2024')`\n</code></pre> </li> <li> <p>Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Exemplo:</p> <p><code>ptax_series(end='27-10-2024')</code></p> </li> </ul> <p>S\u00e9rie Hist\u00f3rica Completa: - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984 at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>. Exemplo:</p> <pre><code>    `ptax_series()`\n</code></pre> <p>Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo: - Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim. - Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>. - Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateLike, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateLike, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.</p> <code>DataFrame</code> <p>Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio</p> <code>DataFrame</code> <p>ser\u00e1 retornado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.ptax_series(start=\"20-04-2025\", end=\"25-04-2025\")\nshape: (4, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 DateTime                \u2506 BuyRate \u2506 SellRate \u2506 MidRate \u2502\n\u2502 ---        \u2506 ---                     \u2506 ---     \u2506 ---      \u2506 ---     \u2502\n\u2502 date       \u2506 datetime[ms]            \u2506 f64     \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-04-22 \u2506 2025-04-22 13:09:35.629 \u2506 5.749   \u2506 5.7496   \u2506 5.7493  \u2502\n\u2502 2025-04-23 \u2506 2025-04-23 13:06:30.443 \u2506 5.6874  \u2506 5.688    \u2506 5.6877  \u2502\n\u2502 2025-04-24 \u2506 2025-04-24 13:04:29.639 \u2506 5.6732  \u2506 5.6738   \u2506 5.6735  \u2502\n\u2502 2025-04-25 \u2506 2025-04-25 13:09:26.592 \u2506 5.684   \u2506 5.6846   \u2506 5.6843  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990 e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992, essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de 2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de 1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta; o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos boletins do dia.</p> <ul> <li>Primeira data dispon\u00edvel: 28.11.1984</li> <li>\u00daltima data dispon\u00edvel: data atual</li> </ul> <p>O DataFrame possui as seguintes colunas: - Date: Data da cota\u00e7\u00e3o. - DateTime: Data e hora da cota\u00e7\u00e3o. - BuyRate: Taxa de compra. - SellRate: Taxa de venda. - MidRate: Taxa m\u00e9dia entre a compra/venda arredondada para 5 casas decimais.</p> Source code in <code>pyield/bc/ptax_api.py</code> <pre><code>def ptax_series(\n    start: DateLike | None = None,\n    end: DateLike | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio)\n    - Fonte: Banco Central do Brasil (BCB)\n    - Frequ\u00eancia: Di\u00e1ria\n    - Unidade: R$\n\n    Documenta\u00e7\u00e3o da API do BCB:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n\n    Exemplo de chamada \u00e0 API:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n\n    Consultas de Per\u00edodo:\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n    Exemplo:\n\n            `ptax_series(start='20-10-2024', end='27-10-2024')`\n\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados a partir\n    da data de `start` at\u00e9 a data mais recente dispon\u00edvel. Exemplo:\n\n            `ptax_series(start='20-10-2024')`\n\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados desde a data mais\n    antiga dispon\u00edvel at\u00e9 a data de `end`. Exemplo:\n\n        `ptax_series(end='27-10-2024')`\n\n    S\u00e9rie Hist\u00f3rica Completa:\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984\n    at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n    Exemplo:\n\n            `ptax_series()`\n\n    Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start (DateLike, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateLike, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n\n    Returns:\n        pl.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.\n        Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio\n        ser\u00e1 retornado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.ptax_series(start=\"20-04-2025\", end=\"25-04-2025\")\n        shape: (4, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 DateTime                \u2506 BuyRate \u2506 SellRate \u2506 MidRate \u2502\n        \u2502 ---        \u2506 ---                     \u2506 ---     \u2506 ---      \u2506 ---     \u2502\n        \u2502 date       \u2506 datetime[ms]            \u2506 f64     \u2506 f64      \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-04-22 \u2506 2025-04-22 13:09:35.629 \u2506 5.749   \u2506 5.7496   \u2506 5.7493  \u2502\n        \u2502 2025-04-23 \u2506 2025-04-23 13:06:30.443 \u2506 5.6874  \u2506 5.688    \u2506 5.6877  \u2502\n        \u2502 2025-04-24 \u2506 2025-04-24 13:04:29.639 \u2506 5.6732  \u2506 5.6738   \u2506 5.6735  \u2502\n        \u2502 2025-04-25 \u2506 2025-04-25 13:09:26.592 \u2506 5.684   \u2506 5.6846   \u2506 5.6843  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990\n        e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas\n        administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992,\n        essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de\n        2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no\n        mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de\n        1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder\n        \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de\n        c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta;\n        o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos\n        boletins do dia.\n\n        - Primeira data dispon\u00edvel: 28.11.1984\n        - \u00daltima data dispon\u00edvel: data atual\n\n        O DataFrame possui as seguintes colunas:\n        - Date: Data da cota\u00e7\u00e3o.\n        - DateTime: Data e hora da cota\u00e7\u00e3o.\n        - BuyRate: Taxa de compra.\n        - SellRate: Taxa de venda.\n        - MidRate: Taxa m\u00e9dia entre a compra/venda arredondada para 5 casas decimais.\n    \"\"\"\n    if start:\n        start = cv.converter_datas(start)\n    else:\n        start = dt.date(1984, 11, 28)  # Primeira data dispon\u00edvel na API\n\n    if end:\n        end = cv.converter_datas(end)\n    else:\n        end = clock.today()\n\n    try:\n        url = _montar_url_api(start, end)\n        texto = _buscar_texto_api(url)\n        df = _ler_csv(texto)\n        if df.is_empty():\n            registro.warning(\"Nenhum dado encontrado para o per\u00edodo informado.\")\n            return pl.DataFrame()\n        df = _processar_df(df)\n        return df\n    except Exception as e:\n        registro.exception(f\"Erro ao buscar dados PTAX na API do BC: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.repos","title":"<code>repos(start=None, end=None)</code>","text":"<p>Consulta e retorna leil\u00f5es de opera\u00e7\u00f5es compromissadas (repos) do BCB.</p> <p>Sem\u00e2ntica dos par\u00e2metros de per\u00edodo (API OData):     - start somente: dados de start at\u00e9 o fim da s\u00e9rie.     - end somente: dados do in\u00edcio da s\u00e9rie at\u00e9 end.     - ambos omitidos: s\u00e9rie hist\u00f3rica completa.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike | None</code> <p>Data inicial (inclusive) ou None.</p> <code>None</code> <code>end</code> <code>DateLike | None</code> <p>Data final (inclusive) ou None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame com colunas normalizadas em portugu\u00eas e tipos</p> <code>DataFrame</code> <p>enriquecidos (fra\u00e7\u00f5es decimais, inteiros, datas). Em caso de erro</p> <code>DataFrame</code> <p>retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.</p> Output Columns <ul> <li>data_leilao (Date): data de ocorr\u00eancia do leil\u00e3o.</li> <li>data_liquidacao (Date): data de liquida\u00e7\u00e3o (in\u00edcio da opera\u00e7\u00e3o).</li> <li>data_retorno (Date): data de recompra / t\u00e9rmino da opera\u00e7\u00e3o.</li> <li>hora_inicio (Time): hor\u00e1rio de in\u00edcio do leil\u00e3o.</li> <li>prazo_dias_corridos (Int64): dias corridos at\u00e9 a data de retorno.</li> <li>prazo_dias_uteis (Int64): dias \u00fateis entre liquida\u00e7\u00e3o e retorno (bday.count).</li> <li>numero_comunicado (Int64): n\u00famero do comunicado/aviso do BC (pode ser nulo).</li> <li>tipo_oferta (String): classif. do tipo de oferta (ex: Tomador, Compromissada 1047).</li> <li>publico_permitido (String): escopo de participantes (SomenteDealer, TodoMercado).</li> <li>volume_aceito (Int64): volume aceito no leil\u00e3o em reais (convertido de milhares).</li> <li>taxa_corte (Float64): taxa de corte (ex. 0.1490 = 14,90%). Nula se volume_aceito = 0.</li> <li>percentual_aceito (Float64): percentual do volume ofertado efetivamente aceito (0-100).   100 = nenhuma rejei\u00e7\u00e3o. 0 indica nada aceito (volume_aceito = 0).</li> </ul> Notes <ul> <li>Dados ordenados por: data_leilao, hora_inicio, tipo_oferta.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.repos(start=\"21-08-2025\", end=\"21-08-2025\")\nshape: (2, 12)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 data_leilao \u2506 data_liquidacao \u2506 data_retorno \u2506 hora_inicio \u2506 \u2026 \u2506 publico_permitido \u2506 volume_aceito \u2506 taxa_corte \u2506 percentual_aceito \u2502\n\u2502 ---         \u2506 ---             \u2506 ---          \u2506 ---         \u2506   \u2506 ---               \u2506 ---           \u2506 ---        \u2506 ---               \u2502\n\u2502 date        \u2506 date            \u2506 date         \u2506 time        \u2506   \u2506 str               \u2506 i64           \u2506 f64        \u2506 f64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-08-21  \u2506 2025-08-21      \u2506 2025-08-22   \u2506 09:00:00    \u2506 \u2026 \u2506 SomenteDealer     \u2506 647707406000  \u2506 0.149      \u2506 100.0             \u2502\n\u2502 2025-08-21  \u2506 2025-08-22      \u2506 2025-11-21   \u2506 12:00:00    \u2506 \u2026 \u2506 TodoMercado       \u2506 5000000000    \u2506 0.9978     \u2506 35.87             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/repo.py</code> <pre><code>def repos(\n    start: DateLike | None = None,\n    end: DateLike | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"Consulta e retorna leil\u00f5es de opera\u00e7\u00f5es compromissadas (repos) do BCB.\n\n    Sem\u00e2ntica dos par\u00e2metros de per\u00edodo (API OData):\n        - start somente: dados de start at\u00e9 o fim da s\u00e9rie.\n        - end somente: dados do in\u00edcio da s\u00e9rie at\u00e9 end.\n        - ambos omitidos: s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start: Data inicial (inclusive) ou None.\n        end: Data final (inclusive) ou None.\n\n    Returns:\n        DataFrame com colunas normalizadas em portugu\u00eas e tipos\n        enriquecidos (fra\u00e7\u00f5es decimais, inteiros, datas). Em caso de erro\n        retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.\n\n    Output Columns:\n        - data_leilao (Date): data de ocorr\u00eancia do leil\u00e3o.\n        - data_liquidacao (Date): data de liquida\u00e7\u00e3o (in\u00edcio da opera\u00e7\u00e3o).\n        - data_retorno (Date): data de recompra / t\u00e9rmino da opera\u00e7\u00e3o.\n        - hora_inicio (Time): hor\u00e1rio de in\u00edcio do leil\u00e3o.\n        - prazo_dias_corridos (Int64): dias corridos at\u00e9 a data de retorno.\n        - prazo_dias_uteis (Int64): dias \u00fateis entre liquida\u00e7\u00e3o e retorno (bday.count).\n        - numero_comunicado (Int64): n\u00famero do comunicado/aviso do BC (pode ser nulo).\n        - tipo_oferta (String): classif. do tipo de oferta (ex: Tomador, Compromissada 1047).\n        - publico_permitido (String): escopo de participantes (SomenteDealer, TodoMercado).\n        - volume_aceito (Int64): volume aceito no leil\u00e3o em reais (convertido de milhares).\n        - taxa_corte (Float64): taxa de corte (ex. 0.1490 = 14,90%). Nula se volume_aceito = 0.\n        - percentual_aceito (Float64): percentual do volume ofertado efetivamente aceito (0-100).\n          100 = nenhuma rejei\u00e7\u00e3o. 0 indica nada aceito (volume_aceito = 0).\n\n    Notes:\n        - Dados ordenados por: data_leilao, hora_inicio, tipo_oferta.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.repos(start=\"21-08-2025\", end=\"21-08-2025\")\n        shape: (2, 12)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 data_leilao \u2506 data_liquidacao \u2506 data_retorno \u2506 hora_inicio \u2506 \u2026 \u2506 publico_permitido \u2506 volume_aceito \u2506 taxa_corte \u2506 percentual_aceito \u2502\n        \u2502 ---         \u2506 ---             \u2506 ---          \u2506 ---         \u2506   \u2506 ---               \u2506 ---           \u2506 ---        \u2506 ---               \u2502\n        \u2502 date        \u2506 date            \u2506 date         \u2506 time        \u2506   \u2506 str               \u2506 i64           \u2506 f64        \u2506 f64               \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-08-21  \u2506 2025-08-21      \u2506 2025-08-22   \u2506 09:00:00    \u2506 \u2026 \u2506 SomenteDealer     \u2506 647707406000  \u2506 0.149      \u2506 100.0             \u2502\n        \u2502 2025-08-21  \u2506 2025-08-22      \u2506 2025-11-21   \u2506 12:00:00    \u2506 \u2026 \u2506 TodoMercado       \u2506 5000000000    \u2506 0.9978     \u2506 35.87             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    try:\n        url = _montar_url(inicio=start, fim=end)\n        registro.debug(f\"Consultando API do BC: {url}\")\n        csv_api = _buscar_csv_api(url)\n        df = _ler_csv(csv_api)\n        if df.is_empty():\n            registro.warning(\"Sem dados de leil\u00f5es para o per\u00edodo especificado.\")\n            return pl.DataFrame()\n        df = _processar_df(df)\n        df = _ajustar_volume_zero(df)\n        df = _ordenar_selecionar_colunas(df)\n        return df\n    except Exception as e:\n        registro.exception(f\"Erro ao buscar dados de leil\u00f5es na API do BC: {e}\")\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over","title":"<code>selic_over(date)</code>","text":"<p>Busca o valor da taxa SELIC Over para uma data espec\u00edfica.</p> <p>Fun\u00e7\u00e3o de conveni\u00eancia que retorna apenas o valor (n\u00e3o o DataFrame) para a data especificada.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar a taxa SELIC Over.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Taxa SELIC Over como float ou NaN se n\u00e3o dispon\u00edvel.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n0.104\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_over(date: DateLike) -&gt; float:\n    \"\"\"Busca o valor da taxa SELIC Over para uma data espec\u00edfica.\n\n    Fun\u00e7\u00e3o de conveni\u00eancia que retorna apenas o valor (n\u00e3o o DataFrame) para a\n    data especificada.\n\n    Args:\n        date: Data de refer\u00eancia para buscar a taxa SELIC Over.\n\n    Returns:\n        Taxa SELIC Over como float ou NaN se n\u00e3o dispon\u00edvel.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n        0.104\n    \"\"\"\n    if any_is_empty(date):\n        return float(\"nan\")\n    df = selic_over_series(date, date)\n    if df.is_empty():\n        return float(\"nan\")\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over_series","title":"<code>selic_over_series(start, end=None)</code>","text":"<p>Busca a taxa SELIC Over do Banco Central do Brasil.</p> <p>A taxa SELIC Over \u00e9 a taxa de juros m\u00e9dia di\u00e1ria efetivamente praticada entre bancos no mercado interbanc\u00e1rio, usando t\u00edtulos p\u00fablicos como garantia.</p> Exemplo de URL da API <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>Data inicial para buscar os dados. Se None, retorna dados desde a data mais antiga dispon\u00edvel.</p> required <code>end</code> <code>DateLike | None</code> <p>Data final para buscar os dados. Se None, retorna dados at\u00e9 a data mais recente dispon\u00edvel.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame contendo colunas Date e Value com a taxa SELIC Over, ou</p> <code>DataFrame</code> <p>DataFrame vazio se dados n\u00e3o estiverem dispon\u00edveis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Sem dados em 26-01-2025 (domingo). Selic mudou por reuni\u00e3o do Copom.\n&gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\").head(5)  # Primeiras 5 linhas\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value  \u2502\n\u2502 ---        \u2506 ---    \u2502\n\u2502 date       \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-27 \u2506 0.1215 \u2502\n\u2502 2025-01-28 \u2506 0.1215 \u2502\n\u2502 2025-01-29 \u2506 0.1215 \u2502\n\u2502 2025-01-30 \u2506 0.1315 \u2502\n\u2502 2025-01-31 \u2506 0.1315 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; # Buscando dados para um intervalo espec\u00edfico\n&gt;&gt;&gt; bc.selic_over_series(\"14-09-2025\", \"17-09-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value \u2502\n\u2502 ---        \u2506 ---   \u2502\n\u2502 date       \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-09-15 \u2506 0.149 \u2502\n\u2502 2025-09-16 \u2506 0.149 \u2502\n\u2502 2025-09-17 \u2506 0.149 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_over_series(\n    start: DateLike,\n    end: DateLike | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"Busca a taxa SELIC Over do Banco Central do Brasil.\n\n    A taxa SELIC Over \u00e9 a taxa de juros m\u00e9dia di\u00e1ria efetivamente praticada\n    entre bancos no mercado interbanc\u00e1rio, usando t\u00edtulos p\u00fablicos como garantia.\n\n    Exemplo de URL da API:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: Data inicial para buscar os dados. Se None, retorna dados desde\n            a data mais antiga dispon\u00edvel.\n        end: Data final para buscar os dados. Se None, retorna dados at\u00e9 a\n            data mais recente dispon\u00edvel.\n\n    Returns:\n        DataFrame contendo colunas Date e Value com a taxa SELIC Over, ou\n        DataFrame vazio se dados n\u00e3o estiverem dispon\u00edveis.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Sem dados em 26-01-2025 (domingo). Selic mudou por reuni\u00e3o do Copom.\n        &gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\").head(5)  # Primeiras 5 linhas\n        shape: (5, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value  \u2502\n        \u2502 ---        \u2506 ---    \u2502\n        \u2502 date       \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-27 \u2506 0.1215 \u2502\n        \u2502 2025-01-28 \u2506 0.1215 \u2502\n        \u2502 2025-01-29 \u2506 0.1215 \u2502\n        \u2502 2025-01-30 \u2506 0.1315 \u2502\n        \u2502 2025-01-31 \u2506 0.1315 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; # Buscando dados para um intervalo espec\u00edfico\n        &gt;&gt;&gt; bc.selic_over_series(\"14-09-2025\", \"17-09-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value \u2502\n        \u2502 ---        \u2506 ---   \u2502\n        \u2502 date       \u2506 f64   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-09-15 \u2506 0.149 \u2502\n        \u2502 2025-09-16 \u2506 0.149 \u2502\n        \u2502 2025-09-17 \u2506 0.149 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(start):  # start deve ser fornecido\n        return pl.DataFrame()\n    df = _buscar_dados_url(SerieBC.SELIC_OVER, start, end)\n    return df.with_columns(pl.col(\"Value\").round(CASAS_DECIMAIS_ANUALIZADA))\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target","title":"<code>selic_target(date)</code>","text":"<p>Busca o valor da taxa SELIC Meta para uma data espec\u00edfica.</p> <p>Fun\u00e7\u00e3o de conveni\u00eancia que retorna apenas o valor (n\u00e3o o DataFrame) para a data especificada.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar a taxa SELIC Meta.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Taxa SELIC Meta como float ou NaN se n\u00e3o dispon\u00edvel.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n0.105\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_target(date: DateLike) -&gt; float:\n    \"\"\"Busca o valor da taxa SELIC Meta para uma data espec\u00edfica.\n\n    Fun\u00e7\u00e3o de conveni\u00eancia que retorna apenas o valor (n\u00e3o o DataFrame) para a\n    data especificada.\n\n    Args:\n        date: Data de refer\u00eancia para buscar a taxa SELIC Meta.\n\n    Returns:\n        Taxa SELIC Meta como float ou NaN se n\u00e3o dispon\u00edvel.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n        0.105\n    \"\"\"\n    if any_is_empty(date):\n        return float(\"nan\")\n    df = selic_target_series(date, date)\n    if df.is_empty():\n        return float(\"nan\")\n    return df[\"Value\"].item(0)\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target_series","title":"<code>selic_target_series(start, end=None)</code>","text":"<p>Busca a taxa SELIC Meta do Banco Central do Brasil.</p> <p>A taxa SELIC Meta \u00e9 a taxa de juros oficial definida pelo Comit\u00ea de Pol\u00edtica Monet\u00e1ria (COPOM) do Banco Central do Brasil.</p> Exemplo de URL da API <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>Data inicial para buscar os dados.</p> required <code>end</code> <code>DateLike | None</code> <p>Data final para buscar os dados. Se None, retorna dados at\u00e9 a data mais recente dispon\u00edvel.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame contendo colunas Date e Value com a taxa SELIC Meta, ou</p> <code>DataFrame</code> <p>DataFrame vazio se dados n\u00e3o estiverem dispon\u00edveis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Date       \u2506 Value \u2502\n\u2502 ---        \u2506 ---   \u2502\n\u2502 date       \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 0.105 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/rates.py</code> <pre><code>def selic_target_series(\n    start: DateLike,\n    end: DateLike | None = None,\n) -&gt; pl.DataFrame:\n    \"\"\"Busca a taxa SELIC Meta do Banco Central do Brasil.\n\n    A taxa SELIC Meta \u00e9 a taxa de juros oficial definida pelo Comit\u00ea de Pol\u00edtica\n    Monet\u00e1ria (COPOM) do Banco Central do Brasil.\n\n    Exemplo de URL da API:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: Data inicial para buscar os dados.\n        end: Data final para buscar os dados. Se None, retorna dados at\u00e9 a\n            data mais recente dispon\u00edvel.\n\n    Returns:\n        DataFrame contendo colunas Date e Value com a taxa SELIC Meta, ou\n        DataFrame vazio se dados n\u00e3o estiverem dispon\u00edveis.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\n        shape: (1, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Date       \u2506 Value \u2502\n        \u2502 ---        \u2506 ---   \u2502\n        \u2502 date       \u2506 f64   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 0.105 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(start):  # start deve ser fornecido\n        return pl.DataFrame()\n    df = _buscar_dados_url(SerieBC.SELIC_TARGET, start, end)\n    df = df.with_columns(pl.col(\"Value\").round(CASAS_DECIMAIS_ANUALIZADA))\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_intraday_trades","title":"<code>tpf_intraday_trades()</code>","text":"<p>Obt\u00e9m dados intradi\u00e1rios de negocia\u00e7\u00f5es secund\u00e1rias da d\u00edvida p\u00fablica federal (TPF - t\u00edtulos p\u00fablicos federais) no Banco Central do Brasil (BCB).</p> <p>Os dados ficam dispon\u00edveis apenas durante o hor\u00e1rio do SELIC (09:00\u201322:00 BRT) em dias \u00fateis. Retorna DataFrame vazio fora desse per\u00edodo.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com negocia\u00e7\u00f5es intradi\u00e1rias. Vazio se o mercado estiver fechado ou ocorrer erro.</p> Output Columns <ul> <li>CollectedAt (datetime): Timestamp da coleta (BRT).</li> <li>SettlementDate (date): Data de liquida\u00e7\u00e3o \u00e0 vista.</li> <li>BondType (str): Sigla do t\u00edtulo (ex.: LFT, LTN, NTN-B).</li> <li>SelicCode (int): C\u00f3digo SELIC do t\u00edtulo.</li> <li>MaturityDate (date): Data de vencimento do t\u00edtulo.</li> <li>MinPrice (float): Menor pre\u00e7o negociado.</li> <li>AvgPrice (float): Pre\u00e7o m\u00e9dio negociado.</li> <li>MaxPrice (float): Maior pre\u00e7o negociado.</li> <li>LastPrice (float): \u00daltimo pre\u00e7o negociado.</li> <li>MinRate (float): Menor taxa negociada (decimal).</li> <li>AvgRate (float): Taxa m\u00e9dia negociada (decimal).</li> <li>MaxRate (float): Maior taxa negociada (decimal).</li> <li>LastRate (float): \u00daltima taxa negociada (decimal).</li> <li>Trades (int): Total de opera\u00e7\u00f5es liquidadas.</li> <li>Quantity (int): Quantidade total de t\u00edtulos negociados.</li> <li>Value (float): Valor financeiro total negociado (BRL).</li> <li>BrokeredTrades (int): Opera\u00e7\u00f5es liquidadas via corretagem.</li> <li>BrokeredQuantity (int): T\u00edtulos negociados via corretagem.</li> <li>FwdMinPrice (float): Menor pre\u00e7o a termo negociado.</li> <li>FwdAvgPrice (float): Pre\u00e7o m\u00e9dio a termo negociado.</li> <li>FwdMaxPrice (float): Maior pre\u00e7o a termo negociado.</li> <li>FwdLastPrice (float): \u00daltimo pre\u00e7o a termo negociado.</li> <li>FwdMinRate (float): Menor taxa a termo negociada (decimal).</li> <li>FwdAvgRate (float): Taxa m\u00e9dia a termo negociada (decimal).</li> <li>FwdMaxRate (float): Maior taxa a termo negociada (decimal).</li> <li>FwdLastRate (float): \u00daltima taxa a termo negociada (decimal).</li> <li>FwdTrades (int): Total de opera\u00e7\u00f5es a termo contratadas.</li> <li>FwdQuantity (int): Total de t\u00edtulos a termo negociados.</li> <li>FwdValue (float): Valor financeiro total a termo (BRL).</li> <li>FwdBrokeredTrades (int): Opera\u00e7\u00f5es a termo via corretagem.</li> <li>FwdBrokeredQuantity (int): T\u00edtulos a termo via corretagem.</li> </ul> Notes <ul> <li>Retorna DataFrame vazio fora do hor\u00e1rio do SELIC (09:00\u201322:00 BRT).</li> <li>Em caso de erro na coleta, registra log e retorna DataFrame vazio.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; df = bc.tpf_intraday_trades()\n</code></pre> Source code in <code>pyield/bc/trades_intraday.py</code> <pre><code>def tpf_intraday_trades() -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m dados intradi\u00e1rios de negocia\u00e7\u00f5es secund\u00e1rias da d\u00edvida p\u00fablica\n    federal (TPF - t\u00edtulos p\u00fablicos federais) no Banco Central do Brasil (BCB).\n\n    Os dados ficam dispon\u00edveis apenas durante o hor\u00e1rio do SELIC\n    (09:00\u201322:00 BRT) em dias \u00fateis. Retorna DataFrame vazio fora desse per\u00edodo.\n\n    Returns:\n        pl.DataFrame: DataFrame com negocia\u00e7\u00f5es intradi\u00e1rias. Vazio se o mercado\n            estiver fechado ou ocorrer erro.\n\n    Output Columns:\n        - CollectedAt (datetime): Timestamp da coleta (BRT).\n        - SettlementDate (date): Data de liquida\u00e7\u00e3o \u00e0 vista.\n        - BondType (str): Sigla do t\u00edtulo (ex.: LFT, LTN, NTN-B).\n        - SelicCode (int): C\u00f3digo SELIC do t\u00edtulo.\n        - MaturityDate (date): Data de vencimento do t\u00edtulo.\n        - MinPrice (float): Menor pre\u00e7o negociado.\n        - AvgPrice (float): Pre\u00e7o m\u00e9dio negociado.\n        - MaxPrice (float): Maior pre\u00e7o negociado.\n        - LastPrice (float): \u00daltimo pre\u00e7o negociado.\n        - MinRate (float): Menor taxa negociada (decimal).\n        - AvgRate (float): Taxa m\u00e9dia negociada (decimal).\n        - MaxRate (float): Maior taxa negociada (decimal).\n        - LastRate (float): \u00daltima taxa negociada (decimal).\n        - Trades (int): Total de opera\u00e7\u00f5es liquidadas.\n        - Quantity (int): Quantidade total de t\u00edtulos negociados.\n        - Value (float): Valor financeiro total negociado (BRL).\n        - BrokeredTrades (int): Opera\u00e7\u00f5es liquidadas via corretagem.\n        - BrokeredQuantity (int): T\u00edtulos negociados via corretagem.\n        - FwdMinPrice (float): Menor pre\u00e7o a termo negociado.\n        - FwdAvgPrice (float): Pre\u00e7o m\u00e9dio a termo negociado.\n        - FwdMaxPrice (float): Maior pre\u00e7o a termo negociado.\n        - FwdLastPrice (float): \u00daltimo pre\u00e7o a termo negociado.\n        - FwdMinRate (float): Menor taxa a termo negociada (decimal).\n        - FwdAvgRate (float): Taxa m\u00e9dia a termo negociada (decimal).\n        - FwdMaxRate (float): Maior taxa a termo negociada (decimal).\n        - FwdLastRate (float): \u00daltima taxa a termo negociada (decimal).\n        - FwdTrades (int): Total de opera\u00e7\u00f5es a termo contratadas.\n        - FwdQuantity (int): Total de t\u00edtulos a termo negociados.\n        - FwdValue (float): Valor financeiro total a termo (BRL).\n        - FwdBrokeredTrades (int): Opera\u00e7\u00f5es a termo via corretagem.\n        - FwdBrokeredQuantity (int): T\u00edtulos a termo via corretagem.\n\n    Notes:\n        - Retorna DataFrame vazio fora do hor\u00e1rio do SELIC (09:00\u201322:00 BRT).\n        - Em caso de erro na coleta, registra log e retorna DataFrame vazio.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; df = bc.tpf_intraday_trades()\n    \"\"\"\n    if not _mercado_selic_aberto():\n        registro.info(\"Mercado fechado. Retornando DataFrame vazio.\")\n        return pl.DataFrame()\n\n    try:\n        texto_bruto = _buscar_csv()\n        texto_limpo = _limpar_csv(texto_bruto)\n        if not texto_limpo:\n            registro.warning(\"Nenhum dado encontrado nas negocia\u00e7\u00f5es intradi\u00e1rias.\")\n            return pl.DataFrame()\n\n        df = _csv_para_df(texto_limpo)\n        df = _processar_df(df)\n\n        valor = df[\"Value\"].sum() / 10**9\n        registro.info(f\"Foram coletados {valor:,.1f} bilh\u00f5es de BRL em negocia\u00e7\u00f5es.\")\n        return df\n    except Exception as e:\n        registro.exception(\n            f\"Erro ao coletar dados do BCB: {e}. Retornando DataFrame vazio.\"\n        )\n        return pl.DataFrame()\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_monthly_trades","title":"<code>tpf_monthly_trades(target_date, extragroup=False)</code>","text":"<p>Consulta negocia\u00e7\u00f5es mensais no mercado secund\u00e1rio de T\u00edtulos P\u00fablicos Federais (TPF) registradas no sistema Selic do Banco Central do Brasil (BCB).</p> <p>Baixa os dados mensais de negocia\u00e7\u00e3o do site do BCB para o m\u00eas correspondente \u00e0 data fornecida. Os dados s\u00e3o baixados como arquivo ZIP, extra\u00eddos e carregados em um DataFrame Polars. Cont\u00e9m todas as negocia\u00e7\u00f5es do m\u00eas, separadas por data de liquida\u00e7\u00e3o (SettlementDate).</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>DateLike</code> <p>Data de refer\u00eancia. Apenas ano e m\u00eas s\u00e3o utilizados para baixar o arquivo correspondente.</p> required <code>extragroup</code> <code>bool</code> <p>Se True, busca apenas negocia\u00e7\u00f5es extragrupo (entre grupos econ\u00f4micos distintos). Se False, busca todas. Default \u00e9 False. Negocia\u00e7\u00f5es extragrupo s\u00e3o aquelas em que o conglomerado da contraparte cedente difere do conglomerado da contraparte cession\u00e1ria, ou quando ao menos uma das contrapartes n\u00e3o pertence a um conglomerado. No caso de fundos, considera-se o conglomerado do administrador.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame com dados de negocia\u00e7\u00e3o do m\u00eas especificado. Em caso de erro</p> <code>DataFrame</code> <p>retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.</p> Output Columns <ul> <li>SettlementDate (Date): data de liquida\u00e7\u00e3o da negocia\u00e7\u00e3o.</li> <li>BondType (str): sigla do t\u00edtulo (ex: LFT, LTN, NTN-B, NTN-F).</li> <li>SelicCode (Int64): c\u00f3digo \u00fanico no sistema Selic.</li> <li>ISIN (str): c\u00f3digo ISIN (International Securities Identification Number).</li> <li>IssueDate (Date): data de emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate (Date): data de vencimento do t\u00edtulo.</li> <li>Trades (Int64): n\u00famero de opera\u00e7\u00f5es realizadas.</li> <li>Quantity (Int64): quantidade negociada.</li> <li>Value (Float64): valor financeiro negociado (Quantity * AvgPrice).</li> <li>MinPrice (Float64): pre\u00e7o unit\u00e1rio m\u00ednimo.</li> <li>AvgPrice (Float64): pre\u00e7o unit\u00e1rio m\u00e9dio.</li> <li>MaxPrice (Float64): pre\u00e7o unit\u00e1rio m\u00e1ximo.</li> <li>UnderlyingPrice (Float64): PU lastro.</li> <li>ParValue (Float64): valor par.</li> <li>MinRate (Float64): taxa m\u00ednima.</li> <li>AvgRate (Float64): taxa m\u00e9dia.</li> <li>MaxRate (Float64): taxa m\u00e1xima.</li> <li>BrokerageTrades (Int64): n\u00famero de opera\u00e7\u00f5es com corretagem.</li> <li>BrokerageQuantity (Int64): quantidade negociada com corretagem.</li> </ul> Notes <ul> <li>Dados ordenados por: SettlementDate, BondType, MaturityDate.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; # Busca todas as negocia\u00e7\u00f5es de jan/2025\n&gt;&gt;&gt; bc.tpf_monthly_trades(\"07-01-2025\", extragroup=True)\nshape: (1_019, 19)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SettlementDate \u2506 BondType \u2506 SelicCode \u2506 ISIN         \u2506 \u2026 \u2506 AvgRate \u2506 MaxRate \u2506 BrokerageTrades \u2506 BrokerageQuantity \u2502\n\u2502 ---            \u2506 ---      \u2506 ---       \u2506 ---          \u2506   \u2506 ---     \u2506 ---     \u2506 ---             \u2506 ---               \u2502\n\u2502 date           \u2506 str      \u2506 i64       \u2506 str          \u2506   \u2506 f64     \u2506 f64     \u2506 i64             \u2506 i64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RC4 \u2506 \u2026 \u2506 0.0132  \u2506 0.0906  \u2506 2               \u2506 9581              \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RD2 \u2506 \u2026 \u2506 0.0561  \u2506 0.101   \u2506 11              \u2506 42823             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RE0 \u2506 \u2026 \u2506 0.0191  \u2506 0.0405  \u2506 19              \u2506 33330             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RF7 \u2506 \u2026 \u2506 0.0304  \u2506 0.05    \u2506 10              \u2506 14583             \u2502\n\u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RG5 \u2506 \u2026 \u2506 0.0697  \u2506 0.0935  \u2506 12              \u2506 51776             \u2502\n\u2502 \u2026              \u2506 \u2026        \u2506 \u2026         \u2506 \u2026            \u2506 \u2026 \u2506 \u2026       \u2506 \u2026       \u2506 \u2026               \u2506 \u2026                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1P8 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1Q6 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF204 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 12              \u2506 570000            \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF212 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n\u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF238 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 4               \u2506 115000            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bc/trades_monthly.py</code> <pre><code>def tpf_monthly_trades(target_date: DateLike, extragroup: bool = False) -&gt; pl.DataFrame:\n    \"\"\"Consulta negocia\u00e7\u00f5es mensais no mercado secund\u00e1rio de T\u00edtulos P\u00fablicos Federais (TPF)\n    registradas no sistema Selic do Banco Central do Brasil (BCB).\n\n    Baixa os dados mensais de negocia\u00e7\u00e3o do site do BCB para o m\u00eas correspondente\n    \u00e0 data fornecida. Os dados s\u00e3o baixados como arquivo ZIP, extra\u00eddos e carregados\n    em um DataFrame Polars. Cont\u00e9m todas as negocia\u00e7\u00f5es do m\u00eas, separadas por\n    data de liquida\u00e7\u00e3o (SettlementDate).\n\n    Args:\n        target_date: Data de refer\u00eancia. Apenas ano e m\u00eas s\u00e3o utilizados para\n            baixar o arquivo correspondente.\n        extragroup: Se True, busca apenas negocia\u00e7\u00f5es extragrupo (entre grupos\n            econ\u00f4micos distintos). Se False, busca todas. Default \u00e9 False.\n            Negocia\u00e7\u00f5es extragrupo s\u00e3o aquelas em que o conglomerado da contraparte\n            cedente difere do conglomerado da contraparte cession\u00e1ria, ou quando ao\n            menos uma das contrapartes n\u00e3o pertence a um conglomerado. No caso de\n            fundos, considera-se o conglomerado do administrador.\n\n    Returns:\n        DataFrame com dados de negocia\u00e7\u00e3o do m\u00eas especificado. Em caso de erro\n        retorna DataFrame vazio e registra log da exce\u00e7\u00e3o.\n\n    Output Columns:\n        - SettlementDate (Date): data de liquida\u00e7\u00e3o da negocia\u00e7\u00e3o.\n        - BondType (str): sigla do t\u00edtulo (ex: LFT, LTN, NTN-B, NTN-F).\n        - SelicCode (Int64): c\u00f3digo \u00fanico no sistema Selic.\n        - ISIN (str): c\u00f3digo ISIN (International Securities Identification Number).\n        - IssueDate (Date): data de emiss\u00e3o do t\u00edtulo.\n        - MaturityDate (Date): data de vencimento do t\u00edtulo.\n        - Trades (Int64): n\u00famero de opera\u00e7\u00f5es realizadas.\n        - Quantity (Int64): quantidade negociada.\n        - Value (Float64): valor financeiro negociado (Quantity * AvgPrice).\n        - MinPrice (Float64): pre\u00e7o unit\u00e1rio m\u00ednimo.\n        - AvgPrice (Float64): pre\u00e7o unit\u00e1rio m\u00e9dio.\n        - MaxPrice (Float64): pre\u00e7o unit\u00e1rio m\u00e1ximo.\n        - UnderlyingPrice (Float64): PU lastro.\n        - ParValue (Float64): valor par.\n        - MinRate (Float64): taxa m\u00ednima.\n        - AvgRate (Float64): taxa m\u00e9dia.\n        - MaxRate (Float64): taxa m\u00e1xima.\n        - BrokerageTrades (Int64): n\u00famero de opera\u00e7\u00f5es com corretagem.\n        - BrokerageQuantity (Int64): quantidade negociada com corretagem.\n\n    Notes:\n        - Dados ordenados por: SettlementDate, BondType, MaturityDate.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; # Busca todas as negocia\u00e7\u00f5es de jan/2025\n        &gt;&gt;&gt; bc.tpf_monthly_trades(\"07-01-2025\", extragroup=True)\n        shape: (1_019, 19)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 SettlementDate \u2506 BondType \u2506 SelicCode \u2506 ISIN         \u2506 \u2026 \u2506 AvgRate \u2506 MaxRate \u2506 BrokerageTrades \u2506 BrokerageQuantity \u2502\n        \u2502 ---            \u2506 ---      \u2506 ---       \u2506 ---          \u2506   \u2506 ---     \u2506 ---     \u2506 ---             \u2506 ---               \u2502\n        \u2502 date           \u2506 str      \u2506 i64       \u2506 str          \u2506   \u2506 f64     \u2506 f64     \u2506 i64             \u2506 i64               \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RC4 \u2506 \u2026 \u2506 0.0132  \u2506 0.0906  \u2506 2               \u2506 9581              \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RD2 \u2506 \u2026 \u2506 0.0561  \u2506 0.101   \u2506 11              \u2506 42823             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RE0 \u2506 \u2026 \u2506 0.0191  \u2506 0.0405  \u2506 19              \u2506 33330             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RF7 \u2506 \u2026 \u2506 0.0304  \u2506 0.05    \u2506 10              \u2506 14583             \u2502\n        \u2502 2025-01-02     \u2506 LFT      \u2506 210100    \u2506 BRSTNCLF1RG5 \u2506 \u2026 \u2506 0.0697  \u2506 0.0935  \u2506 12              \u2506 51776             \u2502\n        \u2502 \u2026              \u2506 \u2026        \u2506 \u2026         \u2506 \u2026            \u2506 \u2026 \u2506 \u2026       \u2506 \u2026       \u2506 \u2026               \u2506 \u2026                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1P8 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF1Q6 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF204 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 12              \u2506 570000            \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF212 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 0               \u2506 0                 \u2502\n        \u2502 2025-01-31     \u2506 NTN-F    \u2506 950199    \u2506 BRSTNCNTF238 \u2506 \u2026 \u2506 null    \u2506 null    \u2506 4               \u2506 115000            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if any_is_empty(target_date):\n        registro.warning(\"Nenhuma data informada. Retornando DataFrame vazio.\")\n        return pl.DataFrame()\n    try:\n        data_alvo = converter_datas(target_date)\n        url = _montar_url(data_alvo, extragroup)\n        registro.debug(f\"Consultando BCB: {url}\")\n        conteudo_zip = _baixar_zip(url)\n        arquivo_extraido = _descompactar_zip(conteudo_zip)\n        df = _ler_df_zip(arquivo_extraido)\n        df = _processar_df(df)\n        df = _ordenar_selecionar_colunas(df)\n    except Exception as e:\n        registro.exception(f\"Erro ao coletar dados mensais do BCB: {e}\")\n        return pl.DataFrame()\n\n    registro.info(f\"Dados processados de {url}. Registros: {len(df)}.\")\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.vna_lft","title":"<code>vna_lft(date)</code>","text":"<p>Obt\u00e9m o VNA (Valor Nominal Atualizado) da LFT no site do BCB.</p> <p>Baixa o arquivo di\u00e1rio do BCB (SELIC), extrai a tabela com os valores VNA e retorna o valor correspondente \u00e0 data informada.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia. Aceita string, date ou datetime, convertidos internamente por <code>converter_datas</code>.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Valor do VNA para a data especificada. Retorna <code>NaN</code> se a data for nula ou vazia.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os valores VNA extra\u00eddos do site do BCB forem inconsistentes (nem todos iguais), indicando poss\u00edvel diverg\u00eancia nos dados da fonte. A mensagem inclui o link do BCB para verifica\u00e7\u00e3o manual.</p> <code>HTTPError</code> <p>Se a requisi\u00e7\u00e3o HTTP ao site do BCB falhar (problemas de rede, site indispon\u00edvel ou dados n\u00e3o encontrados para a data informada).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n14903.01148\n</code></pre> Source code in <code>pyield/bc/vna.py</code> <pre><code>def vna_lft(date: DateLike) -&gt; float:\n    \"\"\"Obt\u00e9m o VNA (Valor Nominal Atualizado) da LFT no site do BCB.\n\n    Baixa o arquivo di\u00e1rio do BCB (SELIC), extrai a tabela com os valores\n    VNA e retorna o valor correspondente \u00e0 data informada.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia. Aceita string, date ou datetime,\n            convertidos internamente por ``converter_datas``.\n\n    Returns:\n        float: Valor do VNA para a data especificada. Retorna ``NaN`` se a\n            data for nula ou vazia.\n\n    Raises:\n        ValueError: Se os valores VNA extra\u00eddos do site do BCB forem\n            inconsistentes (nem todos iguais), indicando poss\u00edvel diverg\u00eancia\n            nos dados da fonte. A mensagem inclui o link do BCB para\n            verifica\u00e7\u00e3o manual.\n        requests.exceptions.HTTPError: Se a requisi\u00e7\u00e3o HTTP ao site do BCB\n            falhar (problemas de rede, site indispon\u00edvel ou dados n\u00e3o\n            encontrados para a data informada).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n        14903.01148\n    \"\"\"\n    if any_is_empty(date):\n        logger.warning(\"No valid date provided. Returning NaN.\")\n        return float(\"nan\")\n    texto = _baixar_texto(date)\n    tabela = _recortar_tabela(texto)\n    linhas = _obter_linhas(tabela)\n    valores = _extrair_valores(linhas)\n    return _validar_valores(valores)\n</code></pre>"},{"location":"bday/","title":"Ferramentas de Dias \u00dateis","text":""},{"location":"bday/#pyield.bday.count","title":"<code>count(start, end)</code>","text":"<p>Conta dias \u00fateis entre <code>start</code> (inclusivo) e <code>end</code> (exclusivo).</p> <p>Considera feriados brasileiros com sele\u00e7\u00e3o de regime de feriados por elemento.</p> <p>PRESERVA\u00c7\u00c3O DE ORDEM (cr\u00edtico): A ordem de sa\u00edda SEMPRE corresponde \u00e0 ordem elemento a elemento das entradas originais. Nenhuma ordena\u00e7\u00e3o, deduplica\u00e7\u00e3o, alinhamento ou remodela\u00e7\u00e3o \u00e9 realizada. Se voc\u00ea passar arrays, o i-\u00e9simo resultado corresponde ao i-\u00e9simo par de (<code>start</code>, <code>end</code>) ap\u00f3s expans\u00e3o. Isso garante atribui\u00e7\u00e3o segura de volta ao DataFrame de origem.</p> <p>Regime de feriados: Para cada valor de <code>start</code>, a lista de feriados (antiga vs. nova) \u00e9 escolhida com base na data de transi\u00e7\u00e3o 2023-12-26 (<code>DATA_TRANSICAO</code>). Datas de in\u00edcio antes da transi\u00e7\u00e3o usam a lista antiga; datas na transi\u00e7\u00e3o ou ap\u00f3s usam a lista nova.</p> <p>Propaga\u00e7\u00e3o de nulos: Se qualquer argumento escalar for nulo, retorna <code>None</code>. Nulos dentro de arrays de entrada produzem nulos nas posi\u00e7\u00f5es correspondentes do resultado.</p> <p>Tipo de retorno: Se ambas as entradas forem escalares (n\u00e3o-nulos), um <code>int</code> \u00e9 retornado; caso contr\u00e1rio, uma <code>polars.Series</code> de contagens inteiras (nome: 'bday_count'). Se um escalar nulo causar curto-circuito, <code>None</code> \u00e9 retornado.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>None | DateLike | ArrayLike</code> <p>Data \u00fanica ou cole\u00e7\u00e3o (limite inclusivo).</p> required <code>end</code> <code>None | DateLike | ArrayLike</code> <p>Data \u00fanica ou cole\u00e7\u00e3o (limite exclusivo).</p> required <p>Returns:</p> Type Description <code>None | int | Series</code> <p>Inteiro ou <code>None</code> se <code>start</code> e <code>end</code> forem datas \u00fanicas, ou Series</p> <code>None | int | Series</code> <p>se qualquer um deles for um array de datas.</p> Notes <ul> <li>Esta fun\u00e7\u00e3o \u00e9 um encapsulamento de <code>polars.business_day_count</code>.</li> <li>A lista de feriados \u00e9 determinada por linha com base na data <code>start</code>.</li> <li>Strings de data aceitas: <code>DD-MM-YYYY</code>, <code>DD/MM/YYYY</code> e <code>YYYY-MM-DD</code>.</li> <li>Strings inv\u00e1lidas s\u00e3o tratadas como <code>null</code> e propagadas ao resultado.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n10\n</code></pre> <p>Total de dias \u00fateis em janeiro e fevereiro desde o in\u00edcio do ano:</p> <pre><code>&gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\nshape: (2,)\nSeries: 'bday_count' [i64]\n[\n    22\n    41\n]\n</code></pre> <p>Dias \u00fateis restantes de janeiro/fevereiro at\u00e9 o fim do ano:</p> <pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\nshape: (2,)\nSeries: 'bday_count' [i64]\n[\n    253\n    231\n]\n</code></pre> <p>Total de dias \u00fateis em janeiro e fevereiro de 2024:</p> <pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\nshape: (2,)\nSeries: 'bday_count' [i64]\n[\n    22\n    19\n]\n</code></pre> <p>Valores nulos s\u00e3o propagados:</p> <pre><code>&gt;&gt;&gt; bday.count(None, \"01-01-2024\")  # None em start\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"01-01-2024\", None)  # None em end\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"01-01-2024\", [\"01-02-2024\", None])  # None dentro do array\nshape: (2,)\nSeries: 'bday_count' [i64]\n[\n    22\n    null\n]\n</code></pre> <pre><code>&gt;&gt;&gt; start_dates = [\"01-01-2024\", \"01-02-2024\", \"01-03-2024\"]\n&gt;&gt;&gt; bday.count(start_dates, \"01-01-2025\")\nshape: (3,)\nSeries: 'bday_count' [i64]\n[\n    253\n    231\n    212\n]\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def count(\n    start: None | DateLike | ArrayLike,\n    end: None | DateLike | ArrayLike,\n) -&gt; None | int | pl.Series:\n    \"\"\"Conta dias \u00fateis entre ``start`` (inclusivo) e ``end`` (exclusivo).\n\n    Considera feriados brasileiros com sele\u00e7\u00e3o de regime de feriados por elemento.\n\n    PRESERVA\u00c7\u00c3O DE ORDEM (cr\u00edtico): A ordem de sa\u00edda SEMPRE corresponde \u00e0 ordem\n    elemento a elemento das entradas originais. Nenhuma ordena\u00e7\u00e3o, deduplica\u00e7\u00e3o,\n    alinhamento ou remodela\u00e7\u00e3o \u00e9 realizada. Se voc\u00ea passar arrays, o i-\u00e9simo\n    resultado corresponde ao i-\u00e9simo par de (``start``, ``end``) ap\u00f3s expans\u00e3o.\n    Isso garante atribui\u00e7\u00e3o segura de volta ao DataFrame de origem.\n\n    Regime de feriados: Para cada valor de ``start``, a lista de feriados (antiga vs.\n    nova) \u00e9 escolhida com base na data de transi\u00e7\u00e3o 2023-12-26 (``DATA_TRANSICAO``).\n    Datas de in\u00edcio antes da transi\u00e7\u00e3o usam a lista antiga; datas na transi\u00e7\u00e3o ou\n    ap\u00f3s usam a lista nova.\n\n    Propaga\u00e7\u00e3o de nulos: Se qualquer argumento escalar for nulo, retorna ``None``.\n    Nulos dentro de arrays de entrada produzem nulos nas posi\u00e7\u00f5es correspondentes\n    do resultado.\n\n    Tipo de retorno: Se ambas as entradas forem escalares (n\u00e3o-nulos), um ``int``\n    \u00e9 retornado; caso contr\u00e1rio, uma ``polars.Series`` de contagens inteiras\n    (nome: 'bday_count'). Se um escalar nulo causar curto-circuito, ``None`` \u00e9\n    retornado.\n\n    Args:\n        start: Data \u00fanica ou cole\u00e7\u00e3o (limite inclusivo).\n        end: Data \u00fanica ou cole\u00e7\u00e3o (limite exclusivo).\n\n    Returns:\n        Inteiro ou ``None`` se ``start`` e ``end`` forem datas \u00fanicas, ou Series\n        se qualquer um deles for um array de datas.\n\n    Notes:\n        - Esta fun\u00e7\u00e3o \u00e9 um encapsulamento de ``polars.business_day_count``.\n        - A lista de feriados \u00e9 determinada por linha com base na data ``start``.\n        - Strings de data aceitas: ``DD-MM-YYYY``, ``DD/MM/YYYY`` e ``YYYY-MM-DD``.\n        - Strings inv\u00e1lidas s\u00e3o tratadas como ``null`` e propagadas ao resultado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n        10\n\n        Total de dias \u00fateis em janeiro e fevereiro desde o in\u00edcio do ano:\n        &gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n        shape: (2,)\n        Series: 'bday_count' [i64]\n        [\n            22\n            41\n        ]\n\n        Dias \u00fateis restantes de janeiro/fevereiro at\u00e9 o fim do ano:\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n        shape: (2,)\n        Series: 'bday_count' [i64]\n        [\n            253\n            231\n        ]\n\n        Total de dias \u00fateis em janeiro e fevereiro de 2024:\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n        shape: (2,)\n        Series: 'bday_count' [i64]\n        [\n            22\n            19\n        ]\n\n        Valores nulos s\u00e3o propagados:\n        &gt;&gt;&gt; bday.count(None, \"01-01-2024\")  # None em start\n\n        &gt;&gt;&gt; bday.count(\"01-01-2024\", None)  # None em end\n\n        &gt;&gt;&gt; bday.count(\"01-01-2024\", [\"01-02-2024\", None])  # None dentro do array\n        shape: (2,)\n        Series: 'bday_count' [i64]\n        [\n            22\n            null\n        ]\n\n        &gt;&gt;&gt; start_dates = [\"01-01-2024\", \"01-02-2024\", \"01-03-2024\"]\n        &gt;&gt;&gt; bday.count(start_dates, \"01-01-2025\")\n        shape: (3,)\n        Series: 'bday_count' [i64]\n        [\n            253\n            231\n            212\n        ]\n    \"\"\"\n    s = (\n        pl.DataFrame(\n            data={\"start\": start, \"end\": end},\n            nan_to_null=True,\n        )\n        .select(bday_count=count_expr(\"start\", \"end\"))\n        .get_column(\"bday_count\")\n    )\n\n    if not tp.any_is_collection(start, end):\n        return s.item()\n\n    return s\n</code></pre>"},{"location":"bday/#pyield.bday.count_expr","title":"<code>count_expr(start, end)</code>","text":"<p>Cria uma express\u00e3o Polars para contar dias \u00fateis (com suporte a LazyFrame).</p> <p>Esta fun\u00e7\u00e3o foi projetada para ser usada dentro de contextos do Polars, como <code>df.select()</code>, <code>df.with_columns()</code> ou <code>df.filter()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Expr | str | date</code> <p>Nome da coluna, express\u00e3o Polars ou data literal.</p> required <code>end</code> <code>Expr | str | date</code> <p>Nome da coluna, express\u00e3o Polars ou data literal.</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>Uma <code>pl.Expr</code> que resulta em Int64.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pyield.bday import count_expr\n&gt;&gt;&gt; start = [dt.date(2024, 1, 1), dt.date(2024, 2, 9)]\n&gt;&gt;&gt; end = [dt.date(2024, 1, 5), dt.date(2024, 2, 12)]\n&gt;&gt;&gt; df = pl.DataFrame({\"start\": start, \"end\": end})\n&gt;&gt;&gt; df.select(count_expr(\"start\", \"end\").alias(\"bdays\"))\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 bdays \u2502\n\u2502 ---   \u2502\n\u2502 i64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3     \u2502\n\u2502 1     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Uso com literais (ex: contar dias at\u00e9 o fim do ano):</p> <pre><code>&gt;&gt;&gt; df.select(bdays=count_expr(\"start\", dt.date(2024, 12, 31)))\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 bdays \u2502\n\u2502 ---   \u2502\n\u2502 i64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 252   \u2502\n\u2502 224   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def count_expr(start: pl.Expr | str | dt.date, end: pl.Expr | str | dt.date) -&gt; pl.Expr:\n    \"\"\"Cria uma express\u00e3o Polars para contar dias \u00fateis (com suporte a LazyFrame).\n\n    Esta fun\u00e7\u00e3o foi projetada para ser usada dentro de contextos do Polars,\n    como ``df.select()``, ``df.with_columns()`` ou ``df.filter()``.\n\n    Args:\n        start: Nome da coluna, express\u00e3o Polars ou data literal.\n        end: Nome da coluna, express\u00e3o Polars ou data literal.\n\n    Returns:\n        Uma ``pl.Expr`` que resulta em Int64.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from pyield.bday import count_expr\n        &gt;&gt;&gt; start = [dt.date(2024, 1, 1), dt.date(2024, 2, 9)]\n        &gt;&gt;&gt; end = [dt.date(2024, 1, 5), dt.date(2024, 2, 12)]\n        &gt;&gt;&gt; df = pl.DataFrame({\"start\": start, \"end\": end})\n        &gt;&gt;&gt; df.select(count_expr(\"start\", \"end\").alias(\"bdays\"))\n        shape: (2, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 bdays \u2502\n        \u2502 ---   \u2502\n        \u2502 i64   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 3     \u2502\n        \u2502 1     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        Uso com literais (ex: contar dias at\u00e9 o fim do ano):\n        &gt;&gt;&gt; df.select(bdays=count_expr(\"start\", dt.date(2024, 12, 31)))\n        shape: (2, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 bdays \u2502\n        \u2502 ---   \u2502\n        \u2502 i64   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 252   \u2502\n        \u2502 224   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if isinstance(start, dt.date):\n        start_date = pl.lit(start)\n    else:\n        start_date = cv.converter_datas_expr(start)\n\n    if isinstance(end, dt.date):\n        end_date = pl.lit(end)\n    else:\n        end_date = cv.converter_datas_expr(end)\n\n    return (\n        pl.when(start_date &lt; DATA_TRANSICAO)\n        .then(\n            pl.business_day_count(\n                start=start_date, end=end_date, holidays=FERIADOS_ANTIGOS\n            )\n        )\n        .otherwise(\n            pl.business_day_count(\n                start=start_date, end=end_date, holidays=FERIADOS_NOVOS\n            )\n        )\n        .cast(pl.Int64)\n    )\n</code></pre>"},{"location":"bday/#pyield.bday.generate","title":"<code>generate(start=None, end=None, closed='both', holiday_option='new')</code>","text":"<p>Gera uma Series de dias \u00fateis entre <code>start</code> e <code>end</code>.</p> <p>Considera a lista de feriados brasileiros.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike | None</code> <p>Data inicial. Se None, usa a data atual.</p> <code>None</code> <code>end</code> <code>DateLike | None</code> <p>Data final. Se None, usa a data atual.</p> <code>None</code> <code>closed</code> <code>Literal['both', 'left', 'right', 'none']</code> <p>Define quais lados do intervalo s\u00e3o fechados (inclusivos). Op\u00e7\u00f5es v\u00e1lidas: 'both', 'left', 'right', 'none'. Padr\u00e3o: 'both'.</p> <code>'both'</code> <code>holiday_option</code> <code>Literal['old', 'new', 'infer']</code> <p>Especifica a lista de feriados a considerar. Padr\u00e3o: \"new\". - 'old': Usa a lista de feriados vigente antes de 2023-12-26. - 'new': Usa a lista de feriados vigente a partir de 2023-12-26. - 'infer': Seleciona com base na data <code>start</code> relativa \u00e0 transi\u00e7\u00e3o.</p> <code>'new'</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series de dias \u00fateis (nome: 'bday').</p> Notes <ul> <li>Strings de data aceitas: <code>DD-MM-YYYY</code>, <code>DD/MM/YYYY</code> e <code>YYYY-MM-DD</code>.</li> <li><code>start</code> e <code>end</code> nulos usam a data atual.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\nshape: (6,)\nSeries: 'bday' [date]\n[\n    2023-12-22\n    2023-12-26\n    2023-12-27\n    2023-12-28\n    2023-12-29\n    2024-01-02\n]\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def generate(\n    start: DateLike | None = None,\n    end: DateLike | None = None,\n    closed: Literal[\"both\", \"left\", \"right\", \"none\"] = \"both\",\n    holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"new\",\n) -&gt; pl.Series:\n    \"\"\"Gera uma Series de dias \u00fateis entre ``start`` e ``end``.\n\n    Considera a lista de feriados brasileiros.\n\n    Args:\n        start: Data inicial. Se None, usa a data atual.\n        end: Data final. Se None, usa a data atual.\n        closed: Define quais lados do intervalo s\u00e3o fechados (inclusivos).\n            Op\u00e7\u00f5es v\u00e1lidas: 'both', 'left', 'right', 'none'. Padr\u00e3o: 'both'.\n        holiday_option: Especifica a lista de feriados a considerar. Padr\u00e3o: \"new\".\n            - 'old': Usa a lista de feriados vigente antes de 2023-12-26.\n            - 'new': Usa a lista de feriados vigente a partir de 2023-12-26.\n            - 'infer': Seleciona com base na data ``start`` relativa \u00e0 transi\u00e7\u00e3o.\n\n    Returns:\n        Series de dias \u00fateis (nome: 'bday').\n\n    Notes:\n        - Strings de data aceitas: ``DD-MM-YYYY``, ``DD/MM/YYYY`` e ``YYYY-MM-DD``.\n        - ``start`` e ``end`` nulos usam a data atual.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n        shape: (6,)\n        Series: 'bday' [date]\n        [\n            2023-12-22\n            2023-12-26\n            2023-12-27\n            2023-12-28\n            2023-12-29\n            2024-01-02\n        ]\n    \"\"\"\n    today = clock.today()\n    conv_start = cv.converter_datas(start) or today\n    conv_end = cv.converter_datas(end) or today\n\n    # Gera range completo de datas\n    s = pl.date_range(conv_start, conv_end, closed=closed, eager=True).alias(\"bday\")\n\n    # Pega feriados aplic\u00e1veis\n    feriados = feriados_br.obter_feriados(\n        datas=conv_start, opcao_feriado=holiday_option\n    )\n\n    # Filtra: s\u00f3 dias \u00fateis (seg-sex e n\u00e3o feriado)\n    return s.filter((s.dt.weekday() &lt; LIMITE_DIA_UTIL) &amp; (~s.is_in(feriados)))\n</code></pre>"},{"location":"bday/#pyield.bday.is_business_day","title":"<code>is_business_day(dates)</code>","text":"<p>Determina se data(s) s\u00e3o dias \u00fateis brasileiros.</p> <p>REGIME DE FERIADOS POR LINHA: Para CADA data de entrada, a lista de feriados apropriada (\"antiga\" vs. \"nova\") \u00e9 selecionada comparando com a data de transi\u00e7\u00e3o 2023-12-26 (<code>DATA_TRANSICAO</code>). Datas estritamente antes da transi\u00e7\u00e3o usam a lista antiga; datas na transi\u00e7\u00e3o ou ap\u00f3s usam a lista nova. Isso espelha o comportamento de <code>count</code> e <code>offset</code> que aplicam a l\u00f3gica de regime elemento a elemento.</p> <p>PRESERVA\u00c7\u00c3O DE ORDEM E FORMA: A sa\u00edda preserva a ordem original dos elementos. Nenhuma ordena\u00e7\u00e3o, deduplica\u00e7\u00e3o, remodela\u00e7\u00e3o ou alinhamento \u00e9 realizado; o i-\u00e9simo resultado corresponde \u00e0 i-\u00e9sima data fornecida ap\u00f3s expans\u00e3o (se alguma expans\u00e3o ocorreu de uma entrada escalar em outro lugar da cadeia de chamadas).</p> <p>PROPAGA\u00c7\u00c3O DE NULOS: Um argumento escalar nulo faz curto-circuito para <code>None</code>. Valores nulos dentro de entradas array-like produzem nulos nas posi\u00e7\u00f5es correspondentes da sa\u00edda.</p> <p>TIPO DE RETORNO: Se a entrada (n\u00e3o-nula) resolve para um \u00fanico elemento, um <code>bool</code> Python \u00e9 retornado. Se esse \u00fanico elemento for nulo, <code>None</code> \u00e9 retornado. Caso contr\u00e1rio, uma <code>polars.Series</code> de booleanos nomeada <code>'is_bday'</code> \u00e9 produzida.</p> <p>FINS DE SEMANA: S\u00e1bados e domingos nunca s\u00e3o dias \u00fateis independentemente do regime de feriados.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>None | DateLike | ArrayLike</code> <p>Data \u00fanica ou cole\u00e7\u00e3o (list/tuple/ndarray/Polars/Pandas Series). Pode incluir nulos que propagam. Entrada escalar nula retorna <code>None</code>.</p> required <p>Returns:</p> Type Description <code>None | bool | Series</code> <p><code>True</code> se for dia \u00fatil, <code>False</code> caso contr\u00e1rio para entrada escalar;</p> <code>None | bool | Series</code> <p><code>None</code> para entrada escalar nula; ou uma Series Polars de booleanos</p> <code>None | bool | Series</code> <p>(nome: <code>'is_bday'</code>) para entradas de array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Natal (calend\u00e1rio antigo)\nFalse\n&gt;&gt;&gt; bday.is_business_day(\"20-11-2024\")  # Dia Nacional de Zumbi (novo feriado)\nFalse\n&gt;&gt;&gt; bday.is_business_day([\"22-12-2023\", \"26-12-2023\"])  # Per\u00edodos mistos\nshape: (2,)\nSeries: 'is_bday' [bool]\n[\n    true\n    true\n]\n</code></pre> Notes <ul> <li>Data de transi\u00e7\u00e3o definida em <code>DATA_TRANSICAO</code>.</li> <li>Espelha a l\u00f3gica por linha usada em <code>count</code> e <code>offset</code>.</li> <li>Fins de semana sempre avaliam como <code>False</code>.</li> <li>Elementos nulos propagam.</li> <li>Strings de data aceitas: <code>DD-MM-YYYY</code>, <code>DD/MM/YYYY</code> e <code>YYYY-MM-DD</code>.</li> <li>Strings inv\u00e1lidas s\u00e3o tratadas como <code>null</code> e propagadas ao resultado.</li> </ul> Source code in <code>pyield/bday/core.py</code> <pre><code>def is_business_day(dates: None | DateLike | ArrayLike) -&gt; None | bool | pl.Series:\n    \"\"\"Determina se data(s) s\u00e3o dias \u00fateis brasileiros.\n\n    REGIME DE FERIADOS POR LINHA: Para CADA data de entrada, a lista de feriados\n    apropriada (\"antiga\" vs. \"nova\") \u00e9 selecionada comparando com a data de\n    transi\u00e7\u00e3o 2023-12-26 (``DATA_TRANSICAO``). Datas estritamente antes da\n    transi\u00e7\u00e3o usam a lista antiga; datas na transi\u00e7\u00e3o ou ap\u00f3s usam a lista nova.\n    Isso espelha o comportamento de ``count`` e ``offset`` que aplicam a l\u00f3gica\n    de regime elemento a elemento.\n\n    PRESERVA\u00c7\u00c3O DE ORDEM E FORMA: A sa\u00edda preserva a ordem original dos elementos.\n    Nenhuma ordena\u00e7\u00e3o, deduplica\u00e7\u00e3o, remodela\u00e7\u00e3o ou alinhamento \u00e9 realizado; o\n    i-\u00e9simo resultado corresponde \u00e0 i-\u00e9sima data fornecida ap\u00f3s expans\u00e3o (se\n    alguma expans\u00e3o ocorreu de uma entrada escalar em outro lugar da cadeia\n    de chamadas).\n\n    PROPAGA\u00c7\u00c3O DE NULOS: Um argumento escalar nulo faz curto-circuito para ``None``.\n    Valores nulos dentro de entradas array-like produzem nulos nas posi\u00e7\u00f5es\n    correspondentes da sa\u00edda.\n\n    TIPO DE RETORNO: Se a entrada (n\u00e3o-nula) resolve para um \u00fanico elemento, um\n    ``bool`` Python \u00e9 retornado. Se esse \u00fanico elemento for nulo, ``None`` \u00e9\n    retornado. Caso contr\u00e1rio, uma ``polars.Series`` de booleanos nomeada\n    ``'is_bday'`` \u00e9 produzida.\n\n    FINS DE SEMANA: S\u00e1bados e domingos nunca s\u00e3o dias \u00fateis independentemente do\n    regime de feriados.\n\n    Args:\n        dates: Data \u00fanica ou cole\u00e7\u00e3o (list/tuple/ndarray/Polars/Pandas Series).\n            Pode incluir nulos que propagam. Entrada escalar nula retorna ``None``.\n\n    Returns:\n        ``True`` se for dia \u00fatil, ``False`` caso contr\u00e1rio para entrada escalar;\n        ``None`` para entrada escalar nula; ou uma Series Polars de booleanos\n        (nome: ``'is_bday'``) para entradas de array.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Natal (calend\u00e1rio antigo)\n        False\n        &gt;&gt;&gt; bday.is_business_day(\"20-11-2024\")  # Dia Nacional de Zumbi (novo feriado)\n        False\n        &gt;&gt;&gt; bday.is_business_day([\"22-12-2023\", \"26-12-2023\"])  # Per\u00edodos mistos\n        shape: (2,)\n        Series: 'is_bday' [bool]\n        [\n            true\n            true\n        ]\n\n    Notes:\n        - Data de transi\u00e7\u00e3o definida em ``DATA_TRANSICAO``.\n        - Espelha a l\u00f3gica por linha usada em ``count`` e ``offset``.\n        - Fins de semana sempre avaliam como ``False``.\n        - Elementos nulos propagam.\n        - Strings de data aceitas: ``DD-MM-YYYY``, ``DD/MM/YYYY`` e ``YYYY-MM-DD``.\n        - Strings inv\u00e1lidas s\u00e3o tratadas como ``null`` e propagadas ao resultado.\n    \"\"\"\n    s = (\n        pl.DataFrame({\"dates\": dates}, nan_to_null=True)\n        .select(is_bday=is_business_day_expr(\"dates\"))\n        .get_column(\"is_bday\")\n    )\n\n    if not tp.any_is_collection(dates):\n        return s.item()\n\n    return s\n</code></pre>"},{"location":"bday/#pyield.bday.is_business_day_expr","title":"<code>is_business_day_expr(expr)</code>","text":"<p>Cria express\u00e3o Polars para verificar se \u00e9 dia \u00fatil (True/False).</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr | str</code> <p>Coluna de datas ou express\u00e3o Polars.</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>Uma <code>pl.Expr</code> booleana.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pyield.bday import is_business_day_expr\n&gt;&gt;&gt; datas = [dt.date(2023, 12, 25), dt.date(2023, 12, 26)]\n&gt;&gt;&gt; df = pl.DataFrame({\"data\": datas})\n</code></pre> <p>Criando uma flag booleana:</p> <pre><code>&gt;&gt;&gt; df.with_columns(is_bd=is_business_day_expr(\"data\"))\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 data       \u2506 is_bd \u2502\n\u2502 ---        \u2506 ---   \u2502\n\u2502 date       \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2023-12-25 \u2506 false \u2502\n\u2502 2023-12-26 \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Usando para filtrar apenas dias \u00fateis:</p> <pre><code>&gt;&gt;&gt; df.filter(is_business_day_expr(\"data\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 data       \u2502\n\u2502 ---        \u2502\n\u2502 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2023-12-26 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def is_business_day_expr(expr: pl.Expr | str) -&gt; pl.Expr:\n    \"\"\"Cria express\u00e3o Polars para verificar se \u00e9 dia \u00fatil (True/False).\n\n    Args:\n        expr: Coluna de datas ou express\u00e3o Polars.\n\n    Returns:\n        Uma ``pl.Expr`` booleana.\n\n    Examples:\n        &gt;&gt;&gt; import datetime as dt\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from pyield.bday import is_business_day_expr\n        &gt;&gt;&gt; datas = [dt.date(2023, 12, 25), dt.date(2023, 12, 26)]\n        &gt;&gt;&gt; df = pl.DataFrame({\"data\": datas})\n\n        Criando uma flag booleana:\n        &gt;&gt;&gt; df.with_columns(is_bd=is_business_day_expr(\"data\"))\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 data       \u2506 is_bd \u2502\n        \u2502 ---        \u2506 ---   \u2502\n        \u2502 date       \u2506 bool  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2023-12-25 \u2506 false \u2502\n        \u2502 2023-12-26 \u2506 true  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        Usando para filtrar apenas dias \u00fateis:\n        &gt;&gt;&gt; df.filter(is_business_day_expr(\"data\"))\n        shape: (1, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 data       \u2502\n        \u2502 ---        \u2502\n        \u2502 date       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2023-12-26 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    expr_date = cv.converter_datas_expr(expr)\n\n    return (\n        pl.when(expr_date &lt; DATA_TRANSICAO)\n        .then(expr_date.dt.is_business_day(holidays=FERIADOS_ANTIGOS))\n        .otherwise(expr_date.dt.is_business_day(holidays=FERIADOS_NOVOS))\n    )\n</code></pre>"},{"location":"bday/#pyield.bday.last_business_day","title":"<code>last_business_day()</code>","text":"<p>Retorna o \u00faltimo dia \u00fatil no Brasil.</p> <p>Se a data atual for um dia \u00fatil, retorna a data atual. Se for fim de semana ou feriado, retorna o \u00faltimo dia \u00fatil antes da data atual.</p> <p>Returns:</p> Type Description <code>date</code> <p>O \u00faltimo dia \u00fatil no Brasil.</p> Notes <ul> <li>A determina\u00e7\u00e3o do \u00faltimo dia \u00fatil considera a lista de feriados brasileiros   correta (antes ou depois da transi\u00e7\u00e3o 2023-12-26) aplic\u00e1vel \u00e0 data atual.</li> </ul> Source code in <code>pyield/bday/core.py</code> <pre><code>def last_business_day() -&gt; dt.date:\n    \"\"\"Retorna o \u00faltimo dia \u00fatil no Brasil.\n\n    Se a data atual for um dia \u00fatil, retorna a data atual. Se for fim de semana\n    ou feriado, retorna o \u00faltimo dia \u00fatil antes da data atual.\n\n    Returns:\n        O \u00faltimo dia \u00fatil no Brasil.\n\n    Notes:\n        - A determina\u00e7\u00e3o do \u00faltimo dia \u00fatil considera a lista de feriados brasileiros\n          correta (antes ou depois da transi\u00e7\u00e3o 2023-12-26) aplic\u00e1vel \u00e0 data atual.\n    \"\"\"\n    # Obt\u00e9m a data atual do Brasil sem informa\u00e7\u00e3o de fuso hor\u00e1rio\n    bz_today = clock.today()\n    result = offset(bz_today, 0, roll=\"backward\")\n    assert isinstance(result, dt.date), (\n        \"Premissa violada: offset n\u00e3o retornou uma data para a data atual.\"\n    )\n    return result\n</code></pre>"},{"location":"bday/#pyield.bday.offset","title":"<code>offset(dates, offset, roll='forward')</code>","text":"<p>Desloca data(s) por um n\u00famero de dias \u00fateis com regime de feriados brasileiro.</p> <p>A opera\u00e7\u00e3o \u00e9 realizada em duas etapas por elemento: 1) ROLL: Se a data original cair em fim de semana ou feriado, move-a de acordo    com <code>roll</code> (\"forward\" -&gt; pr\u00f3ximo dia \u00fatil; \"backward\" -&gt; anterior). 2) ADD: Aplica o <code>offset</code> de dias \u00fateis com sinal (positivo avan\u00e7a, negativo    retrocede, zero = permanece na data ap\u00f3s roll).</p> <p>PRESERVA\u00c7\u00c3O DE ORDEM (cr\u00edtico): A ordena\u00e7\u00e3o de sa\u00edda corresponde estritamente ao pareamento elemento a elemento ap\u00f3s expans\u00e3o entre <code>dates</code> e <code>offset</code>. Nenhuma ordena\u00e7\u00e3o, deduplica\u00e7\u00e3o ou mudan\u00e7a de forma ocorre. O i-\u00e9simo resultado corresponde ao i-\u00e9simo par (date, offset), permitindo atribui\u00e7\u00e3o segura de volta ao DataFrame de origem.</p> <p>Regime de feriados: Para CADA data, a lista de feriados apropriada (antiga vs. nova) \u00e9 escolhida com base na data de transi\u00e7\u00e3o 2023-12-26 (<code>DATA_TRANSICAO</code>). Datas antes da transi\u00e7\u00e3o usam a lista antiga; datas na transi\u00e7\u00e3o ou ap\u00f3s usam a lista nova.</p> <p>Sem\u00e2ntica do roll: <code>roll</code> s\u00f3 atua quando a data original n\u00e3o \u00e9 um dia \u00fatil sob seu regime. Ap\u00f3s o roll, a adi\u00e7\u00e3o de dias \u00fateis subsequente \u00e9 aplicada a partir dessa \u00e2ncora. Um <code>offset</code> de 0 portanto retorna ou a data original (se j\u00e1 for dia \u00fatil) ou o dia \u00fatil ap\u00f3s roll.</p> <p>Propaga\u00e7\u00e3o de nulos: Se qualquer argumento escalar for nulo, a fun\u00e7\u00e3o faz curto-circuito para <code>None</code>. Nulos dentro de arrays de entrada propagam para suas posi\u00e7\u00f5es correspondentes na sa\u00edda.</p> <p>Expans\u00e3o: <code>dates</code> e <code>offset</code> podem ser escalares ou array-like. Regras padr\u00e3o de expans\u00e3o do Polars aplicam-se ao construir os pares por linha.</p> <p>Tipo de retorno: Se ambas as entradas forem escalares n\u00e3o-nulos, um <code>datetime.date</code> \u00e9 retornado. Caso contr\u00e1rio, uma <code>polars.Series</code> de datas nomeada <code>'adjusted_date'</code> \u00e9 produzida. Entradas escalares nulas resultam em <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateLike | ArrayLike | None</code> <p>Data \u00fanica ou cole\u00e7\u00e3o de datas a serem ajustadas (roll, se necess\u00e1rio) e ent\u00e3o deslocadas. Cada data seleciona independentemente o regime de feriados.</p> required <code>offset</code> <code>int | ArrayLike | None</code> <p>Contagem com sinal de dias \u00fateis a aplicar ap\u00f3s o roll. Positivo move para frente, negativo para tr\u00e1s, zero mant\u00e9m a \u00e2ncora ap\u00f3s roll.</p> required <code>roll</code> <code>Literal['forward', 'backward']</code> <p>Dire\u00e7\u00e3o para ajustar uma data inicial n\u00e3o-\u00fatil (\"forward\" ou \"backward\"). Padr\u00e3o \u00e9 \"forward\".</p> <code>'forward'</code> <p>Returns:</p> Type Description <code>date | Series | None</code> <p>Um <code>date</code> Python para entradas escalares, uma Series Polars de datas para</p> <code>date | Series | None</code> <p>qualquer entrada de array, ou <code>None</code> se um argumento escalar nulo foi</p> <code>date | Series | None</code> <p>fornecido.</p> Notes <ul> <li>Encapsulamento de <code>polars.Expr.dt.add_business_days</code> aplicado   condicionalmente.</li> <li>O regime de feriados \u00e9 decidido por elemento comparando com   <code>DATA_TRANSICAO</code>.</li> <li>Fins de semana s\u00e3o sempre tratados como n\u00e3o-\u00fateis.</li> <li>Strings de data aceitas: <code>DD-MM-YYYY</code>, <code>DD/MM/YYYY</code> e <code>YYYY-MM-DD</code>.</li> <li>Strings inv\u00e1lidas s\u00e3o tratadas como <code>null</code> e propagadas ao resultado.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n</code></pre> <p>Desloca s\u00e1bado antes do Natal para o pr\u00f3ximo dia \u00fatil (ter\u00e7a ap\u00f3s Natal):</p> <pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\ndatetime.date(2023, 12, 26)\n</code></pre> <p>Desloca sexta antes do Natal (sem deslocamento pois \u00e9 dia \u00fatil):</p> <pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Desloca para o dia \u00fatil anterior se n\u00e3o for \u00fatil (offset=0 e roll=\"backward\"):</p> <p>Sem deslocamento pois \u00e9 dia \u00fatil:</p> <pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Desloca para o primeiro dia \u00fatil antes de \"23-12-2023\":</p> <pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\ndatetime.date(2023, 12, 22)\n</code></pre> <p>Avan\u00e7a para o pr\u00f3ximo dia \u00fatil (offset=1 e roll=\"forward\"):</p> <p>Desloca sexta para o pr\u00f3ximo dia \u00fatil (sexta \u00e9 pulada -&gt; segunda):</p> <pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\ndatetime.date(2024, 9, 30)\n</code></pre> <p>Desloca s\u00e1bado para o pr\u00f3ximo dia \u00fatil (segunda \u00e9 pulada -&gt; ter\u00e7a):</p> <pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\ndatetime.date(2024, 10, 1)\n</code></pre> <p>Volta para o dia \u00fatil anterior (offset=-1 e roll=\"backward\"):</p> <p>Desloca sexta para o dia \u00fatil anterior (sexta \u00e9 pulada -&gt; quinta):</p> <pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\ndatetime.date(2024, 9, 26)\n</code></pre> <p>Desloca s\u00e1bado para o dia \u00fatil anterior (sexta \u00e9 pulada -&gt; quinta):</p> <pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\ndatetime.date(2024, 9, 26)\n</code></pre> <p>Lista de datas e offsets:</p> <pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)\nshape: (2,)\nSeries: 'adjusted_date' [date]\n[\n    2024-09-20\n    2024-09-23\n]\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # lista de offsets\nshape: (2,)\nSeries: 'adjusted_date' [date]\n[\n    2024-09-20\n    2024-09-23\n]\n</code></pre> <p>Nulos escalares propagam para None:</p> <pre><code>&gt;&gt;&gt; print(bday.offset(None, 1))\nNone\n</code></pre> <p>Nulo escalar propaga dentro de arrays:</p> <pre><code>&gt;&gt;&gt; bday.offset(None, [1, 2])\nshape: (2,)\nSeries: 'adjusted_date' [date]\n[\n    null\n    null\n]\n</code></pre> <p>Nulos dentro de arrays s\u00e3o preservados:</p> <pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", None], 1)\nshape: (2,)\nSeries: 'adjusted_date' [date]\n[\n    2024-09-20\n    null\n]\n</code></pre> <pre><code>&gt;&gt;&gt; datas = [\"19-09-2024\", \"20-09-2024\", \"21-09-2024\"]\n&gt;&gt;&gt; bday.offset(datas, 1)\nshape: (3,)\nSeries: 'adjusted_date' [date]\n[\n    2024-09-20\n    2024-09-23\n    2024-09-24\n]\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def offset(\n    dates: DateLike | ArrayLike | None,\n    offset: int | ArrayLike | None,\n    roll: Literal[\"forward\", \"backward\"] = \"forward\",\n) -&gt; dt.date | pl.Series | None:\n    \"\"\"Desloca data(s) por um n\u00famero de dias \u00fateis com regime de feriados brasileiro.\n\n    A opera\u00e7\u00e3o \u00e9 realizada em duas etapas por elemento:\n    1) ROLL: Se a data original cair em fim de semana ou feriado, move-a de acordo\n       com ``roll`` (\"forward\" -&gt; pr\u00f3ximo dia \u00fatil; \"backward\" -&gt; anterior).\n    2) ADD: Aplica o ``offset`` de dias \u00fateis com sinal (positivo avan\u00e7a, negativo\n       retrocede, zero = permanece na data ap\u00f3s roll).\n\n    PRESERVA\u00c7\u00c3O DE ORDEM (cr\u00edtico): A ordena\u00e7\u00e3o de sa\u00edda corresponde estritamente\n    ao pareamento elemento a elemento ap\u00f3s expans\u00e3o entre ``dates`` e ``offset``.\n    Nenhuma ordena\u00e7\u00e3o, deduplica\u00e7\u00e3o ou mudan\u00e7a de forma ocorre. O i-\u00e9simo resultado\n    corresponde ao i-\u00e9simo par (date, offset), permitindo atribui\u00e7\u00e3o segura de volta\n    ao DataFrame de origem.\n\n    Regime de feriados: Para CADA data, a lista de feriados apropriada (antiga vs.\n    nova) \u00e9 escolhida com base na data de transi\u00e7\u00e3o 2023-12-26 (``DATA_TRANSICAO``).\n    Datas antes da transi\u00e7\u00e3o usam a lista *antiga*; datas na transi\u00e7\u00e3o ou ap\u00f3s\n    usam a lista *nova*.\n\n    Sem\u00e2ntica do roll: ``roll`` s\u00f3 atua quando a data original n\u00e3o \u00e9 um dia \u00fatil\n    sob seu regime. Ap\u00f3s o roll, a adi\u00e7\u00e3o de dias \u00fateis subsequente \u00e9 aplicada a\n    partir dessa \u00e2ncora. Um ``offset`` de 0 portanto retorna ou a data original\n    (se j\u00e1 for dia \u00fatil) ou o dia \u00fatil ap\u00f3s roll.\n\n    Propaga\u00e7\u00e3o de nulos: Se qualquer argumento escalar for nulo, a fun\u00e7\u00e3o faz\n    curto-circuito para ``None``. Nulos dentro de arrays de entrada propagam para\n    suas posi\u00e7\u00f5es correspondentes na sa\u00edda.\n\n    Expans\u00e3o: ``dates`` e ``offset`` podem ser escalares ou array-like. Regras\n    padr\u00e3o de expans\u00e3o do Polars aplicam-se ao construir os pares por linha.\n\n    Tipo de retorno: Se ambas as entradas forem escalares n\u00e3o-nulos, um\n    ``datetime.date`` \u00e9 retornado. Caso contr\u00e1rio, uma ``polars.Series`` de datas\n    nomeada ``'adjusted_date'`` \u00e9 produzida. Entradas escalares nulas resultam\n    em ``None``.\n\n    Args:\n        dates: Data \u00fanica ou cole\u00e7\u00e3o de datas a serem ajustadas (roll, se necess\u00e1rio)\n            e ent\u00e3o deslocadas. Cada data seleciona independentemente o regime de\n            feriados.\n        offset: Contagem com sinal de dias \u00fateis a aplicar ap\u00f3s o roll. Positivo\n            move para frente, negativo para tr\u00e1s, zero mant\u00e9m a \u00e2ncora ap\u00f3s roll.\n        roll: Dire\u00e7\u00e3o para ajustar uma data inicial n\u00e3o-\u00fatil (\"forward\" ou\n            \"backward\"). Padr\u00e3o \u00e9 \"forward\".\n\n    Returns:\n        Um ``date`` Python para entradas escalares, uma Series Polars de datas para\n        qualquer entrada de array, ou ``None`` se um argumento escalar nulo foi\n        fornecido.\n\n    Notes:\n        - Encapsulamento de ``polars.Expr.dt.add_business_days`` aplicado\n          condicionalmente.\n        - O regime de feriados \u00e9 decidido por elemento comparando com\n          ``DATA_TRANSICAO``.\n        - Fins de semana s\u00e3o sempre tratados como n\u00e3o-\u00fateis.\n        - Strings de data aceitas: ``DD-MM-YYYY``, ``DD/MM/YYYY`` e ``YYYY-MM-DD``.\n        - Strings inv\u00e1lidas s\u00e3o tratadas como ``null`` e propagadas ao resultado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n\n        Desloca s\u00e1bado antes do Natal para o pr\u00f3ximo dia \u00fatil (ter\u00e7a ap\u00f3s Natal):\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\n        datetime.date(2023, 12, 26)\n\n        Desloca sexta antes do Natal (sem deslocamento pois \u00e9 dia \u00fatil):\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\n        datetime.date(2023, 12, 22)\n\n        Desloca para o dia \u00fatil anterior se n\u00e3o for \u00fatil (offset=0 e roll=\"backward\"):\n\n        Sem deslocamento pois \u00e9 dia \u00fatil:\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\n        datetime.date(2023, 12, 22)\n\n        Desloca para o primeiro dia \u00fatil antes de \"23-12-2023\":\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\n        datetime.date(2023, 12, 22)\n\n        Avan\u00e7a para o pr\u00f3ximo dia \u00fatil (offset=1 e roll=\"forward\"):\n\n        Desloca sexta para o pr\u00f3ximo dia \u00fatil (sexta \u00e9 pulada -&gt; segunda):\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\n        datetime.date(2024, 9, 30)\n\n        Desloca s\u00e1bado para o pr\u00f3ximo dia \u00fatil (segunda \u00e9 pulada -&gt; ter\u00e7a):\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\n        datetime.date(2024, 10, 1)\n\n        Volta para o dia \u00fatil anterior (offset=-1 e roll=\"backward\"):\n\n        Desloca sexta para o dia \u00fatil anterior (sexta \u00e9 pulada -&gt; quinta):\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\n        datetime.date(2024, 9, 26)\n\n        Desloca s\u00e1bado para o dia \u00fatil anterior (sexta \u00e9 pulada -&gt; quinta):\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\n        datetime.date(2024, 9, 26)\n\n        Lista de datas e offsets:\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)\n        shape: (2,)\n        Series: 'adjusted_date' [date]\n        [\n            2024-09-20\n            2024-09-23\n        ]\n\n        &gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # lista de offsets\n        shape: (2,)\n        Series: 'adjusted_date' [date]\n        [\n            2024-09-20\n            2024-09-23\n        ]\n\n        Nulos escalares propagam para None:\n        &gt;&gt;&gt; print(bday.offset(None, 1))\n        None\n\n        Nulo escalar propaga dentro de arrays:\n        &gt;&gt;&gt; bday.offset(None, [1, 2])\n        shape: (2,)\n        Series: 'adjusted_date' [date]\n        [\n            null\n            null\n        ]\n\n        Nulos dentro de arrays s\u00e3o preservados:\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", None], 1)\n        shape: (2,)\n        Series: 'adjusted_date' [date]\n        [\n            2024-09-20\n            null\n        ]\n\n        &gt;&gt;&gt; datas = [\"19-09-2024\", \"20-09-2024\", \"21-09-2024\"]\n        &gt;&gt;&gt; bday.offset(datas, 1)\n        shape: (3,)\n        Series: 'adjusted_date' [date]\n        [\n            2024-09-20\n            2024-09-23\n            2024-09-24\n        ]\n    \"\"\"\n    s = (\n        pl.DataFrame(\n            data={\"dates\": dates, \"offset\": offset},\n            nan_to_null=True,\n        )\n        .select(adjusted_date=offset_expr(\"dates\", n=\"offset\", roll=roll))\n        .get_column(\"adjusted_date\")\n    )\n\n    if not tp.any_is_collection(dates, offset):\n        return s.item()\n\n    return s\n</code></pre>"},{"location":"bday/#pyield.bday.offset_expr","title":"<code>offset_expr(expr, n, roll='forward')</code>","text":"<p>Cria uma express\u00e3o Polars para somar dias \u00fateis.</p> <p>Ideal para opera\u00e7\u00f5es vetorizadas em DataFrames ou LazyFrames.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr | str</code> <p>Coluna de data original.</p> required <code>n</code> <code>int | Expr | str</code> <p>N\u00famero de dias \u00fateis a somar. Pode ser um inteiro fixo ou outra coluna.</p> required <code>roll</code> <code>Literal['forward', 'backward']</code> <p>Como tratar a data inicial se ela cair em fim de semana/feriado.</p> <code>'forward'</code> <p>Returns:</p> Type Description <code>Expr</code> <p>Uma <code>pl.Expr</code> que resulta em Date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pyield.bday import offset_expr\n&gt;&gt;&gt; datas = [dt.date(2023, 12, 22), dt.date(2023, 12, 29)]\n&gt;&gt;&gt; offsets = [1, 5]\n&gt;&gt;&gt; df = pl.DataFrame({\"dt\": datas, \"n\": offsets})\n</code></pre> <p>Adicionando um valor fixo (1 dia \u00fatil):</p> <pre><code>&gt;&gt;&gt; df.select(offset_expr(\"dt\", 1).alias(\"t_plus_1\"))\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 t_plus_1   \u2502\n\u2502 ---        \u2502\n\u2502 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2023-12-26 \u2502\n\u2502 2024-01-02 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Adicionando uma coluna din\u00e2mica (prazo vari\u00e1vel por linha):</p> <pre><code>&gt;&gt;&gt; df.select(offset_expr(\"dt\", \"n\").alias(\"vencimento\"))\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vencimento \u2502\n\u2502 ---        \u2502\n\u2502 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2023-12-26 \u2502\n\u2502 2024-01-08 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/bday/core.py</code> <pre><code>def offset_expr(\n    expr: pl.Expr | str,\n    n: int | pl.Expr | str,\n    roll: Literal[\"forward\", \"backward\"] = \"forward\",\n) -&gt; pl.Expr:\n    \"\"\"Cria uma express\u00e3o Polars para somar dias \u00fateis.\n\n    Ideal para opera\u00e7\u00f5es vetorizadas em DataFrames ou LazyFrames.\n\n    Args:\n        expr: Coluna de data original.\n        n: N\u00famero de dias \u00fateis a somar. Pode ser um inteiro fixo ou outra coluna.\n        roll: Como tratar a data inicial se ela cair em fim de semana/feriado.\n\n    Returns:\n        Uma ``pl.Expr`` que resulta em Date.\n\n    Examples:\n        &gt;&gt;&gt; import datetime as dt\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from pyield.bday import offset_expr\n        &gt;&gt;&gt; datas = [dt.date(2023, 12, 22), dt.date(2023, 12, 29)]\n        &gt;&gt;&gt; offsets = [1, 5]\n        &gt;&gt;&gt; df = pl.DataFrame({\"dt\": datas, \"n\": offsets})\n\n        Adicionando um valor fixo (1 dia \u00fatil):\n        &gt;&gt;&gt; df.select(offset_expr(\"dt\", 1).alias(\"t_plus_1\"))\n        shape: (2, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 t_plus_1   \u2502\n        \u2502 ---        \u2502\n        \u2502 date       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2023-12-26 \u2502\n        \u2502 2024-01-02 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        Adicionando uma coluna din\u00e2mica (prazo vari\u00e1vel por linha):\n        &gt;&gt;&gt; df.select(offset_expr(\"dt\", \"n\").alias(\"vencimento\"))\n        shape: (2, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 vencimento \u2502\n        \u2502 ---        \u2502\n        \u2502 date       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2023-12-26 \u2502\n        \u2502 2024-01-08 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if isinstance(expr, str):\n        expr = pl.col(expr)\n    if isinstance(n, str):\n        n = pl.col(n)\n\n    expr_date = cv.converter_datas_expr(expr)\n\n    return (\n        pl.when(expr_date &lt; DATA_TRANSICAO)\n        .then(expr_date.dt.add_business_days(n=n, roll=roll, holidays=FERIADOS_ANTIGOS))\n        .otherwise(\n            expr_date.dt.add_business_days(n=n, roll=roll, holidays=FERIADOS_NOVOS)\n        )\n    )\n</code></pre>"},{"location":"di1/","title":"Futuros de DI","text":""},{"location":"di1/#pyield.b3.di1.available_trade_dates","title":"<code>available_trade_dates()</code>","text":"<p>Retorna todas as datas de negocia\u00e7\u00e3o dispon\u00edveis (completas) no dataset de DI.</p> <p>Obt\u00e9m valores distintos de 'TradeDate' presentes no cache de dados hist\u00f3ricos de futuros de DI, ordenados cronologicamente.</p> <p>Returns:</p> Type Description <code>Series</code> <p>Series ordenada de datas de negocia\u00e7\u00e3o \u00fanicas (dt.date) para as quais</p> <code>Series</code> <p>dados de DI est\u00e3o dispon\u00edveis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # S\u00e9rie de futuros de DI come\u00e7a em 1995-01-02\n&gt;&gt;&gt; di1.available_trade_dates().head(5)\nshape: (5,)\nSeries: 'available_dates' [date]\n[\n    1995-01-02\n    1995-01-03\n    1995-01-04\n    1995-01-05\n    1995-01-06\n]\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def available_trade_dates() -&gt; pl.Series:\n    \"\"\"Retorna todas as datas de negocia\u00e7\u00e3o dispon\u00edveis (completas) no dataset de DI.\n\n    Obt\u00e9m valores distintos de 'TradeDate' presentes no cache de dados hist\u00f3ricos\n    de futuros de DI, ordenados cronologicamente.\n\n    Returns:\n        Series ordenada de datas de negocia\u00e7\u00e3o \u00fanicas (dt.date) para as quais\n        dados de DI est\u00e3o dispon\u00edveis.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # S\u00e9rie de futuros de DI come\u00e7a em 1995-01-02\n        &gt;&gt;&gt; di1.available_trade_dates().head(5)\n        shape: (5,)\n        Series: 'available_dates' [date]\n        [\n            1995-01-02\n            1995-01-03\n            1995-01-04\n            1995-01-05\n            1995-01-06\n        ]\n    \"\"\"\n    datas_disponiveis = (\n        obter_dataset_cacheado(\"di1\")\n        .get_column(\"TradeDate\")\n        .unique()\n        .sort()\n        .alias(\"available_dates\")\n    )\n    return datas_disponiveis\n</code></pre>"},{"location":"di1/#pyield.b3.di1.data","title":"<code>data(dates, month_start=False, pre_filter=False)</code>","text":"<p>Obt\u00e9m dados de contratos de futuros de DI para datas de negocia\u00e7\u00e3o espec\u00edficas.</p> <p>Fornece acesso aos dados de futuros de DI, permitindo ajustes nas datas de vencimento (para in\u00edcio do m\u00eas) e filtragem opcional com base nos vencimentos de t\u00edtulos p\u00fablicos prefixados (LTN e NTN-F).</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateLike | ArrayLike</code> <p>Datas de negocia\u00e7\u00e3o para as quais obter dados de contratos DI.</p> required <code>month_start</code> <code>bool</code> <p>Se True, ajusta todas as datas de vencimento para o primeiro dia de seus respectivos meses (ex: 2025-02-03 vira 2025-02-01). Padr\u00e3o: False.</p> <code>False</code> <code>pre_filter</code> <code>bool</code> <p>Se True, filtra contratos DI para incluir apenas aqueles cujas datas de vencimento coincidem com vencimentos conhecidos de t\u00edtulos p\u00fablicos prefixados (LTN, NTN-F) do dataset TPF mais pr\u00f3ximo da data de negocia\u00e7\u00e3o fornecida. Padr\u00e3o: False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame contendo dados de contratos de futuros de DI para as datas</p> <code>DataFrame</code> <p>especificadas, ordenados por datas de negocia\u00e7\u00e3o e vencimento. Retorna</p> <code>DataFrame</code> <p>DataFrame vazio se nenhum dado for encontrado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; df = di1.data(dates=\"16-10-2024\", month_start=True)\n&gt;&gt;&gt; df\nshape: (38, 22)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 ExpirationDate \u2506 TickerSymbol \u2506 DaysToExp \u2506 \u2026 \u2506 MaxRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---            \u2506 ---          \u2506 ---       \u2506   \u2506 ---     \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 date           \u2506 str          \u2506 i64       \u2506   \u2506 f64     \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-10-16 \u2506 2024-11-01     \u2506 DI1X24       \u2506 16        \u2506 \u2026 \u2506 0.10656 \u2506 0.10652   \u2506 0.10653        \u2506 0.10653     \u2502\n\u2502 2024-10-16 \u2506 2024-12-01     \u2506 DI1Z24       \u2506 47        \u2506 \u2026 \u2506 0.10914 \u2506 0.10914   \u2506 0.1091         \u2506 0.110726    \u2502\n\u2502 2024-10-16 \u2506 2025-01-01     \u2506 DI1F25       \u2506 78        \u2506 \u2026 \u2506 0.11174 \u2506 0.11164   \u2506 0.11164        \u2506 0.1154      \u2502\n\u2502 2024-10-16 \u2506 2025-02-01     \u2506 DI1G25       \u2506 110       \u2506 \u2026 \u2506 0.1137  \u2506 0.11365   \u2506 0.11362        \u2506 0.118314    \u2502\n\u2502 2024-10-16 \u2506 2025-03-01     \u2506 DI1H25       \u2506 140       \u2506 \u2026 \u2506 0.11595 \u2506 0.11565   \u2506 0.1157         \u2506 0.12343     \u2502\n\u2502 \u2026          \u2506 \u2026              \u2506 \u2026            \u2506 \u2026         \u2506 \u2026 \u2506 \u2026       \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-10-16 \u2506 2035-01-01     \u2506 DI1F35       \u2506 3730      \u2506 \u2026 \u2506 0.1267  \u2506 0.1264    \u2506 0.1265         \u2506 0.124455    \u2502\n\u2502 2024-10-16 \u2506 2036-01-01     \u2506 DI1F36       \u2506 4095      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.124249    \u2502\n\u2502 2024-10-16 \u2506 2037-01-01     \u2506 DI1F37       \u2506 4461      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n\u2502 2024-10-16 \u2506 2038-01-01     \u2506 DI1F38       \u2506 4828      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n\u2502 2024-10-16 \u2506 2039-01-01     \u2506 DI1F39       \u2506 5192      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def data(\n    dates: DateLike | ArrayLike,\n    month_start: bool = False,\n    pre_filter: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m dados de contratos de futuros de DI para datas de negocia\u00e7\u00e3o espec\u00edficas.\n\n    Fornece acesso aos dados de futuros de DI, permitindo ajustes nas datas de\n    vencimento (para in\u00edcio do m\u00eas) e filtragem opcional com base nos vencimentos\n    de t\u00edtulos p\u00fablicos prefixados (LTN e NTN-F).\n\n    Args:\n        dates: Datas de negocia\u00e7\u00e3o para as quais obter dados de contratos DI.\n        month_start: Se True, ajusta todas as datas de vencimento para o primeiro\n            dia de seus respectivos meses (ex: 2025-02-03 vira 2025-02-01).\n            Padr\u00e3o: False.\n        pre_filter: Se True, filtra contratos DI para incluir apenas aqueles cujas\n            datas de vencimento coincidem com vencimentos conhecidos de t\u00edtulos\n            p\u00fablicos prefixados (LTN, NTN-F) do dataset TPF mais pr\u00f3ximo da data\n            de negocia\u00e7\u00e3o fornecida. Padr\u00e3o: False.\n\n    Returns:\n        DataFrame contendo dados de contratos de futuros de DI para as datas\n        especificadas, ordenados por datas de negocia\u00e7\u00e3o e vencimento. Retorna\n        DataFrame vazio se nenhum dado for encontrado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; df = di1.data(dates=\"16-10-2024\", month_start=True)\n        &gt;&gt;&gt; df\n        shape: (38, 22)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 ExpirationDate \u2506 TickerSymbol \u2506 DaysToExp \u2506 \u2026 \u2506 MaxRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---            \u2506 ---          \u2506 ---       \u2506   \u2506 ---     \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 date           \u2506 str          \u2506 i64       \u2506   \u2506 f64     \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-10-16 \u2506 2024-11-01     \u2506 DI1X24       \u2506 16        \u2506 \u2026 \u2506 0.10656 \u2506 0.10652   \u2506 0.10653        \u2506 0.10653     \u2502\n        \u2502 2024-10-16 \u2506 2024-12-01     \u2506 DI1Z24       \u2506 47        \u2506 \u2026 \u2506 0.10914 \u2506 0.10914   \u2506 0.1091         \u2506 0.110726    \u2502\n        \u2502 2024-10-16 \u2506 2025-01-01     \u2506 DI1F25       \u2506 78        \u2506 \u2026 \u2506 0.11174 \u2506 0.11164   \u2506 0.11164        \u2506 0.1154      \u2502\n        \u2502 2024-10-16 \u2506 2025-02-01     \u2506 DI1G25       \u2506 110       \u2506 \u2026 \u2506 0.1137  \u2506 0.11365   \u2506 0.11362        \u2506 0.118314    \u2502\n        \u2502 2024-10-16 \u2506 2025-03-01     \u2506 DI1H25       \u2506 140       \u2506 \u2026 \u2506 0.11595 \u2506 0.11565   \u2506 0.1157         \u2506 0.12343     \u2502\n        \u2502 \u2026          \u2506 \u2026              \u2506 \u2026            \u2506 \u2026         \u2506 \u2026 \u2506 \u2026       \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-10-16 \u2506 2035-01-01     \u2506 DI1F35       \u2506 3730      \u2506 \u2026 \u2506 0.1267  \u2506 0.1264    \u2506 0.1265         \u2506 0.124455    \u2502\n        \u2502 2024-10-16 \u2506 2036-01-01     \u2506 DI1F36       \u2506 4095      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.124249    \u2502\n        \u2502 2024-10-16 \u2506 2037-01-01     \u2506 DI1F37       \u2506 4461      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2502 2024-10-16 \u2506 2038-01-01     \u2506 DI1F38       \u2506 4828      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2502 2024-10-16 \u2506 2039-01-01     \u2506 DI1F39       \u2506 5192      \u2506 \u2026 \u2506 null    \u2506 null      \u2506 0.1263         \u2506 0.1263      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if any_is_empty(dates):\n        return pl.DataFrame()\n\n    df = _obter_dados(datas=dates)\n\n    if pre_filter:\n        df_tpf = (\n            obter_dataset_cacheado(\"tpf\")\n            .filter(pl.col(\"BondType\").is_in([\"LTN\", \"NTN-F\"]))\n            .unique(subset=[\"MaturityDate\", \"ReferenceDate\"])\n            .select(\n                TradeDate_tpf=pl.col(\"ReferenceDate\"),\n                ExpirationDate=bday.offset_expr(\"MaturityDate\", 0),\n            )\n            .sort(\"TradeDate_tpf\", \"ExpirationDate\")\n        )\n\n        # Ajustar as datas de vencimento para dias \u00fateis, como est\u00e1 no DI1\n        # exp_dates = bday.offset(df_tpf[\"ExpirationDate\"], 0)\n        # df_tpf = df_tpf.with_columns(ExpirationDate=exp_dates)\n\n        # Mapear cada TradeDate do DI para a data TPF mais pr\u00f3xima\n        df = df.join_asof(\n            df_tpf.select(\"TradeDate_tpf\").unique().sort(\"TradeDate_tpf\"),\n            left_on=\"TradeDate\",\n            right_on=\"TradeDate_tpf\",\n            strategy=\"backward\",\n        )\n\n        # Filtrar apenas vencimentos que existem no TPF\n        df = df.join(df_tpf, on=[\"TradeDate_tpf\", \"ExpirationDate\"], how=\"inner\").drop(\n            \"TradeDate_tpf\"\n        )\n\n    if month_start:\n        df = df.with_columns(pl.col(\"ExpirationDate\").dt.truncate(\"1mo\"))\n\n    return df.sort(\"TradeDate\", \"ExpirationDate\")\n</code></pre>"},{"location":"di1/#pyield.b3.di1.interpolate_rate","title":"<code>interpolate_rate(date, expiration, extrapolate=False)</code>","text":"<p>Interpola ou obt\u00e9m a taxa DI para uma \u00fanica data de vencimento.</p> <p>Busca dados de contratos DI para a data de negocia\u00e7\u00e3o especificada e determina a taxa de liquida\u00e7\u00e3o para o vencimento fornecido. Se existir uma correspond\u00eancia exata para a data de vencimento, sua taxa \u00e9 retornada. Caso contr\u00e1rio, a taxa \u00e9 interpolada usando o m\u00e9todo flat-forward baseado nas taxas dos contratos adjacentes.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de negocia\u00e7\u00e3o para a qual obter dados de DI.</p> required <code>expiration</code> <code>DateLike</code> <p>Data de vencimento alvo para a taxa.</p> required <code>extrapolate</code> <code>bool</code> <p>Se True, permite extrapola\u00e7\u00e3o se o <code>expiration</code> estiver fora do intervalo de vencimentos de contratos dispon\u00edveis para a <code>date</code>. Padr\u00e3o: False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Taxa de liquida\u00e7\u00e3o DI exata ou interpolada para a data e vencimento</p> <code>float</code> <p>especificados. Retorna <code>float(\"nan\")</code> se:</p> <code>float</code> <ul> <li><code>date</code> ou <code>expiration</code> for nulo.</li> </ul> <code>float</code> <ul> <li>N\u00e3o h\u00e1 dados DI para a <code>date</code>.</li> </ul> <code>float</code> <ul> <li>O <code>expiration</code> est\u00e1 fora do intervalo e <code>extrapolate</code> \u00e9 False.</li> </ul> <code>float</code> <ul> <li>O c\u00e1lculo de interpola\u00e7\u00e3o falhou.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; # Obt\u00e9m taxa para um vencimento de contrato existente\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2027\")\n0.13901\n</code></pre> <pre><code>&gt;&gt;&gt; # Obt\u00e9m taxa para um vencimento n\u00e3o existente\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-11-2027\")\n0.13576348733268917\n</code></pre> <pre><code>&gt;&gt;&gt; # Extrapola taxa para uma data de vencimento futura\n&gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2050\", extrapolate=True)\n0.13881\n</code></pre> <pre><code>&gt;&gt;&gt; # Entradas nulas retornam NaN\n&gt;&gt;&gt; di1.interpolate_rate(None, \"01-01-2030\")\nnan\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def interpolate_rate(\n    date: DateLike,\n    expiration: DateLike,\n    extrapolate: bool = False,\n) -&gt; float:\n    \"\"\"Interpola ou obt\u00e9m a taxa DI para uma \u00fanica data de vencimento.\n\n    Busca dados de contratos DI para a data de negocia\u00e7\u00e3o especificada e determina\n    a taxa de liquida\u00e7\u00e3o para o vencimento fornecido. Se existir uma correspond\u00eancia\n    exata para a data de vencimento, sua taxa \u00e9 retornada. Caso contr\u00e1rio, a taxa\n    \u00e9 interpolada usando o m\u00e9todo flat-forward baseado nas taxas dos contratos\n    adjacentes.\n\n    Args:\n        date: Data de negocia\u00e7\u00e3o para a qual obter dados de DI.\n        expiration: Data de vencimento alvo para a taxa.\n        extrapolate: Se True, permite extrapola\u00e7\u00e3o se o ``expiration`` estiver\n            fora do intervalo de vencimentos de contratos dispon\u00edveis para a\n            ``date``. Padr\u00e3o: False.\n\n    Returns:\n        Taxa de liquida\u00e7\u00e3o DI exata ou interpolada para a data e vencimento\n        especificados. Retorna ``float(\"nan\")`` se:\n        - ``date`` ou ``expiration`` for nulo.\n        - N\u00e3o h\u00e1 dados DI para a ``date``.\n        - O ``expiration`` est\u00e1 fora do intervalo e ``extrapolate`` \u00e9 False.\n        - O c\u00e1lculo de interpola\u00e7\u00e3o falhou.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; # Obt\u00e9m taxa para um vencimento de contrato existente\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2027\")\n        0.13901\n\n        &gt;&gt;&gt; # Obt\u00e9m taxa para um vencimento n\u00e3o existente\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-11-2027\")\n        0.13576348733268917\n\n        &gt;&gt;&gt; # Extrapola taxa para uma data de vencimento futura\n        &gt;&gt;&gt; di1.interpolate_rate(\"25-04-2025\", \"01-01-2050\", extrapolate=True)\n        0.13881\n\n        &gt;&gt;&gt; # Entradas nulas retornam NaN\n        &gt;&gt;&gt; di1.interpolate_rate(None, \"01-01-2030\")\n        nan\n    \"\"\"\n    if any_is_collection(date, expiration):\n        raise ValueError(\"As entradas 'date' e 'expiration' devem ser datas escalares.\")\n\n    taxa = interpolate_rates(\n        dates=date,\n        expirations=expiration,\n        extrapolate=extrapolate,\n    )\n    if taxa.is_empty():\n        return float(\"nan\")\n\n    valor = taxa.item()\n    if valor is None:\n        return float(\"nan\")\n\n    return float(valor)\n</code></pre>"},{"location":"di1/#pyield.b3.di1.interpolate_rates","title":"<code>interpolate_rates(dates, expirations, extrapolate=True)</code>","text":"<p>Interpola taxas de DI para datas de negocia\u00e7\u00e3o e vencimentos especificados.</p> <p>Calcula taxas de DI interpoladas usando o m\u00e9todo flat-forward para conjuntos de datas de negocia\u00e7\u00e3o e vencimentos. Esta fun\u00e7\u00e3o \u00e9 adequada para c\u00e1lculos vetorizados com m\u00faltiplos pares de datas.</p> <p>Se taxas de DI n\u00e3o estiverem dispon\u00edveis para uma data de negocia\u00e7\u00e3o, as taxas interpoladas correspondentes ser\u00e3o NaN.</p> <p>Trata broadcasting: Se um argumento for escalar e o outro for array, o valor escalar \u00e9 aplicado a todos os elementos do array.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateLike | ArrayLike</code> <p>Data(s) de negocia\u00e7\u00e3o para as taxas.</p> required <code>expirations</code> <code>DateLike | ArrayLike</code> <p>Data(s) de vencimento correspondentes. Deve ser compat\u00edvel em tamanho com <code>dates</code> se ambos forem arrays.</p> required <code>extrapolate</code> <code>bool</code> <p>Se permite extrapola\u00e7\u00e3o al\u00e9m do intervalo de taxas DI conhecidas para uma data de negocia\u00e7\u00e3o. Padr\u00e3o: True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series contendo as taxas DI interpoladas (como floats). Valores ser\u00e3o</p> <code>Series</code> <p>NaN onde interpola\u00e7\u00e3o n\u00e3o for poss\u00edvel (ex: sem dados DI para a data</p> <code>Series</code> <p>de negocia\u00e7\u00e3o).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se <code>dates</code> e <code>expirations</code> forem ambos array-like mas tiverem tamanhos diferentes.</p> Notes <ul> <li>Todas as taxas de liquida\u00e7\u00e3o dispon\u00edveis s\u00e3o usadas para interpola\u00e7\u00e3o   flat-forward.</li> <li>A fun\u00e7\u00e3o trata broadcasting de entradas escalares e array-like.</li> </ul> <p>Examples:</p> <p>Interpola taxas para m\u00faltiplas datas de negocia\u00e7\u00e3o e vencimento:</p> <pre><code>&gt;&gt;&gt; # Para contrato com vencimento 01-01-2027 em 08-05-2025\n&gt;&gt;&gt; # A taxa n\u00e3o \u00e9 interpolada (taxa de liquida\u00e7\u00e3o \u00e9 usada)\n&gt;&gt;&gt; # N\u00e3o h\u00e1 contrato com vencimento 25-11-2027 em 09-05-2025\n&gt;&gt;&gt; # A taxa \u00e9 interpolada (m\u00e9todo flat-forward)\n&gt;&gt;&gt; # N\u00e3o h\u00e1 dados para 10-05-2025 (s\u00e1bado) -&gt; NaN\n&gt;&gt;&gt; from pyield import di1\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=[\"08-05-2025\", \"09-05-2025\", \"10-05-2025\"],\n...     expirations=[\"01-01-2027\", \"25-11-2027\", \"01-01-2030\"],\n... )\nshape: (3,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.13972\n    0.134613\n    null\n]\n</code></pre> <p>Interpola taxas para uma data de negocia\u00e7\u00e3o e m\u00faltiplos vencimentos:</p> <pre><code>&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=\"25-04-2025\",\n...     expirations=[\"01-01-2027\", \"01-01-2050\"],\n...     extrapolate=True,\n... )\nshape: (2,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.13901\n    0.13881\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Com extrapola\u00e7\u00e3o desabilitada, vencimentos fora do intervalo retornam null\n&gt;&gt;&gt; di1.interpolate_rates(\n...     dates=\"25-04-2025\",\n...     expirations=[\"01-11-2027\", \"01-01-2050\"],\n...     extrapolate=False,\n... )\nshape: (2,)\nSeries: 'FlatFwdRate' [f64]\n[\n    0.135763\n    null\n]\n</code></pre> Source code in <code>pyield/b3/di1.py</code> <pre><code>def interpolate_rates(\n    dates: DateLike | ArrayLike,\n    expirations: DateLike | ArrayLike,\n    extrapolate: bool = True,\n) -&gt; pl.Series:\n    \"\"\"Interpola taxas de DI para datas de negocia\u00e7\u00e3o e vencimentos especificados.\n\n    Calcula taxas de DI interpoladas usando o m\u00e9todo **flat-forward** para\n    conjuntos de datas de negocia\u00e7\u00e3o e vencimentos. Esta fun\u00e7\u00e3o \u00e9 adequada para\n    c\u00e1lculos vetorizados com m\u00faltiplos pares de datas.\n\n    Se taxas de DI n\u00e3o estiverem dispon\u00edveis para uma data de negocia\u00e7\u00e3o, as\n    taxas interpoladas correspondentes ser\u00e3o NaN.\n\n    Trata broadcasting: Se um argumento for escalar e o outro for array, o valor\n    escalar \u00e9 aplicado a todos os elementos do array.\n\n    Args:\n        dates: Data(s) de negocia\u00e7\u00e3o para as taxas.\n        expirations: Data(s) de vencimento correspondentes. Deve ser compat\u00edvel\n            em tamanho com ``dates`` se ambos forem arrays.\n        extrapolate: Se permite extrapola\u00e7\u00e3o al\u00e9m do intervalo de taxas DI\n            conhecidas para uma data de negocia\u00e7\u00e3o. Padr\u00e3o: True.\n\n    Returns:\n        Series contendo as taxas DI interpoladas (como floats). Valores ser\u00e3o\n        NaN onde interpola\u00e7\u00e3o n\u00e3o for poss\u00edvel (ex: sem dados DI para a data\n        de negocia\u00e7\u00e3o).\n\n    Raises:\n        ValueError: Se ``dates`` e ``expirations`` forem ambos array-like mas\n            tiverem tamanhos diferentes.\n\n    Notes:\n        - Todas as taxas de liquida\u00e7\u00e3o dispon\u00edveis s\u00e3o usadas para interpola\u00e7\u00e3o\n          flat-forward.\n        - A fun\u00e7\u00e3o trata broadcasting de entradas escalares e array-like.\n\n    Examples:\n        Interpola taxas para m\u00faltiplas datas de negocia\u00e7\u00e3o e vencimento:\n        &gt;&gt;&gt; # Para contrato com vencimento 01-01-2027 em 08-05-2025\n        &gt;&gt;&gt; # A taxa n\u00e3o \u00e9 interpolada (taxa de liquida\u00e7\u00e3o \u00e9 usada)\n        &gt;&gt;&gt; # N\u00e3o h\u00e1 contrato com vencimento 25-11-2027 em 09-05-2025\n        &gt;&gt;&gt; # A taxa \u00e9 interpolada (m\u00e9todo flat-forward)\n        &gt;&gt;&gt; # N\u00e3o h\u00e1 dados para 10-05-2025 (s\u00e1bado) -&gt; NaN\n        &gt;&gt;&gt; from pyield import di1\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=[\"08-05-2025\", \"09-05-2025\", \"10-05-2025\"],\n        ...     expirations=[\"01-01-2027\", \"25-11-2027\", \"01-01-2030\"],\n        ... )\n        shape: (3,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.13972\n            0.134613\n            null\n        ]\n\n        Interpola taxas para uma data de negocia\u00e7\u00e3o e m\u00faltiplos vencimentos:\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=\"25-04-2025\",\n        ...     expirations=[\"01-01-2027\", \"01-01-2050\"],\n        ...     extrapolate=True,\n        ... )\n        shape: (2,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.13901\n            0.13881\n        ]\n\n        &gt;&gt;&gt; # Com extrapola\u00e7\u00e3o desabilitada, vencimentos fora do intervalo retornam null\n        &gt;&gt;&gt; di1.interpolate_rates(\n        ...     dates=\"25-04-2025\",\n        ...     expirations=[\"01-11-2027\", \"01-01-2050\"],\n        ...     extrapolate=False,\n        ... )\n        shape: (2,)\n        Series: 'FlatFwdRate' [f64]\n        [\n            0.135763\n            null\n        ]\n    \"\"\"\n    if any_is_empty(dates, expirations):\n        return pl.Series(dtype=pl.Float64)\n\n    df_entrada = pl.DataFrame(\n        data={\"TradeDate\": dates, \"ExpirationDate\": expirations}\n    ).with_columns(\n        TradeDate=cv.converter_datas_expr(\"TradeDate\"),\n        ExpirationDate=cv.converter_datas_expr(\"ExpirationDate\"),\n    )\n    if df_entrada.is_empty():\n        return pl.Series(dtype=pl.Float64)\n\n    # Carrega dataset de taxas DI filtrado pelas datas de refer\u00eancia fornecidas\n    # Usa datas j\u00e1 convertidas do DataFrame de entrada para evitar convers\u00e3o dupla\n    df_ref = _obter_dados(datas=dates)\n    # Retorna Series vazia se nenhuma taxa for encontrada\n    if df_ref.is_empty():\n        return pl.Series(dtype=pl.Float64)\n\n    # 1. CRIA O \u00cdNDICE ORIGINAL AQUI\n    # Isso garante que saberemos a ordem exata depois\n    df_entrada = df_entrada.with_row_index(\"_temp_idx\")\n\n    # Inicializa FlatFwdRate como None\n    df_entrada = df_entrada.with_columns(\n        BDaysToExp=bday.count_expr(\"TradeDate\", \"ExpirationDate\"),\n        FlatFwdRate=None,\n    )\n\n    # Lista para armazenar os blocos processados\n    blocos_processados = []\n\n    # Itera sobre cada data de refer\u00eancia \u00fanica\n    for data_ref in df_entrada[\"TradeDate\"].unique():\n        # 1. Filtra apenas as linhas desta data (Particionamento)\n        df_parcial = df_entrada.filter(pl.col(\"TradeDate\") == data_ref)\n\n        # 2. Busca as taxas de refer\u00eancia para esta data\n        df_referencia = df_ref.filter(pl.col(\"TradeDate\") == data_ref)\n\n        # Se n\u00e3o houver dados de curva, adicionamos o bloco como est\u00e1 (com nulos)\n        # e continuamos.\n        if df_referencia.is_empty():\n            blocos_processados.append(df_parcial)\n            continue\n\n        # Inicializa o interpolador com taxas e dias \u00fateis conhecidos\n        interpolador = interpolator.Interpolator(\n            method=\"flat_forward\",\n            known_bdays=df_referencia[\"BDaysToExp\"],\n            known_rates=df_referencia[\"SettlementRate\"],\n            extrapolate=extrapolate,\n        )\n\n        # 4. A m\u00e1gica: map_batches passa a Series inteira para o interpolador\n        # O interpolador retorna uma Series, que o Polars alinha perfeitamente\n        df_parcial = df_parcial.with_columns(\n            pl.col(\"BDaysToExp\")\n            .map_batches(interpolador)  # Passa Series -&gt; Recebe Series\n            .alias(\"FlatFwdRate\")\n        )\n\n        blocos_processados.append(df_parcial)\n\n    if not blocos_processados:\n        return pl.Series(dtype=pl.Float64)\n\n    # 2. CONCATENA E ORDENA DE VOLTA\n    # O sort(\"_temp_idx\") restaura a ordem original dos inputs\n    df_saida = pl.concat(blocos_processados).sort(\"_temp_idx\")\n\n    return df_saida[\"FlatFwdRate\"].fill_nan(None)\n</code></pre>"},{"location":"forwards/","title":"Taxas a Termo","text":""},{"location":"forwards/#pyield.fwd.forward","title":"<code>forward(bday1, bday2, rate1, rate2)</code>","text":"<p>Calcula a taxa a termo entre dois prazos (dias \u00fateis).</p> <p>Utiliza a f\u00f3rmula:</p> <pre><code>f\u2081\u2192\u2082 = (f\u2082^(du\u2082/252) / f\u2081^(du\u2081/252))^(252/(du\u2082 - du\u2081)) - 1\n</code></pre> Onde <ul> <li>f\u2081 \u00e9 o fator de capitaliza\u00e7\u00e3o do primeiro prazo (f\u2081 = 1 + tx\u2081).</li> <li>f\u2082 \u00e9 o fator de capitaliza\u00e7\u00e3o do segundo prazo (f\u2082 = 1 + tx\u2082).</li> <li>tx\u2081 \u00e9 a taxa zero para o primeiro prazo (du\u2081).</li> <li>tx\u2082 \u00e9 a taxa zero para o segundo prazo (du\u2082).</li> <li>du\u2081 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a primeira data.</li> <li>du\u2082 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a segunda data.</li> <li>A constante 252 representa o n\u00famero de dias \u00fateis no ano.</li> </ul> <p>Como au = du/252 (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:</p> <pre><code>f\u2081\u2192\u2082 = (f\u2082^au\u2082 / f\u2081^au\u2081)^(1/(au\u2082 - au\u2081)) - 1\n</code></pre> <p>Que em latex fica:</p> \\[ f_{1 \\rightarrow 2} = \\left( \\frac{f_2^{au_2}}{f_1^{au_1}} \\right)^{\\frac{1}{au_2 - au_1}} - 1 \\] <p>Parameters:</p> Name Type Description Default <code>bday1</code> <code>int</code> <p>N\u00famero de dias \u00fateis do primeiro ponto (prazo menor).</p> required <code>bday2</code> <code>int</code> <p>N\u00famero de dias \u00fateis do segundo ponto (prazo maior).</p> required <code>rate1</code> <code>float</code> <p>Taxa zero para o prazo <code>bday1</code>.</p> required <code>rate2</code> <code>float</code> <p>Taxa zero para o prazo <code>bday2</code>.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>A taxa a termo calculada entre <code>du\u2081</code> e <code>du\u2082</code>. Retorna <code>nan</code> se <code>du\u2081 &gt;= du\u2082</code> ou se qualquer um dos argumentos de entrada for <code>float(\"nan\")</code> ou <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Exemplo v\u00e1lido: du\u2082 &gt; du\u2081\n&gt;&gt;&gt; yd.forward(10, 20, 0.05, 0.06)\n0.0700952380952371\n&gt;&gt;&gt; # Exemplo inv\u00e1lido: du\u2081 &gt;= du\u2082\n&gt;&gt;&gt; print(yd.forward(20, 10, 0.06, 0.05))\nnan\n</code></pre> <pre><code>&gt;&gt;&gt; # Argumentos nulos retornam nan\n&gt;&gt;&gt; print(yd.forward(10, 20, 0.05, None))\nnan\n</code></pre> Notes <p><code>du\u2082</code> precisa ser necessariamente maior que <code>du\u2081</code> para que o c\u00e1lculo da taxa a termo seja matematicamente v\u00e1lido.</p> Source code in <code>pyield/fwd.py</code> <pre><code>def forward(\n    bday1: int,\n    bday2: int,\n    rate1: float,\n    rate2: float,\n) -&gt; float:\n    r\"\"\"\n    Calcula a taxa a termo entre dois prazos (dias \u00fateis).\n\n    Utiliza a f\u00f3rmula:\n\n        f\u2081\u2192\u2082 = (f\u2082^(du\u2082/252) / f\u2081^(du\u2081/252))^(252/(du\u2082 - du\u2081)) - 1\n\n    Onde:\n        - f\u2081 \u00e9 o fator de capitaliza\u00e7\u00e3o do primeiro prazo (f\u2081 = 1 + tx\u2081).\n        - f\u2082 \u00e9 o fator de capitaliza\u00e7\u00e3o do segundo prazo (f\u2082 = 1 + tx\u2082).\n        - tx\u2081 \u00e9 a taxa zero para o primeiro prazo (du\u2081).\n        - tx\u2082 \u00e9 a taxa zero para o segundo prazo (du\u2082).\n        - du\u2081 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a primeira data.\n        - du\u2082 \u00e9 o n\u00famero de dias \u00fateis at\u00e9 a segunda data.\n        - A constante 252 representa o n\u00famero de dias \u00fateis no ano.\n\n    Como au = du/252 (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:\n\n        f\u2081\u2192\u2082 = (f\u2082^au\u2082 / f\u2081^au\u2081)^(1/(au\u2082 - au\u2081)) - 1\n\n    Que em latex fica:\n\n    \\[\n    f_{1 \\rightarrow 2} = \\left( \\frac{f_2^{au_2}}{f_1^{au_1}} \\right)^{\\frac{1}{au_2 - au_1}} - 1\n    \\]\n\n    Args:\n        bday1 (int): N\u00famero de dias \u00fateis do primeiro ponto (prazo menor).\n        bday2 (int): N\u00famero de dias \u00fateis do segundo ponto (prazo maior).\n        rate1 (float): Taxa zero para o prazo `bday1`.\n        rate2 (float): Taxa zero para o prazo `bday2`.\n\n    Returns:\n        float: A taxa a termo calculada entre `du\u2081` e `du\u2082`. Retorna\n            `nan` se `du\u2081 &gt;= du\u2082` ou se qualquer um dos\n            argumentos de entrada for `float(\"nan\")` ou `None`.\n\n    Examples:\n        &gt;&gt;&gt; # Exemplo v\u00e1lido: du\u2082 &gt; du\u2081\n        &gt;&gt;&gt; yd.forward(10, 20, 0.05, 0.06)\n        0.0700952380952371\n        &gt;&gt;&gt; # Exemplo inv\u00e1lido: du\u2081 &gt;= du\u2082\n        &gt;&gt;&gt; print(yd.forward(20, 10, 0.06, 0.05))\n        nan\n\n        &gt;&gt;&gt; # Argumentos nulos retornam nan\n        &gt;&gt;&gt; print(yd.forward(10, 20, 0.05, None))\n        nan\n\n    Notes:\n        `du\u2082` precisa ser necessariamente maior que `du\u2081` para que\n        o c\u00e1lculo da taxa a termo seja matematicamente v\u00e1lido.\n    \"\"\"  # noqa: E501\n    if any_is_empty(rate1, rate2, bday1, bday2):\n        # Se qualquer entrada for nula/NaN, retorna NaN\n        return float(\"nan\")\n\n    # Prazo final deve ser maior que o inicial\n    if bday2 &lt;= bday1:\n        return float(\"nan\")\n\n    # Converter dias \u00fateis para anos \u00fateis\n    au1 = bday1 / 252\n    au2 = bday2 / 252\n\n    # Defini\u00e7\u00e3o dos fatores de capitaliza\u00e7\u00e3o:\n    # f\u2081 = 1 + tx\u2081 e f\u2082 = 1 + tx\u2082\n    f1 = 1 + rate1\n    f2 = 1 + rate2\n\n    # f\u2081\u2192\u2082 = (f\u2082^au\u2082 / f\u2081^au\u2081)^(1/(au\u2082 - au\u2081)) - 1\n    return (f2**au2 / f1**au1) ** (1 / (au2 - au1)) - 1\n</code></pre>"},{"location":"forwards/#pyield.fwd.forwards","title":"<code>forwards(bdays, rates, group_by=None)</code>","text":"<p>Calcula taxas a termo a partir de taxas zero.</p> <p>A taxa a termo no v\u00e9rtice 'n' \u00e9 definida como:</p> <pre><code>fwd\u2096 = fwd\u2c7c\u2192\u2096 (a taxa a termo de j para k)\n</code></pre> <p>Definindo o fator de capitaliza\u00e7\u00e3o no v\u00e9rtice k como:</p> <pre><code>f\u2096 = 1 + tx\u2096\n</code></pre> <p>A f\u00f3rmula utilizada \u00e9:</p> <pre><code>fwd\u2096 = (f\u2096^(du\u2096/252) / f\u2c7c^(du\u2c7c/252))^(252/(du\u2096 - du\u2c7c)) - 1\n</code></pre> <p>Como au = du/252 (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:</p> <pre><code>fwd\u2096 = (f\u2096^au\u2096 / f\u2c7c^au\u2c7c)^(1/(au\u2096 - au\u2c7c)) - 1\n</code></pre> <p>Em LaTeX, a f\u00f3rmula \u00e9 representada como:</p> \\[ fwd_k = \\left( \\frac{f_k^{au_k}}{f_j^{au_j}} \\right)^{\\frac{1}{au_k - au_j}} - 1 \\] <p>Onde: - f\u2c7c \u00e9 o fator de capitaliza\u00e7\u00e3o no v\u00e9rtice anterior (f\u2c7c = 1 + tx\u2c7c). - f\u2096 \u00e9 o fator de capitaliza\u00e7\u00e3o no v\u00e9rtice atual (f\u2096 = 1 + tx\u2096). - tx\u2c7c \u00e9 a taxa zero para o v\u00e9rtice anterior. - tx\u2096 \u00e9 a taxa zero para o v\u00e9rtice atual. - au\u2c7c \u00e9 o prazo em anos \u00fateis no v\u00e9rtice anterior (au\u2c7c = du\u2c7c/252). - au\u2096 \u00e9 o prazo em anos \u00fateis no v\u00e9rtice atual (au\u2096 = du\u2096/252). - A constante 252 representa o n\u00famero de dias \u00fateis no ano.</p> <p>A fun\u00e7\u00e3o preserva a ordem original dos dados de entrada e lida com valores nulos de forma apropriada. Valores nulos nas entradas resultar\u00e3o em valores nulos nas taxas a termo calculadas.</p> <p>A primeira taxa a termo de cada grupo \u00e9 definida como a taxa zero desse primeiro v\u00e9rtice (fwd\u2081 = tx\u2081), dado que n\u00e3o existe um v\u00e9rtice anterior a tx\u2081 para se calcular a taxa a termo no primeiro ponto.</p> <p>A fun\u00e7\u00e3o tamb\u00e9m lida com agrupamentos opcionais, permitindo calcular taxas a termo para diferentes grupos de datas. O agrupamento \u00e9 feito com base em <code>group_by</code>. Se este argumento for None, todos os dados ser\u00e3o tratados como um \u00fanico grupo.</p> <p>A fun\u00e7\u00e3o calcula as taxas a termo para todos os pontos, exceto o primeiro de cada grupo, que \u00e9 tratado separadamente.</p> <p>Parameters:</p> Name Type Description Default <code>bdays</code> <code>ArrayLike</code> <p>N\u00famero de dias \u00fateis (du) para cada taxa zero.</p> required <code>rates</code> <code>ArrayLike</code> <p>Taxas zero (tx) correspondentes aos dias \u00fateis.</p> required <code>group_by</code> <code>Sequence[str | int | date] | Series | None</code> <p>Crit\u00e9rio de agrupamento para os c\u00e1lculos (ex: datas de refer\u00eancia, tickers de t\u00edtulos). Pode ser uma lista/s\u00e9rie de strings, inteiros ou datas. Se None, todos os dados s\u00e3o tratados como um \u00fanico grupo. Padr\u00e3o None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie contendo as taxas a termo calculadas (tipo Float64). A primeira taxa de cada grupo corresponde \u00e0 taxa zero inicial.</p> <p>Raises:</p> Type Description <code>ShapeError</code> <p>Se os comprimentos de <code>bdays</code>, <code>rates</code> e <code>group_by</code> (quando fornecido) n\u00e3o forem iguais.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bdays = [10, 20, 30]\n&gt;&gt;&gt; rates = [0.05, 0.06, 0.07]\n&gt;&gt;&gt; yd.forwards(bdays, rates)\nshape: (3,)\nSeries: 'fwd' [f64]\n[\n    0.05\n    0.070095\n    0.090284\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Exemplo com agrupamento (a \u00faltima est\u00e1 isolada em outro grupo)\n&gt;&gt;&gt; group_by = [\"LTN\", \"LTN\", \"NTN-F\"]\n&gt;&gt;&gt; yd.forwards(bdays, rates, group_by)\nshape: (3,)\nSeries: 'fwd' [f64]\n[\n    0.05\n    0.070095\n    0.07\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Exemplo com taxas indicativas de NTN-B em 16-09-2025\n&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; df = ntnb.data(\"16-09-2025\")\n&gt;&gt;&gt; yd.forwards(df[\"BDToMat\"], df[\"IndicativeRate\"])\nshape: (13,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.071549\n    0.072439\n    0.069558\n    0.076614\n    \u2026\n    0.068105\n    0.071278\n    0.069117\n    0.070373\n    0.073286\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # Valores nulos s\u00e3o descartados no c\u00e1lculo e retornados como nulos\n&gt;&gt;&gt; du = [230, 415, 730, None, 914]\n&gt;&gt;&gt; tx = [0.0943, 0.084099, 0.079052, 0.1, 0.077134]\n&gt;&gt;&gt; yd.forwards(du, tx)\nshape: (5,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.071549\n    0.072439\n    null\n    0.069558\n]\n</code></pre> <pre><code>&gt;&gt;&gt; # O algoritmo ordena os dados de entrada antes do c\u00e1lculo e retorna\n&gt;&gt;&gt; # os resultados na ordem original. Valores duplicados s\u00e3o tratados\n&gt;&gt;&gt; # como um \u00fanico ponto no c\u00e1lculo da taxa a termo (\u00faltimo valor \u00e9 mantido).\n&gt;&gt;&gt; du = [230, 730, 415, 230]\n&gt;&gt;&gt; tx = [0.1, 0.079052, 0.084099, 0.0943]\n&gt;&gt;&gt; yd.forwards(du, tx)\nshape: (4,)\nSeries: 'fwd' [f64]\n[\n    0.0943\n    0.072439\n    0.071549\n    0.0943\n]\n</code></pre> Notes <ul> <li>A fun\u00e7\u00e3o ordena os dados de entrada primeiro por <code>group_by</code>,   se for fornecido, e depois por <code>bdays</code> para garantir a ordem cronol\u00f3gica   correta no c\u00e1lculo das taxas a termo.</li> <li>Valores nulos em <code>bdays</code> ou <code>rates</code> s\u00e3o ignorados no c\u00e1lculo,   resultando em valores nulos nas posi\u00e7\u00f5es correspondentes na sa\u00edda.</li> <li>Os resultados s\u00e3o retornados na mesma ordem dos dados de entrada.</li> </ul> Source code in <code>pyield/fwd.py</code> <pre><code>def forwards(\n    bdays: ArrayLike,\n    rates: ArrayLike,\n    group_by: Sequence[str | int | dt.date] | pl.Series | None = None,\n) -&gt; pl.Series:\n    r\"\"\"\n    Calcula taxas a termo a partir de taxas zero.\n\n    A taxa a termo no v\u00e9rtice 'n' \u00e9 definida como:\n\n        fwd\u2096 = fwd\u2c7c\u2192\u2096 (a taxa a termo de j para k)\n\n    Definindo o fator de capitaliza\u00e7\u00e3o no v\u00e9rtice k como:\n\n        f\u2096 = 1 + tx\u2096\n\n    A f\u00f3rmula utilizada \u00e9:\n\n        fwd\u2096 = (f\u2096^(du\u2096/252) / f\u2c7c^(du\u2c7c/252))^(252/(du\u2096 - du\u2c7c)) - 1\n\n    Como au = du/252 (tempo em anos \u00fateis), a f\u00f3rmula pode ser simplificada para:\n\n        fwd\u2096 = (f\u2096^au\u2096 / f\u2c7c^au\u2c7c)^(1/(au\u2096 - au\u2c7c)) - 1\n\n    Em LaTeX, a f\u00f3rmula \u00e9 representada como:\n\n    \\[\n    fwd_k = \\left( \\frac{f_k^{au_k}}{f_j^{au_j}} \\right)^{\\frac{1}{au_k - au_j}} - 1\n    \\]\n\n    Onde:\n    - f\u2c7c \u00e9 o fator de capitaliza\u00e7\u00e3o no v\u00e9rtice anterior (f\u2c7c = 1 + tx\u2c7c).\n    - f\u2096 \u00e9 o fator de capitaliza\u00e7\u00e3o no v\u00e9rtice atual (f\u2096 = 1 + tx\u2096).\n    - tx\u2c7c \u00e9 a taxa zero para o v\u00e9rtice anterior.\n    - tx\u2096 \u00e9 a taxa zero para o v\u00e9rtice atual.\n    - au\u2c7c \u00e9 o prazo em anos \u00fateis no v\u00e9rtice anterior (au\u2c7c = du\u2c7c/252).\n    - au\u2096 \u00e9 o prazo em anos \u00fateis no v\u00e9rtice atual (au\u2096 = du\u2096/252).\n    - A constante 252 representa o n\u00famero de dias \u00fateis no ano.\n\n    A fun\u00e7\u00e3o preserva a ordem original dos dados de entrada e lida com valores nulos\n    de forma apropriada. Valores nulos nas entradas resultar\u00e3o em valores nulos\n    nas taxas a termo calculadas.\n\n    A primeira taxa a termo de cada grupo \u00e9 definida como a\n    taxa zero desse primeiro v\u00e9rtice (fwd\u2081 = tx\u2081), dado que n\u00e3o existe um v\u00e9rtice\n    anterior a tx\u2081 para se calcular a taxa a termo no primeiro ponto.\n\n    A fun\u00e7\u00e3o tamb\u00e9m lida com agrupamentos opcionais, permitindo calcular taxas\n    a termo para diferentes grupos de datas. O agrupamento \u00e9 feito com base em `group_by`.\n    Se este argumento for None, todos os dados ser\u00e3o tratados como um \u00fanico grupo.\n\n    A fun\u00e7\u00e3o calcula as taxas a termo para todos os pontos, exceto o primeiro\n    de cada grupo, que \u00e9 tratado separadamente.\n\n    Args:\n        bdays (ArrayLike): N\u00famero de dias \u00fateis (du) para cada taxa zero.\n        rates (ArrayLike): Taxas zero (tx) correspondentes aos dias \u00fateis.\n        group_by (Sequence[str | int | date] | pl.Series | None, optional):\n            Crit\u00e9rio de agrupamento para os c\u00e1lculos (ex: datas de refer\u00eancia,\n            tickers de t\u00edtulos). Pode ser uma lista/s\u00e9rie de strings, inteiros\n            ou datas. Se None, todos os dados s\u00e3o tratados como um \u00fanico grupo.\n            Padr\u00e3o None.\n\n    Returns:\n        pl.Series: S\u00e9rie contendo as taxas a termo calculadas (tipo Float64).\n            A primeira taxa de cada grupo corresponde \u00e0 taxa zero inicial.\n\n    Raises:\n        polars.exceptions.ShapeError: Se os comprimentos de `bdays`, `rates`\n            e `group_by` (quando fornecido) n\u00e3o forem iguais.\n\n    Examples:\n        &gt;&gt;&gt; bdays = [10, 20, 30]\n        &gt;&gt;&gt; rates = [0.05, 0.06, 0.07]\n        &gt;&gt;&gt; yd.forwards(bdays, rates)\n        shape: (3,)\n        Series: 'fwd' [f64]\n        [\n            0.05\n            0.070095\n            0.090284\n        ]\n\n        &gt;&gt;&gt; # Exemplo com agrupamento (a \u00faltima est\u00e1 isolada em outro grupo)\n        &gt;&gt;&gt; group_by = [\"LTN\", \"LTN\", \"NTN-F\"]\n        &gt;&gt;&gt; yd.forwards(bdays, rates, group_by)\n        shape: (3,)\n        Series: 'fwd' [f64]\n        [\n            0.05\n            0.070095\n            0.07\n        ]\n\n        &gt;&gt;&gt; # Exemplo com taxas indicativas de NTN-B em 16-09-2025\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; df = ntnb.data(\"16-09-2025\")\n        &gt;&gt;&gt; yd.forwards(df[\"BDToMat\"], df[\"IndicativeRate\"])\n        shape: (13,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.071549\n            0.072439\n            0.069558\n            0.076614\n            \u2026\n            0.068105\n            0.071278\n            0.069117\n            0.070373\n            0.073286\n        ]\n\n        &gt;&gt;&gt; # Valores nulos s\u00e3o descartados no c\u00e1lculo e retornados como nulos\n        &gt;&gt;&gt; du = [230, 415, 730, None, 914]\n        &gt;&gt;&gt; tx = [0.0943, 0.084099, 0.079052, 0.1, 0.077134]\n        &gt;&gt;&gt; yd.forwards(du, tx)\n        shape: (5,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.071549\n            0.072439\n            null\n            0.069558\n        ]\n\n        &gt;&gt;&gt; # O algoritmo ordena os dados de entrada antes do c\u00e1lculo e retorna\n        &gt;&gt;&gt; # os resultados na ordem original. Valores duplicados s\u00e3o tratados\n        &gt;&gt;&gt; # como um \u00fanico ponto no c\u00e1lculo da taxa a termo (\u00faltimo valor \u00e9 mantido).\n        &gt;&gt;&gt; du = [230, 730, 415, 230]\n        &gt;&gt;&gt; tx = [0.1, 0.079052, 0.084099, 0.0943]\n        &gt;&gt;&gt; yd.forwards(du, tx)\n        shape: (4,)\n        Series: 'fwd' [f64]\n        [\n            0.0943\n            0.072439\n            0.071549\n            0.0943\n        ]\n\n    Notes:\n        - A fun\u00e7\u00e3o ordena os dados de entrada primeiro por `group_by`,\n          se for fornecido, e depois por `bdays` para garantir a ordem cronol\u00f3gica\n          correta no c\u00e1lculo das taxas a termo.\n        - Valores nulos em `bdays` ou `rates` s\u00e3o ignorados no c\u00e1lculo,\n          resultando em valores nulos nas posi\u00e7\u00f5es correspondentes na sa\u00edda.\n        - Os resultados s\u00e3o retornados na mesma ordem dos dados de entrada.\n    \"\"\"  # noqa: E501\n    # Valida\u00e7\u00f5es iniciais\n    if any_is_empty(bdays, rates):\n        return pl.Series(dtype=pl.Float64)\n\n    # 1. Montar o DataFrame\n    df_orig = pl.DataFrame(\n        {\n            \"du_k\": bdays,\n            \"tx_k\": rates,\n            \"group_by\": 0 if group_by is None else group_by,\n        }\n    )\n\n    # 2. Definir a f\u00f3rmula da taxa a termo\n    # Defini\u00e7\u00e3o dos fatores de capitaliza\u00e7\u00e3o:\n    # f\u2096 = 1 + tx\u2096 e f\u2c7c = 1 + tx\u2c7c\n    fk = 1 + pl.col(\"tx_k\")\n    fj = 1 + pl.col(\"tx_j\")\n    # fwd\u2096  = fwd\u2c7c\u2192\u2096 = (f\u2096^au\u2096 / f\u2c7c^au\u2c7c) ^ (1/(au\u2096 - au\u2c7c)) - 1\n    fator_k = fk ** pl.col(\"au_k\")\n    fator_j = fj ** pl.col(\"au_j\")\n    expoente = 1 / (pl.col(\"au_k\") - pl.col(\"au_j\"))  # 1/(au\u2096 - au\u2c7c)\n    fwd_exp = (fator_k / fator_j) ** expoente - 1\n\n    # 3. Calcular as taxas a termo\n    df_fwd = (\n        df_orig.drop_nans()\n        .drop_nulls()\n        .unique(subset=[\"du_k\", \"group_by\"], keep=\"last\")\n        .sort(\"group_by\", \"du_k\")\n        .with_columns(au_k=pl.col(\"du_k\") / 252)  # Criar coluna de anos \u00fateis\n        .with_columns(\n            # Calcular os valores deslocados (shift) dentro de cada grupo\n            tx_j=pl.col(\"tx_k\").shift(1).over(\"group_by\"),\n            au_j=pl.col(\"au_k\").shift(1).over(\"group_by\"),\n        )\n        .with_columns(fwd=fwd_exp)\n        .with_columns(\n            # A matriz de c\u00e1lculo j\u00e1 foi tratada: ela est\u00e1 deduplicada,\n            # sem nulos e ordenada por group_by e du_k. Ent\u00e3o, basta\n            # ajustar a primeira taxa fwd de cada grupo para ser igual \u00e0 taxa spot!\n            fwd=pl.when(pl.col(\"du_k\") == pl.first(\"du_k\").over(\"group_by\"))\n            .then(\"tx_k\")\n            .otherwise(\"fwd\")\n        )\n    )\n    # 4. Reunir os resultados na ordem original\n    df_orig = df_orig.join(\n        df_fwd.drop(\"tx_k\"),  # tx_k j\u00e1 existe em df_orig\n        on=[\"du_k\", \"group_by\"],\n        how=\"left\",\n        maintain_order=\"left\",\n    )\n\n    # Retornar a s\u00e9rie de taxas a termo\n    return df_orig[\"fwd\"]\n</code></pre>"},{"location":"futures/","title":"Futuros","text":""},{"location":"futures/#pyield.futures.futures","title":"<code>futures(date, contract_code)</code>","text":"<p>Fetches data for a specified futures contract based on type and reference date.</p> <p>Parameters:</p> Name Type Description Default <code>contract_code</code> <code>str</code> <p>The B3 futures contract code identifying the derivative. Supported contract codes are: - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3. - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3. - \"FRC\": Forward Rate Agreement (FRA). - \"FRO\": FRA DE CUPOM CAMBIAL EM OC1 - \"DAP\": DI x IPCA Spread Futures. - \"DOL\": U.S. Dollar Futures from B3. - \"WDO\": Mini U.S. Dollar Futures from B3. - \"IND\": Ibovespa Futures from B3. - \"WIN\": Mini Ibovespa Futures from B3.</p> required <code>date</code> <code>DateLike</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame containing the fetched data for the specified futures contract.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the futures contract code is not recognized or supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; futures(\"31-05-2024\", \"DI1\")\nshape: (40, 20)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 DI1M24       \u2506 2024-06-03     \u2506 1          \u2506 \u2026 \u2506 0.10404      \u2506 0.10404   \u2506 0.10399        \u2506 0.10399     \u2502\n\u2502 2024-05-31 \u2506 DI1N24       \u2506 2024-07-01     \u2506 21         \u2506 \u2026 \u2506 0.1039       \u2506 0.10386   \u2506 0.1039         \u2506 0.103896    \u2502\n\u2502 2024-05-31 \u2506 DI1Q24       \u2506 2024-08-01     \u2506 44         \u2506 \u2026 \u2506 0.10374      \u2506 0.10374   \u2506 0.1037         \u2506 0.103517    \u2502\n\u2502 2024-05-31 \u2506 DI1U24       \u2506 2024-09-02     \u2506 66         \u2506 \u2026 \u2506 0.10365      \u2506 0.10355   \u2506 0.1036         \u2506 0.1034      \u2502\n\u2502 2024-05-31 \u2506 DI1V24       \u2506 2024-10-01     \u2506 87         \u2506 \u2026 \u2506 0.1036       \u2506 0.10355   \u2506 0.1036         \u2506 0.1036      \u2502\n\u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-05-31 \u2506 DI1F35       \u2506 2035-01-02     \u2506 2654       \u2506 \u2026 \u2506 0.1193       \u2506 0.1192    \u2506 0.11907        \u2506 0.12179     \u2502\n\u2502 2024-05-31 \u2506 DI1F36       \u2506 2036-01-02     \u2506 2903       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11674     \u2502\n\u2502 2024-05-31 \u2506 DI1F37       \u2506 2037-01-02     \u2506 3156       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2502 2024-05-31 \u2506 DI1F38       \u2506 2038-01-04     \u2506 3405       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2502 2024-05-31 \u2506 DI1F39       \u2506 2039-01-03     \u2506 3656       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; futures(\"31-05-2024\", \"DAP\")\nshape: (22, 19)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n\u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n\u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-31 \u2506 DAPM24       \u2506 2024-06-17     \u2506 11         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.0555         \u2506 0.0555      \u2502\n\u2502 2024-05-31 \u2506 DAPN24       \u2506 2024-07-15     \u2506 31         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07524        \u2506 0.086254    \u2502\n\u2502 2024-05-31 \u2506 DAPQ24       \u2506 2024-08-15     \u2506 54         \u2506 \u2026 \u2506 null         \u2506 0.0885    \u2506 0.0885         \u2506 0.106631    \u2502\n\u2502 2024-05-31 \u2506 DAPU24       \u2506 2024-09-16     \u2506 76         \u2506 \u2026 \u2506 null         \u2506 0.0865    \u2506 0.0855         \u2506 0.078171    \u2502\n\u2502 2024-05-31 \u2506 DAPV24       \u2506 2024-10-15     \u2506 97         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07932        \u2506 0.057247    \u2502\n\u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2024-05-31 \u2506 DAPQ40       \u2506 2040-08-15     \u2506 4064       \u2506 \u2026 \u2506 null         \u2506 0.0609    \u2506 0.06099        \u2506 0.060553    \u2502\n\u2502 2024-05-31 \u2506 DAPK45       \u2506 2045-05-15     \u2506 5251       \u2506 \u2026 \u2506 null         \u2506 0.0619    \u2506 0.0588         \u2506 0.051336    \u2502\n\u2502 2024-05-31 \u2506 DAPQ50       \u2506 2050-08-15     \u2506 6566       \u2506 \u2026 \u2506 null         \u2506 0.0605    \u2506 0.06086        \u2506 0.069126    \u2502\n\u2502 2024-05-31 \u2506 DAPK55       \u2506 2055-05-17     \u2506 7755       \u2506 \u2026 \u2506 null         \u2506 0.0646    \u2506 0.06022        \u2506 0.056693    \u2502\n\u2502 2024-05-31 \u2506 DAPQ60       \u2506 2060-08-16     \u2506 9072       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.05821        \u2506 0.046451    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/b3/futures/core.py</code> <pre><code>def futures(\n    date: DateLike,\n    contract_code: OpcoesContrato | str,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches data for a specified futures contract based on type and reference date.\n\n    Args:\n        contract_code (str): The B3 futures contract code identifying the derivative.\n            Supported contract codes are:\n            - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3.\n            - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3.\n            - \"FRC\": Forward Rate Agreement (FRA).\n            - \"FRO\": FRA DE CUPOM CAMBIAL EM OC1\n            - \"DAP\": DI x IPCA Spread Futures.\n            - \"DOL\": U.S. Dollar Futures from B3.\n            - \"WDO\": Mini U.S. Dollar Futures from B3.\n            - \"IND\": Ibovespa Futures from B3.\n            - \"WIN\": Mini Ibovespa Futures from B3.\n        date (DateLike): The reference date for fetching the data.\n\n    Returns:\n        pl.DataFrame: DataFrame containing the fetched data for the specified futures\n            contract.\n\n    Raises:\n        ValueError: If the futures contract code is not recognized or supported.\n\n    Examples:\n        &gt;&gt;&gt; futures(\"31-05-2024\", \"DI1\")\n        shape: (40, 20)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 DI1M24       \u2506 2024-06-03     \u2506 1          \u2506 \u2026 \u2506 0.10404      \u2506 0.10404   \u2506 0.10399        \u2506 0.10399     \u2502\n        \u2502 2024-05-31 \u2506 DI1N24       \u2506 2024-07-01     \u2506 21         \u2506 \u2026 \u2506 0.1039       \u2506 0.10386   \u2506 0.1039         \u2506 0.103896    \u2502\n        \u2502 2024-05-31 \u2506 DI1Q24       \u2506 2024-08-01     \u2506 44         \u2506 \u2026 \u2506 0.10374      \u2506 0.10374   \u2506 0.1037         \u2506 0.103517    \u2502\n        \u2502 2024-05-31 \u2506 DI1U24       \u2506 2024-09-02     \u2506 66         \u2506 \u2026 \u2506 0.10365      \u2506 0.10355   \u2506 0.1036         \u2506 0.1034      \u2502\n        \u2502 2024-05-31 \u2506 DI1V24       \u2506 2024-10-01     \u2506 87         \u2506 \u2026 \u2506 0.1036       \u2506 0.10355   \u2506 0.1036         \u2506 0.1036      \u2502\n        \u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-05-31 \u2506 DI1F35       \u2506 2035-01-02     \u2506 2654       \u2506 \u2026 \u2506 0.1193       \u2506 0.1192    \u2506 0.11907        \u2506 0.12179     \u2502\n        \u2502 2024-05-31 \u2506 DI1F36       \u2506 2036-01-02     \u2506 2903       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11674     \u2502\n        \u2502 2024-05-31 \u2506 DI1F37       \u2506 2037-01-02     \u2506 3156       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2502 2024-05-31 \u2506 DI1F38       \u2506 2038-01-04     \u2506 3405       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2502 2024-05-31 \u2506 DI1F39       \u2506 2039-01-03     \u2506 3656       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.11887        \u2506 0.11887     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; futures(\"31-05-2024\", \"DAP\")\n        shape: (22, 19)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 TradeDate  \u2506 TickerSymbol \u2506 ExpirationDate \u2506 BDaysToExp \u2506 \u2026 \u2506 CloseBidRate \u2506 CloseRate \u2506 SettlementRate \u2506 ForwardRate \u2502\n        \u2502 ---        \u2506 ---          \u2506 ---            \u2506 ---        \u2506   \u2506 ---          \u2506 ---       \u2506 ---            \u2506 ---         \u2502\n        \u2502 date       \u2506 str          \u2506 date           \u2506 i64        \u2506   \u2506 f64          \u2506 f64       \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-31 \u2506 DAPM24       \u2506 2024-06-17     \u2506 11         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.0555         \u2506 0.0555      \u2502\n        \u2502 2024-05-31 \u2506 DAPN24       \u2506 2024-07-15     \u2506 31         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07524        \u2506 0.086254    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ24       \u2506 2024-08-15     \u2506 54         \u2506 \u2026 \u2506 null         \u2506 0.0885    \u2506 0.0885         \u2506 0.106631    \u2502\n        \u2502 2024-05-31 \u2506 DAPU24       \u2506 2024-09-16     \u2506 76         \u2506 \u2026 \u2506 null         \u2506 0.0865    \u2506 0.0855         \u2506 0.078171    \u2502\n        \u2502 2024-05-31 \u2506 DAPV24       \u2506 2024-10-15     \u2506 97         \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.07932        \u2506 0.057247    \u2502\n        \u2502 \u2026          \u2506 \u2026            \u2506 \u2026              \u2506 \u2026          \u2506 \u2026 \u2506 \u2026            \u2506 \u2026         \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2024-05-31 \u2506 DAPQ40       \u2506 2040-08-15     \u2506 4064       \u2506 \u2026 \u2506 null         \u2506 0.0609    \u2506 0.06099        \u2506 0.060553    \u2502\n        \u2502 2024-05-31 \u2506 DAPK45       \u2506 2045-05-15     \u2506 5251       \u2506 \u2026 \u2506 null         \u2506 0.0619    \u2506 0.0588         \u2506 0.051336    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ50       \u2506 2050-08-15     \u2506 6566       \u2506 \u2026 \u2506 null         \u2506 0.0605    \u2506 0.06086        \u2506 0.069126    \u2502\n        \u2502 2024-05-31 \u2506 DAPK55       \u2506 2055-05-17     \u2506 7755       \u2506 \u2026 \u2506 null         \u2506 0.0646    \u2506 0.06022        \u2506 0.056693    \u2502\n        \u2502 2024-05-31 \u2506 DAPQ60       \u2506 2060-08-16     \u2506 9072       \u2506 \u2026 \u2506 null         \u2506 null      \u2506 0.05821        \u2506 0.046451    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"  # noqa: E501\n    if any_is_empty(date, contract_code):\n        return pl.DataFrame()\n    data_negociacao = cv.converter_datas(date)\n\n    # Valida\u00e7\u00e3o centralizada (evita chamadas desnecess\u00e1rias \u00e0s APIs B3)\n    if not cm.data_negociacao_valida(data_negociacao):\n        logger.warning(\n            \"A data %s n\u00e3o \u00e9 v\u00e1lida. Retornando DataFrame vazio.\",\n            data_negociacao,\n        )\n        return pl.DataFrame()\n\n    contrato_selecionado = str(contract_code).upper()\n\n    if _data_intraday_valida(data_negociacao):\n        # \u00c9 um dia de negocia\u00e7\u00e3o intraday\n        horario_atual = clock.now().time()\n        if horario_atual &lt; HORA_INICIO_INTRADAY:  # Mercado n\u00e3o est\u00e1 aberto ainda\n            logger.warning(\"Mercado ainda n\u00e3o abriu. Retornando DataFrame vazio.\")\n            return pl.DataFrame()\n\n        # Existe a chance de que os dados consolidados estejam dispon\u00edveis ap\u00f3s as 18h\n        if horario_atual &gt;= HORA_FIM_INTRADAY:\n            df_hist = hcore.buscar_df_historico(data_negociacao, contrato_selecionado)\n            if not df_hist.is_empty():\n                logger.info(\"Dados consolidados dispon\u00edveis. Usando hist\u00f3rico.\")\n                return df_hist\n\n        # Mercado est\u00e1 aberto e n\u00e3o h\u00e1 dados consolidados dispon\u00edveis ainda\n        return fetch_intraday_df(contrato_selecionado)\n\n    else:  # \u00c9 um dia hist\u00f3rico\n        return hcore.buscar_df_historico(data_negociacao, contrato_selecionado)\n</code></pre>"},{"location":"interpolator/","title":"Interpolator","text":"<p>Classe interpoladora para interpola\u00e7\u00e3o de taxas de juros.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['flat_forward', 'linear']</code> <p>M\u00e9todo de interpola\u00e7\u00e3o a usar. Op\u00e7\u00f5es: \"flat_forward\" ou \"linear\".</p> required <code>known_bdays</code> <code>ArrayLike</code> <p>Sequ\u00eancia de dias \u00fateis (DU) conhecidos.</p> required <code>known_rates</code> <code>ArrayLike</code> <p>Sequ\u00eancia de taxas de juros conhecidas.</p> required <code>extrapolate</code> <code>bool</code> <p>Se True, extrapola al\u00e9m dos dias \u00fateis conhecidos usando a \u00faltima taxa dispon\u00edvel. Padr\u00e3o: False, retornando NaN para valores fora do intervalo.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se known_bdays e known_rates n\u00e3o tiverem o mesmo tamanho.</p> <code>ValueError</code> <p>Se o m\u00e9todo de interpola\u00e7\u00e3o n\u00e3o for reconhecido.</p> Notes <ul> <li>Esta classe usa conven\u00e7\u00e3o de 252 dias \u00fateis por ano.</li> <li>Na API p\u00fablica, os par\u00e2metros mant\u00eam o nome <code>bday</code>/<code>bdays</code> por   compatibilidade, mas o conceito de neg\u00f3cio \u00e9 DU (dias \u00fateis).</li> <li>Inst\u00e2ncias desta classe s\u00e3o imut\u00e1veis. Para modificar as   configura\u00e7\u00f5es de interpola\u00e7\u00e3o, crie uma nova inst\u00e2ncia.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import Interpolator\n&gt;&gt;&gt; dus = [30, 60, 90]\n&gt;&gt;&gt; txs = [0.045, 0.05, 0.055]\n</code></pre> <p>Interpola\u00e7\u00e3o linear:</p> <pre><code>&gt;&gt;&gt; linear = Interpolator(\"linear\", dus, txs)\n&gt;&gt;&gt; linear(45)\n0.0475\n</code></pre> <p>Interpola\u00e7\u00e3o flat forward:</p> <pre><code>&gt;&gt;&gt; fforward = Interpolator(\"flat_forward\", dus, txs)\n&gt;&gt;&gt; fforward(45)\n0.04833068080970859\n</code></pre> <p>Interpola\u00e7\u00e3o de array (polars mostra 6 casas decimais por padr\u00e3o):</p> <pre><code>&gt;&gt;&gt; fforward([15, 45, 75, 100])\nshape: (4,)\nSeries: 'interpolated_rate' [f64]\n[\n    0.045\n    0.048331\n    0.052997\n    null\n]\n</code></pre> <pre><code>&gt;&gt;&gt; print(fforward(100))  # Extrapola\u00e7\u00e3o desabilitada por padr\u00e3o\nnan\n</code></pre> <pre><code>&gt;&gt;&gt; print(fforward(-10))  # Entrada inv\u00e1lida retorna NaN\nnan\n</code></pre> <p>Se extrapola\u00e7\u00e3o estiver habilitada, a \u00faltima taxa conhecida \u00e9 usada:</p> <pre><code>&gt;&gt;&gt; fforward_extrap = Interpolator(\"flat_forward\", dus, txs, extrapolate=True)\n&gt;&gt;&gt; print(fforward_extrap(100))\n0.055\n</code></pre> Source code in <code>pyield/interpolator.py</code> <pre><code>def __init__(\n    self,\n    method: Literal[\"flat_forward\", \"linear\"],\n    known_bdays: ArrayLike,\n    known_rates: ArrayLike,\n    extrapolate: bool = False,\n):\n    df = (\n        pl.DataFrame({\"dus\": known_bdays, \"txs\": known_rates})\n        .with_columns(pl.col(\"dus\").cast(pl.Int64))\n        .with_columns(pl.col(\"txs\").cast(pl.Float64))\n        .drop_nulls()\n        .drop_nans()\n        .unique(subset=\"dus\", keep=\"last\")\n        .sort(\"dus\")\n    )\n    self._df = df\n    self._method = str(method)\n    self._dus = tuple(df.get_column(\"dus\"))\n    self._txs = tuple(df.get_column(\"txs\"))\n    self._extrapolate = bool(extrapolate)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.linear","title":"<code>linear(bday, k)</code>","text":"<p>Realiza interpola\u00e7\u00e3o de taxa de juros usando o m\u00e9todo linear.</p> <p>A taxa interpolada \u00e9 dada pela f\u00f3rmula: y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)</p> <p>Onde: - (x, y) \u00e9 o ponto a ser interpolado (du, tx_interpolada). - (x1, y1) \u00e9 o ponto conhecido anterior (du_j, tx_j). - (x2, y2) \u00e9 o pr\u00f3ximo ponto conhecido (du_k, tx_k).</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>N\u00famero de dias \u00fateis (DU) para os quais a taxa ser\u00e1 interpolada.</p> required <code>k</code> <code>int</code> <p>O \u00edndice tal que dus[k-1] &lt; bday &lt; dus[k].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Taxa de juros interpolada em forma decimal.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def linear(self, bday: int, k: int) -&gt; float:\n    \"\"\"Realiza interpola\u00e7\u00e3o de taxa de juros usando o m\u00e9todo linear.\n\n    A taxa interpolada \u00e9 dada pela f\u00f3rmula:\n    y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)\n\n    Onde:\n    - (x, y) \u00e9 o ponto a ser interpolado (du, tx_interpolada).\n    - (x1, y1) \u00e9 o ponto conhecido anterior (du_j, tx_j).\n    - (x2, y2) \u00e9 o pr\u00f3ximo ponto conhecido (du_k, tx_k).\n\n    Args:\n        bday: N\u00famero de dias \u00fateis (DU) para os quais a taxa ser\u00e1 interpolada.\n        k: O \u00edndice tal que dus[k-1] &lt; bday &lt; dus[k].\n\n    Returns:\n        Taxa de juros interpolada em forma decimal.\n    \"\"\"\n    du = bday\n    # Obt\u00e9m os pontos imediatamente anterior e posterior ao DU desejado.\n    du_j, tx_j = self._dus[k - 1], self._txs[k - 1]\n    du_k, tx_k = self._dus[k], self._txs[k]\n\n    return tx_j + (du - du_j) * (tx_k - tx_j) / (du_k - du_j)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.flat_forward","title":"<code>flat_forward(bday, k)</code>","text":"<p>Realiza interpola\u00e7\u00e3o de taxa de juros usando o m\u00e9todo flat forward.</p> <p>Este m\u00e9todo calcula a taxa de juros interpolada para um dado n\u00famero de dias \u00fateis (<code>bday</code>) usando a metodologia flat forward, baseada em dois pontos conhecidos: o ponto atual (<code>k</code>) e o ponto anterior (<code>j</code>).</p> <p>Assumindo taxas de juros em forma decimal, a taxa interpolada \u00e9 calculada. O tempo \u00e9 medido em anos baseado em 252 dias \u00fateis por ano.</p> <p>Definindo os fatores simples: - <code>f\u2c7c = 1 + tx\u2c7c</code> - <code>f\u2096 = 1 + tx\u2096</code></p> <p>A taxa interpolada \u00e9 dada pela f\u00f3rmula:</p> \\[ \\left(F_j*\\left(\\frac{F_k}{F_j}\\right)^{f_t}\\right)^{\\frac{1}{au}}-1 \\] <p>Onde os fatores usados na f\u00f3rmula s\u00e3o definidos como: - <code>F\u2c7c = f\u2c7c^au\u2c7c</code> \u00e9 o fator acumulado no ponto <code>j</code>. - <code>F\u2096 = f\u2096^au\u2096</code> \u00e9 o fator acumulado no ponto <code>k</code>. - <code>f\u209c = (au - au\u2c7c)/(au\u2096 - au\u2c7c)</code> \u00e9 o fator de tempo.</p> <p>E as vari\u00e1veis s\u00e3o definidas como: - <code>au = du/252</code> \u00e9 o tempo em anos para o ponto interpolado. <code>bday</code>   \u00e9 o n\u00famero de dias \u00fateis para o ponto interpolado (entrada deste m\u00e9todo). - <code>k</code> \u00e9 o \u00edndice do ponto conhecido atual. - <code>au\u2096 = du\u2096/252</code> \u00e9 o tempo em anos do ponto <code>k</code>. - <code>tx\u2096</code> \u00e9 a taxa de juros (decimal) no ponto <code>k</code>. - <code>j</code> \u00e9 o \u00edndice do ponto conhecido anterior (<code>k - 1</code>). - <code>au\u2c7c = du\u2c7c/252</code> \u00e9 o tempo em anos do ponto <code>j</code>. - <code>tx\u2c7c</code> \u00e9 a taxa de juros (decimal) no ponto <code>j</code>.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>N\u00famero de dias \u00fateis (DU) para os quais a taxa ser\u00e1 interpolada.</p> required <code>k</code> <code>int</code> <p>\u00cdndice tal que <code>dus[k-1] &lt; bday &lt; dus[k]</code>. Esse <code>k</code> corresponde ao pr\u00f3ximo v\u00e9rtice conhecido ap\u00f3s <code>bday</code>.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Taxa de juros interpolada em forma decimal.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def flat_forward(self, bday: int, k: int) -&gt; float:\n    r\"\"\"Realiza interpola\u00e7\u00e3o de taxa de juros usando o m\u00e9todo flat forward.\n\n    Este m\u00e9todo calcula a taxa de juros interpolada para um dado n\u00famero de\n    dias \u00fateis (``bday``) usando a metodologia flat forward, baseada em dois\n    pontos conhecidos: o ponto atual (``k``) e o ponto anterior (``j``).\n\n    Assumindo taxas de juros em forma decimal, a taxa interpolada \u00e9 calculada.\n    O tempo \u00e9 medido em anos baseado em 252 dias \u00fateis por ano.\n\n    Definindo os fatores simples:\n    - ``f\u2c7c = 1 + tx\u2c7c``\n    - ``f\u2096 = 1 + tx\u2096``\n\n    A taxa interpolada \u00e9 dada pela f\u00f3rmula:\n\n    \\[\n    \\left(F_j*\\left(\\frac{F_k}{F_j}\\right)^{f_t}\\right)^{\\frac{1}{au}}-1\n    \\]\n\n    Onde os fatores usados na f\u00f3rmula s\u00e3o definidos como:\n    - ``F\u2c7c = f\u2c7c^au\u2c7c`` \u00e9 o fator acumulado no ponto ``j``.\n    - ``F\u2096 = f\u2096^au\u2096`` \u00e9 o fator acumulado no ponto ``k``.\n    - ``f\u209c = (au - au\u2c7c)/(au\u2096 - au\u2c7c)`` \u00e9 o fator de tempo.\n\n    E as vari\u00e1veis s\u00e3o definidas como:\n    - ``au = du/252`` \u00e9 o tempo em anos para o ponto interpolado. ``bday``\n      \u00e9 o n\u00famero de dias \u00fateis para o ponto interpolado (entrada deste m\u00e9todo).\n    - ``k`` \u00e9 o \u00edndice do ponto conhecido atual.\n    - ``au\u2096 = du\u2096/252`` \u00e9 o tempo em anos do ponto ``k``.\n    - ``tx\u2096`` \u00e9 a taxa de juros (decimal) no ponto ``k``.\n    - ``j`` \u00e9 o \u00edndice do ponto conhecido anterior (``k - 1``).\n    - ``au\u2c7c = du\u2c7c/252`` \u00e9 o tempo em anos do ponto ``j``.\n    - ``tx\u2c7c`` \u00e9 a taxa de juros (decimal) no ponto ``j``.\n\n    Args:\n        bday: N\u00famero de dias \u00fateis (DU) para os quais a taxa ser\u00e1 interpolada.\n        k: \u00cdndice tal que ``dus[k-1] &lt; bday &lt; dus[k]``. Esse ``k``\n            corresponde ao pr\u00f3ximo v\u00e9rtice conhecido ap\u00f3s ``bday``.\n\n    Returns:\n        Taxa de juros interpolada em forma decimal.\n    \"\"\"\n    du = bday\n    tx_j = self._txs[k - 1]\n    au_j = self._dus[k - 1] / 252\n    tx_k = self._txs[k]\n    au_k = self._dus[k] / 252\n    au = du / 252\n\n    # Siglas: fs = fator simples; fa = fator acumulado; ft = fator de tempo.\n    fs_j = 1 + tx_j\n    fs_k = 1 + tx_k\n    fa_j = fs_j**au_j\n    fa_k = fs_k**au_k\n    ft = (au - au_j) / (au_k - au_j)\n    return (fa_j * (fa_k / fa_j) ** ft) ** (1 / au) - 1\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.interpolate","title":"<code>interpolate(bdays)</code>","text":"<p>Interpola taxas para dia(s) \u00fatil(eis) fornecido(s).</p> <p>Parameters:</p> Name Type Description Default <code>bdays</code> <code>int | ArrayLike</code> <p>DU(s) para interpola\u00e7\u00e3o. Aceita int ou ArrayLike.</p> required <p>Returns:</p> Type Description <code>float | Series</code> <p>Taxa(s) interpolada(s). Float para entrada escalar, pl.Series para array.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bdays: int | ArrayLike) -&gt; float | pl.Series:\n    \"\"\"Interpola taxas para dia(s) \u00fatil(eis) fornecido(s).\n\n    Args:\n        bdays: DU(s) para interpola\u00e7\u00e3o. Aceita int ou ArrayLike.\n\n    Returns:\n        Taxa(s) interpolada(s). Float para entrada escalar, pl.Series para array.\n    \"\"\"\n    if is_collection(bdays):\n        s_dus = pl.Series(name=\"interpolated_rate\", values=bdays, dtype=pl.Int64)\n        result = s_dus.map_elements(\n            self._interpolated_rate, return_dtype=pl.Float64\n        )\n        return result.fill_nan(None)\n\n    # Aceita qualquer tipo integral (int, np.int64, etc) e rejeita float/string.\n    elif isinstance(bdays, numbers.Integral):\n        return self._interpolated_rate(int(bdays))\n\n    else:\n        raise TypeError(\"bdays deve ser int ou uma estrutura array-like.\")\n</code></pre>"},{"location":"ipca/","title":"IPCA","text":""},{"location":"ipca/#pyield.ipca.indexes","title":"<code>indexes(start, end)</code>","text":"<p>Obt\u00e9m os valores do n\u00famero-\u00edndice do IPCA para um intervalo de datas.</p> <p>Realiza chamada \u00e0 API do portal de dados do IBGE no formato: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]</p> <p>Exemplo: Para o intervalo \"01-01-2024\" a \"31-03-2024\", a URL ser\u00e1: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>Data de in\u00edcio do intervalo.</p> required <code>end</code> <code>DateLike</code> <p>Data de fim do intervalo.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com colunas 'Period' e 'Value'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Obter os n\u00fameros-\u00edndice do IPCA para o primeiro trimestre de 2025\n&gt;&gt;&gt; ipca.indexes(start=\"01-01-2025\", end=\"01-03-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Period \u2506 Value   \u2502\n\u2502 ---    \u2506 ---     \u2502\n\u2502 i64    \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 202501 \u2506 7111.86 \u2502\n\u2502 202502 \u2506 7205.03 \u2502\n\u2502 202503 \u2506 7245.38 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def indexes(start: DateLike, end: DateLike) -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m os valores do n\u00famero-\u00edndice do IPCA para um intervalo de datas.\n\n    Realiza chamada \u00e0 API do portal de dados do IBGE no formato:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]\n\n    Exemplo: Para o intervalo \"01-01-2024\" a \"31-03-2024\", a URL ser\u00e1:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]\n\n    Args:\n        start (DateLike): Data de in\u00edcio do intervalo.\n        end (DateLike): Data de fim do intervalo.\n\n    Returns:\n        pl.DataFrame: DataFrame com colunas 'Period' e 'Value'.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Obter os n\u00fameros-\u00edndice do IPCA para o primeiro trimestre de 2025\n        &gt;&gt;&gt; ipca.indexes(start=\"01-01-2025\", end=\"01-03-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Period \u2506 Value   \u2502\n        \u2502 ---    \u2506 ---     \u2502\n        \u2502 i64    \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 202501 \u2506 7111.86 \u2502\n        \u2502 202502 \u2506 7205.03 \u2502\n        \u2502 202503 \u2506 7245.38 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(start, end):\n        return pl.DataFrame()\n    start = converter_datas(start)\n    end = converter_datas(end)\n\n    data_inicio = start.strftime(\"%Y%m\")\n    data_fim = end.strftime(\"%Y%m\")\n    url_api = f\"{IPCA_URL}{data_inicio}-{data_fim}/variaveis/2266?localidades=N1[all]\"\n    dados = _buscar_dados_api(url_api)\n\n    return _processar_df_ipca(dados)\n</code></pre>"},{"location":"ipca/#pyield.ipca.last_indexes","title":"<code>last_indexes(qtd_meses=1)</code>","text":"<p>Obt\u00e9m os \u00faltimos valores do n\u00famero-\u00edndice do IPCA para um n\u00famero especificado de meses.</p> <p>Realiza chamada \u00e0 API do portal de dados do IBGE no formato: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]</p> <p>Exemplo: Para os \u00faltimos 2 meses, a URL ser\u00e1: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>qtd_meses</code> <code>int</code> <p>N\u00famero de meses a recuperar. Padr\u00e3o: 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com colunas 'Period' e 'Value'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se qtd_meses for menor ou igual a 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Obter o n\u00famero-\u00edndice do IPCA do \u00faltimo m\u00eas\n&gt;&gt;&gt; df = ipca.last_indexes(1)\n&gt;&gt;&gt; # Obter os n\u00fameros-\u00edndice do IPCA dos \u00faltimos 3 meses\n&gt;&gt;&gt; df = ipca.last_indexes(3)\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def last_indexes(qtd_meses: int = 1) -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m os \u00faltimos valores do n\u00famero-\u00edndice do IPCA para um n\u00famero\n    especificado de meses.\n\n    Realiza chamada \u00e0 API do portal de dados do IBGE no formato:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]\n\n    Exemplo: Para os \u00faltimos 2 meses, a URL ser\u00e1:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]\n\n    Args:\n        qtd_meses (int, optional): N\u00famero de meses a recuperar. Padr\u00e3o: 1.\n\n    Returns:\n        pl.DataFrame: DataFrame com colunas 'Period' e 'Value'.\n\n    Raises:\n        ValueError: Se qtd_meses for menor ou igual a 0.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Obter o n\u00famero-\u00edndice do IPCA do \u00faltimo m\u00eas\n        &gt;&gt;&gt; df = ipca.last_indexes(1)\n        &gt;&gt;&gt; # Obter os n\u00fameros-\u00edndice do IPCA dos \u00faltimos 3 meses\n        &gt;&gt;&gt; df = ipca.last_indexes(3)\n    \"\"\"\n    if qtd_meses &lt;= 0:\n        raise ValueError(\"O n\u00famero de meses deve ser maior que 0.\")\n\n    url_api = f\"{IPCA_URL}-{qtd_meses}/variaveis/2266?localidades=N1[all]\"\n    dados = _buscar_dados_api(url_api)\n\n    return _processar_df_ipca(dados)\n</code></pre>"},{"location":"ipca/#pyield.ipca.last_rates","title":"<code>last_rates(qtd_meses=1)</code>","text":"<p>Obt\u00e9m as \u00faltimas taxas mensais do IPCA para um n\u00famero especificado de meses.</p> <p>Realiza chamada \u00e0 API do portal de dados do IBGE no formato: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]</p> <p>Exemplo: Para os \u00faltimos 2 meses, a URL ser\u00e1: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>qtd_meses</code> <code>int</code> <p>N\u00famero de meses a recuperar. Padr\u00e3o: 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com colunas 'Period' e 'Value'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se qtd_meses for menor ou igual a 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Obter a taxa do IPCA do \u00faltimo m\u00eas\n&gt;&gt;&gt; df = ipca.last_rates(1)\n&gt;&gt;&gt; # Obter as taxas do IPCA dos \u00faltimos 3 meses\n&gt;&gt;&gt; df = ipca.last_rates(3)\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def last_rates(qtd_meses: int = 1) -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m as \u00faltimas taxas mensais do IPCA para um n\u00famero especificado de meses.\n\n    Realiza chamada \u00e0 API do portal de dados do IBGE no formato:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]\n\n    Exemplo: Para os \u00faltimos 2 meses, a URL ser\u00e1:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]\n\n    Args:\n        qtd_meses (int, optional): N\u00famero de meses a recuperar. Padr\u00e3o: 1.\n\n    Returns:\n        pl.DataFrame: DataFrame com colunas 'Period' e 'Value'.\n\n    Raises:\n        ValueError: Se qtd_meses for menor ou igual a 0.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Obter a taxa do IPCA do \u00faltimo m\u00eas\n        &gt;&gt;&gt; df = ipca.last_rates(1)\n        &gt;&gt;&gt; # Obter as taxas do IPCA dos \u00faltimos 3 meses\n        &gt;&gt;&gt; df = ipca.last_rates(3)\n    \"\"\"\n    if qtd_meses &lt;= 0:\n        raise ValueError(\"O n\u00famero de meses deve ser maior que 0.\")\n\n    url_api = f\"{IPCA_URL}-{qtd_meses}/variaveis/63?localidades=N1[all]\"\n    dados = _buscar_dados_api(url_api)\n\n    return _processar_df_ipca(dados, em_percentual=True)\n</code></pre>"},{"location":"ipca/#pyield.ipca.projected_rate","title":"<code>projected_rate()</code>","text":"<p>Obt\u00e9m a proje\u00e7\u00e3o atual do IPCA no site da ANBIMA.</p> <p>A fun\u00e7\u00e3o acessa a p\u00e1gina de indicadores da ANBIMA e extrai os dados da proje\u00e7\u00e3o do IPCA diretamente do HTML usando express\u00f5es regulares.</p> <p>Returns:</p> Name Type Description <code>ProjecaoIndicador</code> <code>ProjecaoIndicador</code> <p>Objeto contendo: - ultima_atualizacao (dt.datetime): Data e hora da \u00faltima atualiza\u00e7\u00e3o. - periodo_referencia (str): Per\u00edodo de refer\u00eancia no formato \"MMM/YY\"   (ex.: \"jan/26\"). - valor_projetado (float): Valor projetado do IPCA (decimal).</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>Se houver erro de conex\u00e3o com o site da ANBIMA.</p> <code>ValueError</code> <p>Se os padr\u00f5es esperados n\u00e3o forem encontrados no HTML.</p> Notes <ul> <li>Requer conex\u00e3o com a internet para acessar o site da ANBIMA.</li> <li>A extra\u00e7\u00e3o depende de padr\u00f5es de texto no HTML. Mudan\u00e7as na estrutura   da p\u00e1gina podem afetar o resultado.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Obter a proje\u00e7\u00e3o atual do IPCA na ANBIMA\n&gt;&gt;&gt; ipca.projected_rate()\nProjecaoIndicador(ultima_atualizacao=..., periodo_referencia=..., valor_projetado=...)\n</code></pre> Source code in <code>pyield/ipca/projected.py</code> <pre><code>def projected_rate() -&gt; ProjecaoIndicador:\n    \"\"\"\n    Obt\u00e9m a proje\u00e7\u00e3o atual do IPCA no site da ANBIMA.\n\n    A fun\u00e7\u00e3o acessa a p\u00e1gina de indicadores da ANBIMA e extrai os dados da\n    proje\u00e7\u00e3o do IPCA diretamente do HTML usando express\u00f5es regulares.\n\n    Returns:\n        ProjecaoIndicador: Objeto contendo:\n            - ultima_atualizacao (dt.datetime): Data e hora da \u00faltima atualiza\u00e7\u00e3o.\n            - periodo_referencia (str): Per\u00edodo de refer\u00eancia no formato \"MMM/YY\"\n              (ex.: \"jan/26\").\n            - valor_projetado (float): Valor projetado do IPCA (decimal).\n\n    Raises:\n        ConnectionError: Se houver erro de conex\u00e3o com o site da ANBIMA.\n        ValueError: Se os padr\u00f5es esperados n\u00e3o forem encontrados no HTML.\n\n    Notes:\n        - Requer conex\u00e3o com a internet para acessar o site da ANBIMA.\n        - A extra\u00e7\u00e3o depende de padr\u00f5es de texto no HTML. Mudan\u00e7as na estrutura\n          da p\u00e1gina podem afetar o resultado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Obter a proje\u00e7\u00e3o atual do IPCA na ANBIMA\n        &gt;&gt;&gt; ipca.projected_rate()\n        ProjecaoIndicador(ultima_atualizacao=..., periodo_referencia=..., valor_projetado=...)\n    \"\"\"  # noqa:E501\n    # 1. Obt\u00e9m o texto j\u00e1 decodificado (str)\n    html = _buscar_texto_pagina()\n\n    # 2. Extrair Data de Atualiza\u00e7\u00e3o\n    # Procura por: \"Data e Hora da \u00daltima Atualiza\u00e7\u00e3o: 23/01/2026 - 16:48 h\"\n    padrao_atualizacao = r\"Data e Hora da \u00daltima Atualiza\u00e7\u00e3o:\\s*([0-9]{2}/[0-9]{2}/[0-9]{4}\\s*-\\s*[0-9]{2}:[0-9]{2})\"  # noqa:E501\n\n    correspondencia_atualizacao = re.search(padrao_atualizacao, html)\n    if not correspondencia_atualizacao:\n        raise ValueError(\"N\u00e3o foi poss\u00edvel encontrar a data de atualiza\u00e7\u00e3o na p\u00e1gina.\")\n\n    texto_atualizacao = correspondencia_atualizacao.group(1)\n    # Remove espa\u00e7os extras que possam existir na captura\n    texto_atualizacao = texto_atualizacao.replace(\" - \", \"-\").strip()\n\n    # Formato esperado: \"23/01/2026-16:48\"\n    try:\n        ultima_atualizacao = dt.datetime.strptime(texto_atualizacao, \"%d/%m/%Y-%H:%M\")\n    except ValueError:\n        # Fallback caso o espa\u00e7o seja mantido ou o formato varie levemente\n        ultima_atualizacao = dt.datetime.strptime(\n            correspondencia_atualizacao.group(1), \"%d/%m/%Y - %H:%M\"\n        )\n\n    # 3. Extrair Bloco do IPCA\n    # Regex explicado:\n    # IPCA.*?         -&gt; Encontra IPCA e avan\u00e7a (ignora o IPCA \u00edndice, busca o pr\u00f3ximo)\n    # Proje\u00e7\u00e3o\\s*\\(   -&gt; Encontra \"Proje\u00e7\u00e3o (\"\n    # (.*?)           -&gt; GRUPO 1: Captura o per\u00edodo (ex.: jan/26)\n    # \\)              -&gt; Fecha par\u00eanteses\n    # .*?&gt;            -&gt; Avan\u00e7a at\u00e9 fechar a pr\u00f3xima tag HTML (&lt;td&gt;)\n    # ([0-9]+,[0-9]+) -&gt; GRUPO 2: Captura o valor (ex.: 0,36)\n    # &lt;               -&gt; Garante que o n\u00famero acabou\n\n    padrao_ipca = r\"IPCA.*?Proje\u00e7\u00e3o\\s*\\((.*?)\\).*?&gt;([0-9]+,[0-9]+)&lt;\"\n\n    # Passamos flags= explicitamente para satisfazer linters estritos\n    correspondencia_ipca = re.search(padrao_ipca, html, flags=re.DOTALL | re.IGNORECASE)\n\n    if not correspondencia_ipca:\n        raise ValueError(\"N\u00e3o foi poss\u00edvel encontrar os dados de proje\u00e7\u00e3o do IPCA.\")\n\n    periodo_referencia = correspondencia_ipca.group(1)  # Ex.: jan/26\n    texto_valor = correspondencia_ipca.group(2)  # Ex.: 0,36\n\n    # Convers\u00e3o de valores\n    valor_projetado = float(texto_valor.replace(\",\", \".\")) / 100\n    valor_projetado = round(valor_projetado, 4)\n\n    return ProjecaoIndicador(\n        ultima_atualizacao=ultima_atualizacao,\n        periodo_referencia=periodo_referencia,\n        valor_projetado=valor_projetado,\n    )\n</code></pre>"},{"location":"ipca/#pyield.ipca.rates","title":"<code>rates(start, end)</code>","text":"<p>Obt\u00e9m as taxas mensais do IPCA para um intervalo de datas.</p> <p>Realiza chamada \u00e0 API do portal de dados do IBGE no formato: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]</p> <p>Exemplo: Para o intervalo \"01-01-2024\" a \"31-03-2024\", a URL ser\u00e1: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateLike</code> <p>Data de in\u00edcio do intervalo.</p> required <code>end</code> <code>DateLike</code> <p>Data de fim do intervalo.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com colunas 'Period' e 'Value'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ipca\n&gt;&gt;&gt; # Obter as taxas do IPCA para o primeiro trimestre de 2025\n&gt;&gt;&gt; ipca.rates(\"01-01-2025\", \"01-03-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Period \u2506 Value  \u2502\n\u2502 ---    \u2506 ---    \u2502\n\u2502 i64    \u2506 f64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 202501 \u2506 0.0016 \u2502\n\u2502 202502 \u2506 0.0131 \u2502\n\u2502 202503 \u2506 0.0056 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/ipca/historical.py</code> <pre><code>def rates(start: DateLike, end: DateLike) -&gt; pl.DataFrame:\n    \"\"\"Obt\u00e9m as taxas mensais do IPCA para um intervalo de datas.\n\n    Realiza chamada \u00e0 API do portal de dados do IBGE no formato:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]\n\n    Exemplo: Para o intervalo \"01-01-2024\" a \"31-03-2024\", a URL ser\u00e1:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]\n\n    Args:\n        start (DateLike): Data de in\u00edcio do intervalo.\n        end (DateLike): Data de fim do intervalo.\n\n    Returns:\n        pl.DataFrame: DataFrame com colunas 'Period' e 'Value'.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ipca\n        &gt;&gt;&gt; # Obter as taxas do IPCA para o primeiro trimestre de 2025\n        &gt;&gt;&gt; ipca.rates(\"01-01-2025\", \"01-03-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Period \u2506 Value  \u2502\n        \u2502 ---    \u2506 ---    \u2502\n        \u2502 i64    \u2506 f64    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 202501 \u2506 0.0016 \u2502\n        \u2502 202502 \u2506 0.0131 \u2502\n        \u2502 202503 \u2506 0.0056 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(start, end):\n        return pl.DataFrame()\n    start = converter_datas(start)\n    end = converter_datas(end)\n\n    data_inicio = start.strftime(\"%Y%m\")\n    data_fim = end.strftime(\"%Y%m\")\n    url_api = f\"{IPCA_URL}{data_inicio}-{data_fim}/variaveis/63?localidades=N1[all]\"\n    dados = _buscar_dados_api(url_api)\n\n    return _processar_df_ipca(dados, em_percentual=True)\n</code></pre>"},{"location":"lft/","title":"LFT","text":""},{"location":"lft/#pyield.tn.lft.data","title":"<code>data(date)</code>","text":"<p>Busca as taxas indicativas de LFT para a data de refer\u00eancia na ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame Polars com os dados de LFT.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo (ex.: \"LFT\").</li> <li>ReferenceDate (Date): Data de refer\u00eancia dos dados.</li> <li>SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento do t\u00edtulo.</li> <li>BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.</li> <li>Duration (Float64): Macaulay Duration do t\u00edtulo (anos).</li> <li>DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.</li> <li>DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.</li> <li>Price (Float64): Pre\u00e7o unit\u00e1rio (PU).</li> <li>BidRate (Float64): Taxa de compra (decimal).</li> <li>AskRate (Float64): Taxa de venda (decimal).</li> <li>IndicativeRate (Float64): Taxa indicativa (decimal).</li> <li>DIRate (Float64): Taxa DI interpolada (flat forward).</li> <li>StdDev (Float64): Desvio padr\u00e3o da taxa indicativa.</li> <li>LowerBoundRateD0 (Float64): Limite inferior do intervalo (D+0).</li> <li>UpperBoundRateD0 (Float64): Limite superior do intervalo (D+0).</li> <li>LowerBoundRateD1 (Float64): Limite inferior do intervalo (D+1).</li> <li>UpperBoundRateD1 (Float64): Limite superior do intervalo (D+1).</li> <li>Criteria (String): Crit\u00e9rio utilizado pela ANBIMA.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.data(\"23-08-2024\")\nshape: (14, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000306  \u2506 0.000226  \u2506 0.000272       \u2506 0.10408  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000397 \u2506 -0.000481 \u2506 -0.000418      \u2506 0.11082  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000205 \u2506 -0.000258 \u2506 -0.00023       \u2506 0.114315 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000085  \u2506 0.00006   \u2506 0.000075       \u2506 0.114982 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000124  \u2506 0.000097  \u2506 0.000114       \u2506 0.114955 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001501  \u2506 0.001476  \u2506 0.001491       \u2506 0.11564  \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001597  \u2506 0.001571  \u2506 0.001587       \u2506 0.115773 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001601  \u2506 0.001574  \u2506 0.001591       \u2506 0.115904 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001649  \u2506 0.001627  \u2506 0.001641       \u2506 0.115854 \u2502\n\u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001696  \u2506 0.00168   \u2506 0.001687       \u2506 0.115806 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Busca as taxas indicativas de LFT para a data de refer\u00eancia na ANBIMA.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.DataFrame: DataFrame Polars com os dados de LFT.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo (ex.: \"LFT\").\n        - ReferenceDate (Date): Data de refer\u00eancia dos dados.\n        - SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento do t\u00edtulo.\n        - BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.\n        - Duration (Float64): Macaulay Duration do t\u00edtulo (anos).\n        - DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.\n        - DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.\n        - Price (Float64): Pre\u00e7o unit\u00e1rio (PU).\n        - BidRate (Float64): Taxa de compra (decimal).\n        - AskRate (Float64): Taxa de venda (decimal).\n        - IndicativeRate (Float64): Taxa indicativa (decimal).\n        - DIRate (Float64): Taxa DI interpolada (flat forward).\n        - StdDev (Float64): Desvio padr\u00e3o da taxa indicativa.\n        - LowerBoundRateD0 (Float64): Limite inferior do intervalo (D+0).\n        - UpperBoundRateD0 (Float64): Limite superior do intervalo (D+0).\n        - LowerBoundRateD1 (Float64): Limite inferior do intervalo (D+1).\n        - UpperBoundRateD1 (Float64): Limite superior do intervalo (D+1).\n        - Criteria (String): Crit\u00e9rio utilizado pela ANBIMA.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.data(\"23-08-2024\")\n        shape: (14, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate   \u2506 AskRate   \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---       \u2506 ---       \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64       \u2506 f64       \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000306  \u2506 0.000226  \u2506 0.000272       \u2506 0.10408  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000397 \u2506 -0.000481 \u2506 -0.000418      \u2506 0.11082  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 -0.000205 \u2506 -0.000258 \u2506 -0.00023       \u2506 0.114315 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000085  \u2506 0.00006   \u2506 0.000075       \u2506 0.114982 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.000124  \u2506 0.000097  \u2506 0.000114       \u2506 0.114955 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026         \u2506 \u2026         \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001501  \u2506 0.001476  \u2506 0.001491       \u2506 0.11564  \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001597  \u2506 0.001571  \u2506 0.001587       \u2506 0.115773 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001601  \u2506 0.001574  \u2506 0.001591       \u2506 0.115904 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001649  \u2506 0.001627  \u2506 0.001641       \u2506 0.115854 \u2502\n        \u2502 2024-08-23    \u2506 LFT      \u2506 210100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.001696  \u2506 0.00168   \u2506 0.001687       \u2506 0.115806 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"LFT\")\n</code></pre>"},{"location":"lft/#pyield.tn.lft.maturities","title":"<code>maturities(date)</code>","text":"<p>Busca os vencimentos dispon\u00edveis para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie de datas de vencimento dispon\u00edveis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.maturities(\"22-08-2024\")\nshape: (14,)\nSeries: 'MaturityDate' [date]\n[\n    2024-09-01\n    2025-03-01\n    2025-09-01\n    2026-03-01\n    2026-09-01\n    \u2026\n    2029-03-01\n    2029-09-01\n    2030-03-01\n    2030-06-01\n    2030-09-01\n]\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def maturities(date: DateLike) -&gt; pl.Series:\n    \"\"\"\n    Busca os vencimentos dispon\u00edveis para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.Series: S\u00e9rie de datas de vencimento dispon\u00edveis.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.maturities(\"22-08-2024\")\n        shape: (14,)\n        Series: 'MaturityDate' [date]\n        [\n            2024-09-01\n            2025-03-01\n            2025-09-01\n            2026-03-01\n            2026-09-01\n            \u2026\n            2029-03-01\n            2029-09-01\n            2030-03-01\n            2030-06-01\n            2030-09-01\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"lft/#pyield.tn.lft.premium","title":"<code>premium(lft_rate, di_rate)</code>","text":"<p>Calcula o pr\u00eamio da LFT sobre a taxa de DI Futuro.</p> <p>Parameters:</p> Name Type Description Default <code>lft_rate</code> <code>float</code> <p>Taxa anualizada da LFT sobre a Selic.</p> required <code>di_rate</code> <code>float</code> <p>Taxa DI Futuro anualizada (interpolada para o mesmo vencimento da LFT).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pr\u00eamio da LFT sobre o DI.</p> <p>Examples:</p> <p>Calcula o pr\u00eamio de uma LFT em 28/04/2025:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft_rate = 0.001124  # 0.1124%\n&gt;&gt;&gt; di_rate = 0.13967670224373396  # 13.967670224373396%\n&gt;&gt;&gt; lft.premium(lft_rate, di_rate)\n1.008594331960501\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def premium(lft_rate: float, di_rate: float) -&gt; float:\n    \"\"\"\n    Calcula o pr\u00eamio da LFT sobre a taxa de DI Futuro.\n\n    Args:\n        lft_rate (float): Taxa anualizada da LFT sobre a Selic.\n        di_rate (float): Taxa DI Futuro anualizada (interpolada para o mesmo\n            vencimento da LFT).\n\n    Returns:\n        float: Pr\u00eamio da LFT sobre o DI.\n\n    Examples:\n        Calcula o pr\u00eamio de uma LFT em 28/04/2025:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft_rate = 0.001124  # 0.1124%\n        &gt;&gt;&gt; di_rate = 0.13967670224373396  # 13.967670224373396%\n        &gt;&gt;&gt; lft.premium(lft_rate, di_rate)\n        1.008594331960501\n    \"\"\"\n    if any_is_empty(lft_rate, di_rate):\n        return float(\"nan\")\n    # Taxa di\u00e1ria\n    fator_lft = (lft_rate + 1) ** (1 / 252)\n    fator_di = (di_rate + 1) ** (1 / 252)\n    return (fator_lft * fator_di - 1) / (fator_di - 1)\n</code></pre>"},{"location":"lft/#pyield.tn.lft.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calcula o pre\u00e7o da LFT pelas regras do Tesouro Nacional.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>Valor nominal atualizado (VNA).</p> required <code>quotation</code> <code>float</code> <p>Cota\u00e7\u00e3o da LFT em base 100.</p> required <p>Returns:     float: Pre\u00e7o da LFT truncado em 6 casas decimais.</p> References <ul> <li>SEI Proccess 17944.005214/2024-09</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.price(15785.324502, 99.9291)\n15774.132706\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o pre\u00e7o da LFT pelas regras do Tesouro Nacional.\n\n    Args:\n        vna (float): Valor nominal atualizado (VNA).\n        quotation (float): Cota\u00e7\u00e3o da LFT em base 100.\n    Returns:\n        float: Pre\u00e7o da LFT truncado em 6 casas decimais.\n\n    References:\n         - SEI Proccess 17944.005214/2024-09\n\n    Examples:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.price(15785.324502, 99.9291)\n        15774.132706\n    \"\"\"\n    if any_is_empty(vna, quotation):\n        return float(\"nan\")\n    return tools.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"lft/#pyield.tn.lft.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calcula a cota\u00e7\u00e3o de uma LFT pelas regras da ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o do t\u00edtulo.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento do t\u00edtulo.</p> required <code>rate</code> <code>float</code> <p>Taxa anualizada do t\u00edtulo.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Cota\u00e7\u00e3o do t\u00edtulo.</p> <p>Examples:</p> <p>Calcula a cota\u00e7\u00e3o de uma LFT com taxa de 0,02:</p> <pre><code>&gt;&gt;&gt; from pyield import lft\n&gt;&gt;&gt; lft.quotation(\n...     settlement=\"24-07-2024\",\n...     maturity=\"01-09-2030\",\n...     rate=0.001717,  # 0.1717%\n... )\n98.9645\n</code></pre> <p>Entradas nulas retornam float('nan'):</p> <pre><code>&gt;&gt;&gt; lft.quotation(settlement=None, maturity=\"01-09-2030\", rate=0.001717)\nnan\n</code></pre> Source code in <code>pyield/tn/lft.py</code> <pre><code>def quotation(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula a cota\u00e7\u00e3o de uma LFT pelas regras da ANBIMA.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o do t\u00edtulo.\n        maturity (DateLike): Data de vencimento do t\u00edtulo.\n        rate (float): Taxa anualizada do t\u00edtulo.\n\n    Returns:\n        float: Cota\u00e7\u00e3o do t\u00edtulo.\n\n    Examples:\n        Calcula a cota\u00e7\u00e3o de uma LFT com taxa de 0,02:\n        &gt;&gt;&gt; from pyield import lft\n        &gt;&gt;&gt; lft.quotation(\n        ...     settlement=\"24-07-2024\",\n        ...     maturity=\"01-09-2030\",\n        ...     rate=0.001717,  # 0.1717%\n        ... )\n        98.9645\n\n        Entradas nulas retornam float('nan'):\n        &gt;&gt;&gt; lft.quotation(settlement=None, maturity=\"01-09-2030\", rate=0.001717)\n        nan\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n    # N\u00famero de dias \u00fateis entre liquida\u00e7\u00e3o (inclusivo) e vencimento (exclusivo)\n    dias_uteis = bday.count(settlement, maturity)\n\n    # N\u00famero de per\u00edodos truncado conforme regras da ANBIMA\n    anos_truncados = tools.truncate(dias_uteis / 252, 14)\n\n    fator_desconto = 1 / (1 + rate) ** anos_truncados\n\n    return tools.truncate(100 * fator_desconto, 4)\n</code></pre>"},{"location":"ltn/","title":"LTN","text":""},{"location":"ltn/#pyield.tn.ltn.data","title":"<code>data(date)</code>","text":"<p>Busca as taxas indicativas de LTN na ANBIMA para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame Polars com os dados de LTN.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo (ex.: \"LTN\").</li> <li>ReferenceDate (Date): Data de refer\u00eancia dos dados.</li> <li>SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento do t\u00edtulo.</li> <li>BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.</li> <li>Duration (Float64): Macaulay Duration do t\u00edtulo (anos).</li> <li>DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.</li> <li>DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.</li> <li>Price (Float64): Pre\u00e7o unit\u00e1rio (PU).</li> <li>BidRate (Float64): Taxa de compra (decimal).</li> <li>AskRate (Float64): Taxa de venda (decimal).</li> <li>IndicativeRate (Float64): Taxa indicativa (decimal).</li> <li>DIRate (Float64): Taxa DI interpolada (flat forward).</li> <li>StdDev (Float64): Desvio padr\u00e3o da taxa indicativa.</li> <li>LowerBoundRateD0 (Float64): Limite inferior do intervalo (D+0).</li> <li>UpperBoundRateD0 (Float64): Limite superior do intervalo (D+0).</li> <li>LowerBoundRateD1 (Float64): Limite inferior do intervalo (D+1).</li> <li>UpperBoundRateD1 (Float64): Limite superior do intervalo (D+1).</li> <li>Criteria (String): Crit\u00e9rio utilizado pela ANBIMA.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.data(\"23-08-2024\")\nshape: (13, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-07-08    \u2506 \u2026 \u2506 0.10459  \u2506 0.104252 \u2506 0.104416       \u2506 0.10472 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2018-02-01    \u2506 \u2026 \u2506 0.107366 \u2506 0.107016 \u2506 0.107171       \u2506 0.10823 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-01-06    \u2506 \u2026 \u2506 0.110992 \u2506 0.110746 \u2506 0.110866       \u2506 0.11179 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.11315  \u2506 0.112947 \u2506 0.113032       \u2506 0.11365 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.114494 \u2506 0.114277 \u2506 0.114374       \u2506 0.11463 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026       \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.115424 \u2506 0.115283 \u2506 0.115357       \u2506 0.11494 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.115452 \u2506 0.115247 \u2506 0.115335       \u2506 0.11498 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.115758 \u2506 0.115633 \u2506 0.115694       \u2506 0.11508 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.11647  \u2506 0.116341 \u2506 0.116417       \u2506 0.11554 \u2502\n\u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.117504 \u2506 0.11737  \u2506 0.117436       \u2506 0.11594 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Busca as taxas indicativas de LTN na ANBIMA para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.DataFrame: DataFrame Polars com os dados de LTN.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo (ex.: \"LTN\").\n        - ReferenceDate (Date): Data de refer\u00eancia dos dados.\n        - SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento do t\u00edtulo.\n        - BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.\n        - Duration (Float64): Macaulay Duration do t\u00edtulo (anos).\n        - DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.\n        - DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.\n        - Price (Float64): Pre\u00e7o unit\u00e1rio (PU).\n        - BidRate (Float64): Taxa de compra (decimal).\n        - AskRate (Float64): Taxa de venda (decimal).\n        - IndicativeRate (Float64): Taxa indicativa (decimal).\n        - DIRate (Float64): Taxa DI interpolada (flat forward).\n        - StdDev (Float64): Desvio padr\u00e3o da taxa indicativa.\n        - LowerBoundRateD0 (Float64): Limite inferior do intervalo (D+0).\n        - UpperBoundRateD0 (Float64): Limite superior do intervalo (D+0).\n        - LowerBoundRateD1 (Float64): Limite inferior do intervalo (D+1).\n        - UpperBoundRateD1 (Float64): Limite superior do intervalo (D+1).\n        - Criteria (String): Crit\u00e9rio utilizado pela ANBIMA.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.data(\"23-08-2024\")\n        shape: (13, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-07-08    \u2506 \u2026 \u2506 0.10459  \u2506 0.104252 \u2506 0.104416       \u2506 0.10472 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2018-02-01    \u2506 \u2026 \u2506 0.107366 \u2506 0.107016 \u2506 0.107171       \u2506 0.10823 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-01-06    \u2506 \u2026 \u2506 0.110992 \u2506 0.110746 \u2506 0.110866       \u2506 0.11179 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.11315  \u2506 0.112947 \u2506 0.113032       \u2506 0.11365 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.114494 \u2506 0.114277 \u2506 0.114374       \u2506 0.11463 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026       \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.115424 \u2506 0.115283 \u2506 0.115357       \u2506 0.11494 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2023-07-07    \u2506 \u2026 \u2506 0.115452 \u2506 0.115247 \u2506 0.115335       \u2506 0.11498 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.115758 \u2506 0.115633 \u2506 0.115694       \u2506 0.11508 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-07-05    \u2506 \u2026 \u2506 0.11647  \u2506 0.116341 \u2506 0.116417       \u2506 0.11554 \u2502\n        \u2502 2024-08-23    \u2506 LTN      \u2506 100000    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.117504 \u2506 0.11737  \u2506 0.117436       \u2506 0.11594 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>Defini\u00e7\u00e3o do spread (forma bruta):     DISpread_raw = IndicativeRate - SettlementRate</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Padr\u00e3o False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas do spread.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento.</li> <li>DISpread (Float64): Spread em decimal ou bps conforme par\u00e2metro.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.di_spreads(\"30-05-2025\", bps=True)\nshape: (13, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 LTN      \u2506 2028-01-01   \u2506 0.55     \u2502\n\u2502 LTN      \u2506 2028-07-01   \u2506 1.5      \u2502\n\u2502 LTN      \u2506 2029-01-01   \u2506 10.77    \u2502\n\u2502 LTN      \u2506 2030-01-01   \u2506 11.0     \u2502\n\u2502 LTN      \u2506 2032-01-01   \u2506 11.24    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def di_spreads(date: DateLike, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    Defini\u00e7\u00e3o do spread (forma bruta):\n        DISpread_raw = IndicativeRate - SettlementRate\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Padr\u00e3o False.\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas do spread.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento.\n        - DISpread (Float64): Spread em decimal ou bps conforme par\u00e2metro.\n\n    Raises:\n        ValueError: Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.di_spreads(\"30-05-2025\", bps=True)\n        shape: (13, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 LTN      \u2506 2028-01-01   \u2506 0.55     \u2502\n        \u2502 LTN      \u2506 2028-07-01   \u2506 1.5      \u2502\n        \u2502 LTN      \u2506 2029-01-01   \u2506 10.77    \u2502\n        \u2502 LTN      \u2506 2030-01-01   \u2506 11.0     \u2502\n        \u2502 LTN      \u2506 2032-01-01   \u2506 11.24    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return pre_di_spreads(date, bps=bps).filter(pl.col(\"BondType\") == \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.dv01","title":"<code>dv01(settlement, maturity, rate)</code>","text":"<p>Calcula o DV01 (Dollar Value of 01) da LTN em R$.</p> <p>Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) do t\u00edtulo.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.dv01(\"26-03-2025\", \"01-01-2032\", 0.150970)\n0.2269059999999854\n</code></pre> <p>Entradas nulas retornam float('nan')</p> <pre><code>&gt;&gt;&gt; ltn.dv01(None, \"01-01-2032\", 0.150970)\nnan\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o DV01 (Dollar Value of 01) da LTN em R$.\n\n    Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto (YTM) do t\u00edtulo.\n\n    Returns:\n        float: DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.dv01(\"26-03-2025\", \"01-01-2032\", 0.150970)\n        0.2269059999999854\n\n        Entradas nulas retornam float('nan')\n        &gt;&gt;&gt; ltn.dv01(None, \"01-01-2032\", 0.150970)\n        nan\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n\n    preco_1 = price(settlement, maturity, rate)\n    preco_2 = price(settlement, maturity, rate + 0.0001)\n    return preco_1 - preco_2\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.forwards","title":"<code>forwards(date)</code>","text":"<p>Calcula as taxas forward da LTN para uma data de refer\u00eancia.</p> <p>As taxas indicativas da LTN j\u00e1 s\u00e3o spot (zero-coupon) por constru\u00e7\u00e3o, pois o t\u00edtulo n\u00e3o paga cupons. Portanto o c\u00e1lculo de forward \u00e9 direto usando a estrutura de vencimentos e suas taxas.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia das taxas indicativas.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as taxas forward.</p> Output Columns <ul> <li>MaturityDate (Date): Data de vencimento.</li> <li>BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.</li> <li>IndicativeRate (Float64): Taxa spot (zero cupom).</li> <li>ForwardRate (Float64): Taxa forward.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.forwards(\"17-10-2025\")\nshape: (13, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n\u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2026-01-01   \u2506 52      \u2506 0.148307       \u2506 0.148307    \u2502\n\u2502 2026-04-01   \u2506 113     \u2506 0.147173       \u2506 0.146207    \u2502\n\u2502 2026-07-01   \u2506 174     \u2506 0.145206       \u2506 0.141571    \u2502\n\u2502 2026-10-01   \u2506 239     \u2506 0.142424       \u2506 0.13501     \u2502\n\u2502 2027-04-01   \u2506 361     \u2506 0.138155       \u2506 0.129838    \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2028-07-01   \u2506 676     \u2506 0.133411       \u2506 0.131654    \u2502\n\u2502 2029-01-01   \u2506 800     \u2506 0.134254       \u2506 0.138861    \u2502\n\u2502 2029-07-01   \u2506 924     \u2506 0.135264       \u2506 0.141802    \u2502\n\u2502 2030-01-01   \u2506 1049    \u2506 0.135967       \u2506 0.141177    \u2502\n\u2502 2032-01-01   \u2506 1553    \u2506 0.13883        \u2506 0.144812    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def forwards(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"Calcula as taxas forward da LTN para uma data de refer\u00eancia.\n\n    As taxas indicativas da LTN j\u00e1 s\u00e3o spot (zero-coupon) por constru\u00e7\u00e3o, pois o\n    t\u00edtulo n\u00e3o paga cupons. Portanto o c\u00e1lculo de forward \u00e9 direto usando a\n    estrutura de vencimentos e suas taxas.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia das taxas indicativas.\n\n    Returns:\n        pl.DataFrame: DataFrame com as taxas forward.\n\n    Output Columns:\n        - MaturityDate (Date): Data de vencimento.\n        - BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.\n        - IndicativeRate (Float64): Taxa spot (zero cupom).\n        - ForwardRate (Float64): Taxa forward.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.forwards(\"17-10-2025\")\n        shape: (13, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n        \u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2026-01-01   \u2506 52      \u2506 0.148307       \u2506 0.148307    \u2502\n        \u2502 2026-04-01   \u2506 113     \u2506 0.147173       \u2506 0.146207    \u2502\n        \u2502 2026-07-01   \u2506 174     \u2506 0.145206       \u2506 0.141571    \u2502\n        \u2502 2026-10-01   \u2506 239     \u2506 0.142424       \u2506 0.13501     \u2502\n        \u2502 2027-04-01   \u2506 361     \u2506 0.138155       \u2506 0.129838    \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2028-07-01   \u2506 676     \u2506 0.133411       \u2506 0.131654    \u2502\n        \u2502 2029-01-01   \u2506 800     \u2506 0.134254       \u2506 0.138861    \u2502\n        \u2502 2029-07-01   \u2506 924     \u2506 0.135264       \u2506 0.141802    \u2502\n        \u2502 2030-01-01   \u2506 1049    \u2506 0.135967       \u2506 0.141177    \u2502\n        \u2502 2032-01-01   \u2506 1553    \u2506 0.13883        \u2506 0.144812    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(date):\n        return pl.DataFrame()\n    df = data(date).select(\"MaturityDate\", \"BDToMat\", \"IndicativeRate\")\n    taxas_forward = fwd.forwards(bdays=df[\"BDToMat\"], rates=df[\"IndicativeRate\"])\n    return df.with_columns(ForwardRate=taxas_forward).sort(\"MaturityDate\")\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.maturities","title":"<code>maturities(date)</code>","text":"<p>Busca os vencimentos dispon\u00edveis para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie de datas de vencimento dispon\u00edveis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.maturities(\"22-08-2024\")\nshape: (13,)\nSeries: 'MaturityDate' [date]\n[\n    2024-10-01\n    2025-01-01\n    2025-04-01\n    2025-07-01\n    2025-10-01\n    \u2026\n    2026-10-01\n    2027-07-01\n    2028-01-01\n    2028-07-01\n    2030-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def maturities(date: DateLike) -&gt; pl.Series:\n    \"\"\"\n    Busca os vencimentos dispon\u00edveis para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.Series: S\u00e9rie de datas de vencimento dispon\u00edveis.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.maturities(\"22-08-2024\")\n        shape: (13,)\n        Series: 'MaturityDate' [date]\n        [\n            2024-10-01\n            2025-01-01\n            2025-04-01\n            2025-07-01\n            2025-10-01\n            \u2026\n            2026-10-01\n            2027-07-01\n            2028-01-01\n            2028-07-01\n            2030-01-01\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.premium","title":"<code>premium(ltn_rate, di_rate)</code>","text":"<p>Calcula o pr\u00eamio da LTN sobre a taxa de DI Futuro.</p> <p>Parameters:</p> Name Type Description Default <code>ltn_rate</code> <code>float</code> <p>Taxa anualizada da LTN.</p> required <code>di_rate</code> <code>float</code> <p>Taxa anualizada do DI Futuro.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pr\u00eamio da LTN sobre o DI.</p> <p>Examples:</p> <p>Reference date: 22-08-2024 LTN rate for 01-01-2030: 0.118746 DI (JAN30) Settlement rate: 0.11725</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.premium(0.118746, 0.11725)\n1.0120718007994287\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def premium(ltn_rate: float, di_rate: float) -&gt; float:\n    \"\"\"\n    Calcula o pr\u00eamio da LTN sobre a taxa de DI Futuro.\n\n    Args:\n        ltn_rate (float): Taxa anualizada da LTN.\n        di_rate (float): Taxa anualizada do DI Futuro.\n\n    Returns:\n        float: Pr\u00eamio da LTN sobre o DI.\n\n    Examples:\n        Reference date: 22-08-2024\n        LTN rate for 01-01-2030: 0.118746\n        DI (JAN30) Settlement rate: 0.11725\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.premium(0.118746, 0.11725)\n        1.0120718007994287\n    \"\"\"\n    if any_is_empty(ltn_rate, di_rate):\n        return float(\"nan\")\n    # C\u00e1lculo das taxas di\u00e1rias\n    taxa_diaria_ltn = (1 + ltn_rate) ** (1 / 252) - 1\n    taxa_diaria_di = (1 + di_rate) ** (1 / 252) - 1\n\n    # Retorno do c\u00e1lculo do pr\u00eamio\n    return taxa_diaria_ltn / taxa_diaria_di\n</code></pre>"},{"location":"ltn/#pyield.tn.ltn.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calcula o pre\u00e7o da LTN pelas regras da ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) do t\u00edtulo.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pre\u00e7o da LTN conforme ANBIMA.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ltn\n&gt;&gt;&gt; ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n535.279902\n</code></pre> Source code in <code>pyield/tn/ltn.py</code> <pre><code>def price(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o pre\u00e7o da LTN pelas regras da ANBIMA.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto (YTM) do t\u00edtulo.\n\n    Returns:\n        float: Pre\u00e7o da LTN conforme ANBIMA.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ltn\n        &gt;&gt;&gt; ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n        535.279902\n    \"\"\"\n    # Valida e normaliza entradas\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n    # Calcula dias \u00fateis entre liquida\u00e7\u00e3o e vencimento\n    dias_uteis = bday.count(settlement, maturity)\n\n    # Calcula anos \u00fateis truncados conforme ANBIMA\n    anos_truncados = tools.truncate(dias_uteis / 252, 14)\n\n    fator_desconto = (1 + rate) ** anos_truncados\n\n    # Trunca o pre\u00e7o em 6 casas conforme ANBIMA\n    return tools.truncate(VALOR_FACE / fator_desconto, 6)\n</code></pre>"},{"location":"ntnb/","title":"NTN-B","text":""},{"location":"ntnb/#pyield.tn.ntnb.bei_rates","title":"<code>bei_rates(settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates)</code>","text":"<p>Calcula a infla\u00e7\u00e3o impl\u00edcita (BEI) para NTN-B a partir de taxas nominais e reais.</p> <p>A BEI \u00e9 a infla\u00e7\u00e3o que iguala yields reais e nominais, baseada nas taxas spot das NTN-B.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.</p> required <code>ntnb_maturities</code> <code>ArrayLike</code> <p>Vencimentos das NTN-B.</p> required <code>ntnb_rates</code> <code>ArrayLike</code> <p>Taxas reais (YTM) correspondentes.</p> required <code>nominal_maturities</code> <code>ArrayLike</code> <p>Vencimentos de refer\u00eancia para taxas nominais.</p> required <code>nominal_rates</code> <code>ArrayLike</code> <p>Taxas nominais (ex.: DI Futuro).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as BEI calculadas.</p> Output Columns <ul> <li>MaturityDate (Date): Data de vencimento.</li> <li>BDToMat (Int64): Dias \u00fateis entre liquida\u00e7\u00e3o e vencimento.</li> <li>RIR (Float64): Taxa real (spot).</li> <li>NIR (Float64): Taxa nominal interpolada.</li> <li>BEI (Float64): Infla\u00e7\u00e3o impl\u00edcita (breakeven).</li> </ul> Notes <p>A BEI indica a infla\u00e7\u00e3o esperada pelo mercado entre liquida\u00e7\u00e3o e vencimento.</p> <p>Examples:</p> <p>Busca as taxas de NTN-B para uma data de refer\u00eancia. Estas s\u00e3o taxas YTM e as taxas spot s\u00e3o calculadas a partir delas.</p> <pre><code>&gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n</code></pre> <p>Busca as taxas de ajuste do DI Futuro para a mesma data de refer\u00eancia:</p> <pre><code>&gt;&gt;&gt; df_di = yd.di1.data(\"05-09-2024\")\n</code></pre> <p>Calcula as BEI considerando a liquida\u00e7\u00e3o na data de refer\u00eancia:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.bei_rates(\n...     settlement=\"05-09-2024\",\n...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n...     nominal_maturities=df_di[\"ExpirationDate\"],\n...     nominal_rates=df_di[\"SettlementRate\"],\n... )\nshape: (14, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 RIR      \u2506 NIR      \u2506 BEI      \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2506 ---      \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-05-15   \u2506 171     \u2506 0.061748 \u2506 0.113836 \u2506 0.049059 \u2502\n\u2502 2026-08-15   \u2506 488     \u2506 0.066133 \u2506 0.117126 \u2506 0.04783  \u2502\n\u2502 2027-05-15   \u2506 673     \u2506 0.063816 \u2506 0.117169 \u2506 0.050152 \u2502\n\u2502 2028-08-15   \u2506 988     \u2506 0.063635 \u2506 0.11828  \u2506 0.051376 \u2502\n\u2502 2029-05-15   \u2506 1172    \u2506 0.062532 \u2506 0.11838  \u2506 0.052561 \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2506 \u2026        \u2506 \u2026        \u2502\n\u2502 2040-08-15   \u2506 3995    \u2506 0.060468 \u2506 0.11759  \u2506 0.053865 \u2502\n\u2502 2045-05-15   \u2506 5182    \u2506 0.0625   \u2506 0.11759  \u2506 0.05185  \u2502\n\u2502 2050-08-15   \u2506 6497    \u2506 0.063016 \u2506 0.11759  \u2506 0.051339 \u2502\n\u2502 2055-05-15   \u2506 7686    \u2506 0.062252 \u2506 0.11759  \u2506 0.052095 \u2502\n\u2502 2060-08-15   \u2506 9003    \u2506 0.063001 \u2506 0.11759  \u2506 0.051354 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def bei_rates(\n    settlement: DateLike,\n    ntnb_maturities: ArrayLike,\n    ntnb_rates: ArrayLike,\n    nominal_maturities: ArrayLike,\n    nominal_rates: ArrayLike,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula a infla\u00e7\u00e3o impl\u00edcita (BEI) para NTN-B a partir de taxas nominais e reais.\n\n    A BEI \u00e9 a infla\u00e7\u00e3o que iguala yields reais e nominais, baseada nas taxas spot\n    das NTN-B.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.\n        ntnb_maturities (ArrayLike): Vencimentos das NTN-B.\n        ntnb_rates (ArrayLike): Taxas reais (YTM) correspondentes.\n        nominal_maturities (ArrayLike): Vencimentos de refer\u00eancia para taxas nominais.\n        nominal_rates (ArrayLike): Taxas nominais (ex.: DI Futuro).\n\n    Returns:\n        pl.DataFrame: DataFrame com as BEI calculadas.\n\n    Output Columns:\n        - MaturityDate (Date): Data de vencimento.\n        - BDToMat (Int64): Dias \u00fateis entre liquida\u00e7\u00e3o e vencimento.\n        - RIR (Float64): Taxa real (spot).\n        - NIR (Float64): Taxa nominal interpolada.\n        - BEI (Float64): Infla\u00e7\u00e3o impl\u00edcita (breakeven).\n\n    Notes:\n        A BEI indica a infla\u00e7\u00e3o esperada pelo mercado entre liquida\u00e7\u00e3o e vencimento.\n\n    Examples:\n        Busca as taxas de NTN-B para uma data de refer\u00eancia.\n        Estas s\u00e3o taxas YTM e as taxas spot s\u00e3o calculadas a partir delas.\n        &gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n\n        Busca as taxas de ajuste do DI Futuro para a mesma data de refer\u00eancia:\n        &gt;&gt;&gt; df_di = yd.di1.data(\"05-09-2024\")\n\n        Calcula as BEI considerando a liquida\u00e7\u00e3o na data de refer\u00eancia:\n        &gt;&gt;&gt; yd.ntnb.bei_rates(\n        ...     settlement=\"05-09-2024\",\n        ...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n        ...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n        ...     nominal_maturities=df_di[\"ExpirationDate\"],\n        ...     nominal_rates=df_di[\"SettlementRate\"],\n        ... )\n        shape: (14, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 RIR      \u2506 NIR      \u2506 BEI      \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2506 ---      \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2506 f64      \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-05-15   \u2506 171     \u2506 0.061748 \u2506 0.113836 \u2506 0.049059 \u2502\n        \u2502 2026-08-15   \u2506 488     \u2506 0.066133 \u2506 0.117126 \u2506 0.04783  \u2502\n        \u2502 2027-05-15   \u2506 673     \u2506 0.063816 \u2506 0.117169 \u2506 0.050152 \u2502\n        \u2502 2028-08-15   \u2506 988     \u2506 0.063635 \u2506 0.11828  \u2506 0.051376 \u2502\n        \u2502 2029-05-15   \u2506 1172    \u2506 0.062532 \u2506 0.11838  \u2506 0.052561 \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2506 \u2026        \u2506 \u2026        \u2502\n        \u2502 2040-08-15   \u2506 3995    \u2506 0.060468 \u2506 0.11759  \u2506 0.053865 \u2502\n        \u2502 2045-05-15   \u2506 5182    \u2506 0.0625   \u2506 0.11759  \u2506 0.05185  \u2502\n        \u2502 2050-08-15   \u2506 6497    \u2506 0.063016 \u2506 0.11759  \u2506 0.051339 \u2502\n        \u2502 2055-05-15   \u2506 7686    \u2506 0.062252 \u2506 0.11759  \u2506 0.052095 \u2502\n        \u2502 2060-08-15   \u2506 9003    \u2506 0.063001 \u2506 0.11759  \u2506 0.051354 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(\n        settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates\n    ):\n        return pl.DataFrame()\n    # Normaliza datas de entrada\n    liquidacao = conversores.converter_datas(settlement)\n    ntnb_maturities = conversores.converter_datas(ntnb_maturities)\n\n    interpolador_ff = interpolador.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(liquidacao, nominal_maturities),\n        known_rates=nominal_rates,\n        extrapolate=True,\n    )\n    df_spot = spot_rates(liquidacao, ntnb_maturities, ntnb_rates)\n    df = (\n        df_spot.rename({\"SpotRate\": \"RIR\"})\n        .with_columns(\n            NIR=interpolador_ff(df_spot[\"BDToMat\"]),\n        )\n        .with_columns(\n            BEI=((pl.col(\"NIR\") + 1) / (pl.col(\"RIR\") + 1)) - 1,\n        )\n        .select(\"MaturityDate\", \"BDToMat\", \"RIR\", \"NIR\", \"BEI\")\n    )\n\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Gera os fluxos de caixa da NTN-B entre liquida\u00e7\u00e3o e vencimento.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o (exclusiva).</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas de fluxo.</p> Output Columns <ul> <li>PaymentDate (Date): Data de pagamento do fluxo.</li> <li>CashFlow (Float64): Valor do fluxo de caixa.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-05-15  \u2506 2.956301   \u2502\n\u2502 2024-11-15  \u2506 2.956301   \u2502\n\u2502 2025-05-15  \u2506 102.956301 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def cash_flows(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Gera os fluxos de caixa da NTN-B entre liquida\u00e7\u00e3o e vencimento.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o (exclusiva).\n        maturity (DateLike): Data de vencimento.\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas de fluxo.\n\n    Output Columns:\n        - PaymentDate (Date): Data de pagamento do fluxo.\n        - CashFlow (Float64): Valor do fluxo de caixa.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-05-15  \u2506 2.956301   \u2502\n        \u2502 2024-11-15  \u2506 2.956301   \u2502\n        \u2502 2025-05-15  \u2506 102.956301 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(settlement, maturity):\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    # Obt\u00e9m as datas de cupom entre liquida\u00e7\u00e3o e vencimento\n    liquidacao = conversores.converter_datas(settlement)\n    vencimento = conversores.converter_datas(maturity)\n    datas_pagamento = payment_dates(liquidacao, vencimento)\n\n    # Retorna DataFrame vazio se n\u00e3o houver pagamentos (liquida\u00e7\u00e3o &gt;= vencimento)\n    if datas_pagamento.is_empty():\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    df = pl.DataFrame(\n        {\"PaymentDate\": datas_pagamento},\n    ).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == vencimento)\n        .then(VALOR_FINAL)\n        .otherwise(VALOR_CUPOM)\n        .alias(\"CashFlow\")\n    )\n\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.data","title":"<code>data(date)</code>","text":"<p>Busca as taxas indicativas de NTN-B para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame Polars com os dados de NTN-B.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo (ex.: \"NTN-B\").</li> <li>ReferenceDate (Date): Data de refer\u00eancia dos dados.</li> <li>SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento do t\u00edtulo.</li> <li>BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.</li> <li>Duration (Float64): Macaulay Duration do t\u00edtulo (anos).</li> <li>DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.</li> <li>DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.</li> <li>Price (Float64): Pre\u00e7o unit\u00e1rio (PU).</li> <li>BidRate (Float64): Taxa de compra (decimal).</li> <li>AskRate (Float64): Taxa de venda (decimal).</li> <li>IndicativeRate (Float64): Taxa indicativa (decimal).</li> <li>DIRate (Float64): Taxa DI interpolada (flat forward).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.data(\"23-08-2024\")\nshape: (14, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate   \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---      \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063961 \u2506 0.063667 \u2506 0.063804       \u2506 0.112749 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.06594  \u2506 0.065635 \u2506 0.065795       \u2506 0.114963 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063925 \u2506 0.063601 \u2506 0.063794       \u2506 0.114888 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063217 \u2506 0.062905 \u2506 0.063094       \u2506 0.115595 \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.062245 \u2506 0.061954 \u2506 0.0621         \u2506 0.115665 \u2502\n\u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026        \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.060005 \u2506 0.059574 \u2506 0.059797       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061107 \u2506 0.060733 \u2506 0.060923       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061304 \u2506 0.060931 \u2506 0.06114        \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061053 \u2506 0.06074  \u2506 0.060892       \u2506 0.11511  \u2502\n\u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061211 \u2506 0.0608   \u2506 0.061005       \u2506 0.11511  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Busca as taxas indicativas de NTN-B para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.DataFrame: DataFrame Polars com os dados de NTN-B.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo (ex.: \"NTN-B\").\n        - ReferenceDate (Date): Data de refer\u00eancia dos dados.\n        - SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento do t\u00edtulo.\n        - BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.\n        - Duration (Float64): Macaulay Duration do t\u00edtulo (anos).\n        - DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.\n        - DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.\n        - Price (Float64): Pre\u00e7o unit\u00e1rio (PU).\n        - BidRate (Float64): Taxa de compra (decimal).\n        - AskRate (Float64): Taxa de venda (decimal).\n        - IndicativeRate (Float64): Taxa indicativa (decimal).\n        - DIRate (Float64): Taxa DI interpolada (flat forward).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.data(\"23-08-2024\")\n        shape: (14, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate   \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---      \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063961 \u2506 0.063667 \u2506 0.063804       \u2506 0.112749 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.06594  \u2506 0.065635 \u2506 0.065795       \u2506 0.114963 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063925 \u2506 0.063601 \u2506 0.063794       \u2506 0.114888 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.063217 \u2506 0.062905 \u2506 0.063094       \u2506 0.115595 \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.062245 \u2506 0.061954 \u2506 0.0621         \u2506 0.115665 \u2502\n        \u2502 \u2026             \u2506 \u2026        \u2506 \u2026         \u2506 \u2026             \u2506 \u2026 \u2506 \u2026        \u2506 \u2026        \u2506 \u2026              \u2506 \u2026        \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.060005 \u2506 0.059574 \u2506 0.059797       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061107 \u2506 0.060733 \u2506 0.060923       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061304 \u2506 0.060931 \u2506 0.06114        \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061053 \u2506 0.06074  \u2506 0.060892       \u2506 0.11511  \u2502\n        \u2502 2024-08-23    \u2506 NTN-B    \u2506 760199    \u2506 2000-07-15    \u2506 \u2026 \u2506 0.061211 \u2506 0.0608   \u2506 0.061005       \u2506 0.11511  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"NTN-B\")\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calcula a Macaulay duration da NTN-B em anos \u00fateis.</p> F\u00f3rmula <p>Sum( t * CF\u209c / (1 + y)\u1d57 )</p> <pre><code> MacD = ---------------------------------\n                 Current Bond Price\n</code></pre> Onde <p>t    = tempo (anos) at\u00e9 o pagamento CF\u209c = fluxo no tempo t y    = taxa YTM (peri\u00f3dica) Price = Soma( CF\u209c / (1 + y)\u1d57 )</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto usada no c\u00e1lculo.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Macaulay duration em anos \u00fateis.</p> <p>Examples:      &gt;&gt;&gt; from pyield import ntnb      &gt;&gt;&gt; ntnb.duration(\"23-08-2024\", \"15-08-2060\", 0.061005)      15.08305431313046</p> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def duration(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula a Macaulay duration da NTN-B em anos \u00fateis.\n\n    F\u00f3rmula:\n                   Sum( t * CF\u209c / (1 + y)\u1d57 )\n         MacD = ---------------------------------\n                         Current Bond Price\n\n    Onde:\n        t    = tempo (anos) at\u00e9 o pagamento\n        CF\u209c = fluxo no tempo t\n        y    = taxa YTM (peri\u00f3dica)\n        Price = Soma( CF\u209c / (1 + y)\u1d57 )\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto usada no c\u00e1lculo.\n\n    Returns:\n        float: Macaulay duration em anos \u00fateis.\n\n     Examples:\n         &gt;&gt;&gt; from pyield import ntnb\n         &gt;&gt;&gt; ntnb.duration(\"23-08-2024\", \"15-08-2060\", 0.061005)\n         15.08305431313046\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    anos_uteis = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** anos_uteis\n    duracao = (dcf * anos_uteis).sum() / dcf.sum()\n    # Truncar para 14 casas decimais para repetibilidade dos resultados\n    return ferramentas.truncate(duracao, 14)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.dv01","title":"<code>dv01(settlement, maturity, rate, vna)</code>","text":"<p>Calcula o DV01 (Dollar Value of 01) da NTN-B em R$.</p> <p>Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) da NTN-B.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.dv01(\"26-03-2025\", \"15-08-2060\", 0.074358, 4470.979474)\n4.640875999999935\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    vna: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o DV01 (Dollar Value of 01) da NTN-B em R$.\n\n    Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto (YTM) da NTN-B.\n\n    Returns:\n        float: DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.dv01(\"26-03-2025\", \"15-08-2060\", 0.074358, 4470.979474)\n        4.640875999999935\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate, vna):\n        return float(\"nan\")\n\n    cotacao_1 = quotation(settlement, maturity, rate)\n    cotacao_2 = quotation(settlement, maturity, rate + 0.0001)\n    preco_1 = price(vna, cotacao_1)\n    preco_2 = price(vna, cotacao_2)\n    return preco_1 - preco_2\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.forwards","title":"<code>forwards(date, zero_coupon=True)</code>","text":"<p>Calcula as taxas forward da NTN-B para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <code>zero_coupon</code> <code>bool</code> <p>Se True, usa taxas zero cupom no c\u00e1lculo. Padr\u00e3o True. Se False, usa as taxas YTM.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as taxas forward.</p> Output Columns <ul> <li>MaturityDate (Date): Data de vencimento.</li> <li>BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.</li> <li>IndicativeRate (Float64): Taxa indicativa (spot ou YTM).</li> <li>ForwardRate (Float64): Taxa forward calculada.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.forwards(\"17-10-2025\", zero_coupon=True)\nshape: (13, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n\u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2026-08-15   \u2506 207     \u2506 0.10089        \u2506 0.10089     \u2502\n\u2502 2027-05-15   \u2506 392     \u2506 0.088776       \u2506 0.074793    \u2502\n\u2502 2028-08-15   \u2506 707     \u2506 0.083615       \u2506 0.076598    \u2502\n\u2502 2029-05-15   \u2506 891     \u2506 0.0818         \u2506 0.074148    \u2502\n\u2502 2030-08-15   \u2506 1205    \u2506 0.080902       \u2506 0.077857    \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n\u2502 2040-08-15   \u2506 3714    \u2506 0.076067       \u2506 0.070587    \u2502\n\u2502 2045-05-15   \u2506 4901    \u2506 0.075195       \u2506 0.069811    \u2502\n\u2502 2050-08-15   \u2506 6216    \u2506 0.074087       \u2506 0.064348    \u2502\n\u2502 2055-05-15   \u2506 7405    \u2506 0.073702       \u2506 0.067551    \u2502\n\u2502 2060-08-15   \u2506 8722    \u2506 0.073795       \u2506 0.074505    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def forwards(\n    date: DateLike,\n    zero_coupon: bool = True,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula as taxas forward da NTN-B para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n        zero_coupon (bool, optional): Se True, usa taxas zero cupom no c\u00e1lculo.\n            Padr\u00e3o True. Se False, usa as taxas YTM.\n\n    Returns:\n        pl.DataFrame: DataFrame com as taxas forward.\n\n    Output Columns:\n        - MaturityDate (Date): Data de vencimento.\n        - BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.\n        - IndicativeRate (Float64): Taxa indicativa (spot ou YTM).\n        - ForwardRate (Float64): Taxa forward calculada.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.forwards(\"17-10-2025\", zero_coupon=True)\n        shape: (13, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 IndicativeRate \u2506 ForwardRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---            \u2506 ---         \u2502\n        \u2502 date         \u2506 i64     \u2506 f64            \u2506 f64         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2026-08-15   \u2506 207     \u2506 0.10089        \u2506 0.10089     \u2502\n        \u2502 2027-05-15   \u2506 392     \u2506 0.088776       \u2506 0.074793    \u2502\n        \u2502 2028-08-15   \u2506 707     \u2506 0.083615       \u2506 0.076598    \u2502\n        \u2502 2029-05-15   \u2506 891     \u2506 0.0818         \u2506 0.074148    \u2502\n        \u2502 2030-08-15   \u2506 1205    \u2506 0.080902       \u2506 0.077857    \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026              \u2506 \u2026           \u2502\n        \u2502 2040-08-15   \u2506 3714    \u2506 0.076067       \u2506 0.070587    \u2502\n        \u2502 2045-05-15   \u2506 4901    \u2506 0.075195       \u2506 0.069811    \u2502\n        \u2502 2050-08-15   \u2506 6216    \u2506 0.074087       \u2506 0.064348    \u2502\n        \u2502 2055-05-15   \u2506 7405    \u2506 0.073702       \u2506 0.067551    \u2502\n        \u2502 2060-08-15   \u2506 8722    \u2506 0.073795       \u2506 0.074505    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(date):\n        return pl.DataFrame()\n\n    # Valida e normaliza a data\n    df = data(date).select(\"MaturityDate\", \"BDToMat\", \"IndicativeRate\")\n    if zero_coupon:\n        df_ref = spot_rates(\n            settlement=date,\n            maturities=df[\"MaturityDate\"],\n            rates=df[\"IndicativeRate\"],\n        ).rename({\"SpotRate\": \"ReferenceRate\"})\n    else:\n        df_ref = df.rename({\"IndicativeRate\": \"ReferenceRate\"})\n    taxas_forward = fwd.forwards(bdays=df_ref[\"BDToMat\"], rates=df_ref[\"ReferenceRate\"])\n    df_ref = df_ref.with_columns(ForwardRate=taxas_forward)\n    df = df.join(\n        df_ref.select(\"MaturityDate\", \"ForwardRate\"),\n        on=\"MaturityDate\",\n        how=\"inner\",\n    ).sort(\"MaturityDate\")\n    return df\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.maturities","title":"<code>maturities(date)</code>","text":"<p>Busca os vencimentos de NTN-B dispon\u00edveis para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie de datas de vencimento de NTN-B.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.maturities(\"16-08-2024\")\nshape: (14,)\nSeries: 'MaturityDate' [date]\n[\n    2025-05-15\n    2026-08-15\n    2027-05-15\n    2028-08-15\n    2029-05-15\n    \u2026\n    2040-08-15\n    2045-05-15\n    2050-08-15\n    2055-05-15\n    2060-08-15\n]\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def maturities(date: DateLike) -&gt; pl.Series:\n    \"\"\"\n    Busca os vencimentos de NTN-B dispon\u00edveis para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.Series: S\u00e9rie de datas de vencimento de NTN-B.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.maturities(\"16-08-2024\")\n        shape: (14,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-05-15\n            2026-08-15\n            2027-05-15\n            2028-08-15\n            2029-05-15\n            \u2026\n            2040-08-15\n            2045-05-15\n            2050-08-15\n            2055-05-15\n            2060-08-15\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Gera todas as datas de cupom entre liquida\u00e7\u00e3o e vencimento (inclusivas).</p> <p>Os cupons s\u00e3o pagos em 15/02, 15/05, 15/08 e 15/11. A NTN-B \u00e9 definida pela data de vencimento.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o (exclusiva).</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie de datas de cupom no intervalo. Retorna s\u00e9rie vazia se vencimento for menor ou igual \u00e0 liquida\u00e7\u00e3o.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\nshape: (3,)\nSeries: 'payment_dates' [date]\n[\n    2024-05-15\n    2024-11-15\n    2025-05-15\n]\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def payment_dates(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.Series:\n    \"\"\"\n    Gera todas as datas de cupom entre liquida\u00e7\u00e3o e vencimento (inclusivas).\n\n    Os cupons s\u00e3o pagos em 15/02, 15/05, 15/08 e 15/11. A NTN-B \u00e9 definida\n    pela data de vencimento.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o (exclusiva).\n        maturity (DateLike): Data de vencimento.\n\n    Returns:\n        pl.Series: S\u00e9rie de datas de cupom no intervalo. Retorna s\u00e9rie vazia se\n            vencimento for menor ou igual \u00e0 liquida\u00e7\u00e3o.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n        shape: (3,)\n        Series: 'payment_dates' [date]\n        [\n            2024-05-15\n            2024-11-15\n            2025-05-15\n        ]\n    \"\"\"\n    if any_is_empty(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n\n    liquidacao = conversores.converter_datas(settlement)\n    vencimento = conversores.converter_datas(maturity)\n\n    if vencimento &lt;= liquidacao:\n        return pl.Series(dtype=pl.Date)\n\n    data_cupom = vencimento\n    datas_cupons = []\n\n    while data_cupom &gt; liquidacao:\n        datas_cupons.append(data_cupom)\n        data_cupom -= relativedelta(months=6)\n\n    return pl.Series(name=\"payment_dates\", values=datas_cupons).sort()\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calcula o pre\u00e7o da NTN-B pelas regras da ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>Valor nominal atualizado (VNA).</p> required <code>quotation</code> <code>float</code> <p>Cota\u00e7\u00e3o da NTN-B em base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pre\u00e7o da NTN-B truncado em 6 casas decimais.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n4271.864805\n&gt;&gt;&gt; ntnb.price(4315.498383, 100.6409)\n4343.156412\n&gt;&gt;&gt; ntnb.price(None, 99.5341)  # Entradas nulas retornam float('nan')\nnan\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o pre\u00e7o da NTN-B pelas regras da ANBIMA.\n\n    Args:\n        vna (float): Valor nominal atualizado (VNA).\n        quotation (float): Cota\u00e7\u00e3o da NTN-B em base 100.\n\n    Returns:\n        float: Pre\u00e7o da NTN-B truncado em 6 casas decimais.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.price(4299.160173, 99.3651)\n        4271.864805\n        &gt;&gt;&gt; ntnb.price(4315.498383, 100.6409)\n        4343.156412\n        &gt;&gt;&gt; ntnb.price(None, 99.5341)  # Entradas nulas retornam float('nan')\n        nan\n    \"\"\"\n    if any_is_empty(vna, quotation):\n        return float(\"nan\")\n    return ferramentas.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calcula a cota\u00e7\u00e3o da NTN-B em base 100 pelas regras da ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento da NTN-B.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) usada no valor presente.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Cota\u00e7\u00e3o da NTN-B truncada em 4 casas. Retorna NaN em erro.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>O cupom semestral \u00e9 2,956301, equivalente a 6% a.a. com capitaliza\u00e7\u00e3o   semestral e arredondamento para 6 casas, conforme ANBIMA.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n&gt;&gt;&gt; ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n100.6409\n</code></pre> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def quotation(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula a cota\u00e7\u00e3o da NTN-B em base 100 pelas regras da ANBIMA.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento da NTN-B.\n        rate (float): Taxa de desconto (YTM) usada no valor presente.\n\n    Returns:\n        float: Cota\u00e7\u00e3o da NTN-B truncada em 4 casas. Retorna NaN em erro.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - O cupom semestral \u00e9 2,956301, equivalente a 6% a.a. com capitaliza\u00e7\u00e3o\n          semestral e arredondamento para 6 casas, conforme ANBIMA.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n        99.3651\n        &gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n        99.5341\n        &gt;&gt;&gt; ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n        100.6409\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    datas_fluxo = df[\"PaymentDate\"]\n    valores_fluxo = df[\"CashFlow\"]\n\n    # Calcula dias \u00fateis entre liquida\u00e7\u00e3o e datas de fluxo\n    dias_uteis = bday.count(settlement, datas_fluxo)\n\n    # Calcula anos \u00fateis truncados conforme ANBIMA\n    anos_uteis = ferramentas.truncate(dias_uteis / 252, 14)\n\n    fator_desconto = (1 + rate) ** anos_uteis\n\n    # Calcula o valor presente de cada fluxo (DCF) com arredondamento ANBIMA\n    valor_presente_fluxos = (valores_fluxo / fator_desconto).round(10)\n\n    # Retorna a cota\u00e7\u00e3o (soma do DCF) com truncamento ANBIMA\n    return ferramentas.truncate(valor_presente_fluxos.sum(), 4)\n</code></pre>"},{"location":"ntnb/#pyield.tn.ntnb.spot_rates","title":"<code>spot_rates(settlement, maturities, rates, show_coupons=False)</code>","text":"<p>Calcula as taxas spot da NTN-B usando bootstrap.</p> <p>O bootstrap determina as taxas spot a partir dos yields dos t\u00edtulos, resolvendo iterativamente as taxas que descontam os fluxos ao pre\u00e7o.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturities</code> <code>ArrayLike</code> <p>Datas de vencimento dos t\u00edtulos.</p> required <code>rates</code> <code>ArrayLike</code> <p>Taxas YTM correspondentes.</p> required <code>show_coupons</code> <code>bool</code> <p>Se True, inclui datas intermedi\u00e1rias de cupom. Padr\u00e3o False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as taxas spot.</p> Output Columns <ul> <li>MaturityDate (Date): Data de vencimento.</li> <li>BDToMat (Int64): Dias \u00fateis entre liquida\u00e7\u00e3o e vencimento.</li> <li>SpotRate (Float64): Taxa spot (real).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb\n&gt;&gt;&gt; # Busca as taxas de NTN-B para uma data de refer\u00eancia\n&gt;&gt;&gt; df = ntnb.data(\"16-08-2024\")\n&gt;&gt;&gt; # Calcula as taxas spot considerando a liquida\u00e7\u00e3o na data de refer\u00eancia\n&gt;&gt;&gt; ntnb.spot_rates(\n...     settlement=\"16-08-2024\",\n...     maturities=df[\"MaturityDate\"],\n...     rates=df[\"IndicativeRate\"],\n... )\nshape: (14, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-05-15   \u2506 185     \u2506 0.063893 \u2502\n\u2502 2026-08-15   \u2506 502     \u2506 0.066141 \u2502\n\u2502 2027-05-15   \u2506 687     \u2506 0.064087 \u2502\n\u2502 2028-08-15   \u2506 1002    \u2506 0.063057 \u2502\n\u2502 2029-05-15   \u2506 1186    \u2506 0.061458 \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n\u2502 2040-08-15   \u2506 4009    \u2506 0.058326 \u2502\n\u2502 2045-05-15   \u2506 5196    \u2506 0.060371 \u2502\n\u2502 2050-08-15   \u2506 6511    \u2506 0.060772 \u2502\n\u2502 2055-05-15   \u2506 7700    \u2506 0.059909 \u2502\n\u2502 2060-08-15   \u2506 9017    \u2506 0.060652 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notes <p>O c\u00e1lculo considera: - Mapear todas as datas de pagamento at\u00e9 o \u00faltimo vencimento. - Interpolar as taxas YTM nas datas intermedi\u00e1rias. - Calcular a cota\u00e7\u00e3o da NTN-B para cada vencimento. - Calcular as taxas spot reais.</p> Source code in <code>pyield/tn/ntnb.py</code> <pre><code>def spot_rates(\n    settlement: DateLike,\n    maturities: ArrayLike,\n    rates: ArrayLike,\n    show_coupons: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula as taxas spot da NTN-B usando bootstrap.\n\n    O bootstrap determina as taxas spot a partir dos yields dos t\u00edtulos,\n    resolvendo iterativamente as taxas que descontam os fluxos ao pre\u00e7o.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturities (ArrayLike): Datas de vencimento dos t\u00edtulos.\n        rates (ArrayLike): Taxas YTM correspondentes.\n        show_coupons (bool, optional): Se True, inclui datas intermedi\u00e1rias de cupom.\n            Padr\u00e3o False.\n\n    Returns:\n        pl.DataFrame: DataFrame com as taxas spot.\n\n    Output Columns:\n        - MaturityDate (Date): Data de vencimento.\n        - BDToMat (Int64): Dias \u00fateis entre liquida\u00e7\u00e3o e vencimento.\n        - SpotRate (Float64): Taxa spot (real).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb\n        &gt;&gt;&gt; # Busca as taxas de NTN-B para uma data de refer\u00eancia\n        &gt;&gt;&gt; df = ntnb.data(\"16-08-2024\")\n        &gt;&gt;&gt; # Calcula as taxas spot considerando a liquida\u00e7\u00e3o na data de refer\u00eancia\n        &gt;&gt;&gt; ntnb.spot_rates(\n        ...     settlement=\"16-08-2024\",\n        ...     maturities=df[\"MaturityDate\"],\n        ...     rates=df[\"IndicativeRate\"],\n        ... )\n        shape: (14, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-05-15   \u2506 185     \u2506 0.063893 \u2502\n        \u2502 2026-08-15   \u2506 502     \u2506 0.066141 \u2502\n        \u2502 2027-05-15   \u2506 687     \u2506 0.064087 \u2502\n        \u2502 2028-08-15   \u2506 1002    \u2506 0.063057 \u2502\n        \u2502 2029-05-15   \u2506 1186    \u2506 0.061458 \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n        \u2502 2040-08-15   \u2506 4009    \u2506 0.058326 \u2502\n        \u2502 2045-05-15   \u2506 5196    \u2506 0.060371 \u2502\n        \u2502 2050-08-15   \u2506 6511    \u2506 0.060772 \u2502\n        \u2502 2055-05-15   \u2506 7700    \u2506 0.059909 \u2502\n        \u2502 2060-08-15   \u2506 9017    \u2506 0.060652 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Notes:\n        O c\u00e1lculo considera:\n        - Mapear todas as datas de pagamento at\u00e9 o \u00faltimo vencimento.\n        - Interpolar as taxas YTM nas datas intermedi\u00e1rias.\n        - Calcular a cota\u00e7\u00e3o da NTN-B para cada vencimento.\n        - Calcular as taxas spot reais.\n    \"\"\"\n    if any_is_empty(settlement, maturities, rates):\n        return pl.DataFrame()\n\n    settlement, maturities, rates = _validar_entradas_taxa_spot(\n        settlement, maturities, rates\n    )\n\n    df = _criar_df_bootstrap(settlement, rates, maturities)\n\n    # Bootstrap para calcular taxas spot\n    linhas = df.to_dicts()\n    primeiro_vencimento = maturities.min()\n    for linha in linhas:\n        vencimento = linha[\"MaturityDate\"]\n\n        # Taxas spot &lt;= primeiro vencimento s\u00e3o YTM por defini\u00e7\u00e3o\n        if vencimento &lt;= primeiro_vencimento:\n            taxa_spot = linha[\"YTM\"]\n            df = _atualizar_taxa_spot(df, vencimento, taxa_spot)\n            continue\n\n        # Calcula taxa spot para o vencimento corrente\n        valor_presente_cupons = _calcular_valor_presente_cupons(\n            df, settlement, vencimento\n        )\n        preco_titulo = quotation(settlement, vencimento, linha[\"YTM\"])\n        fator_preco = VALOR_FINAL / (preco_titulo - valor_presente_cupons)\n        taxa_spot = fator_preco ** (1 / linha[\"BYears\"]) - 1\n\n        df = _atualizar_taxa_spot(df, vencimento, taxa_spot)\n\n    if not show_coupons:\n        df = df.filter(pl.col(\"MaturityDate\").is_in(maturities.to_list()))\n    return df.select([\"MaturityDate\", \"BDToMat\", \"SpotRate\"])\n</code></pre>"},{"location":"ntnb1/","title":"NTN-B1","text":""},{"location":"ntnb1/#pyield.tn.ntnb1.CommercialName","title":"<code>CommercialName</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum do nome comercial usado para identificar o tipo de NTN-B1 (Renda+ ou Educa+).</p>"},{"location":"ntnb1/#pyield.tn.ntnb1.cash_flows","title":"<code>cash_flows(settlement, maturity, commercial_name)</code>","text":"<p>Gera os fluxos de caixa da NTN-B1 entre liquida\u00e7\u00e3o e vencimento.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o (exclusiva).</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>Nome comercial (Renda+ ou Educa+).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas de fluxo.</p> Output Columns <ul> <li>PaymentDate (Date): Data de pagamento do fluxo.</li> <li>CashFlow (Float64): Valor do fluxo.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.cash_flows(\"10-05-2024\", \"15-12-2060\", r_mais)\nshape: (240, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow \u2502\n\u2502 ---         \u2506 ---      \u2502\n\u2502 date        \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2041-01-15  \u2506 0.004167 \u2502\n\u2502 2041-02-15  \u2506 0.004167 \u2502\n\u2502 2041-03-15  \u2506 0.004167 \u2502\n\u2502 2041-04-15  \u2506 0.004167 \u2502\n\u2502 2041-05-15  \u2506 0.004167 \u2502\n\u2502 \u2026           \u2506 \u2026        \u2502\n\u2502 2060-08-15  \u2506 0.004167 \u2502\n\u2502 2060-09-15  \u2506 0.004167 \u2502\n\u2502 2060-10-15  \u2506 0.004167 \u2502\n\u2502 2060-11-15  \u2506 0.004167 \u2502\n\u2502 2060-12-15  \u2506 0.004167 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def cash_flows(\n    settlement: DateLike, maturity: DateLike, commercial_name: CommercialName\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Gera os fluxos de caixa da NTN-B1 entre liquida\u00e7\u00e3o e vencimento.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o (exclusiva).\n        maturity (DateLike): Data de vencimento.\n        commercial_name (CommercialName): Nome comercial (Renda+ ou Educa+).\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas de fluxo.\n\n    Output Columns:\n        - PaymentDate (Date): Data de pagamento do fluxo.\n        - CashFlow (Float64): Valor do fluxo.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.cash_flows(\"10-05-2024\", \"15-12-2060\", r_mais)\n        shape: (240, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow \u2502\n        \u2502 ---         \u2506 ---      \u2502\n        \u2502 date        \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2041-01-15  \u2506 0.004167 \u2502\n        \u2502 2041-02-15  \u2506 0.004167 \u2502\n        \u2502 2041-03-15  \u2506 0.004167 \u2502\n        \u2502 2041-04-15  \u2506 0.004167 \u2502\n        \u2502 2041-05-15  \u2506 0.004167 \u2502\n        \u2502 \u2026           \u2506 \u2026        \u2502\n        \u2502 2060-08-15  \u2506 0.004167 \u2502\n        \u2502 2060-09-15  \u2506 0.004167 \u2502\n        \u2502 2060-10-15  \u2506 0.004167 \u2502\n        \u2502 2060-11-15  \u2506 0.004167 \u2502\n        \u2502 2060-12-15  \u2506 0.004167 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    if any_is_empty(settlement, maturity, commercial_name):\n        return pl.DataFrame({\"PaymentDate\": [], \"CashFlow\": []})\n\n    # Valida e normaliza datas\n    liquidacao = conversores.converter_datas(settlement)\n    vencimento = conversores.converter_datas(maturity)\n\n    # Obt\u00e9m as datas de amortiza\u00e7\u00e3o\n    datas_pagamento = payment_dates(liquidacao, vencimento, commercial_name)\n    df = pl.DataFrame({\"PaymentDate\": datas_pagamento})\n\n    # Par\u00e2metros do t\u00edtulo\n    pagamento_amort, pagamento_amort_final, _ = _obter_parametros_titulo(\n        commercial_name\n    )\n\n    # Define o fluxo final no vencimento e os demais como amortiza\u00e7\u00f5es\n    df = df.with_columns(\n        pl.when(pl.col(\"PaymentDate\") == vencimento)\n        .then(pagamento_amort_final)\n        .otherwise(pagamento_amort)\n        .alias(\"CashFlow\")\n    )\n\n    # Retorna o DataFrame com datas e fluxos\n    return df\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.duration","title":"<code>duration(settlement, maturity, rate, commercial_name)</code>","text":"<p>Calcula a Macaulay duration da NTN-B1 em anos \u00fateis.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto usada no c\u00e1lculo.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>Nome comercial (Renda+ ou Educa+).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Macaulay duration em anos \u00fateis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.duration(\"23-06-2025\", \"15-12-2084\", 0.0686, r_mais)\n47.10493458167134\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def duration(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    commercial_name: CommercialName,\n) -&gt; float:\n    \"\"\"\n    Calcula a Macaulay duration da NTN-B1 em anos \u00fateis.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto usada no c\u00e1lculo.\n        commercial_name (CommercialName): Nome comercial (Renda+ ou Educa+).\n\n    Returns:\n        float: Macaulay duration em anos \u00fateis.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.duration(\"23-06-2025\", \"15-12-2084\", 0.0686, r_mais)\n        47.10493458167134\n    \"\"\"\n    # Retorna NaN se houver entradas nulas\n    if any_is_empty(settlement, maturity, rate, commercial_name):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity, commercial_name)\n    anos_uteis = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** anos_uteis\n    duracao = (dcf * anos_uteis).sum() / dcf.sum()\n\n    # Trunca a dura\u00e7\u00e3o para 14 casas para reprodutibilidade\n    return tools.truncate(duracao, 14)\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.dv01","title":"<code>dv01(settlement, maturity, rate, vna, commercial_name=CommercialName.RENDA_MAIS)</code>","text":"<p>Calcula o DV01 (Dollar Value of 01) da NTN-B1 em R$.</p> <p>Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) da NTN-B1.</p> required <code>vna</code> <code>float</code> <p>Valor nominal atualizado (VNA).</p> required <code>commercial_name</code> <code>CommercialName</code> <p>Nome comercial (Renda+ ou Educa+).</p> <code>RENDA_MAIS</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.dv01(\"23-06-2025\", \"15-12-2084\", 0.0686, 4299.160173, r_mais)\n0.7738490000000127\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    vna: float,\n    commercial_name: CommercialName = CommercialName.RENDA_MAIS,\n) -&gt; float:\n    \"\"\"\n    Calcula o DV01 (Dollar Value of 01) da NTN-B1 em R$.\n\n    Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto (YTM) da NTN-B1.\n        vna (float): Valor nominal atualizado (VNA).\n        commercial_name (CommercialName): Nome comercial (Renda+ ou Educa+).\n\n    Returns:\n        float: DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.dv01(\"23-06-2025\", \"15-12-2084\", 0.0686, 4299.160173, r_mais)\n        0.7738490000000127\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate, vna, commercial_name):\n        return float(\"nan\")\n\n    quotation1 = quotation(settlement, maturity, rate, commercial_name)\n    quotation2 = quotation(settlement, maturity, rate + 0.0001, commercial_name)\n    price1 = price(vna, quotation1)\n    price2 = price(vna, quotation2)\n    return price1 - price2\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.payment_dates","title":"<code>payment_dates(settlement, maturity, commercial_name)</code>","text":"<p>Gera todas as datas de amortiza\u00e7\u00e3o entre liquida\u00e7\u00e3o e vencimento.</p> <p>As datas s\u00e3o inclusivas. Os pagamentos ocorrem de 15/01 do ano de convers\u00e3o at\u00e9 15/12 do ano de vencimento.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o (exclusiva).</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>Nome comercial (Renda+ ou Educa+).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie de datas de amortiza\u00e7\u00e3o no intervalo.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.payment_dates(\"10-05-2024\", \"15-12-2050\", r_mais)\nshape: (240,)\nSeries: 'payment_dates' [date]\n[\n    2031-01-15\n    2031-02-15\n    2031-03-15\n    2031-04-15\n    2031-05-15\n    \u2026\n    2050-08-15\n    2050-09-15\n    2050-10-15\n    2050-11-15\n    2050-12-15\n]\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def payment_dates(\n    settlement: DateLike, maturity: DateLike, commercial_name: CommercialName\n) -&gt; pl.Series:\n    \"\"\"\n    Gera todas as datas de amortiza\u00e7\u00e3o entre liquida\u00e7\u00e3o e vencimento.\n\n    As datas s\u00e3o inclusivas. Os pagamentos ocorrem de 15/01 do ano de convers\u00e3o\n    at\u00e9 15/12 do ano de vencimento.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o (exclusiva).\n        maturity (DateLike): Data de vencimento.\n        commercial_name (CommercialName): Nome comercial (Renda+ ou Educa+).\n\n    Returns:\n        pl.Series: S\u00e9rie de datas de amortiza\u00e7\u00e3o no intervalo.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.payment_dates(\"10-05-2024\", \"15-12-2050\", r_mais)\n        shape: (240,)\n        Series: 'payment_dates' [date]\n        [\n            2031-01-15\n            2031-02-15\n            2031-03-15\n            2031-04-15\n            2031-05-15\n            \u2026\n            2050-08-15\n            2050-09-15\n            2050-10-15\n            2050-11-15\n            2050-12-15\n        ]\n    \"\"\"\n    if any_is_empty(settlement, maturity, commercial_name):\n        return pl.Series(\"payment_dates\", dtype=pl.Date)\n\n    # Valida e normaliza datas\n    liquidacao = conversores.converter_datas(settlement)\n    vencimento = conversores.converter_datas(maturity)\n\n    if vencimento &lt;= liquidacao:\n        raise ValueError(\"A data de vencimento deve ser posterior \u00e0 liquida\u00e7\u00e3o.\")\n\n    vencimento = vencimento.replace(day=15)\n\n    # Par\u00e2metros do t\u00edtulo\n    _, _, numero_amortizacoes = _obter_parametros_titulo(commercial_name)\n\n    datas_amortizacao = [\n        vencimento - relativedelta(months=i) for i in range(numero_amortizacoes)\n    ]\n\n    if len(datas_amortizacao) == 0:\n        raise ValueError(\"Nenhuma data de amortiza\u00e7\u00e3o ap\u00f3s a liquida\u00e7\u00e3o.\")\n\n    datas_pagamento = pl.Series(name=\"payment_dates\", values=datas_amortizacao).cast(\n        pl.Date\n    )\n\n    return datas_pagamento.filter(datas_pagamento &gt; liquidacao).sort()\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calcula o pre\u00e7o da NTN-B1 pelas regras do Tesouro Nacional.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>Valor nominal atualizado (VNA).</p> required <code>quotation</code> <code>float</code> <p>Cota\u00e7\u00e3o da NTN-B1 em base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pre\u00e7o da NTN-B1 truncado em 6 casas decimais.</p> References <ul> <li>SEI Proccess 17944.005214/2024-09</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; ntnb1.price(4299.160173, 99.3651 / 100)\n4271.864805\n&gt;&gt;&gt; ntnb1.price(4315.498383, 100.6409 / 100)\n4343.156412\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o pre\u00e7o da NTN-B1 pelas regras do Tesouro Nacional.\n\n    Args:\n        vna (float): Valor nominal atualizado (VNA).\n        quotation (float): Cota\u00e7\u00e3o da NTN-B1 em base 100.\n\n    Returns:\n        float: Pre\u00e7o da NTN-B1 truncado em 6 casas decimais.\n\n    References:\n         - SEI Proccess 17944.005214/2024-09\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; ntnb1.price(4299.160173, 99.3651 / 100)\n        4271.864805\n        &gt;&gt;&gt; ntnb1.price(4315.498383, 100.6409 / 100)\n        4343.156412\n    \"\"\"\n    if any_is_empty(vna, quotation):\n        return float(\"nan\")\n    return tools.truncate(vna * quotation, 6)\n</code></pre>"},{"location":"ntnb1/#pyield.tn.ntnb1.quotation","title":"<code>quotation(settlement, maturity, rate, commercial_name)</code>","text":"<p>Calcula a cota\u00e7\u00e3o da NTN-B1 em base 100 pelas regras da ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento da NTN-B1.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) usada no valor presente.</p> required <code>commercial_name</code> <code>CommercialName</code> <p>Nome comercial (Renda+ ou Educa+).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Cota\u00e7\u00e3o da NTN-B1 truncada em 6 casas decimais.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnb1\n&gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n&gt;&gt;&gt; ntnb1.quotation(\"18-06-2025\", \"15-12-2084\", 0.07010, r_mais)\n0.038332\n</code></pre> Source code in <code>pyield/tn/ntnb1.py</code> <pre><code>def quotation(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    commercial_name: CommercialName,\n) -&gt; float:\n    \"\"\"\n    Calcula a cota\u00e7\u00e3o da NTN-B1 em base 100 pelas regras da ANBIMA.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento da NTN-B1.\n        rate (float): Taxa de desconto (YTM) usada no valor presente.\n        commercial_name (CommercialName): Nome comercial (Renda+ ou Educa+).\n\n    Returns:\n        float: Cota\u00e7\u00e3o da NTN-B1 truncada em 6 casas decimais.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnb1\n        &gt;&gt;&gt; r_mais = ntnb1.CommercialName.RENDA_MAIS\n        &gt;&gt;&gt; ntnb1.quotation(\"18-06-2025\", \"15-12-2084\", 0.07010, r_mais)\n        0.038332\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate, commercial_name):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity, commercial_name)\n    datas_fluxo = df[\"PaymentDate\"]\n    valores_fluxo = df[\"CashFlow\"]\n\n    # Calcula dias \u00fateis entre liquida\u00e7\u00e3o e fluxos\n    dias_uteis = bday.count(settlement, datas_fluxo)\n\n    # Calcula anos \u00fateis truncados conforme ANBIMA\n    anos_uteis = tools.truncate(dias_uteis / 252, 14)\n\n    fator_desconto = (1 + rate) ** anos_uteis\n\n    # Calcula o valor presente de cada fluxo (DCF) com arredondamento ANBIMA\n    valor_presente_fluxos = (valores_fluxo / fator_desconto).round(10)\n\n    # Retorna a cota\u00e7\u00e3o (soma do DCF) com truncamento ANBIMA\n    return tools.truncate(valor_presente_fluxos.sum(), 6)\n</code></pre>"},{"location":"ntnbp/","title":"NTN-B Principal","text":""},{"location":"ntnbp/#pyield.tn.ntnbprinc.dv01","title":"<code>dv01(settlement, maturity, rate, face_value)</code>","text":"<p>Calcula o DV01 (Dollar Value of 01) da NTN-B Principal em R$.</p> <p>Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) do t\u00edtulo.</p> required <code>face_value</code> <code>float</code> <p>Valor nominal atualizado (VNA).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnbprinc as bp\n&gt;&gt;&gt; bp.dv01(\"02-12-2025\", \"15-05-2029\", 0.0777, 4567.033825)\n1.1200559999997495\n</code></pre> Source code in <code>pyield/tn/ntnbprinc.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    face_value: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o DV01 (Dollar Value of 01) da NTN-B Principal em R$.\n\n    Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto (YTM) do t\u00edtulo.\n        face_value (float): Valor nominal atualizado (VNA).\n\n    Returns:\n        float: DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnbprinc as bp\n        &gt;&gt;&gt; bp.dv01(\"02-12-2025\", \"15-05-2029\", 0.0777, 4567.033825)\n        1.1200559999997495\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate, face_value):\n        return float(\"nan\")\n\n    preco_1 = price(settlement, maturity, rate, face_value)\n    preco_2 = price(settlement, maturity, rate + 0.0001, face_value)\n    return preco_1 - preco_2\n</code></pre>"},{"location":"ntnbp/#pyield.tn.ntnbprinc.price","title":"<code>price(settlement, maturity, rate, face_value)</code>","text":"<p>Calcula o pre\u00e7o da NTN-B Principal pelas regras da ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) do t\u00edtulo.</p> required <code>face_value</code> <code>float</code> <p>Valor nominal atualizado (VNA).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pre\u00e7o da NTN-B Principal conforme ANBIMA.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnbprinc\n&gt;&gt;&gt; ntnbprinc.price(\"02-12-2025\", \"15-05-2029\", 0.0777, 4567.033825)\n3537.763157\n</code></pre> Source code in <code>pyield/tn/ntnbprinc.py</code> <pre><code>def price(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n    face_value: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o pre\u00e7o da NTN-B Principal pelas regras da ANBIMA.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto (YTM) do t\u00edtulo.\n        face_value (float): Valor nominal atualizado (VNA).\n\n    Returns:\n        float: Pre\u00e7o da NTN-B Principal conforme ANBIMA.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnbprinc\n        &gt;&gt;&gt; ntnbprinc.price(\"02-12-2025\", \"15-05-2029\", 0.0777, 4567.033825)\n        3537.763157\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate, face_value):\n        return float(\"nan\")\n\n    # Calcula dias \u00fateis entre liquida\u00e7\u00e3o e vencimento\n    dias_uteis = bday.count(settlement, maturity)\n\n    # Calcula anos \u00fateis truncados conforme ANBIMA\n    anos_uteis = tools.truncate(dias_uteis / 252, 14)\n\n    fator_desconto = (1 + rate) ** anos_uteis\n\n    # Trunca o pre\u00e7o em 6 casas conforme ANBIMA\n    return tools.truncate(face_value / fator_desconto, 6)\n</code></pre>"},{"location":"ntnc/","title":"NTN-C","text":""},{"location":"ntnc/#pyield.tn.ntnc.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Gera os fluxos de caixa da NTN-C entre liquida\u00e7\u00e3o e vencimento.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o (exclusiva).</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas de fluxo.</p> Output Columns <ul> <li>PaymentDate (Date): Data de pagamento do fluxo.</li> <li>CashFlow (Float64): Valor do fluxo.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.cash_flows(\"21-03-2025\", \"01-01-2031\")\nshape: (12, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-07-01  \u2506 5.830052   \u2502\n\u2502 2026-01-01  \u2506 5.830052   \u2502\n\u2502 2026-07-01  \u2506 5.830052   \u2502\n\u2502 2027-01-01  \u2506 5.830052   \u2502\n\u2502 2027-07-01  \u2506 5.830052   \u2502\n\u2502 \u2026           \u2506 \u2026          \u2502\n\u2502 2029-01-01  \u2506 5.830052   \u2502\n\u2502 2029-07-01  \u2506 5.830052   \u2502\n\u2502 2030-01-01  \u2506 5.830052   \u2502\n\u2502 2030-07-01  \u2506 5.830052   \u2502\n\u2502 2031-01-01  \u2506 105.830052 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def cash_flows(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Gera os fluxos de caixa da NTN-C entre liquida\u00e7\u00e3o e vencimento.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o (exclusiva).\n        maturity (DateLike): Data de vencimento.\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas de fluxo.\n\n    Output Columns:\n        - PaymentDate (Date): Data de pagamento do fluxo.\n        - CashFlow (Float64): Valor do fluxo.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.cash_flows(\"21-03-2025\", \"01-01-2031\")\n        shape: (12, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-07-01  \u2506 5.830052   \u2502\n        \u2502 2026-01-01  \u2506 5.830052   \u2502\n        \u2502 2026-07-01  \u2506 5.830052   \u2502\n        \u2502 2027-01-01  \u2506 5.830052   \u2502\n        \u2502 2027-07-01  \u2506 5.830052   \u2502\n        \u2502 \u2026           \u2506 \u2026          \u2502\n        \u2502 2029-01-01  \u2506 5.830052   \u2502\n        \u2502 2029-07-01  \u2506 5.830052   \u2502\n        \u2502 2030-01-01  \u2506 5.830052   \u2502\n        \u2502 2030-07-01  \u2506 5.830052   \u2502\n        \u2502 2031-01-01  \u2506 105.830052 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(settlement, maturity):\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    # Valida e normaliza datas\n    liquidacao = conversores.converter_datas(settlement)\n    vencimento = conversores.converter_datas(maturity)\n\n    # Obt\u00e9m as datas de cupom entre liquida\u00e7\u00e3o e vencimento\n    datas_pagamento = payment_dates(liquidacao, vencimento)\n\n    # Retorna DataFrame vazio se n\u00e3o houver pagamentos (liquida\u00e7\u00e3o &gt;= vencimento)\n    if datas_pagamento.is_empty():\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    # Obt\u00e9m os valores corretos de cupom e final\n    valor_cupom = _obter_valor_cupom(vencimento)\n    valor_final = _obter_valor_final(vencimento)\n\n    # Build dataframe and assign cash flows using Polars expressions\n    df = pl.DataFrame({\"PaymentDate\": datas_pagamento}).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == vencimento)\n        .then(valor_final)\n        .otherwise(valor_cupom)\n        .alias(\"CashFlow\")\n    )\n    return df\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.data","title":"<code>data(date)</code>","text":"<p>Busca as taxas indicativas de NTN-C para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame Polars com os dados de NTN-C.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo (ex.: \"NTN-C\").</li> <li>ReferenceDate (Date): Data de refer\u00eancia dos dados.</li> <li>SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento do t\u00edtulo.</li> <li>BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.</li> <li>Duration (Float64): Macaulay Duration do t\u00edtulo (anos).</li> <li>DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.</li> <li>DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.</li> <li>Price (Float64): Pre\u00e7o unit\u00e1rio (PU).</li> <li>BidRate (Float64): Taxa de compra (decimal).</li> <li>AskRate (Float64): Taxa de venda (decimal).</li> <li>IndicativeRate (Float64): Taxa indicativa (decimal).</li> <li>DIRate (Float64): Taxa DI interpolada (flat forward).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.data(\"23-08-2024\")\nshape: (1, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-C    \u2506 770100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.061591 \u2506 0.057587 \u2506 0.059617       \u2506 0.11575 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Busca as taxas indicativas de NTN-C para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.DataFrame: DataFrame Polars com os dados de NTN-C.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo (ex.: \"NTN-C\").\n        - ReferenceDate (Date): Data de refer\u00eancia dos dados.\n        - SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento do t\u00edtulo.\n        - BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.\n        - Duration (Float64): Macaulay Duration do t\u00edtulo (anos).\n        - DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.\n        - DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.\n        - Price (Float64): Pre\u00e7o unit\u00e1rio (PU).\n        - BidRate (Float64): Taxa de compra (decimal).\n        - AskRate (Float64): Taxa de venda (decimal).\n        - IndicativeRate (Float64): Taxa indicativa (decimal).\n        - DIRate (Float64): Taxa DI interpolada (flat forward).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.data(\"23-08-2024\")\n        shape: (1, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-C    \u2506 770100    \u2506 2000-07-01    \u2506 \u2026 \u2506 0.061591 \u2506 0.057587 \u2506 0.059617       \u2506 0.11575 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa: E501\n    return anbima.tpf_data(date, \"NTN-C\")\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calcula a Macaulay duration da NTN-C em anos \u00fateis.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto usada no c\u00e1lculo.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Macaulay duration em anos \u00fateis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.duration(\"21-03-2025\", \"01-01-2031\", 0.067626)\n4.405363320448\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def duration(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula a Macaulay duration da NTN-C em anos \u00fateis.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto usada no c\u00e1lculo.\n\n    Returns:\n        float: Macaulay duration em anos \u00fateis.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.duration(\"21-03-2025\", \"01-01-2031\", 0.067626)\n        4.405363320448\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    anos_uteis = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    dcf = df[\"CashFlow\"] / (1 + rate) ** anos_uteis\n    duracao = (dcf * anos_uteis).sum() / dcf.sum()\n    # Truncar para 14 casas decimais para repetibilidade dos resultados\n    return ferramentas.truncate(duracao, 14)\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Gera todas as datas de cupom entre liquida\u00e7\u00e3o e vencimento (inclusivas). A NTN-C \u00e9 definida pela data de vencimento.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o (exclusiva).</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie de datas de cupom no intervalo. Retorna s\u00e9rie vazia se vencimento for menor que a liquida\u00e7\u00e3o.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.payment_dates(\"21-03-2025\", \"01-01-2031\")\nshape: (12,)\nSeries: '' [date]\n[\n    2025-07-01\n    2026-01-01\n    2026-07-01\n    2027-01-01\n    2027-07-01\n    \u2026\n    2029-01-01\n    2029-07-01\n    2030-01-01\n    2030-07-01\n    2031-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def payment_dates(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.Series:\n    \"\"\"\n    Gera todas as datas de cupom entre liquida\u00e7\u00e3o e vencimento (inclusivas).\n    A NTN-C \u00e9 definida pela data de vencimento.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o (exclusiva).\n        maturity (DateLike): Data de vencimento.\n\n    Returns:\n        pl.Series: S\u00e9rie de datas de cupom no intervalo. Retorna s\u00e9rie vazia se\n            vencimento for menor que a liquida\u00e7\u00e3o.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.payment_dates(\"21-03-2025\", \"01-01-2031\")\n        shape: (12,)\n        Series: '' [date]\n        [\n            2025-07-01\n            2026-01-01\n            2026-07-01\n            2027-01-01\n            2027-07-01\n            \u2026\n            2029-01-01\n            2029-07-01\n            2030-01-01\n            2030-07-01\n            2031-01-01\n        ]\n    \"\"\"\n    if any_is_empty(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n\n    # Valida e normaliza datas\n    liquidacao = conversores.converter_datas(settlement)\n    vencimento = conversores.converter_datas(maturity)\n\n    # Check if maturity date is after the start date\n    if vencimento &lt; liquidacao:\n        return pl.Series(dtype=pl.Date)\n\n    # Initialize loop variables\n    data_cupom = vencimento\n    datas_cupons = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while data_cupom &gt; liquidacao:\n        datas_cupons.append(data_cupom)\n        # Retrocede 6 meses\n        data_cupom -= relativedelta(months=6)\n\n    return pl.Series(datas_cupons).sort()\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calcula o pre\u00e7o da NTN-C pelas regras da ANBIMA.</p> <p>price = VNA * quotation / 100</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>Valor nominal atualizado (VNA).</p> required <code>quotation</code> <code>float</code> <p>Cota\u00e7\u00e3o da NTN-C em base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pre\u00e7o da NTN-C truncado em 6 casas decimais.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.price(6598.913723, 126.4958)\n8347.348705\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o pre\u00e7o da NTN-C pelas regras da ANBIMA.\n\n    price = VNA * quotation / 100\n\n    Args:\n        vna (float): Valor nominal atualizado (VNA).\n        quotation (float): Cota\u00e7\u00e3o da NTN-C em base 100.\n\n    Returns:\n        float: Pre\u00e7o da NTN-C truncado em 6 casas decimais.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.price(6598.913723, 126.4958)\n        8347.348705\n    \"\"\"\n    if any_is_empty(vna, quotation):\n        return float(\"nan\")\n    return ferramentas.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnc/#pyield.tn.ntnc.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calcula a cota\u00e7\u00e3o da NTN-C em base 100 pelas regras da ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento da NTN-C.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) usada no valor presente.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Cota\u00e7\u00e3o da NTN-C truncada em 4 casas decimais.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>O cupom semestral \u00e9 2,956301, equivalente a 6% a.a. com capitaliza\u00e7\u00e3o   semestral e arredondamento para 6 casas, conforme ANBIMA.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnc\n&gt;&gt;&gt; ntnc.quotation(\"21-03-2025\", \"01-01-2031\", 0.067626)\n126.4958\n</code></pre> Source code in <code>pyield/tn/ntnc.py</code> <pre><code>def quotation(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula a cota\u00e7\u00e3o da NTN-C em base 100 pelas regras da ANBIMA.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o da opera\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento da NTN-C.\n        rate (float): Taxa de desconto (YTM) usada no valor presente.\n\n    Returns:\n        float: Cota\u00e7\u00e3o da NTN-C truncada em 4 casas decimais.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - O cupom semestral \u00e9 2,956301, equivalente a 6% a.a. com capitaliza\u00e7\u00e3o\n          semestral e arredondamento para 6 casas, conforme ANBIMA.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnc\n        &gt;&gt;&gt; ntnc.quotation(\"21-03-2025\", \"01-01-2031\", 0.067626)\n        126.4958\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df = cash_flows(settlement, maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    datas_fluxo = df[\"PaymentDate\"]\n    valores_fluxo = df[\"CashFlow\"]\n\n    # Calcula dias \u00fateis entre liquida\u00e7\u00e3o e fluxos\n    dias_uteis = bday.count(settlement, datas_fluxo)\n\n    # Calcula anos \u00fateis truncados conforme ANBIMA\n    anos_uteis = ferramentas.truncate(dias_uteis / 252, 14)\n\n    fator_desconto = (1 + rate) ** anos_uteis\n\n    # Calcula o valor presente de cada fluxo (DCF) com arredondamento ANBIMA\n    valor_presente_fluxos = (valores_fluxo / fator_desconto).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return ferramentas.truncate(valor_presente_fluxos.sum(), 4)\n</code></pre>"},{"location":"ntnf/","title":"NTN-F","text":""},{"location":"ntnf/#pyield.tn.ntnf.cash_flows","title":"<code>cash_flows(settlement, maturity, adj_payment_dates=False)</code>","text":"<p>Gera os fluxos de caixa da NTN-F entre liquida\u00e7\u00e3o (exclusiva) e vencimento (inclusivo). Os fluxos incluem cupons e o pagamento final no vencimento.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o (exclusiva).</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento do t\u00edtulo.</p> required <code>adj_payment_dates</code> <code>bool</code> <p>Se True, ajusta as datas de pagamento para o pr\u00f3ximo dia \u00fatil.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas \"PaymentDate\" e \"CashFlow\".</p> Output Columns <ul> <li>PaymentDate (Date): Data de pagamento do fluxo.</li> <li>CashFlow (Float64): Valor do fluxo de caixa.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.cash_flows(\"15-05-2024\", \"01-01-2027\")\nshape: (6, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PaymentDate \u2506 CashFlow   \u2502\n\u2502 ---         \u2506 ---        \u2502\n\u2502 date        \u2506 f64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-07-01  \u2506 48.80885   \u2502\n\u2502 2025-01-01  \u2506 48.80885   \u2502\n\u2502 2025-07-01  \u2506 48.80885   \u2502\n\u2502 2026-01-01  \u2506 48.80885   \u2502\n\u2502 2026-07-01  \u2506 48.80885   \u2502\n\u2502 2027-01-01  \u2506 1048.80885 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def cash_flows(\n    settlement: DateLike,\n    maturity: DateLike,\n    adj_payment_dates: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Gera os fluxos de caixa da NTN-F entre liquida\u00e7\u00e3o (exclusiva) e vencimento\n    (inclusivo). Os fluxos incluem cupons e o pagamento final no vencimento.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o (exclusiva).\n        maturity (DateLike): Data de vencimento do t\u00edtulo.\n        adj_payment_dates (bool): Se True, ajusta as datas de pagamento para o\n            pr\u00f3ximo dia \u00fatil.\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas \"PaymentDate\" e \"CashFlow\".\n\n    Output Columns:\n        - PaymentDate (Date): Data de pagamento do fluxo.\n        - CashFlow (Float64): Valor do fluxo de caixa.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.cash_flows(\"15-05-2024\", \"01-01-2027\")\n        shape: (6, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 PaymentDate \u2506 CashFlow   \u2502\n        \u2502 ---         \u2506 ---        \u2502\n        \u2502 date        \u2506 f64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-07-01  \u2506 48.80885   \u2502\n        \u2502 2025-01-01  \u2506 48.80885   \u2502\n        \u2502 2025-07-01  \u2506 48.80885   \u2502\n        \u2502 2026-01-01  \u2506 48.80885   \u2502\n        \u2502 2026-07-01  \u2506 48.80885   \u2502\n        \u2502 2027-01-01  \u2506 1048.80885 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(settlement, maturity):\n        return pl.DataFrame()\n    # Normaliza datas de entrada\n    liquidacao = cv.converter_datas(settlement)\n    vencimento = cv.converter_datas(maturity)\n\n    # Obt\u00e9m as datas de pagamento entre liquida\u00e7\u00e3o e vencimento\n    datas_pagamento = payment_dates(liquidacao, vencimento)\n\n    # Retorna DataFrame vazio se n\u00e3o houver pagamentos (liquida\u00e7\u00e3o &gt;= vencimento)\n    if datas_pagamento.is_empty():\n        return pl.DataFrame(schema={\"PaymentDate\": pl.Date, \"CashFlow\": pl.Float64})\n\n    # Define o fluxo final no vencimento e os demais como cupom\n    df = pl.DataFrame(\n        data={\"PaymentDate\": datas_pagamento},\n    ).with_columns(\n        pl.when(pl.col(\"PaymentDate\") == vencimento)\n        .then(VALOR_FINAL)\n        .otherwise(VALOR_CUPOM)\n        .alias(\"CashFlow\")\n    )\n\n    if adj_payment_dates:\n        df = df.with_columns(PaymentDate=bday.offset_expr(\"PaymentDate\", 0))\n    return df\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.data","title":"<code>data(date)</code>","text":"<p>Busca as taxas indicativas de NTN-F para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame Polars com os dados de NTN-F.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo (ex.: \"NTN-F\").</li> <li>ReferenceDate (Date): Data de refer\u00eancia dos dados.</li> <li>SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.</li> <li>IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento do t\u00edtulo.</li> <li>BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.</li> <li>Duration (Float64): Macaulay Duration do t\u00edtulo (anos).</li> <li>DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.</li> <li>DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.</li> <li>Price (Float64): Pre\u00e7o unit\u00e1rio (PU).</li> <li>BidRate (Float64): Taxa de compra (decimal).</li> <li>AskRate (Float64): Taxa de venda (decimal).</li> <li>IndicativeRate (Float64): Taxa indicativa (decimal).</li> <li>DIRate (Float64): Taxa DI interpolada (flat forward).</li> <li>StdDev (Float64): Desvio padr\u00e3o da taxa indicativa.</li> <li>LowerBoundRateD0 (Float64): Limite inferior do intervalo (D+0).</li> <li>UpperBoundRateD0 (Float64): Limite superior do intervalo (D+0).</li> <li>LowerBoundRateD1 (Float64): Limite inferior do intervalo (D+1).</li> <li>UpperBoundRateD1 (Float64): Limite superior do intervalo (D+1).</li> <li>Criteria (String): Crit\u00e9rio utilizado pela ANBIMA.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.data(\"23-08-2024\")\nshape: (6, 14)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n\u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n\u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2014-01-10    \u2506 \u2026 \u2506 0.107864 \u2506 0.107524 \u2506 0.107692       \u2506 0.10823 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.11527  \u2506 0.114948 \u2506 0.115109       \u2506 0.11467 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.116468 \u2506 0.11621  \u2506 0.116337       \u2506 0.1156  \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.117072 \u2506 0.116958 \u2506 0.117008       \u2506 0.11575 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.116473 \u2506 0.116164 \u2506 0.116307       \u2506 0.11554 \u2502\n\u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.116662 \u2506 0.116523 \u2506 0.116586       \u2506 0.11531 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def data(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Busca as taxas indicativas de NTN-F para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.DataFrame: DataFrame Polars com os dados de NTN-F.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo (ex.: \"NTN-F\").\n        - ReferenceDate (Date): Data de refer\u00eancia dos dados.\n        - SelicCode (Int64): C\u00f3digo do t\u00edtulo no SELIC.\n        - IssueBaseDate (Date): Data base/emiss\u00e3o do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento do t\u00edtulo.\n        - BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.\n        - Duration (Float64): Macaulay Duration do t\u00edtulo (anos).\n        - DV01 (Float64): Varia\u00e7\u00e3o no pre\u00e7o para 1bp de taxa.\n        - DV01USD (Float64): DV01 convertido para USD pela PTAX do dia.\n        - Price (Float64): Pre\u00e7o unit\u00e1rio (PU).\n        - BidRate (Float64): Taxa de compra (decimal).\n        - AskRate (Float64): Taxa de venda (decimal).\n        - IndicativeRate (Float64): Taxa indicativa (decimal).\n        - DIRate (Float64): Taxa DI interpolada (flat forward).\n        - StdDev (Float64): Desvio padr\u00e3o da taxa indicativa.\n        - LowerBoundRateD0 (Float64): Limite inferior do intervalo (D+0).\n        - UpperBoundRateD0 (Float64): Limite superior do intervalo (D+0).\n        - LowerBoundRateD1 (Float64): Limite inferior do intervalo (D+1).\n        - UpperBoundRateD1 (Float64): Limite superior do intervalo (D+1).\n        - Criteria (String): Crit\u00e9rio utilizado pela ANBIMA.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.data(\"23-08-2024\")\n        shape: (6, 14)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 ReferenceDate \u2506 BondType \u2506 SelicCode \u2506 IssueBaseDate \u2506 \u2026 \u2506 BidRate  \u2506 AskRate  \u2506 IndicativeRate \u2506 DIRate  \u2502\n        \u2502 ---           \u2506 ---      \u2506 ---       \u2506 ---           \u2506   \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---     \u2502\n        \u2502 date          \u2506 str      \u2506 i64       \u2506 date          \u2506   \u2506 f64      \u2506 f64      \u2506 f64            \u2506 f64     \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2014-01-10    \u2506 \u2026 \u2506 0.107864 \u2506 0.107524 \u2506 0.107692       \u2506 0.10823 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2016-01-15    \u2506 \u2026 \u2506 0.11527  \u2506 0.114948 \u2506 0.115109       \u2506 0.11467 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2018-01-05    \u2506 \u2026 \u2506 0.116468 \u2506 0.11621  \u2506 0.116337       \u2506 0.1156  \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2020-01-10    \u2506 \u2026 \u2506 0.117072 \u2506 0.116958 \u2506 0.117008       \u2506 0.11575 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2022-01-07    \u2506 \u2026 \u2506 0.116473 \u2506 0.116164 \u2506 0.116307       \u2506 0.11554 \u2502\n        \u2502 2024-08-23    \u2506 NTN-F    \u2506 950199    \u2506 2024-01-05    \u2506 \u2026 \u2506 0.116662 \u2506 0.116523 \u2506 0.116586       \u2506 0.11531 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"  # noqa\n    return anbima.tpf_data(date, \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.di_net_spread","title":"<code>di_net_spread(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates)</code>","text":"<p>Calcula o spread l\u00edquido sobre DI dado a YTM e a curva DI.</p> <p>A fun\u00e7\u00e3o determina o spread que iguala o valor presente dos fluxos ao pre\u00e7o do t\u00edtulo. Interpola as taxas DI nas datas de pagamento e encontra o spread (em bps) que zera a diferen\u00e7a de pre\u00e7os.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o para o c\u00e1lculo.</p> required <code>ntnf_maturity</code> <code>DateLike</code> <p>Data de vencimento do t\u00edtulo.</p> required <code>ntnf_rate</code> <code>float</code> <p>Taxa YTM do t\u00edtulo.</p> required <code>di_rates</code> <code>ArrayLike</code> <p>S\u00e9rie de taxas DI.</p> required <code>di_expirations</code> <code>ArrayLike</code> <p>Vencimentos da curva DI.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Spread l\u00edquido em formato decimal (ex.: 0.0012 = 12 bps). Retorna NaN em caso de erro.</p> <p>Examples:</p>"},{"location":"ntnf/#pyield.tn.ntnf.di_net_spread--obs-apenas-algumas-taxas-di-serao-usadas-no-exemplo","title":"Obs: apenas algumas taxas DI ser\u00e3o usadas no exemplo.","text":"<pre><code>&gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n&gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n&gt;&gt;&gt; spread = di_net_spread(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n&gt;&gt;&gt; round(spread * 10_000, 2)  # Converte para bps para exibi\u00e7\u00e3o\n12.13\n</code></pre> <pre><code>&gt;&gt;&gt; # Entradas nulas retornam float('nan')\n&gt;&gt;&gt; di_net_spread(\n...     settlement=None,\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\nnan\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def di_net_spread(  # noqa\n    settlement: DateLike,\n    ntnf_maturity: DateLike,\n    ntnf_rate: float,\n    di_expirations: ArrayLike,\n    di_rates: ArrayLike,\n) -&gt; float:\n    \"\"\"\n    Calcula o spread l\u00edquido sobre DI dado a YTM e a curva DI.\n\n    A fun\u00e7\u00e3o determina o spread que iguala o valor presente dos fluxos ao pre\u00e7o\n    do t\u00edtulo. Interpola as taxas DI nas datas de pagamento e encontra o spread\n    (em bps) que zera a diferen\u00e7a de pre\u00e7os.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o para o c\u00e1lculo.\n        ntnf_maturity (DateLike): Data de vencimento do t\u00edtulo.\n        ntnf_rate (float): Taxa YTM do t\u00edtulo.\n        di_rates (ArrayLike): S\u00e9rie de taxas DI.\n        di_expirations (ArrayLike): Vencimentos da curva DI.\n\n    Returns:\n        float: Spread l\u00edquido em formato decimal (ex.: 0.0012 = 12 bps).\n            Retorna NaN em caso de erro.\n\n    Examples:\n        # Obs: apenas algumas taxas DI ser\u00e3o usadas no exemplo.\n        &gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n        &gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n        &gt;&gt;&gt; spread = di_net_spread(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        &gt;&gt;&gt; round(spread * 10_000, 2)  # Converte para bps para exibi\u00e7\u00e3o\n        12.13\n\n        &gt;&gt;&gt; # Entradas nulas retornam float('nan')\n        &gt;&gt;&gt; di_net_spread(\n        ...     settlement=None,\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        nan\n    \"\"\"\n    # Valida\u00e7\u00e3o de inputs\n    if any_is_empty(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates):\n        return float(\"nan\")\n\n    # Garante di_rates como Series\n    if not isinstance(di_rates, pl.Series):\n        taxas_di = pl.Series(di_rates)\n    else:\n        taxas_di = di_rates\n\n    # Cria\u00e7\u00e3o do interpolador\n    interpolador_ff = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        taxas_di,\n    )\n\n    # Gera\u00e7\u00e3o dos fluxos de caixa do NTN-F\n    df = cash_flows(settlement, ntnf_maturity)\n    if df.is_empty():\n        return float(\"nan\")\n\n    dias_uteis_pagamento = bday.count(settlement, df[\"PaymentDate\"])\n    anos_uteis_pagamento = dias_uteis_pagamento / 252\n\n    df = df.with_columns(\n        BDaysToPayment=dias_uteis_pagamento,\n        DIRateInterp=interpolador_ff(dias_uteis_pagamento),\n    )\n\n    # Extra\u00e7\u00e3o dos dados para o c\u00e1lculo num\u00e9rico\n    preco_titulo = price(settlement, ntnf_maturity, ntnf_rate)\n    fluxos_titulo = df[\"CashFlow\"]\n    di_interpolada = df[\"DIRateInterp\"]\n\n    # Fun\u00e7\u00e3o de diferen\u00e7a de pre\u00e7o para o solver\n    def diferenca_preco(p: float) -&gt; float:\n        fluxos_descontados = (\n            fluxos_titulo / (1 + di_interpolada + p) ** anos_uteis_pagamento\n        )\n        return fluxos_descontados.sum() - preco_titulo\n\n    # 7. Resolver para o spread\n    return _resolver_spread(diferenca_preco)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>Defini\u00e7\u00e3o do spread (forma bruta):     DISpread_raw = IndicativeRate - SettlementRate</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Padr\u00e3o False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas do spread.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento.</li> <li>DISpread (Float64): Spread em decimal ou bps conforme par\u00e2metro.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.di_spreads(\"30-05-2025\", bps=True)\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def di_spreads(date: DateLike, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    Defini\u00e7\u00e3o do spread (forma bruta):\n        DISpread_raw = IndicativeRate - SettlementRate\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Padr\u00e3o False.\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas do spread.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento.\n        - DISpread (Float64): Spread em decimal ou bps conforme par\u00e2metro.\n\n    Raises:\n        ValueError: Se os dados de DI n\u00e3o possuem 'SettlementRate' ou est\u00e3o vazios.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.di_spreads(\"30-05-2025\", bps=True)\n        shape: (5, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return pre_di_spreads(date, bps=bps).filter(pl.col(\"BondType\") == \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calcula a Macaulay duration de uma NTN-F em anos \u00fateis.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o para o c\u00e1lculo.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento do t\u00edtulo.</p> required <code>rate</code> <code>float</code> <p>Taxa YTM usada para descontar os fluxos.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Macaulay duration em anos \u00fateis. Retorna NaN se inv\u00e1lido.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n6.32854218039796\n</code></pre> <p>Entradas nulas retornam NaN:</p> <pre><code>&gt;&gt;&gt; ntnf.duration(None, \"01-01-2035\", 0.121785)\nnan\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def duration(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula a Macaulay duration de uma NTN-F em anos \u00fateis.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o para o c\u00e1lculo.\n        maturity (DateLike): Data de vencimento do t\u00edtulo.\n        rate (float): Taxa YTM usada para descontar os fluxos.\n\n    Returns:\n        float: Macaulay duration em anos \u00fateis. Retorna NaN se inv\u00e1lido.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n        6.32854218039796\n\n        Entradas nulas retornam NaN:\n        &gt;&gt;&gt; ntnf.duration(None, \"01-01-2035\", 0.121785)\n        nan\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df_fluxos = cash_flows(settlement, maturity)\n    if df_fluxos.is_empty():\n        return float(\"nan\")\n\n    anos_uteis = bday.count(settlement, df_fluxos[\"PaymentDate\"]) / 252\n    dcf = df_fluxos[\"CashFlow\"] / (1 + rate) ** anos_uteis\n    duracao = (dcf * anos_uteis).sum() / dcf.sum()\n    return duracao\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.dv01","title":"<code>dv01(settlement, maturity, rate)</code>","text":"<p>Calcula o DV01 (Dollar Value of 01) de uma NTN-F em R$.</p> <p>Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) do t\u00edtulo.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.dv01(\"26-03-2025\", \"01-01-2035\", 0.151375)\n0.39025200000003224\n</code></pre> <p>Entradas nulas retornam NaN:</p> <pre><code>&gt;&gt;&gt; ntnf.dv01(\"\", \"01-01-2035\", 0.151375)\nnan\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def dv01(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o DV01 (Dollar Value of 01) de uma NTN-F em R$.\n\n    Representa a varia\u00e7\u00e3o de pre\u00e7o para um aumento de 1 bp (0,01%) na taxa.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n        rate (float): Taxa de desconto (YTM) do t\u00edtulo.\n\n    Returns:\n        float: DV01, varia\u00e7\u00e3o de pre\u00e7o para 1 bp.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.dv01(\"26-03-2025\", \"01-01-2035\", 0.151375)\n        0.39025200000003224\n\n        Entradas nulas retornam NaN:\n        &gt;&gt;&gt; ntnf.dv01(\"\", \"01-01-2035\", 0.151375)\n        nan\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n\n    preco_1 = price(settlement, maturity, rate)\n    preco_2 = price(settlement, maturity, rate + 0.0001)\n    return preco_1 - preco_2\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.maturities","title":"<code>maturities(date)</code>","text":"<p>Busca os vencimentos de NTN-F dispon\u00edveis para a data de refer\u00eancia.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie de datas de vencimento de NTN-F.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.maturities(\"23-08-2024\")\nshape: (6,)\nSeries: 'MaturityDate' [date]\n[\n    2025-01-01\n    2027-01-01\n    2029-01-01\n    2031-01-01\n    2033-01-01\n    2035-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def maturities(date: DateLike) -&gt; pl.Series:\n    \"\"\"\n    Busca os vencimentos de NTN-F dispon\u00edveis para a data de refer\u00eancia.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.Series: S\u00e9rie de datas de vencimento de NTN-F.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.maturities(\"23-08-2024\")\n        shape: (6,)\n        Series: 'MaturityDate' [date]\n        [\n            2025-01-01\n            2027-01-01\n            2029-01-01\n            2031-01-01\n            2033-01-01\n            2035-01-01\n        ]\n    \"\"\"\n    return data(date)[\"MaturityDate\"]\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Gera todas as datas de cupom entre liquida\u00e7\u00e3o e vencimento.</p> <p>As datas s\u00e3o exclusivas para a liquida\u00e7\u00e3o e inclusivas para o vencimento. Os cupons s\u00e3o pagos em 1\u00ba de janeiro e 1\u00ba de julho. O t\u00edtulo NTN-F \u00e9 determinado pela data de vencimento.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pl.Series: S\u00e9rie com as datas de cupom entre a liquida\u00e7\u00e3o (exclusiva) e o vencimento (inclusiva). Retorna s\u00e9rie vazia se o vencimento for menor ou igual \u00e0 liquida\u00e7\u00e3o.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.payment_dates(\"15-05-2024\", \"01-01-2027\")\nshape: (6,)\nSeries: 'payment_dates' [date]\n[\n    2024-07-01\n    2025-01-01\n    2025-07-01\n    2026-01-01\n    2026-07-01\n    2027-01-01\n]\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def payment_dates(\n    settlement: DateLike,\n    maturity: DateLike,\n) -&gt; pl.Series:\n    \"\"\"\n    Gera todas as datas de cupom entre liquida\u00e7\u00e3o e vencimento.\n\n    As datas s\u00e3o exclusivas para a liquida\u00e7\u00e3o e inclusivas para o vencimento.\n    Os cupons s\u00e3o pagos em 1\u00ba de janeiro e 1\u00ba de julho. O t\u00edtulo NTN-F \u00e9\n    determinado pela data de vencimento.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o.\n        maturity (DateLike): Data de vencimento.\n\n    Returns:\n        pl.Series: S\u00e9rie com as datas de cupom entre a liquida\u00e7\u00e3o (exclusiva)\n            e o vencimento (inclusiva). Retorna s\u00e9rie vazia se o vencimento\n            for menor ou igual \u00e0 liquida\u00e7\u00e3o.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.payment_dates(\"15-05-2024\", \"01-01-2027\")\n        shape: (6,)\n        Series: 'payment_dates' [date]\n        [\n            2024-07-01\n            2025-01-01\n            2025-07-01\n            2026-01-01\n            2026-07-01\n            2027-01-01\n        ]\n    \"\"\"\n    if any_is_empty(settlement, maturity):\n        return pl.Series(dtype=pl.Date)\n    # Normaliza datas\n    liquidacao = cv.converter_datas(settlement)\n    vencimento = cv.converter_datas(maturity)\n\n    # Verifica se vencimento \u00e9 posterior \u00e0 liquida\u00e7\u00e3o\n    if vencimento &lt;= liquidacao:\n        return pl.Series(dtype=pl.Date)\n\n    # Inicializa vari\u00e1veis do loop\n    data_cupom = vencimento\n    datas_cupons = []\n\n    # Itera de tr\u00e1s para frente do vencimento at\u00e9 a liquida\u00e7\u00e3o\n    while data_cupom &gt; liquidacao:\n        datas_cupons.append(data_cupom)\n        # Retrocede 6 meses\n        data_cupom -= relativedelta(months=6)\n\n    return pl.Series(name=\"payment_dates\", values=datas_cupons).sort()\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.premium","title":"<code>premium(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates)</code>","text":"<p>Calcula o pr\u00eamio de uma NTN-F sobre a curva DI.</p> <p>A fun\u00e7\u00e3o compara o fator de desconto impl\u00edcito da NTN-F com o da curva DI, determinando o pr\u00eamio l\u00edquido com base na diferen\u00e7a entre os fatores.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o para o c\u00e1lculo.</p> required <code>ntnf_maturity</code> <code>DateLike</code> <p>Data de vencimento da NTN-F.</p> required <code>ntnf_rate</code> <code>float</code> <p>Taxa de YTM da NTN-F.</p> required <code>di_expirations</code> <code>DateLike</code> <p>Datas de vencimento da curva DI.</p> required <code>di_rates</code> <code>ArrayLike</code> <p>Taxas DI correspondentes aos vencimentos.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pr\u00eamio da NTN-F sobre a curva DI, em fator. Retorna NaN em erro.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Obs: apenas algumas taxas DI ser\u00e3o usadas no exemplo.\n&gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n&gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n&gt;&gt;&gt; premium(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n1.0099602679927115\n</code></pre> Notes <p>A fun\u00e7\u00e3o ajusta as datas de pagamento para dias \u00fateis e calcula o valor presente dos fluxos da NTN-F usando as taxas DI.</p> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def premium(  # noqa\n    settlement: DateLike,\n    ntnf_maturity: DateLike,\n    ntnf_rate: float,\n    di_expirations: DateLike,\n    di_rates: ArrayLike,\n) -&gt; float:\n    \"\"\"\n    Calcula o pr\u00eamio de uma NTN-F sobre a curva DI.\n\n    A fun\u00e7\u00e3o compara o fator de desconto impl\u00edcito da NTN-F com o da curva DI,\n    determinando o pr\u00eamio l\u00edquido com base na diferen\u00e7a entre os fatores.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o para o c\u00e1lculo.\n        ntnf_maturity (DateLike): Data de vencimento da NTN-F.\n        ntnf_rate (float): Taxa de YTM da NTN-F.\n        di_expirations (DateLike): Datas de vencimento da curva DI.\n        di_rates (ArrayLike): Taxas DI correspondentes aos vencimentos.\n\n    Returns:\n        float: Pr\u00eamio da NTN-F sobre a curva DI, em fator. Retorna NaN em erro.\n\n    Examples:\n        &gt;&gt;&gt; # Obs: apenas algumas taxas DI ser\u00e3o usadas no exemplo.\n        &gt;&gt;&gt; exp_dates = [\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"]\n        &gt;&gt;&gt; di_rates = [0.10823, 0.11594, 0.11531]\n        &gt;&gt;&gt; premium(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        1.0099602679927115\n\n    Notes:\n        A fun\u00e7\u00e3o ajusta as datas de pagamento para dias \u00fateis e calcula o valor\n        presente dos fluxos da NTN-F usando as taxas DI.\n\n    \"\"\"\n    if any_is_empty(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates):\n        return float(\"nan\")\n\n    if not isinstance(di_rates, pl.Series):\n        taxas_di = pl.Series(di_rates)\n    else:\n        taxas_di = di_rates\n\n    df_fluxos = cash_flows(settlement, ntnf_maturity, adj_payment_dates=True)\n    if df_fluxos.is_empty():\n        return float(\"nan\")\n\n    interpolador_ff = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),  # type: ignore[arg-type]\n        taxas_di,\n    )\n\n    dias_uteis_pagamento = bday.count(settlement, df_fluxos[\"PaymentDate\"])\n    df = df_fluxos.with_columns(\n        BDToMat=dias_uteis_pagamento,\n        BYears=dias_uteis_pagamento / 252,\n        DIRate=interpolador_ff(dias_uteis_pagamento),\n    )\n\n    preco_titulo = tools.calculate_present_value(\n        cash_flows=df[\"CashFlow\"],\n        rates=df[\"DIRate\"],\n        periods=df[\"BYears\"],\n    )\n\n    if math.isnan(preco_titulo):\n        return float(\"nan\")\n\n    def diferenca_preco(taxa: float) -&gt; float:\n        fluxos_descontados = df[\"CashFlow\"] / (1 + taxa) ** df[\"BYears\"]\n        return fluxos_descontados.sum() - preco_titulo\n\n    di_ytm = _resolver_spread(diferenca_preco)\n\n    if math.isnan(di_ytm):\n        return float(\"nan\")\n\n    fator_ntnf = (1 + ntnf_rate) ** (1 / 252)\n    fator_di = (1 + di_ytm) ** (1 / 252)\n    if fator_di == 1:\n        return float(\"inf\") if fator_ntnf &gt; 1 else 0.0\n\n    premio = (fator_ntnf - 1) / (fator_di - 1)\n    return premio\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calcula o pre\u00e7o da NTN-F pelas regras da ANBIMA, equivalente ao valor presente dos fluxos descontados pela taxa de YTM informada.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o para c\u00e1lculo do pre\u00e7o.</p> required <code>maturity</code> <code>DateLike</code> <p>Data de vencimento do t\u00edtulo.</p> required <code>rate</code> <code>float</code> <p>Taxa de desconto (YTM) usada para calcular o valor presente.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pre\u00e7o da NTN-F conforme ANBIMA.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>O cupom semestral \u00e9 48,81, que representa 10% a.a. com capitaliza\u00e7\u00e3o   semestral e arredondamento para 5 casas, conforme ANBIMA.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf\n&gt;&gt;&gt; ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n895.359254\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def price(\n    settlement: DateLike,\n    maturity: DateLike,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calcula o pre\u00e7o da NTN-F pelas regras da ANBIMA, equivalente ao valor\n    presente dos fluxos descontados pela taxa de YTM informada.\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o para c\u00e1lculo do pre\u00e7o.\n        maturity (DateLike): Data de vencimento do t\u00edtulo.\n        rate (float): Taxa de desconto (YTM) usada para calcular o valor presente.\n\n    Returns:\n        float: Pre\u00e7o da NTN-F conforme ANBIMA.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - O cupom semestral \u00e9 48,81, que representa 10% a.a. com capitaliza\u00e7\u00e3o\n          semestral e arredondamento para 5 casas, conforme ANBIMA.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf\n        &gt;&gt;&gt; ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n        895.359254\n    \"\"\"\n    if any_is_empty(settlement, maturity, rate):\n        return float(\"nan\")\n\n    df_fluxos = cash_flows(settlement, maturity)\n    if df_fluxos.is_empty():\n        return float(\"nan\")\n\n    valores_fluxo = df_fluxos[\"CashFlow\"]\n    dias_uteis = bday.count(settlement, df_fluxos[\"PaymentDate\"])\n    anos_uteis = tools.truncate(dias_uteis / 252, 14)\n    fatores_desconto = (1 + rate) ** anos_uteis\n    # Calcula o valor presente de cada fluxo (DCF) com arredondamento ANBIMA\n    dcf = (valores_fluxo / fatores_desconto).round(9)\n    # Soma dos fluxos descontados com truncamento ANBIMA\n    return tools.truncate(dcf.sum(), 6)\n</code></pre>"},{"location":"ntnf/#pyield.tn.ntnf.spot_rates","title":"<code>spot_rates(settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates, show_coupons=False)</code>","text":"<p>Calcula as taxas spot (zero cupom) para NTN-F usando bootstrap.</p> <p>O bootstrap determina as taxas spot a partir dos yields dos t\u00edtulos. O m\u00e9todo resolve iterativamente as taxas que descontam os fluxos ao pre\u00e7o. Usa as LTNs (zero cupom) at\u00e9 o \u00faltimo vencimento LTN dispon\u00edvel. Ap\u00f3s isso, calcula as taxas spot a partir das NTN-F.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateLike</code> <p>Data de liquida\u00e7\u00e3o para o c\u00e1lculo.</p> required <code>ltn_maturities</code> <code>ArrayLike</code> <p>Vencimentos conhecidos de LTN.</p> required <code>ltn_rates</code> <code>ArrayLike</code> <p>Taxas conhecidas de LTN.</p> required <code>ntnf_maturities</code> <code>ArrayLike</code> <p>Vencimentos conhecidos de NTN-F.</p> required <code>ntnf_rates</code> <code>ArrayLike</code> <p>Taxas conhecidas de NTN-F.</p> required <code>show_coupons</code> <code>bool</code> <p>Se True, inclui as datas de cupom (julho). Padr\u00e3o False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com colunas \"MaturityDate\", \"BDToMat\" e \"SpotRate\". \"BDToMat\" s\u00e3o os dias \u00fateis entre liquida\u00e7\u00e3o e vencimento.</p> Output Columns <ul> <li>MaturityDate (Date): Data de vencimento.</li> <li>BDToMat (Int64): Dias \u00fateis entre liquida\u00e7\u00e3o e vencimento.</li> <li>SpotRate (Float64): Taxa spot (zero cupom).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ntnf, ltn\n&gt;&gt;&gt; df_ltn = ltn.data(\"03-09-2024\")\n&gt;&gt;&gt; df_ntnf = ntnf.data(\"03-09-2024\")\n&gt;&gt;&gt; ntnf.spot_rates(\n...     settlement=\"03-09-2024\",\n...     ltn_maturities=df_ltn[\"MaturityDate\"],\n...     ltn_rates=df_ltn[\"IndicativeRate\"],\n...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n... )\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-01-01   \u2506 83      \u2506 0.108837 \u2502\n\u2502 2027-01-01   \u2506 584     \u2506 0.119981 \u2502\n\u2502 2029-01-01   \u2506 1083    \u2506 0.122113 \u2502\n\u2502 2031-01-01   \u2506 1584    \u2506 0.122231 \u2502\n\u2502 2033-01-01   \u2506 2088    \u2506 0.121355 \u2502\n\u2502 2035-01-01   \u2506 2587    \u2506 0.121398 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/ntnf.py</code> <pre><code>def spot_rates(  # noqa\n    settlement: DateLike,\n    ltn_maturities: ArrayLike,\n    ltn_rates: ArrayLike,\n    ntnf_maturities: ArrayLike,\n    ntnf_rates: ArrayLike,\n    show_coupons: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula as taxas spot (zero cupom) para NTN-F usando bootstrap.\n\n    O bootstrap determina as taxas spot a partir dos yields dos t\u00edtulos.\n    O m\u00e9todo resolve iterativamente as taxas que descontam os fluxos ao pre\u00e7o.\n    Usa as LTNs (zero cupom) at\u00e9 o \u00faltimo vencimento LTN dispon\u00edvel. Ap\u00f3s\n    isso, calcula as taxas spot a partir das NTN-F.\n\n\n    Args:\n        settlement (DateLike): Data de liquida\u00e7\u00e3o para o c\u00e1lculo.\n        ltn_maturities (ArrayLike): Vencimentos conhecidos de LTN.\n        ltn_rates (ArrayLike): Taxas conhecidas de LTN.\n        ntnf_maturities (ArrayLike): Vencimentos conhecidos de NTN-F.\n        ntnf_rates (ArrayLike): Taxas conhecidas de NTN-F.\n        show_coupons (bool): Se True, inclui as datas de cupom (julho).\n            Padr\u00e3o False.\n\n    Returns:\n        pl.DataFrame: DataFrame com colunas \"MaturityDate\", \"BDToMat\" e \"SpotRate\".\n            \"BDToMat\" s\u00e3o os dias \u00fateis entre liquida\u00e7\u00e3o e vencimento.\n\n    Output Columns:\n        - MaturityDate (Date): Data de vencimento.\n        - BDToMat (Int64): Dias \u00fateis entre liquida\u00e7\u00e3o e vencimento.\n        - SpotRate (Float64): Taxa spot (zero cupom).\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ntnf, ltn\n        &gt;&gt;&gt; df_ltn = ltn.data(\"03-09-2024\")\n        &gt;&gt;&gt; df_ntnf = ntnf.data(\"03-09-2024\")\n        &gt;&gt;&gt; ntnf.spot_rates(\n        ...     settlement=\"03-09-2024\",\n        ...     ltn_maturities=df_ltn[\"MaturityDate\"],\n        ...     ltn_rates=df_ltn[\"IndicativeRate\"],\n        ...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n        ...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n        ... )\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-01-01   \u2506 83      \u2506 0.108837 \u2502\n        \u2502 2027-01-01   \u2506 584     \u2506 0.119981 \u2502\n        \u2502 2029-01-01   \u2506 1083    \u2506 0.122113 \u2502\n        \u2502 2031-01-01   \u2506 1584    \u2506 0.122231 \u2502\n        \u2502 2033-01-01   \u2506 2088    \u2506 0.121355 \u2502\n        \u2502 2035-01-01   \u2506 2587    \u2506 0.121398 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if any_is_empty(settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates):\n        return pl.DataFrame()\n    # 1. Converter e normalizar inputs para Polars\n    liquidacao = cv.converter_datas(settlement)\n    vencimentos_ltn = cv.converter_datas(ltn_maturities)\n    vencimentos_ntnf = cv.converter_datas(ntnf_maturities)\n    if not isinstance(ltn_rates, pl.Series):\n        taxas_ltn = pl.Series(ltn_rates).cast(pl.Float64)\n    else:\n        taxas_ltn = ltn_rates\n    if not isinstance(ntnf_rates, pl.Series):\n        taxas_ntnf = pl.Series(ntnf_rates).cast(pl.Float64)\n    else:\n        taxas_ntnf = ntnf_rates\n\n    # 2. Criar interpoladores (aceitam pl.Series diretamente)\n    interpolador_ltn = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(liquidacao, vencimentos_ltn),\n        known_rates=taxas_ltn,\n    )\n    interpolador_ntnf = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(liquidacao, vencimentos_ntnf),\n        known_rates=taxas_ntnf,\n    )\n\n    # 3. Gerar todas as datas de cupom at\u00e9 o \u00faltimo vencimento NTN-F\n    ultimo_vencimento = vencimentos_ntnf.max()\n    assert isinstance(ultimo_vencimento, dt.date)\n    todas_datas_cupom = payment_dates(liquidacao, ultimo_vencimento)\n\n    # 4. Construir DataFrame inicial\n    dias_uteis_ate_venc = bday.count(liquidacao, todas_datas_cupom)\n    taxas_ytm = interpolador_ntnf(dias_uteis_ate_venc)\n    df = pl.DataFrame(\n        {\n            \"MaturityDate\": todas_datas_cupom,\n            \"BDToMat\": dias_uteis_ate_venc,\n            \"BYears\": dias_uteis_ate_venc / 252,\n            \"YTM\": taxas_ytm,\n        }\n    ).with_columns(\n        Coupon=pl.lit(VALOR_CUPOM),\n    )\n\n    # 5. Loop de bootstrap (iterativo por depend\u00eancia sequencial)\n    ultimo_vencimento_ltn = vencimentos_ltn.max()\n    assert isinstance(ultimo_vencimento_ltn, dt.date)\n\n    lista_vencimentos = df[\"MaturityDate\"]\n    lista_dias_uteis = df[\"BDToMat\"]\n    lista_anos_uteis = df[\"BYears\"]\n    lista_ytm = df[\"YTM\"]\n\n    taxas_spot_resolvidas: list[float | None] = []\n    mapa_spot: dict[dt.date, float | None] = {}\n\n    for i in range(len(df)):\n        data_venc = lista_vencimentos[i]\n        assert isinstance(data_venc, dt.date)\n        dias_uteis_val = int(lista_dias_uteis[i])\n        anos_uteis_val = float(lista_anos_uteis[i])\n        ytm_val = float(lista_ytm[i])\n\n        # Caso esteja antes (ou igual) ao \u00faltimo vencimento LTN: usar interpolador LTN\n        if data_venc &lt;= ultimo_vencimento_ltn:\n            taxa_spot = interpolador_ltn(dias_uteis_val)\n            taxas_spot_resolvidas.append(taxa_spot)\n            mapa_spot[data_venc] = taxa_spot\n            continue\n\n        # Datas de cupom (exclui \u00faltimo pagamento) para este vencimento\n        datas_fluxo = payment_dates(liquidacao, data_venc)[:-1]\n        if len(datas_fluxo) == 0:\n            # Caso improv\u00e1vel, mas protege contra divis\u00e3o por zero mais adiante\n            taxa_spot = None\n            taxas_spot_resolvidas.append(taxa_spot)\n            mapa_spot[data_venc] = taxa_spot\n            continue\n\n        # Recuperar SpotRates j\u00e1 solucionadas para estes cupons\n        taxas_spot_fluxo = [mapa_spot[d] for d in datas_fluxo]\n        periodos_fluxo = bday.count(liquidacao, datas_fluxo) / 252\n        fluxos = [VALOR_CUPOM] * len(datas_fluxo)\n\n        valor_presente_fluxo = tools.calculate_present_value(\n            cash_flows=pl.Series(fluxos),\n            rates=pl.Series(taxas_spot_fluxo),\n            periods=periodos_fluxo,\n        )\n\n        preco_titulo = price(liquidacao, data_venc, ytm_val)\n        fator_preco = VALOR_FINAL / (preco_titulo - valor_presente_fluxo)\n        taxa_spot = fator_preco ** (1 / anos_uteis_val) - 1\n\n        taxas_spot_resolvidas.append(taxa_spot)\n        mapa_spot[data_venc] = taxa_spot\n\n    # 6. Anexar coluna SpotRate\n    df = df.with_columns(SpotRate=pl.Series(taxas_spot_resolvidas, dtype=pl.Float64))\n\n    # 7. Selecionar colunas finais\n    df = df.select([\"MaturityDate\", \"BDToMat\", \"SpotRate\"])\n\n    # 8. Remover cupons (Julho) se n\u00e3o solicitado\n    if not show_coupons:\n        df = df.filter(pl.col(\"MaturityDate\").is_in(vencimentos_ntnf.implode()))\n\n    return df\n</code></pre>"},{"location":"pre/","title":"PRE","text":""},{"location":"pre/#pyield.tn.pre.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>spread = taxa indicativa do PRE - taxa de ajuste do DI</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Padr\u00e3o False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas do spread.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento.</li> <li>DISpread (Float64): Spread em decimal ou bps conforme par\u00e2metro.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\nshape: (18, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def di_spreads(date: DateLike, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    spread = taxa indicativa do PRE - taxa de ajuste do DI\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Padr\u00e3o False.\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas do spread.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento.\n        - DISpread (Float64): Spread em decimal ou bps conforme par\u00e2metro.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\n        shape: (18, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Busca taxas dos t\u00edtulos (LTN e NTN-F)\n    df = (\n        tpf.tpf_data(date, \"PRE\")\n        .with_columns(DISpread=pl.col(\"IndicativeRate\") - pl.col(\"DIRate\"))\n        .select(\"BondType\", \"MaturityDate\", \"DISpread\")\n        .sort(\"BondType\", \"MaturityDate\")\n    )\n\n    if bps:\n        df = df.with_columns(pl.col(\"DISpread\") * 10_000)\n\n    return df\n</code></pre>"},{"location":"pre/#pyield.tn.pre.spot_rates","title":"<code>spot_rates(date)</code>","text":"<p>Cria a curva PRE (taxas zero cupom) para t\u00edtulos prefixados brasileiros.</p> <p>Combina taxas de LTN (j\u00e1 zero cupom) com taxas spot derivadas de NTN-F via bootstrap.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para a consulta.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas da curva PRE.</p> Output Columns <ul> <li>MaturityDate (Date): Data de vencimento.</li> <li>BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.</li> <li>SpotRate (Float64): Taxa spot (zero cupom).</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>Se algum vencimento n\u00e3o puder ser processado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.spot_rates(\"18-06-2025\")\nshape: (17, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n\u2502 ---          \u2506 ---     \u2506 ---      \u2502\n\u2502 date         \u2506 i64     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025-07-01   \u2506 8       \u2506 0.14835  \u2502\n\u2502 2025-10-01   \u2506 74      \u2506 0.147463 \u2502\n\u2502 2026-01-01   \u2506 138     \u2506 0.147752 \u2502\n\u2502 2026-04-01   \u2506 199     \u2506 0.147947 \u2502\n\u2502 2026-07-01   \u2506 260     \u2506 0.147069 \u2502\n\u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n\u2502 2030-01-01   \u2506 1135    \u2506 0.137279 \u2502\n\u2502 2031-01-01   \u2506 1387    \u2506 0.138154 \u2502\n\u2502 2032-01-01   \u2506 1639    \u2506 0.13876  \u2502\n\u2502 2033-01-01   \u2506 1891    \u2506 0.1393   \u2502\n\u2502 2035-01-01   \u2506 2390    \u2506 0.141068 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def spot_rates(date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"\n    Cria a curva PRE (taxas zero cupom) para t\u00edtulos prefixados brasileiros.\n\n    Combina taxas de LTN (j\u00e1 zero cupom) com taxas spot derivadas de NTN-F\n    via bootstrap.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para a consulta.\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas da curva PRE.\n\n    Output Columns:\n        - MaturityDate (Date): Data de vencimento.\n        - BDToMat (Int64): Dias \u00fateis entre refer\u00eancia e vencimento.\n        - SpotRate (Float64): Taxa spot (zero cupom).\n\n    Raises:\n        ValueError: Se algum vencimento n\u00e3o puder ser processado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.spot_rates(\"18-06-2025\")\n        shape: (17, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 MaturityDate \u2506 BDToMat \u2506 SpotRate \u2502\n        \u2502 ---          \u2506 ---     \u2506 ---      \u2502\n        \u2502 date         \u2506 i64     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2025-07-01   \u2506 8       \u2506 0.14835  \u2502\n        \u2502 2025-10-01   \u2506 74      \u2506 0.147463 \u2502\n        \u2502 2026-01-01   \u2506 138     \u2506 0.147752 \u2502\n        \u2502 2026-04-01   \u2506 199     \u2506 0.147947 \u2502\n        \u2502 2026-07-01   \u2506 260     \u2506 0.147069 \u2502\n        \u2502 \u2026            \u2506 \u2026       \u2506 \u2026        \u2502\n        \u2502 2030-01-01   \u2506 1135    \u2506 0.137279 \u2502\n        \u2502 2031-01-01   \u2506 1387    \u2506 0.138154 \u2502\n        \u2502 2032-01-01   \u2506 1639    \u2506 0.13876  \u2502\n        \u2502 2033-01-01   \u2506 1891    \u2506 0.1393   \u2502\n        \u2502 2035-01-01   \u2506 2390    \u2506 0.141068 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Busca dados de LTN (zero cupom)\n    df_ltn = anbima.tpf_data(date, \"LTN\")\n\n    # Busca dados de NTN-F (com cupom)\n    df_ntnf = anbima.tpf_data(date, \"NTN-F\")\n\n    # Verifica se h\u00e1 dados para ambos os tipos\n    if df_ltn.is_empty() and df_ntnf.is_empty():\n        return pl.DataFrame(\n            schema={\n                \"MaturityDate\": pl.Date,\n                \"BDToMat\": pl.Int64,\n                \"SpotRate\": pl.Float64,\n            }\n        )\n\n    # Se s\u00f3 h\u00e1 NTN-F, n\u00e3o \u00e9 poss\u00edvel fazer bootstrap sem LTN\n    if df_ltn.is_empty():\n        raise ValueError(\n            \"N\u00e3o \u00e9 poss\u00edvel construir a curva PRE sem taxas de LTN para bootstrap\"\n        )\n\n    # Se s\u00f3 h\u00e1 LTN, retorna direto (LTN j\u00e1 s\u00e3o zero cupom)\n    if df_ntnf.is_empty():\n        df = _processar_ltn_adicionais(date, df_ltn)\n    else:\n        # Usa spot_rates de NTN-F para calcular zero cupom\n        df_spots = ntnf.spot_rates(\n            settlement=date,\n            ltn_maturities=df_ltn[\"MaturityDate\"],\n            ltn_rates=df_ltn[\"IndicativeRate\"],\n            ntnf_maturities=df_ntnf[\"MaturityDate\"],\n            ntnf_rates=df_ntnf[\"IndicativeRate\"],\n            show_coupons=False,\n        )\n\n        # Encontra vencimentos de LTN que n\u00e3o est\u00e3o no resultado de NTN-F\n        ltn_mask = ~df_ltn[\"MaturityDate\"].is_in(df_spots[\"MaturityDate\"].to_list())\n        ltn_not_in_ntnf = df_ltn.filter(ltn_mask)\n\n        if not ltn_not_in_ntnf.is_empty():\n            # Processa vencimentos de LTN adicionais\n            ltn_subset = _processar_ltn_adicionais(date, ltn_not_in_ntnf)\n\n            # Combina LTN e NTN-F\n            df = pl.concat([df_spots, ltn_subset])\n        else:\n            df = df_spots\n\n    # Valida\u00e7\u00e3o final\n    _validar_resultado_final(df)\n\n    # Ordena por vencimento\n    return df.sort(\"MaturityDate\")\n</code></pre>"},{"location":"tn/","title":"Vis\u00e3o Geral","text":""},{"location":"tn/#pyield.tn.auction","title":"<code>auction(auction_date)</code>","text":"<p>Consulta e processa os resultados de leil\u00f5es de t\u00edtulos do Tesouro Nacional.</p> <p>Busca os dados da API do Tesouro para a data informada e retorna um DataFrame estruturado com quantidades, financeiros, taxas de coloca\u00e7\u00e3o, duration e DV01.</p> <p>Parameters:</p> Name Type Description Default <code>auction_date</code> <code>DateLike</code> <p>Data do leil\u00e3o em qualquer formato aceito por DateLike (ex: \"DD-MM-YYYY\", datetime.date).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame com os dados processados do leil\u00e3o. Em caso de erro na</p> <code>DataFrame</code> <p>requisi\u00e7\u00e3o, no processamento ou se n\u00e3o houver dados para a data</p> <code>DataFrame</code> <p>especificada, retorna DataFrame vazio.</p> Output Columns <ul> <li>data_1v (Date): data de realiza\u00e7\u00e3o do leil\u00e3o (1\u00aa volta).</li> <li>data_liquidacao_1v (Date): data de liquida\u00e7\u00e3o financeira da 1\u00aa volta.</li> <li>data_liquidacao_2v (Date): data de liquida\u00e7\u00e3o financeira da 2\u00aa volta     (se houver).</li> <li>numero_edital (Int64): n\u00famero do edital que rege o leil\u00e3o.</li> <li>tipo_leilao (String): tipo da opera\u00e7\u00e3o (ex: \"Venda\", \"Compra\").</li> <li>titulo (String): c\u00f3digo do t\u00edtulo p\u00fablico leiloado (ex: \"NTN-B\", \"LFT\").</li> <li>benchmark (String): descri\u00e7\u00e3o de refer\u00eancia do t\u00edtulo (ex: \"NTN-B 3 anos\").</li> <li>data_vencimento (Date): data de vencimento do t\u00edtulo.</li> <li>dias_uteis (Int32): dias \u00fateis entre a liquida\u00e7\u00e3o (1v) e o vencimento.</li> <li>dias_corridos (Int32): prazo em dias corridos entre liquida\u00e7\u00e3o e vencimento.</li> <li>duration (Float64): Dura\u00e7\u00e3o de Macaulay em anos, calculada entre a liquida\u00e7\u00e3o     da 1\u00aa volta e o vencimento.</li> <li>prazo_medio (Float64): maturidade m\u00e9dia em anos, conforme metodologia do     Tesouro Nacional.</li> <li>quantidade_ofertada_1v (Int64): quantidade de t\u00edtulos ofertados na 1\u00aa volta.</li> <li>quantidade_ofertada_2v (Int64): quantidade de t\u00edtulos ofertados na 2\u00aa volta.</li> <li>quantidade_aceita_1v (Int64): quantidade de propostas aceitas na 1\u00aa volta.</li> <li>quantidade_aceita_2v (Int64): quantidade de t\u00edtulos aceitos na 2\u00aa volta.</li> <li>quantidade_aceita_total (Int64): soma das quantidades aceitas nas duas voltas.</li> <li>financeiro_ofertado_1v (Float64): financeiro ofertado na 1\u00aa volta (BRL).</li> <li>financeiro_ofertado_2v (Float64): financeiro ofertado na 2\u00aa volta (BRL).</li> <li>financeiro_ofertado_total (Float64): financeiro total ofertado (BRL).</li> <li>financeiro_aceito_1v (Float64): financeiro aceito na 1\u00aa volta (BRL).</li> <li>financeiro_aceito_2v (Float64): financeiro aceito na 2\u00aa volta (BRL).</li> <li>financeiro_aceito_total (Float64): soma do financeiro aceito nas     duas voltas (BRL).</li> <li>quantidade_bcb (Int64): quantidade de t\u00edtulos adquirida pelo Banco Central.</li> <li>financeiro_bcb (Int64): financeiro adquirido pelo Banco Central.</li> <li>colocacao_1v (Float64): taxa de coloca\u00e7\u00e3o da 1\u00aa volta (aceita / ofertada).</li> <li>colocacao_2v (Float64): taxa de coloca\u00e7\u00e3o da 2\u00aa volta (aceita / ofertada).</li> <li>colocacao_total (Float64): taxa de coloca\u00e7\u00e3o total (aceita / ofertada).</li> <li>dv01_1v (Float64): DV01 da 1\u00aa volta em BRL.</li> <li>dv01_2v (Float64): DV01 da 2\u00aa volta em BRL.</li> <li>dv01_total (Float64): DV01 total do leil\u00e3o em BRL.</li> <li>ptax (Float64): taxa PTAX (venda) utilizada na convers\u00e3o do DV01 para USD.</li> <li>dv01_1v_usd (Float64): DV01 da 1\u00aa volta em USD (PTAX do dia).</li> <li>dv01_2v_usd (Float64): DV01 da 2\u00aa volta em USD (PTAX do dia).</li> <li>dv01_total_usd (Float64): DV01 total em USD (PTAX do dia).</li> <li>pu_minimo (Float64): pre\u00e7o unit\u00e1rio m\u00ednimo aceito no leil\u00e3o.</li> <li>pu_medio (Float64): pre\u00e7o unit\u00e1rio m\u00e9dio ponderado das propostas aceitas.</li> <li>tipo_pu_medio (String): indica se o PU m\u00e9dio \u00e9 \"original\" (da API) ou     \"calculado\" (recalculado pela fun\u00e7\u00e3o).</li> <li>taxa_media (Float64): taxa de juros m\u00e9dia aceita (em formato decimal).</li> <li>taxa_maxima (Float64): taxa de juros m\u00e1xima aceita, taxa de corte (decimal).</li> </ul> Source code in <code>pyield/tn/auctions.py</code> <pre><code>def auction(auction_date: DateLike) -&gt; pl.DataFrame:\n    \"\"\"Consulta e processa os resultados de leil\u00f5es de t\u00edtulos do Tesouro Nacional.\n\n    Busca os dados da API do Tesouro para a data informada e retorna um DataFrame\n    estruturado com quantidades, financeiros, taxas de coloca\u00e7\u00e3o, duration e DV01.\n\n    Args:\n        auction_date: Data do leil\u00e3o em qualquer formato aceito por DateLike\n            (ex: \"DD-MM-YYYY\", datetime.date).\n\n    Returns:\n        DataFrame com os dados processados do leil\u00e3o. Em caso de erro na\n        requisi\u00e7\u00e3o, no processamento ou se n\u00e3o houver dados para a data\n        especificada, retorna DataFrame vazio.\n\n    Output Columns:\n        - data_1v (Date): data de realiza\u00e7\u00e3o do leil\u00e3o (1\u00aa volta).\n        - data_liquidacao_1v (Date): data de liquida\u00e7\u00e3o financeira da 1\u00aa volta.\n        - data_liquidacao_2v (Date): data de liquida\u00e7\u00e3o financeira da 2\u00aa volta\n            (se houver).\n        - numero_edital (Int64): n\u00famero do edital que rege o leil\u00e3o.\n        - tipo_leilao (String): tipo da opera\u00e7\u00e3o (ex: \"Venda\", \"Compra\").\n        - titulo (String): c\u00f3digo do t\u00edtulo p\u00fablico leiloado (ex: \"NTN-B\", \"LFT\").\n        - benchmark (String): descri\u00e7\u00e3o de refer\u00eancia do t\u00edtulo (ex: \"NTN-B 3 anos\").\n        - data_vencimento (Date): data de vencimento do t\u00edtulo.\n        - dias_uteis (Int32): dias \u00fateis entre a liquida\u00e7\u00e3o (1v) e o vencimento.\n        - dias_corridos (Int32): prazo em dias corridos entre liquida\u00e7\u00e3o e vencimento.\n        - duration (Float64): Dura\u00e7\u00e3o de Macaulay em anos, calculada entre a liquida\u00e7\u00e3o\n            da 1\u00aa volta e o vencimento.\n        - prazo_medio (Float64): maturidade m\u00e9dia em anos, conforme metodologia do\n            Tesouro Nacional.\n        - quantidade_ofertada_1v (Int64): quantidade de t\u00edtulos ofertados na 1\u00aa volta.\n        - quantidade_ofertada_2v (Int64): quantidade de t\u00edtulos ofertados na 2\u00aa volta.\n        - quantidade_aceita_1v (Int64): quantidade de propostas aceitas na 1\u00aa volta.\n        - quantidade_aceita_2v (Int64): quantidade de t\u00edtulos aceitos na 2\u00aa volta.\n        - quantidade_aceita_total (Int64): soma das quantidades aceitas nas duas voltas.\n        - financeiro_ofertado_1v (Float64): financeiro ofertado na 1\u00aa volta (BRL).\n        - financeiro_ofertado_2v (Float64): financeiro ofertado na 2\u00aa volta (BRL).\n        - financeiro_ofertado_total (Float64): financeiro total ofertado (BRL).\n        - financeiro_aceito_1v (Float64): financeiro aceito na 1\u00aa volta (BRL).\n        - financeiro_aceito_2v (Float64): financeiro aceito na 2\u00aa volta (BRL).\n        - financeiro_aceito_total (Float64): soma do financeiro aceito nas\n            duas voltas (BRL).\n        - quantidade_bcb (Int64): quantidade de t\u00edtulos adquirida pelo Banco Central.\n        - financeiro_bcb (Int64): financeiro adquirido pelo Banco Central.\n        - colocacao_1v (Float64): taxa de coloca\u00e7\u00e3o da 1\u00aa volta (aceita / ofertada).\n        - colocacao_2v (Float64): taxa de coloca\u00e7\u00e3o da 2\u00aa volta (aceita / ofertada).\n        - colocacao_total (Float64): taxa de coloca\u00e7\u00e3o total (aceita / ofertada).\n        - dv01_1v (Float64): DV01 da 1\u00aa volta em BRL.\n        - dv01_2v (Float64): DV01 da 2\u00aa volta em BRL.\n        - dv01_total (Float64): DV01 total do leil\u00e3o em BRL.\n        - ptax (Float64): taxa PTAX (venda) utilizada na convers\u00e3o do DV01 para USD.\n        - dv01_1v_usd (Float64): DV01 da 1\u00aa volta em USD (PTAX do dia).\n        - dv01_2v_usd (Float64): DV01 da 2\u00aa volta em USD (PTAX do dia).\n        - dv01_total_usd (Float64): DV01 total em USD (PTAX do dia).\n        - pu_minimo (Float64): pre\u00e7o unit\u00e1rio m\u00ednimo aceito no leil\u00e3o.\n        - pu_medio (Float64): pre\u00e7o unit\u00e1rio m\u00e9dio ponderado das propostas aceitas.\n        - tipo_pu_medio (String): indica se o PU m\u00e9dio \u00e9 \"original\" (da API) ou\n            \"calculado\" (recalculado pela fun\u00e7\u00e3o).\n        - taxa_media (Float64): taxa de juros m\u00e9dia aceita (em formato decimal).\n        - taxa_maxima (Float64): taxa de juros m\u00e1xima aceita, taxa de corte (decimal).\n    \"\"\"\n    if any_is_empty(auction_date):\n        logger.info(\"Nenhuma data de leil\u00e3o informada.\")\n        return pl.DataFrame()\n    try:\n        auction_date = cv.converter_datas(auction_date)\n        dados_leilao = _buscar_dados_leilao(auction_date)\n        if not dados_leilao:\n            logger.info(\"Sem dados de leil\u00e3o dispon\u00edveis para %s.\", auction_date)\n            return pl.DataFrame()\n        df = _transformar_dados_brutos(dados_leilao)\n        df = _adicionar_duration(df)\n        df = _adicionar_dv01(df)\n        df = _adicionar_dv01_usd(df)\n        df = _adicionar_prazo_medio(df)\n        # Substituir eventuais NaNs por None para compatibilidade com bancos de dados\n        df = df.with_columns(cs.float().fill_nan(None))\n        df = _selecionar_e_ordenar_colunas(df)\n\n        return df\n\n    except requests.exceptions.RequestException as e:\n        logger.error(\"Erro durante a requisi\u00e7\u00e3o da API: %s\", e)\n        return pl.DataFrame()\n    except (ValueError, TypeError) as e:\n        logger.error(\"Erro ao processar a resposta JSON: %s\", e)\n        return pl.DataFrame()\n</code></pre>"},{"location":"tn/#pyield.tn.benchmarks","title":"<code>benchmarks(bond_type=None, include_history=False)</code>","text":"<p>Busca benchmarks de t\u00edtulos p\u00fablicos brasileiros na API do TN.</p> <p>Recupera dados atuais ou hist\u00f3ricos de benchmarks para t\u00edtulos do Tesouro Nacional (ex.: LTN, LFT, NTN-B). Os dados s\u00e3o obtidos diretamente da API oficial do Tesouro Nacional.</p> <p>Parameters:</p> Name Type Description Default <code>bond_type</code> <code>str</code> <p>Tipo do t\u00edtulo a filtrar (ex.: \"LFT\").</p> <code>None</code> <code>include_history</code> <code>bool</code> <p>Se <code>True</code>, inclui hist\u00f3rico; se <code>False</code> (padr\u00e3o), retorna apenas benchmarks vigentes.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame Polars com os benchmarks.</p> Output Columns <ul> <li><code>BondType</code> (String): Tipo do t\u00edtulo (ex.: \"LTN\", \"LFT\", \"NTN-B\").</li> <li><code>MaturityDate</code> (Date): Data de vencimento do benchmark.</li> <li><code>Benchmark</code> (String): Nome/identificador do benchmark.</li> <li><code>StartDate</code> (Date): Data de in\u00edcio da vig\u00eancia.</li> <li><code>EndDate</code> (Date): Data de t\u00e9rmino da vig\u00eancia.</li> </ul> Notes <ul> <li>Dados obtidos da API oficial do Tesouro Nacional.</li> <li>H\u00e1 retry sem verifica\u00e7\u00e3o de certificado apenas em caso de erro SSL.</li> <li>Linhas com valores nulos s\u00e3o descartadas antes do retorno.</li> <li>Documenta\u00e7\u00e3o da API:   https://portal-conhecimento.tesouro.gov.br/catalogo-componentes/api-leil%C3%B5es</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import tn\n&gt;&gt;&gt; df_current = tn.benchmarks()\n&gt;&gt;&gt; # Benchmarks hist\u00f3ricos\n&gt;&gt;&gt; tn.benchmarks(bond_type=\"LFT\", include_history=True).head()\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 Benchmark  \u2506 StartDate  \u2506 EndDate    \u2502\n\u2502 ---      \u2506 ---          \u2506 ---        \u2506 ---        \u2506 ---        \u2502\n\u2502 str      \u2506 date         \u2506 str        \u2506 date       \u2506 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LFT      \u2506 2020-03-01   \u2506 LFT 6 anos \u2506 2014-01-01 \u2506 2014-06-30 \u2502\n\u2502 LFT      \u2506 2020-09-01   \u2506 LFT 6 anos \u2506 2014-07-01 \u2506 2014-12-31 \u2502\n\u2502 LFT      \u2506 2021-03-01   \u2506 LFT 6 anos \u2506 2015-01-01 \u2506 2015-04-30 \u2502\n\u2502 LFT      \u2506 2021-09-01   \u2506 LFT 6 anos \u2506 2015-05-01 \u2506 2015-12-31 \u2502\n\u2502 LFT      \u2506 2022-03-01   \u2506 LFT 6 anos \u2506 2016-01-01 \u2506 2016-06-30 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/benchmark.py</code> <pre><code>def benchmarks(\n    bond_type: str | None = None, include_history: bool = False\n) -&gt; pl.DataFrame:\n    \"\"\"Busca benchmarks de t\u00edtulos p\u00fablicos brasileiros na API do TN.\n\n    Recupera dados atuais ou hist\u00f3ricos de benchmarks para t\u00edtulos do Tesouro\n    Nacional (ex.: LTN, LFT, NTN-B). Os dados s\u00e3o obtidos diretamente da\n    API oficial do Tesouro Nacional.\n\n    Args:\n        bond_type (str, optional): Tipo do t\u00edtulo a filtrar (ex.: \"LFT\").\n        include_history (bool, optional): Se `True`, inclui hist\u00f3rico; se `False`\n            (padr\u00e3o), retorna apenas benchmarks vigentes.\n\n    Returns:\n        pl.DataFrame: DataFrame Polars com os benchmarks.\n\n    Output Columns:\n        - `BondType` (String): Tipo do t\u00edtulo (ex.: \"LTN\", \"LFT\", \"NTN-B\").\n        - `MaturityDate` (Date): Data de vencimento do benchmark.\n        - `Benchmark` (String): Nome/identificador do benchmark.\n        - `StartDate` (Date): Data de in\u00edcio da vig\u00eancia.\n        - `EndDate` (Date): Data de t\u00e9rmino da vig\u00eancia.\n\n    Notes:\n        - Dados obtidos da API oficial do Tesouro Nacional.\n        - H\u00e1 retry sem verifica\u00e7\u00e3o de certificado apenas em caso de erro SSL.\n        - Linhas com valores nulos s\u00e3o descartadas antes do retorno.\n        - Documenta\u00e7\u00e3o da API:\n          https://portal-conhecimento.tesouro.gov.br/catalogo-componentes/api-leil%C3%B5es\n\n    Examples:\n        &gt;&gt;&gt; from pyield import tn\n        &gt;&gt;&gt; df_current = tn.benchmarks()\n        &gt;&gt;&gt; # Benchmarks hist\u00f3ricos\n        &gt;&gt;&gt; tn.benchmarks(bond_type=\"LFT\", include_history=True).head()\n        shape: (5, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 Benchmark  \u2506 StartDate  \u2506 EndDate    \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---        \u2506 ---        \u2506 ---        \u2502\n        \u2502 str      \u2506 date         \u2506 str        \u2506 date       \u2506 date       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LFT      \u2506 2020-03-01   \u2506 LFT 6 anos \u2506 2014-01-01 \u2506 2014-06-30 \u2502\n        \u2502 LFT      \u2506 2020-09-01   \u2506 LFT 6 anos \u2506 2014-07-01 \u2506 2014-12-31 \u2502\n        \u2502 LFT      \u2506 2021-03-01   \u2506 LFT 6 anos \u2506 2015-01-01 \u2506 2015-04-30 \u2502\n        \u2502 LFT      \u2506 2021-09-01   \u2506 LFT 6 anos \u2506 2015-05-01 \u2506 2015-12-31 \u2502\n        \u2502 LFT      \u2506 2022-03-01   \u2506 LFT 6 anos \u2506 2016-01-01 \u2506 2016-06-30 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    dados_api = _buscar_benchmarks_brutos(incluir_historico=include_history)\n    tabela = _processar_dados_api(dados_api)\n\n    # Definir a ordena\u00e7\u00e3o final com base no caso de uso\n    if include_history:\n        # Para dados hist\u00f3ricos, a ordem cronol\u00f3gica \u00e9 mais \u00fatil\n        colunas_ordenacao = [\"StartDate\", \"BondType\", \"MaturityDate\"]\n    else:\n        # Para dados atuais, agrupar por tipo de t\u00edtulo \u00e9 mais \u00fatil\n        colunas_ordenacao = [\"BondType\", \"MaturityDate\"]\n        # Filtrar apenas os dados atuais\n        hoje = clock.today()\n        tabela = tabela.filter(pl.lit(hoje).is_between(\"StartDate\", \"EndDate\"))\n\n    if bond_type:\n        tabela = tabela.filter(pl.col(\"BondType\") == bond_type.upper())\n\n    return tabela.select(ORDEM_FINAL_COLUNAS).sort(colunas_ordenacao)\n</code></pre>"},{"location":"tn/#pyield.tn.di_spreads","title":"<code>di_spreads(date, bps=False)</code>","text":"<p>Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.</p> <p>spread = taxa indicativa do PRE - taxa de ajuste do DI</p> <p>Quando <code>bps=False</code> a coluna retorna essa diferen\u00e7a em formato decimal (ex: 0.000439 \u2248 4.39 bps). Quando <code>bps=True</code> o valor \u00e9 automaticamente multiplicado por 10_000 e exibido diretamente em basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateLike</code> <p>Data de refer\u00eancia para buscar as taxas.</p> required <code>bps</code> <code>bool</code> <p>Se True, retorna DISpread j\u00e1 convertido em basis points. Padr\u00e3o False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame com as colunas do spread.</p> Output Columns <ul> <li>BondType (String): Tipo do t\u00edtulo.</li> <li>MaturityDate (Date): Data de vencimento.</li> <li>DISpread (Float64): Spread em decimal ou bps conforme par\u00e2metro.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import pre\n&gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\nshape: (18, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n\u2502 ---      \u2506 ---          \u2506 ---      \u2502\n\u2502 str      \u2506 date         \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n\u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n\u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n\u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n\u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n\u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n\u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n\u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n\u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n\u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n\u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyield/tn/pre.py</code> <pre><code>def di_spreads(date: DateLike, bps: bool = False) -&gt; pl.DataFrame:\n    \"\"\"\n    Calcula o DI Spread para t\u00edtulos prefixados (LTN e NTN-F) em uma data de refer\u00eancia.\n\n    spread = taxa indicativa do PRE - taxa de ajuste do DI\n\n    Quando ``bps=False`` a coluna retorna essa diferen\u00e7a em formato decimal\n    (ex: 0.000439 \u2248 4.39 bps). Quando ``bps=True`` o valor \u00e9 automaticamente\n    multiplicado por 10_000 e exibido diretamente em basis points.\n\n    Args:\n        date (DateLike): Data de refer\u00eancia para buscar as taxas.\n        bps (bool): Se True, retorna DISpread j\u00e1 convertido em basis points.\n            Padr\u00e3o False.\n\n    Returns:\n        pl.DataFrame: DataFrame com as colunas do spread.\n\n    Output Columns:\n        - BondType (String): Tipo do t\u00edtulo.\n        - MaturityDate (Date): Data de vencimento.\n        - DISpread (Float64): Spread em decimal ou bps conforme par\u00e2metro.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import pre\n        &gt;&gt;&gt; pre.di_spreads(\"30-05-2025\", bps=True)\n        shape: (18, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 BondType \u2506 MaturityDate \u2506 DISpread \u2502\n        \u2502 ---      \u2506 ---          \u2506 ---      \u2502\n        \u2502 str      \u2506 date         \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 LTN      \u2506 2025-07-01   \u2506 4.39     \u2502\n        \u2502 LTN      \u2506 2025-10-01   \u2506 -9.0     \u2502\n        \u2502 LTN      \u2506 2026-01-01   \u2506 -4.88    \u2502\n        \u2502 LTN      \u2506 2026-04-01   \u2506 -4.45    \u2502\n        \u2502 LTN      \u2506 2026-07-01   \u2506 0.81     \u2502\n        \u2502 \u2026        \u2506 \u2026            \u2506 \u2026        \u2502\n        \u2502 NTN-F    \u2506 2027-01-01   \u2506 -3.31    \u2502\n        \u2502 NTN-F    \u2506 2029-01-01   \u2506 14.21    \u2502\n        \u2502 NTN-F    \u2506 2031-01-01   \u2506 21.61    \u2502\n        \u2502 NTN-F    \u2506 2033-01-01   \u2506 11.51    \u2502\n        \u2502 NTN-F    \u2506 2035-01-01   \u2506 22.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    # Busca taxas dos t\u00edtulos (LTN e NTN-F)\n    df = (\n        tpf.tpf_data(date, \"PRE\")\n        .with_columns(DISpread=pl.col(\"IndicativeRate\") - pl.col(\"DIRate\"))\n        .select(\"BondType\", \"MaturityDate\", \"DISpread\")\n        .sort(\"BondType\", \"MaturityDate\")\n    )\n\n    if bps:\n        df = df.with_columns(pl.col(\"DISpread\") * 10_000)\n\n    return df\n</code></pre>"},{"location":"articles/engineering_style_guide/","title":"Guia de Refer\u00eancia de Engenharia (PYield)","text":"<p>Este guia define padr\u00f5es de arquitetura para decis\u00f5es recorrentes no projeto. Objetivo principal: reduzir complexidade sem perder clareza de contrato.</p>"},{"location":"articles/engineering_style_guide/#1-fronteira-de-api-publica","title":"1) Fronteira de API P\u00fablica","text":"<p>Use esta regra como fonte de verdade:</p> <ul> <li>P\u00fablico: o que est\u00e1 documentado e/ou reexportado na API de topo (<code>pyield/__init__.py</code>).</li> <li>Interno: m\u00f3dulos auxiliares fora da API de topo, mesmo que import\u00e1veis por caminho direto.</li> </ul> <p>Princ\u00edpios:</p> <ul> <li>N\u00e3o promover utilit\u00e1rio interno para p\u00fablico sem necessidade real de usu\u00e1rio final.</li> <li>Evitar \u201cvazamento acidental\u201d de API por conveni\u00eancia de import.</li> <li>Toda adi\u00e7\u00e3o p\u00fablica deve ter compromisso de estabilidade e deprecia\u00e7\u00e3o.</li> </ul>"},{"location":"articles/engineering_style_guide/#2-organizacao-de-internals","title":"2) Organiza\u00e7\u00e3o de Internals","text":"<p>Para utilit\u00e1rios transversais (ex.: convers\u00e3o, tipos, retry), preferir namespace interno:</p> <ul> <li><code>pyield/_internal/converters.py</code></li> <li><code>pyield/_internal/types.py</code></li> <li><code>pyield/_internal/retry.py</code></li> </ul> <p>Diretriz de naming:</p> <ul> <li>Dentro de <code>_internal</code>, usar nomes normais de fun\u00e7\u00e3o (sem <code>_</code> no nome por padr\u00e3o).</li> <li>Reservar <code>_nome</code> para helper local que n\u00e3o deve ser ponto de entrada nem interno.</li> </ul>"},{"location":"articles/engineering_style_guide/#3-contrato-de-estabilidade","title":"3) Contrato de Estabilidade","text":"<p>Antes de mudar assinatura/comportamento, classificar alvo:</p> <ol> <li>API p\u00fablica:</li> <li>Exige compatibilidade retroativa ou deprecia\u00e7\u00e3o expl\u00edcita.</li> <li>Exige release notes.</li> <li>API interna:</li> <li>Pode evoluir mais r\u00e1pido.</li> <li>Ainda deve manter consist\u00eancia entre m\u00f3dulos consumidores.</li> </ol>"},{"location":"articles/engineering_style_guide/#4-conversao-de-datas-dois-caminhos-claros","title":"4) Convers\u00e3o de Datas: Dois Caminhos Claros","text":"<p>N\u00e3o unificar camadas diferentes.</p> <ul> <li>Convers\u00e3o escalar/array (fora de express\u00e3o Polars): manter fun\u00e7\u00e3o dedicada.</li> <li>Convers\u00e3o em <code>pl.Expr</code> (dentro de pipeline Polars): criar fun\u00e7\u00e3o dedicada para <code>Expr</code>.</li> </ul> <p>Regras sugeridas para <code>Expr</code>:</p> <ul> <li>Parse tolerante por linha.</li> <li>Data inv\u00e1lida vira <code>null</code> (n\u00e3o explode ETL).</li> <li>Sem\u00e2ntica explicitamente documentada.</li> </ul>"},{"location":"articles/engineering_style_guide/#5-checklist-de-decisao-rapido","title":"5) Checklist de Decis\u00e3o (r\u00e1pido)","text":"<p>Use este checklist antes de implementar:</p> <ol> <li>Isso \u00e9 p\u00fablico ou interno?</li> <li>Se p\u00fablico, qual pol\u00edtica de deprecia\u00e7\u00e3o?</li> <li>Existe utilit\u00e1rio interno que evita duplica\u00e7\u00e3o?</li> <li>A mudan\u00e7a reduz complexidade acidental?</li> <li>H\u00e1 teste cobrindo comportamento novo e regress\u00e3o principal?</li> <li>O comportamento de erro/null est\u00e1 expl\u00edcito?</li> </ol>"},{"location":"articles/engineering_style_guide/#6-testes-minimos-por-tipo-de-mudanca","title":"6) Testes M\u00ednimos por Tipo de Mudan\u00e7a","text":"<ul> <li>Mudan\u00e7a em utilit\u00e1rio interno transversal:</li> <li>teste unit\u00e1rio do utilit\u00e1rio;</li> <li>pelo menos 1 teste de integra\u00e7\u00e3o no m\u00f3dulo consumidor principal.</li> <li>Mudan\u00e7a em API p\u00fablica:</li> <li>testes de contrato (entrada/sa\u00edda/erro);</li> <li>caso de compatibilidade retroativa (quando aplic\u00e1vel).</li> <li>Mudan\u00e7a em <code>Expr</code>:</li> <li>teste com <code>LazyFrame</code>/<code>select</code>;</li> <li>teste com entrada inv\u00e1lida e nula.</li> </ul>"},{"location":"articles/engineering_style_guide/#7-bibliotecas-de-referencia","title":"7) Bibliotecas de Refer\u00eancia","text":"<p>Projetos para consultar decis\u00f5es de arquitetura e manuten\u00e7\u00e3o:</p> <ul> <li>Pydantic</li> <li>FastAPI</li> <li>Pandas</li> <li>SciPy</li> <li>scikit-learn</li> <li>Polars</li> <li>HTTPX</li> <li>SQLAlchemy</li> </ul> <p>Use essas refer\u00eancias para padr\u00e3o de API est\u00e1vel, internals, deprecia\u00e7\u00e3o e testes.</p>"},{"location":"articles/pyield_intro/","title":"Introdu\u00e7\u00e3o ao PYield","text":""},{"location":"articles/pyield_intro/#pyield-analise-de-renda-fixa-brasileira-em-python","title":"PYield: An\u00e1lise de Renda Fixa Brasileira em Python","text":""},{"location":"articles/pyield_intro/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Qualquer pessoa que trabalhe com an\u00e1lise de renda fixa no Brasil sabe que a obten\u00e7\u00e3o de dados de fontes como ANBIMA, B3 e Banco Central pode ser uma tarefa trabalhosa. \u00c9 preciso lidar com diferentes APIs, formatos de dados variados e, frequentemente, processar informa\u00e7\u00f5es diretamente de sites. Para quem n\u00e3o tem acesso a terminais pagos como Bloomberg, esse desafio se torna ainda maior.</p> <p>Al\u00e9m disso, h\u00e1 a complexidade do calend\u00e1rio de dias \u00fateis brasileiro. Feriados nacionais, estaduais e municipais precisam ser considerados em praticamente todos os c\u00e1lculos financeiros - desde a apura\u00e7\u00e3o de taxas at\u00e9 a precifica\u00e7\u00e3o de t\u00edtulos. Essa \u00e9 uma funcionalidade b\u00e1sica, mas essencial para qualquer an\u00e1lise de renda fixa.</p> <p>PYield foi criado para resolver esses problemas. \u00c9 uma biblioteca Python que centraliza a obten\u00e7\u00e3o e processamento de dados de instrumentos de renda fixa brasileiros, oferecendo uma API unificada e consistente.</p>"},{"location":"articles/pyield_intro/#o-que-e-pyield","title":"O que \u00e9 PYield?","text":"<p>PYield \u00e9 uma biblioteca Python especializada em an\u00e1lise de renda fixa brasileira. Ela busca e processa dados de m\u00faltiplas fontes:</p> <ul> <li>ANBIMA: Taxas indicativas de t\u00edtulos p\u00fablicos, curvas de juros (ETTJ), \u00edndices IMA</li> <li>Banco Central (BCB): SELIC, PTAX, taxas de reposit\u00f3rio, VNA</li> <li>B3: Futuros de DI, DDI, cupom cambial e outros contratos</li> <li>IBGE: Dados de infla\u00e7\u00e3o (IPCA)</li> </ul> <p>Todos os dados retornados pela biblioteca s\u00e3o Polars DataFrames ou Series, proporcionando alto desempenho e seguran\u00e7a de tipos para pipelines de dados modernos.</p>"},{"location":"articles/pyield_intro/#caracteristicas-principais","title":"Caracter\u00edsticas Principais","text":"<ul> <li>Coleta unificada de dados: Uma \u00fanica biblioteca para acessar ANBIMA, BCB, B3 e IBGE</li> <li>API consistente: Todos os m\u00f3dulos seguem as mesmas conven\u00e7\u00f5es de nomenclatura e assinaturas de fun\u00e7\u00e3o</li> <li>Retorno em Polars: DataFrames e Series do Polars para pipelines r\u00e1pidos e type-safe</li> <li>Calend\u00e1rio de dias \u00fateis: Fun\u00e7\u00f5es completas para contagem e gera\u00e7\u00e3o de dias \u00fateis com feriados brasileiros integrados</li> <li>Precifica\u00e7\u00e3o de t\u00edtulos: C\u00e1lculo de cota\u00e7\u00f5es, pre\u00e7os e spreads de t\u00edtulos p\u00fablicos</li> <li>Interpola\u00e7\u00e3o de taxas: Suporte para interpola\u00e7\u00e3o linear e flat forward (padr\u00e3o de mercado) usando conven\u00e7\u00e3o 252 dias \u00fateis/ano</li> <li>Convers\u00e3o flex\u00edvel de datas: Aceita diversos formatos de entrada (strings DD-MM-YYYY, DD/MM/YYYY, YYYY-MM-DD, objetos datetime, etc.)</li> </ul>"},{"location":"articles/pyield_intro/#instalacao","title":"Instala\u00e7\u00e3o","text":"<p>A instala\u00e7\u00e3o \u00e9 simples via pip:</p> <pre><code>pip install pyield\n</code></pre> <p>Requisitos: Python &gt;= 3.12</p>"},{"location":"articles/pyield_intro/#exemplos-praticos","title":"Exemplos Pr\u00e1ticos","text":""},{"location":"articles/pyield_intro/#1-dias-uteis-business-days","title":"1. Dias \u00dateis (Business Days)","text":"<p>O m\u00f3dulo <code>bday</code> \u00e9 a base de todos os c\u00e1lculos na biblioteca. Feriados brasileiros s\u00e3o automaticamente considerados.</p> <pre><code>import pyield as yd\n\n# Contar dias \u00fateis entre duas datas (in\u00edcio inclusivo, fim exclusivo)\nyd.bday.count(\"29-12-2023\", \"02-01-2024\")  # -&gt; 1\n\n# Avan\u00e7ar N dias \u00fateis a partir de uma data\nyd.bday.offset(\"29-12-2023\", 1)  # -&gt; datetime.date(2024, 1, 2)\n\n# Ajustar data para o pr\u00f3ximo dia \u00fatil (se n\u00e3o for dia \u00fatil)\nyd.bday.offset(\"30-12-2023\", 0)  # -&gt; datetime.date(2024, 1, 2)\n\n# Como 29-12-2023 j\u00e1 \u00e9 dia \u00fatil, retorna a mesma data\nyd.bday.offset(\"29-12-2023\", 0)  # -&gt; datetime.date(2023, 12, 29)\n\n# Gerar s\u00e9rie de dias \u00fateis entre duas datas\nyd.bday.generate(\"22-12-2023\", \"02-01-2024\")\n# -&gt; Polars Series: [2023-12-22, 2023-12-26, 2023-12-27, 2023-12-28, 2023-12-29, 2024-01-02]\n\n# Verificar se \u00e9 dia \u00fatil\nyd.bday.is_business_day(\"25-12-2023\")  # -&gt; False (Natal)\n</code></pre> <p>Todas as fun\u00e7\u00f5es suportam opera\u00e7\u00f5es vetorizadas com listas, Series ou arrays.</p>"},{"location":"articles/pyield_intro/#2-futuros-de-di-b3","title":"2. Futuros de DI (B3)","text":"<p>Obtenha dados de contratos futuros negociados na B3:</p> <pre><code># Dados de Futuros de DI em uma data espec\u00edfica\ndf = yd.futures(\"31-05-2024\", \"DI1\")\n\n# DataFrame retornado cont\u00e9m colunas:\n# TradeDate, TickerSymbol, ExpirationDate, BDaysToExp, SettlementRate,\n# OpeningRate, MinRate, MaxRate, TradesCount, ContractsCount, Volume, ...\n\n# Outros contratos dispon\u00edveis: DDI, FRC, DAP, DOL, WDO, IND, WIN\ndf_dap = yd.futures(\"31-05-2024\", \"DAP\")  # Cupom Cambial\n</code></pre>"},{"location":"articles/pyield_intro/#3-titulos-publicos-tesouro-nacional","title":"3. T\u00edtulos P\u00fablicos (Tesouro Nacional)","text":"<p>Acesse taxas indicativas da ANBIMA e dados de t\u00edtulos p\u00fablicos:</p> <pre><code># LTN (Letras do Tesouro Nacional - pr\u00e9-fixado)\ndf_ltn = yd.ltn.data(\"23-08-2024\")\n# Colunas: BondType, ReferenceDate, MaturityDate, BidRate, AskRate, IndicativeRate\n\n# NTN-B (Notas do Tesouro Nacional s\u00e9rie B - IPCA+)\ndf_ntnb = yd.ntnb.data(\"23-08-2024\")\n# Colunas: BondType, ReferenceDate, MaturityDate, BidRate, AskRate, IndicativeRate, VNA\n\n# NTN-F (Notas do Tesouro Nacional s\u00e9rie F - pr\u00e9-fixado com cupom)\ndf_ntnf = yd.ntnf.data(\"23-08-2024\")\n\n# Obs: Dados da ANBIMA est\u00e3o dispon\u00edveis para os \u00faltimos 5 dias \u00fateis\n# (membros da ANBIMA t\u00eam acesso autom\u00e1tico ao hist\u00f3rico completo)\n</code></pre>"},{"location":"articles/pyield_intro/#4-precificacao-de-titulos","title":"4. Precifica\u00e7\u00e3o de T\u00edtulos","text":"<p>Calcule cota\u00e7\u00f5es e pre\u00e7os de t\u00edtulos p\u00fablicos:</p> <pre><code># Cota\u00e7\u00e3o de NTN-B (base 100)\nyd.ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)  # -&gt; 99.3651\n\n# Cota\u00e7\u00e3o para vencimento mais longo\nyd.ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)  # -&gt; 99.5341\n\n# Spreads DI para t\u00edtulos pr\u00e9-fixados (em pontos-base)\ndf_spreads = yd.ltn.di_spreads(\"30-05-2024\", bps=True)\n# Colunas: BondType, MaturityDate, DISpread\n\n# Spreads para NTN-F\ndf_spreads_ntnf = yd.ntnf.di_spreads(\"30-05-2024\", bps=True)\n</code></pre>"},{"location":"articles/pyield_intro/#5-interpolacao-de-taxas","title":"5. Interpola\u00e7\u00e3o de Taxas","text":"<p>Interpolar taxas de juros usando conven\u00e7\u00e3o de mercado (252 dias \u00fateis/ano):</p> <pre><code># Obter curva de DI Futuro\ndf = yd.futures(\"31-05-2024\", \"DI1\")\n\n# Criar interpolador flat forward (padr\u00e3o de mercado)\ninterp = yd.Interpolator(\"flat_forward\", df[\"BDaysToExp\"], df[\"SettlementRate\"])\n\n# Interpolar para 45 dias \u00fateis\ninterp(45)  # -&gt; Taxa interpolada (ex: 0.1037)\n\n# Vetorizado\ninterp([30, 60, 90])  # -&gt; Polars Series com 3 taxas interpoladas\n\n# Interpola\u00e7\u00e3o linear (alternativa)\nlinear_interp = yd.Interpolator(\"linear\", df[\"BDaysToExp\"], df[\"SettlementRate\"])\nlinear_interp(45)  # -&gt; Taxa interpolada linearmente\n</code></pre>"},{"location":"articles/pyield_intro/#6-indicadores-do-banco-central","title":"6. Indicadores do Banco Central","text":"<p>Acesse indicadores econ\u00f4micos do BCB:</p> <pre><code># SELIC Over (taxa anualizada)\nyd.bc.selic_over(\"31-05-2024\")  # -&gt; 0.104  (10.4% a.a.)\n\n# PTAX (taxa de c\u00e2mbio oficial)\nyd.bc.ptax(\"31-05-2024\")  # -&gt; 5.4407\n\n# DI Over (taxa anualizada do mercado interbanc\u00e1rio)\nyd.bc.di_over(\"31-05-2024\")  # -&gt; 0.104  (10.4% a.a.)\n\n# Taxa SELIC meta (definida pelo COPOM)\nyd.bc.selic_target(\"31-05-2024\")  # -&gt; 0.1075  (10.75% a.a.)\n\n# VNA da LFT (Valor Nominal Atualizado)\nyd.bc.vna_lft(\"31-05-2024\")  # -&gt; 15234.56\n</code></pre>"},{"location":"articles/pyield_intro/#7-inflacao-ipca","title":"7. Infla\u00e7\u00e3o (IPCA)","text":"<p>Obtenha dados de infla\u00e7\u00e3o do IBGE:</p> <pre><code># Taxas mensais de IPCA\ndf_ipca = yd.ipca.rates(\"01-01-2024\", \"01-03-2024\")\n# Colunas: ReferenceDate, Rate\n\n# \u00cdndices de IPCA\ndf_indices = yd.ipca.indexes(\"01-01-2024\", \"01-03-2024\")\n# Colunas: ReferenceDate, Index\n\n# Proje\u00e7\u00f5es futuras (quando dispon\u00edveis)\ndf_proj = yd.ipca.rates(\"01-01-2025\", \"01-12-2025\")\n</code></pre>"},{"location":"articles/pyield_intro/#conversao-para-pandas","title":"Convers\u00e3o para Pandas","text":"<p>Embora PYield retorne Polars DataFrames por padr\u00e3o (desde a vers\u00e3o 0.40.0), \u00e9 f\u00e1cil converter para Pandas quando necess\u00e1rio:</p> <pre><code>import pyield as yd\n\n# Obter DataFrame Polars\ndf_polars = yd.ltn.data(\"23-08-2024\")\n\n# Converter para Pandas\ndf_pandas = df_polars.to_pandas(use_pyarrow_extension_array=True)\n</code></pre> <p>A convers\u00e3o com <code>use_pyarrow_extension_array=True</code> mant\u00e9m a compatibilidade de tipos e oferece melhor desempenho.</p>"},{"location":"articles/pyield_intro/#manuseio-de-datas","title":"Manuseio de Datas","text":"<p>PYield aceita formatos flex\u00edveis de data (<code>DateLike</code>):</p> <ul> <li>Strings: <code>\"31-05-2024\"</code>, <code>\"31/05/2024\"</code>, <code>\"2024-05-31\"</code></li> <li>Objetos Python: <code>datetime.date</code>, <code>datetime.datetime</code></li> <li>Objetos Pandas/NumPy: <code>pandas.Timestamp</code>, <code>numpy.datetime64</code></li> </ul> <p>Fun\u00e7\u00f5es escalares retornam <code>datetime.date</code>. Fun\u00e7\u00f5es vetorizadas retornam <code>polars.Series</code>.</p> <p>Para valores nulos, fun\u00e7\u00f5es escalares retornam <code>float('nan')</code>. Fun\u00e7\u00f5es vetorizadas propagam <code>null</code> element-wise:</p> <pre><code># Exemplo com null\nyd.ntnb.quotation(None, \"15-05-2035\", 0.06149)  # -&gt; nan\nyd.bday.count([\"01-01-2024\", None], \"01-02-2024\")  # -&gt; Series: [22, null]\n</code></pre>"},{"location":"articles/pyield_intro/#recursos-adicionais","title":"Recursos Adicionais","text":""},{"location":"articles/pyield_intro/#colab-notebook","title":"Colab Notebook","text":"<p>Um notebook interativo com exemplos pr\u00e1ticos est\u00e1 dispon\u00edvel no Google Colab:</p> <p></p>"},{"location":"articles/pyield_intro/#documentacao-completa","title":"Documenta\u00e7\u00e3o Completa","text":"<p>A documenta\u00e7\u00e3o completa com refer\u00eancia da API est\u00e1 dispon\u00edvel em: https://crdcj.github.io/PYield/</p>"},{"location":"articles/pyield_intro/#codigo-fonte","title":"C\u00f3digo-Fonte","text":"<p>O c\u00f3digo da biblioteca \u00e9 open source e est\u00e1 hospedado no GitHub: https://github.com/crdcj/PYield</p>"},{"location":"articles/pyield_intro/#conclusao","title":"Conclus\u00e3o","text":"<p>PYield oferece uma solu\u00e7\u00e3o integrada para an\u00e1lise de renda fixa brasileira em Python. Com uma API unificada, suporte para m\u00faltiplas fontes de dados e retorno em Polars DataFrames, a biblioteca permite que voc\u00ea foque na an\u00e1lise em vez de se preocupar com a obten\u00e7\u00e3o e processamento de dados.</p> <p>Se voc\u00ea trabalha com renda fixa no Brasil - seja como analista, pesquisador ou desenvolvedor - PYield pode acelerar significativamente seu fluxo de trabalho.</p> <p>Contribui\u00e7\u00f5es s\u00e3o bem-vindas! Entre em contato: cr.cj@outlook.com</p>"}]}