{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyield-brazilian-fixed-income-toolkit","title":"PYield: Brazilian Fixed Income Toolkit","text":"<p>PYield is a Python library designed for the analysis of Brazilian fixed income instruments. Leveraging the power of popular Python libraries like Pandas and Requests, PYield simplifies the process of obtaining and processing data from key sources such as ANBIMA, BCB, IBGE and B3.</p> <p>Documentation: https://crdcj.github.io/PYield/</p> <p>Source Code: https://github.com/crdcj/PYield</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Data Collection: Automated fetching of data from ANBIMA and B3.</li> <li>Data Processing: Efficient processing and normalization of fixed income data.</li> <li>Analysis Tools: Built-in functions for common analysis tasks in fixed income markets.</li> <li>Easy Integration: Seamless integration with pandas data analysis workflows.</li> <li>Type Hints: Full support for static type checking, enhancing development experience and code quality.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install PYield using pip: <pre><code>pip install pyield\n</code></pre></p>"},{"location":"#custom-types","title":"Custom Types","text":""},{"location":"#datescalar","title":"DateScalar","text":"<p><code>DateScalar</code> and <code>DateArray</code> are a type alias used across PYield to represent different types of date inputs. It includes several common date formats, allowing for flexible date handling within the library. </p> <p>The accepted formats in <code>DateScalar</code> are:</p> <ul> <li><code>datetime.date</code></li> <li><code>datetime.datetime</code></li> <li><code>str</code> (in the format <code>DD-MM-YYYY</code> as used in Brazil)</li> <li><code>np.datetime64</code></li> <li><code>pd.Timestamp</code></li> </ul>"},{"location":"#datearray","title":"DateArray","text":"<p>The accepted formats in <code>DateArray</code> are: - <code>pd.Series</code> - <code>pd.DatetimeIndex</code> - <code>np.ndarray</code> - <code>list[DateScalar]</code> - <code>tuple[DateScalar]</code></p> <p>Referencing <code>DateScalar</code> and <code>DateArray</code> in function arguments simplifies the code by allowing any of these date formats to be used interchangeably.</p>"},{"location":"#important-note-on-date-formats","title":"Important Note on Date Formats","text":"<p>When using date strings in PYield functions, please ensure that the date format is day-first (e.g., \"31-05-2024\"). This format was chosen to be consistent with the Brazilian date convention.</p> <p>For production code, it is recommended to parse date strings with <code>pandas.to_datetime</code> using an explicit format to avoid ambiguity and ensure consistency. For example: <pre><code>import pandas as pd\n# Converting a date string to a pandas Timestamp with a specific format\ndate = pd.to_datetime(\"2024/31/05\", format=\"%Y/%d/%m\")\ndate = pd.to_datetime(\"05-31-2024\", format=\"%m-%d-%Y\")\n</code></pre></p>"},{"location":"#how-to-use-pyield","title":"How to use PYield","text":""},{"location":"#brazilian-treasury-bonds-tools","title":"Brazilian Treasury Bonds Tools","text":"<pre><code>&gt;&gt;&gt; from pyield import ntnb, ntnf, ltn\n\n# Calculate the quotation of a NTN-B bond as per ANBIMA's rules\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n\n# Calculate the DI Spread of NTN-F bonds in a given date\n&gt;&gt;&gt; ntnf.di_spreads(\"17-07-2024\")\n2025-01-01   -2.31\n2027-01-01   -1.88\n2029-01-01   -3.26\n2031-01-01    3.61\n2033-01-01   -3.12\n2035-01-01   -1.00\nName: DISpread, dtype: Float64\n\n# Get ANBIMA's indicative rates for LTN bonds\n&gt;&gt;&gt; ltn.anbima_rates(\"17-07-2024\")\n2024-10-01    0.104236\n2025-01-01    0.105400\n2025-04-01    0.107454\n2025-07-01    0.108924\n2025-10-01    0.110751\n2026-01-01    0.111753\n2026-04-01    0.112980\n2026-07-01    0.113870\n2026-10-01    0.114592\n2027-07-01    0.116090\n2028-01-01    0.117160\n2028-07-01    0.118335\n2030-01-01    0.120090\nName: IndicativeRate, dtype: Float64\n</code></pre>"},{"location":"#business-days-tools-brazilian-holidays-are-automatically-considered","title":"Business Days Tools (Brazilian holidays are automatically considered)","text":"<pre><code>&gt;&gt;&gt; from pyield import bday\n# Count the number of business days between two dates\n# Start date is included, end date is excluded\n&gt;&gt;&gt; bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Get the next business day after a given date (offset=1)\n&gt;&gt;&gt; bday.offset(dates=\"29-12-2023\", offset=1)\nTimestamp('2024-01-02 00:00:00')\n\n# Get the next business day if it is not a business day (offset=0)\n&gt;&gt;&gt; bday.offset(dates=\"30-12-2023\", offset=0)\nTimestamp('2024-01-02 00:00:00')\n\n# Since 29-12-2023 is a business day, it returns the same date (offset=0)\n&gt;&gt;&gt; bday.offset(dates=\"29-12-2023\", offset=0)\nTimestamp('2023-12-29 00:00:00')\n\n# Generate a pandas series with the business days between two dates\n&gt;&gt;&gt; bday.generate(start='29-12-2023', end='03-01-2024')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\ndtype: datetime64[ns]\n</code></pre>"},{"location":"#futures-data","title":"Futures Data","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n# Fetch current DI Futures data from B3 (15 minutes delay)\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\")\nLastUpdatee      TickerSymbol ExpirationDate BDaysToExp ... MaxRate LastAskRate LastBidRate LastRate\n2024-04-21 13:37:39       DI1K24     2024-05-02          7 ... 0.10660     0.10652     0.10660  0.10660\n2024-04-21 13:37:39       DI1M24     2024-06-03         28 ... 0.10518     0.10510     0.10516  0.10518\n2024-04-21 13:37:39       DI1N24     2024-07-01         48 ... 0.10480     0.10456     0.10462  0.10460\n                ...          ...            ...        ... ...     ...         ...         ...      ...\n2024-04-21 13:37:39       DI1F37     2037-01-02       3183 ...    &lt;NA&gt;        &lt;NA&gt;     0.11600     &lt;NA&gt;\n2024-04-21 13:37:39       DI1F38     2038-01-04       3432 ...    &lt;NA&gt;        &lt;NA&gt;     0.11600     &lt;NA&gt;\n2024-04-21 13:37:39       DI1F39     2039-01-03       3683 ...    &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;     &lt;NA&gt;\n\n# Fetch historical DI Futures data from B3\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", date='08-03-2024')\nTradeDate  TickerSymbol ExpirationDate BDaysToExp ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08       DI1J24     2024-04-01         15 ...   10.952      10.952      10.956         10.956\n2024-03-08       DI1K24     2024-05-02         37 ...   10.776      10.774      10.780         10.777\n2024-03-08       DI1M24     2024-06-03         58 ...   10.604      10.602      10.604         10.608\n       ...          ...            ...        ... ...      ...         ...         ...            ...\n2024-03-08       DI1F37     2037-01-02       3213 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.859\n2024-03-08       DI1F38     2038-01-04       3462 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.859\n2024-03-08       DI1F39     2039-01-03       3713 ...     &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;         10.85\n</code></pre>"},{"location":"#indicators-data","title":"Indicators Data","text":"<pre><code>&gt;&gt;&gt; from pyield import bc\n# Fetch the SELIC target rate from the Central Bank of Brazil\n&gt;&gt;&gt; bc.selic_over(\"26-01-2025\")  # No data on 26-01-2025 (sunday)\n        Date   Value\n0 2025-01-27  0.1215\n1 2025-01-28  0.1215\n2 2025-01-29  0.1215\n3 2025-01-30  0.1315\n4 2025-01-31  0.1315\n...\n</code></pre>"},{"location":"#projections-data","title":"Projections Data","text":"<pre><code>&gt;&gt;&gt; from pyield import anbima\n# Fetch current month projection for IPCA from IBGE API\n&gt;&gt;&gt; ipca = anbima.ipca_projection()\n&gt;&gt;&gt; print(ipca)\nIndicatorProjection(\n    last_updated=Timestamp('2024-04-19 18:55:00'),\n    reference_month_ts=Timestamp('2024-04-01 00:00:00'),\n    reference_month_br='ABR/2024',\n    projected_value=0.0035  # 0.35%\n)\n&gt;&gt;&gt; ipca.projected_value\n0.0035  # 0.35%\n</code></pre>"},{"location":"#interpolation-tools","title":"Interpolation Tools","text":"<pre><code>&gt;&gt;&gt; from pyield import Interpolator\n# Interpolate interest rates for specific business days using the Interpolator class.\n\n# Initialize the Interpolator with known business days and interest rates.\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n&gt;&gt;&gt; linear_interpolator = Interpolator(\"linear\", known_bdays, known_rates)\n\n# Interpolate the interest rate for a given number of business days.\n&gt;&gt;&gt; linear_interpolator(45)\n0.0475\n\n# Use the flat forward method for interpolation.\n&gt;&gt;&gt; ff_interpolator = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; ff_interpolator(45)\n0.04833068080970859\n</code></pre>"},{"location":"anbima/","title":"Anbima Data","text":""},{"location":"anbima/#pyield.anbima.ipca_projection","title":"<code>ipca_projection()</code>","text":"<p>Retrieves the current IPCA projection from the ANBIMA website.</p> <p>This function makes an HTTP request to the ANBIMA website, extracts HTML tables containing economic indicators, and specifically processes the IPCA projection data.</p> Process <ol> <li>Accesses the ANBIMA indicators webpage</li> <li>Extracts the third table that contains the IPCA projection</li> <li>Locates the row labeled as \"IPCA1\"</li> <li>Extracts the projection value and converts it to decimal format</li> <li>Extracts and formats the reference month of the projection</li> <li>Extracts the date and time of the last update</li> </ol> <p>Returns:</p> Name Type Description <code>IndicatorProjection</code> <code>IndicatorProjection</code> <p>An object containing: - reference_period (pd.Period): Reference period of the projection - projected_value (float): Projected IPCA value as a decimal number - last_updated (pd.Timestamp): Date and time of the last data update</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If there are connection issues with the ANBIMA site</p> <code>ValueError</code> <p>If the expected data is not found in the page structure</p> <code>Error</code> <p>If the 'pt_BR.UTF-8' locale is not available on the system</p> Notes <ul> <li>The function requires internet connection to access the ANBIMA website</li> <li>The structure of the ANBIMA page may change, which could affect the function</li> <li>Temporarily changes the locale to pt_BR.UTF-8 to process dates in Portuguese</li> </ul> Source code in <code>pyield/anbima/ipca.py</code> <pre><code>def ipca_projection() -&gt; IndicatorProjection:\n    \"\"\"\n    Retrieves the current IPCA projection from the ANBIMA website.\n\n    This function makes an HTTP request to the ANBIMA website, extracts HTML tables\n    containing economic indicators, and specifically processes the IPCA projection data.\n\n    Process:\n        1. Accesses the ANBIMA indicators webpage\n        2. Extracts the third table that contains the IPCA projection\n        3. Locates the row labeled as \"IPCA1\"\n        4. Extracts the projection value and converts it to decimal format\n        5. Extracts and formats the reference month of the projection\n        6. Extracts the date and time of the last update\n\n    Returns:\n        IndicatorProjection: An object containing:\n            - reference_period (pd.Period): Reference period of the projection\n            - projected_value (float): Projected IPCA value as a decimal number\n            - last_updated (pd.Timestamp): Date and time of the last data update\n\n    Raises:\n        requests.RequestException: If there are connection issues with the ANBIMA site\n        ValueError: If the expected data is not found in the page structure\n        locale.Error: If the 'pt_BR.UTF-8' locale is not available on the system\n\n    Notes:\n        - The function requires internet connection to access the ANBIMA website\n        - The structure of the ANBIMA page may change, which could affect the function\n        - Temporarily changes the locale to pt_BR.UTF-8 to process dates in Portuguese\n    \"\"\"\n    url = \"https://www.anbima.com.br/informacoes/indicadores/\"\n    r = requests.get(url)\n    r.encoding = \"latin1\"\n    dfs = pd.read_html(\n        io.StringIO(r.text),\n        flavor=\"html5lib\",\n        decimal=\",\",\n        thousands=\".\",\n        dtype_backend=\"numpy_nullable\",\n    )\n    # The IPCA projection is in the third table\n    df = dfs[2]\n\n    last_update_str = df.iat[0, 0].split(\"Atualiza\u00e7\u00e3o:\")[-1].strip()\n    last_update = pd.to_datetime(last_update_str, format=\"%d/%m/%Y - %H:%M h\")\n\n    ipca_row = df.loc[df[0] == \"IPCA1\"]\n    ipca_value = ipca_row.iloc[0, 2]\n    ipca_value = pd.to_numeric(ipca_value, errors=\"coerce\")\n    ipca_value = round(float(ipca_value) / 100, 4)\n\n    # Extract and format the reference month\n    ipca_date = ipca_row.iloc[0, 1]\n    ipca_date = str(ipca_date)\n    ipca_date = ipca_date.split(\"(\")[-1].split(\")\")[0]\n    locale.setlocale(locale.LC_TIME, \"pt_BR.UTF-8\")\n    ipca_date = pd.to_datetime(ipca_date, format=\"%b/%y\")\n    reference_period = ipca_date.to_period(\"M\")\n    locale.setlocale(locale.LC_TIME, \"\")  # Reset locale to default\n\n    return IndicatorProjection(\n        last_updated=last_update,\n        reference_period=reference_period,\n        projected_value=ipca_value,\n    )\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ettj","title":"<code>last_ettj()</code>","text":"<p>Retrieves and processes the latest Brazilian yield curve data from ANBIMA.</p> <p>This function fetches the most recent yield curve data published by ANBIMA, containing real rates (IPCA-indexed), nominal rates, and implied inflation at various vertices (time points). Both spot rates and forward rates are calculated and included in the returned DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the latest ETTJ data.</p> DataFrame columns <ul> <li>date: Reference date of the yield curve</li> <li>vertex: Time point in business days</li> <li>nominal_rate: Zero-coupon nominal interest rate</li> <li>real_rate: Zero-coupon real interest rate (IPCA-indexed)</li> <li>implied_inflation: Implied inflation rate (break-even inflation)</li> <li>nominal_rate_fwd: Forward nominal interest rate</li> <li>real_rate_fwd: Forward real interest rate</li> <li>implied_inflation_fwd: Forward implied inflation rate</li> </ul> Note <p>All rates are expressed in decimal format (e.g., 0.12 for 12%).</p> Source code in <code>pyield/anbima/ettj.py</code> <pre><code>def last_ettj() -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves and processes the latest Brazilian yield curve data from ANBIMA.\n\n    This function fetches the most recent yield curve data published by ANBIMA,\n    containing real rates (IPCA-indexed), nominal rates, and implied inflation\n    at various vertices (time points). Both spot rates and forward rates are\n    calculated and included in the returned DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the latest ETTJ data.\n\n    DataFrame columns:\n        - date: Reference date of the yield curve\n        - vertex: Time point in business days\n        - nominal_rate: Zero-coupon nominal interest rate\n        - real_rate: Zero-coupon real interest rate (IPCA-indexed)\n        - implied_inflation: Implied inflation rate (break-even inflation)\n        - nominal_rate_fwd: Forward nominal interest rate\n        - real_rate_fwd: Forward real interest rate\n        - implied_inflation_fwd: Forward implied inflation rate\n\n    Note:\n        All rates are expressed in decimal format (e.g., 0.12 for 12%).\n    \"\"\"\n    text = _get_last_content()\n    df = _convert_text_to_df(text)\n    return _process_df(df)\n</code></pre>"},{"location":"anbima/#pyield.anbima.last_ima","title":"<code>last_ima(ima_type=None)</code>","text":"<p>Fetch and process the last IMA market data available from ANBIMA.</p> <p>This function processes the data into a structured DataFrame. It handles conversion of date formats, renames columns to English, and converts certain numeric columns to integer types. In the event of an error during data fetching or processing, an empty DataFrame is returned.</p> <p>Parameters:</p> Name Type Description Default <code>ima_type</code> <code>str</code> <p>Type of IMA index to filter the data. If None, all IMA indexes are returned. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the IMA data.</p> DataFrame columns <ul> <li>Date: reference date of the data.</li> <li>IMAType: type of IMA index.</li> <li>BondType: type of bond.</li> <li>Maturity: bond maturity date.</li> <li>SelicCode: bond code in the SELIC system.</li> <li>ISIN: international Securities Identification Number.</li> <li>BDToMat: business days to maturity.</li> <li>Duration: duration of the bond in business years (252 days/year).</li> <li>IndicativeRate: indicative rate.</li> <li>Price: bond price.</li> <li>InterestPrice: interest price.</li> <li>DV01: DV01 in R$.</li> <li>PMR: average repurchase term.</li> <li>Weight: weight of the bond in the index.</li> <li>Convexity: convexity of the bond.</li> <li>TheoreticalQuantity: theoretical quantity.</li> <li>NumberOfOperations: number of operations.</li> <li>NegotiatedQuantity: negotiated quantity.</li> <li>NegotiatedValue: negotiated value.</li> <li>MarketQuantity: market quantity.</li> <li>MarketDV01: market DV01 in R$.</li> <li>MarketValue: market value in R$.</li> </ul> <p>Raises:</p> Type Description <code>Exception</code> <p>Logs error and returns an empty DataFrame if any error occurs during fetching or processing.</p> Source code in <code>pyield/anbima/ima.py</code> <pre><code>def last_ima(ima_type: ima_types | None = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch and process the last IMA market data available from ANBIMA.\n\n    This function processes the data into a structured DataFrame.\n    It handles conversion of date formats, renames columns to English, and converts\n    certain numeric columns to integer types. In the event of an error during data\n    fetching or processing, an empty DataFrame is returned.\n\n    Args:\n        ima_type (str, optional): Type of IMA index to filter the data. If None, all\n            IMA indexes are returned. Defaults to None.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the IMA data.\n\n    DataFrame columns:\n        - Date: reference date of the data.\n        - IMAType: type of IMA index.\n        - BondType: type of bond.\n        - Maturity: bond maturity date.\n        - SelicCode: bond code in the SELIC system.\n        - ISIN: international Securities Identification Number.\n        - BDToMat: business days to maturity.\n        - Duration: duration of the bond in business years (252 days/year).\n        - IndicativeRate: indicative rate.\n        - Price: bond price.\n        - InterestPrice: interest price.\n        - DV01: DV01 in R$.\n        - PMR: average repurchase term.\n        - Weight: weight of the bond in the index.\n        - Convexity: convexity of the bond.\n        - TheoreticalQuantity: theoretical quantity.\n        - NumberOfOperations: number of operations.\n        - NegotiatedQuantity: negotiated quantity.\n        - NegotiatedValue: negotiated value.\n        - MarketQuantity: market quantity.\n        - MarketDV01: market DV01 in R$.\n        - MarketValue: market value in R$.\n\n    Raises:\n        Exception: Logs error and returns an empty DataFrame if any error occurs during\n            fetching or processing.\n    \"\"\"\n    try:\n        df = _fetch_last_ima()\n        df = _process_last_ima(df)\n        df = _reorder_last_ima(df)\n        if ima_type is not None:\n            df = df.query(\"IMAType == @ima_type\").reset_index(drop=True)\n        df = df.sort_values([\"IMAType\", \"BondType\", \"Maturity\"]).reset_index(drop=True)\n        return df\n    except Exception as e:\n        logger.exception(f\"Error fetching or processing the last IMA data: {e}\")\n        return pd.DataFrame()\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_data","title":"<code>tpf_data(date, bond_type=None, adj_maturities=False)</code>","text":"<p>Retrieve indicative rates for bonds from ANBIMA data.</p> <p>This function fetches indicative rates for bonds from ANBIMA, initially attempting to retrieve data from a cached dataset. If the data is not available in the cache, it fetches it directly from the ANBIMA website.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for the rates.</p> required <code>bond_type</code> <code>str</code> <p>Filter rates by bond type. Defaults to None, which returns rates for all bond types.</p> <code>None</code> <code>adj_maturities</code> <code>bool</code> <p>Adjust maturity dates to the next business day. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame with the following columns: - BondType: The type of bond. - MaturityDate: The maturity date of the bond. - IndicativeRate: The indicative rate of the bond. - Price: The price (PU) of the bond.</p> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_data(\n    date: DateScalar,\n    bond_type: str | None = None,\n    adj_maturities: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Retrieve indicative rates for bonds from ANBIMA data.\n\n    This function fetches indicative rates for bonds from ANBIMA,\n    initially attempting to retrieve data from a cached dataset. If the data\n    is not available in the cache, it fetches it directly from the ANBIMA website.\n\n    Args:\n        date (DateScalar): The reference date for the rates.\n        bond_type (str, optional): Filter rates by bond type.\n            Defaults to None, which returns rates for all bond types.\n        adj_maturities (bool, optional): Adjust maturity dates to the next\n            business day. Defaults to False.\n\n    Returns:\n        pd.DataFrame: A DataFrame with the following columns:\n            - BondType: The type of bond.\n            - MaturityDate: The maturity date of the bond.\n            - IndicativeRate: The indicative rate of the bond.\n            - Price: The price (PU) of the bond.\n    \"\"\"\n\n    df = get_anbima_dataset()\n    date = convert_input_dates(date)\n    df = df.query(\"ReferenceDate == @date\").reset_index(drop=True)\n\n    if df.empty:\n        # Try to fetch the data from the Anbima website\n        df = tpf_web_data(date)\n\n    if df.empty:\n        # If the data is still empty, return an empty DataFrame\n        return pd.DataFrame()\n\n    if bond_type:\n        df = df.query(\"BondType == @bond_type\").reset_index(drop=True)\n\n    if adj_maturities:\n        df[\"MaturityDate\"] = bday.offset(df[\"MaturityDate\"], 0)\n\n    return (\n        df[[\"ReferenceDate\", \"BondType\", \"MaturityDate\", \"IndicativeRate\", \"Price\"]]\n        .sort_values([\"BondType\", \"MaturityDate\"])\n        .reset_index(drop=True)\n    )\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_fixed_rate_maturities","title":"<code>tpf_fixed_rate_maturities(date)</code>","text":"<p>Retrieve pre-defined maturity dates for LTN and NTN-F bonds.</p> <p>This function fetches pre-defined maturity dates for 'LTN' (prefixadas) and 'NTN-F' (indexadas ao CDI) bond types from the cached ANBIMA dataset for a given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for maturity dates.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing unique maturity dates for 'LTN' and 'NTN-F' bonds, sorted in ascending order.</p> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_fixed_rate_maturities(date: DateScalar) -&gt; pd.Series:\n    \"\"\"Retrieve pre-defined maturity dates for LTN and NTN-F bonds.\n\n    This function fetches pre-defined maturity dates for 'LTN' (prefixadas) and\n    'NTN-F' (indexadas ao CDI) bond types from the cached ANBIMA dataset\n    for a given reference date.\n\n    Args:\n        date (DateScalar): The reference date for maturity dates.\n\n    Returns:\n        pd.Series: A Series containing unique maturity dates for 'LTN' and\n            'NTN-F' bonds, sorted in ascending order.\n    \"\"\"\n    maturity_dates = (\n        tpf_data(date)\n        .query(\"BondType in ['LTN', 'NTN-F']\")[\"MaturityDate\"]\n        .drop_duplicates()\n        .sort_values(ignore_index=True)\n        .reset_index(drop=True)\n    )\n    return maturity_dates\n</code></pre>"},{"location":"anbima/#pyield.anbima.tpf_web_data","title":"<code>tpf_web_data(date, bond_type=None)</code>","text":"<p>Fetch and process TPF secondary market data from ANBIMA website.</p> <p>This function retrieves bond market data from the ANBIMA website for a specified reference date. It handles different file formats based on the date and attempts to download the data from both member and non-member URLs.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for the data.</p> required <code>bond_type</code> <code>str</code> <p>Filter data by bond type. Defaults to None, which returns data for all bond types.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing bond market data. Returns an empty DataFrame if data is not available for the specified date (weekends, holidays, or unavailable data).</p> Source code in <code>pyield/anbima/tpf.py</code> <pre><code>def tpf_web_data(\n    date: DateScalar, bond_type: str | BOND_TYPES | None = None\n) -&gt; pd.DataFrame:\n    \"\"\"Fetch and process TPF secondary market data from ANBIMA website.\n\n    This function retrieves bond market data from the ANBIMA website for a\n    specified reference date. It handles different file formats based on the date\n    and attempts to download the data from both member and non-member URLs.\n\n    Args:\n        date (DateScalar): The reference date for the data.\n        bond_type (str, optional):  Filter data by bond type.\n            Defaults to None, which returns data for all bond types.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing bond market data.\n            Returns an empty DataFrame if data is not available for the\n            specified date (weekends, holidays, or unavailable data).\n    \"\"\"\n    date = convert_input_dates(date)\n    date_log = date.strftime(\"%d/%m/%Y\")\n\n    try:\n        file_url = _build_file_url(date)\n        df = _read_raw_df(file_url)\n        if df.empty:\n            logger.info(\n                f\"No Anbima TPF secondary market data ANBIMA for {date_log}.\"\n                \"Returning empty DataFrame.\"\n            )\n            return df\n        df = _process_raw_df(df)\n        if bond_type:\n            norm_bond_type = _bond_type_mapping(bond_type)  # noqa\n            df = df.query(\"BondType == @norm_bond_type\").reset_index(drop=True)\n        return df.sort_values([\"BondType\", \"MaturityDate\"]).reset_index(drop=True)\n    except HTTPError as e:\n        if e.code == 404:  # noqa\n            logger.info(\n                f\"No Anbima TPF secondary market data for {date_log}. \"\n                \"Returning empty DataFrame.\"\n            )\n            return pd.DataFrame()\n        raise  # Propagate other HTTP errors\n    except Exception:\n        logger.exception(f\"Error fetching TPF data for {date_log}\")\n        raise\n</code></pre>"},{"location":"b3/","title":"B3 Data","text":""},{"location":"b3/#pyield.b3.DIFutures","title":"<code>DIFutures(date=None, month_start=False, pre_filter=False, all_columns=True)</code>","text":"<p>Class to retrieve and manipulate DI futures contract data.</p> <p>This class provides access to DI futures data for a specified trade date, and includes options to adjust expiration dates and apply filters based on LTN and NTN-F bond maturities.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar | None</code> <p>The trade date to retrieve the DI contract data. If None, an empty DataFrame is returned.</p> <code>None</code> <code>month_start</code> <code>bool</code> <p>If True, adjusts the expirations to the start of the month.</p> <code>False</code> <code>pre_filter</code> <code>bool</code> <p>If True, filters the DI contracts to match only expirations with existing prefixed TN bond maturities (LTN and NTN-F).</p> <code>False</code> <code>all_columns</code> <code>bool</code> <p>If True, returns all available columns in the DI dataset. If False, only the most common columns are returned.</p> <code>True</code> <p>Examples:</p> <p>To create a <code>DIFutures</code> instance and retrieve data:</p> <pre><code>&gt;&gt;&gt; dif = yd.DIFutures(date=\"16-10-2024\", month_start=True)\n&gt;&gt;&gt; df = dif.df  # Retrieve DI contract dataframe for the specified date\n&gt;&gt;&gt; df.iloc[:5, :5]  # Show the first five rows and columns\n   TradeDate ExpirationDate TickerSymbol  BDaysToExp  OpenContracts\n0 2024-10-16     2024-11-01       DI1X24          12        1744269\n1 2024-10-16     2024-12-01       DI1Z24          31        1429375\n2 2024-10-16     2025-01-01       DI1F25          52        5423969\n3 2024-10-16     2025-02-01       DI1G25          74         279491\n4 2024-10-16     2025-03-01       DI1H25          94         344056\n</code></pre> <p>You can also retrieve forward rates for the DI contracts:</p> <pre><code>&gt;&gt;&gt; dif.forwards.iloc[:5]  # Show the first five rows\n   TradeDate ExpirationDate  SettlementRate  ForwardRate\n0 2024-10-16     2024-11-01         0.10653      0.10653\n1 2024-10-16     2024-12-01          0.1091     0.110726\n2 2024-10-16     2025-01-01         0.11164       0.1154\n3 2024-10-16     2025-02-01         0.11362     0.118314\n4 2024-10-16     2025-03-01          0.1157      0.12343\n</code></pre> Note <p>The DI contract DataFrame is not loaded during initialization. It will be automatically loaded the first time the df() method is accessed.</p> Source code in <code>pyield/b3/di.py</code> <pre><code>def __init__(\n    self,\n    date: DateScalar | None = None,\n    month_start: bool = False,\n    pre_filter: bool = False,\n    all_columns: bool = True,\n):\n    \"\"\"\n    Initialize the DIFutures instance with the specified parameters.\n\n    Note:\n        The DI contract DataFrame is not loaded during initialization. It will be\n        automatically loaded the first time the df() method is accessed.\n    \"\"\"\n    self._df = pd.DataFrame()\n    self._dirty = True  # Attribute to track if the df needs updating\n\n    self.date = date\n    self.month_start = month_start\n    self.pre_filter = pre_filter\n    self.all_columns = all_columns\n</code></pre>"},{"location":"b3/#pyield.b3.DIFutures.date","title":"<code>date</code>  <code>property</code> <code>writable</code>","text":"<p>The trade date to retrieve the DI contract data.</p> <p>This property can be both read and set. When setting a value, it automatically converts the input date format to a <code>pd.Timestamp</code>.</p> <p>Returns:</p> Type Description <code>Timestamp</code> <p>pd.Timestamp: The trade date set for this instance.</p>"},{"location":"b3/#pyield.b3.DIFutures.df","title":"<code>df</code>  <code>property</code>","text":"<p>Returns a copy of the DI contract DataFrame for the initialized trade date.</p> <p>If the internal state is marked as 'dirty', the DataFrame will be (re)loaded before returning, ensuring that the returned data reflects the latest attribute values.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The DI contract data.</p>"},{"location":"b3/#pyield.b3.DIFutures.forwards","title":"<code>forwards</code>  <code>property</code>","text":"<p>Calculate the DI forward rates for the initialized trade date.</p> <p>This property returns a DataFrame with both the SettlementRate and the calculated ForwardRate for DI contracts, based on the instance's trade date and applied filters.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the following columns: - ExpirationDate: The expiration dates of the DI contracts. - SettlementRate: The zero rate (interest rate) for each expiration. - ForwardRate: The fwd rate calculated between successive expirations.</p>"},{"location":"b3/#pyield.b3.DIFutures.historical_dates","title":"<code>historical_dates = get_di_dataset().drop_duplicates(subset=['TradeDate'])['TradeDate'].sort_values(ascending=True).reset_index(drop=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>pd.Series: Sorted series of unique trade dates available in the DI dataset. It does not include the intraday date. It can be used to check for available historical data.</p>"},{"location":"b3/#pyield.b3.DIFutures.month_start","title":"<code>month_start</code>  <code>property</code> <code>writable</code>","text":"<p>Adjusts the expiration dates to the start of the month.</p> <p>This property can be both read and set. When set to <code>True</code>, all expiration dates are adjusted to the first day of the month. For example, an expiration date of 02/01/2025 will be adjusted to 01/01/2025.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether expiration dates are adjusted to the start of the month.</p>"},{"location":"b3/#pyield.b3.DIFutures.pre_filter","title":"<code>pre_filter</code>  <code>property</code> <code>writable</code>","text":"<p>Filters DI Futures to match prefixed TN bond maturities.</p> <p>This property can be both read and set. When set to <code>True</code>, only contracts that match the maturities of LTN and NTN-F bonds will be shown.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the contracts are filtered to match prefixed TN bond maturities from the ANBIMA dataset.</p>"},{"location":"b3/#pyield.b3.DIFutures._update_df","title":"<code>_update_df()</code>","text":"<p>Retrieve DI contract DataFrame for the initialized trade date.</p> Source code in <code>pyield/b3/di.py</code> <pre><code>def _update_df(self) -&gt; pd.DataFrame:\n    \"\"\"Retrieve DI contract DataFrame for the initialized trade date.\"\"\"\n    if self._date is None:\n        logger.info(\"No date specified. Returning empty DataFrame.\")\n        return pd.DataFrame()\n    # Return an empty DataFrame if the trade date is a holiday\n    if not bday.is_business_day(self._date):\n        logger.warning(\"Specified date is not a business day.\")\n        logger.warning(\"Returning empty DataFrame.\")\n        return pd.DataFrame()\n\n    # Get historical data\n    df = get_di_dataset().query(\"TradeDate == @self._date\").reset_index(drop=True)\n\n    if df.empty:\n        logger.info(\"No historical data found. Trying real-time data.\")\n        df = b3.futures(contract_code=\"DI1\", date=self._date)\n\n    if df.empty:\n        logger.warning(\"No DI Futures data found for the specified date.\")\n        logger.warning(\"Returning empty DataFrame.\")\n        return pd.DataFrame()\n\n    if \"DaysToExpiration\" in df.columns:\n        df.drop(columns=[\"DaysToExpiration\"], inplace=True)\n\n    if self._pre_filter:\n        df_pre = (\n            get_anbima_dataset()\n            .query(\"BondType in ['LTN', 'NTN-F']\")\n            .query(\"ReferenceDate == @self._date\")[\n                [\"ReferenceDate\", \"MaturityDate\"]\n            ]\n            .drop_duplicates()\n            .reset_index(drop=True)\n        )\n        # Force the expiration date to be a business day as DI contracts\n        df_pre[\"MaturityDate\"] = bday.offset(df_pre[\"MaturityDate\"], 0)\n        df_pre = df_pre.rename(\n            columns={\n                \"ReferenceDate\": \"TradeDate\",\n                \"MaturityDate\": \"ExpirationDate\",\n            }\n        )\n\n        df = df.merge(df_pre, how=\"inner\")\n\n    if self._month_start:\n        df[\"ExpirationDate\"] = (\n            df[\"ExpirationDate\"].dt.to_period(\"M\").dt.to_timestamp()\n        )\n\n    if not self._all_columns:\n        cols = [\n            \"TradeDate\",\n            \"TickerSymbol\",\n            \"ExpirationDate\",\n            \"BDaysToExp\",\n            \"OpenContracts\",\n            \"TradeVolume\",\n            \"DV01\",\n            \"OpenRate\",\n            \"MinRate\",\n            \"MaxRate\",\n            \"CloseRate\",\n            \"SettlementRate\",\n            \"LastRate\",\n            \"SettlementPrice\",\n            \"LastPrice\",\n        ]\n        selected_cols = [col for col in cols if col in df.columns]\n        df = df[selected_cols].copy()\n\n    return df.sort_values(by=[\"TradeDate\", \"ExpirationDate\"]).reset_index(drop=True)\n</code></pre>"},{"location":"b3/#pyield.b3.DIFutures.interpolate_rates","title":"<code>interpolate_rates(dates, expirations, extrapolate=True)</code>  <code>staticmethod</code>","text":"<p>Interpolates DI rates for specified trade dates and maturities. The method is recomended to be used in datasets calculations with multiple dates.</p> <p>This method calculates interpolated DI rates for a given set of trade dates and maturities using a flat-forward interpolation method. If no DI rates are available for a reference date, the interpolated rate is set to NaN.</p> <p>If dates is provided as a scalar and expirations as an array, the method assumes the scalar value is the same for all maturities. The same logic applies when the maturities are scalar and the trade dates are an array.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar | DateArray</code> <p>The trade dates for the rates.</p> required <code>expirations</code> <code>DateScalar | DateArray</code> <p>The expirations corresponding to the trade dates.</p> required <code>extrapolate</code> <code>bool</code> <p>Whether to allow extrapolation beyond known DI rates.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the interpolated DI rates.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dates</code> and <code>maturities</code> have different lengths.</p> Source code in <code>pyield/b3/di.py</code> <pre><code>@staticmethod\ndef interpolate_rates(\n    dates: DateScalar | DateArray,\n    expirations: DateScalar | DateArray,\n    extrapolate: bool = True,\n) -&gt; pd.Series:\n    \"\"\"\n    Interpolates DI rates for specified trade dates and maturities. The method\n    is recomended to be used in datasets calculations with multiple dates.\n\n    This method calculates interpolated DI rates for a given set of trade\n    dates and maturities using a flat-forward interpolation method. If no DI\n    rates are available for a reference date, the interpolated rate is set to NaN.\n\n    If dates is provided as a scalar and expirations as an array, the\n    method assumes the scalar value is the same for all maturities. The same logic\n    applies when the maturities are scalar and the trade dates are an array.\n\n    Args:\n        dates (DateScalar | DateArray): The trade dates for the rates.\n        expirations (DateScalar | DateArray): The expirations corresponding to the\n            trade dates.\n        extrapolate (bool): Whether to allow extrapolation beyond known DI rates.\n\n    Returns:\n        pd.Series: A Series containing the interpolated DI rates.\n\n    Raises:\n        ValueError: If `dates` and `maturities` have different lengths.\n    \"\"\"\n    # Convert input dates to a consistent format\n    dates = dc.convert_input_dates(dates)\n    expirations = dc.convert_input_dates(expirations)\n\n    # Ensure the lengths of input arrays are consistent\n    match (dates, expirations):\n        case pd.Timestamp(), pd.Series():\n            dfi = pd.DataFrame({\"mat\": expirations})\n            dfi[\"tdate\"] = dates\n\n        case pd.Series(), pd.Timestamp():\n            dfi = pd.DataFrame({\"tdate\": dates})\n            dfi[\"mat\"] = expirations\n\n        case pd.Series(), pd.Series():\n            if len(dates) != len(expirations):\n                raise ValueError(\"Args. should have the same length.\")\n            dfi = pd.DataFrame({\"tdate\": dates, \"mat\": expirations})\n\n        case pd.Timestamp(), pd.Timestamp():\n            dfi = pd.DataFrame({\"tdate\": [dates], \"mat\": [expirations]})\n\n    # Compute business days between reference dates and maturities\n    dfi[\"bdays\"] = bday.count(dfi[\"tdate\"], dfi[\"mat\"])\n\n    # Initialize the interpolated rate column with NaN\n    dfi[\"irate\"] = pd.NA\n    dfi[\"irate\"] = dfi[\"irate\"].astype(\"Float64\")\n\n    # Load DI rates dataset filtered by the provided reference dates\n    dfr = (\n        get_di_dataset()\n        .query(\"TradeDate in @dfi['tdate'].unique()\")\n        .reset_index(drop=True)\n    )\n\n    # Return an empty DataFrame if no rates are found\n    if dfr.empty:\n        return pd.Series()\n\n    # Iterate over each unique reference date\n    for date in dfi[\"tdate\"].unique():\n        # Filter DI rates for the current reference date\n        dfr_subset = dfr.query(\"TradeDate == @date\").reset_index(drop=True)\n\n        # Skip processing if no rates are available for the current date\n        if dfr_subset.empty:\n            continue\n\n        # Initialize the interpolator with known rates and business days\n        interp = interpolator.Interpolator(\n            method=\"flat_forward\",\n            known_bdays=dfr_subset[\"BDaysToExp\"],\n            known_rates=dfr_subset[\"SettlementRate\"],\n            extrapolate=extrapolate,\n        )\n\n        # Apply interpolation to rows matching the current reference date\n        mask: pd.Series = dfi[\"tdate\"] == date\n        dfi.loc[mask, \"irate\"] = dfi.loc[mask, \"bdays\"].apply(interp)\n\n    # Return the Series with interpolated rates\n    s_irates = dfi[\"irate\"]\n    s_irates.name = \"InterpolatedRates\"\n    return s_irates\n</code></pre>"},{"location":"b3/#pyield.b3.DIFutures.rate","title":"<code>rate(expiration, interpolate=True, extrapolate=False)</code>","text":"<p>Retrieve the DI rate for a specified expiration date.</p> Source code in <code>pyield/b3/di.py</code> <pre><code>def rate(\n    self,\n    expiration: DateScalar,\n    interpolate: bool = True,\n    extrapolate: bool = False,\n) -&gt; float:\n    \"\"\"Retrieve the DI rate for a specified expiration date.\"\"\"\n    expiration = dc.convert_input_dates(expiration)\n\n    if self._month_start:\n        # Force the expiration date to be the start of the month\n        expiration = expiration.to_period(\"M\").to_timestamp()\n    else:\n        # Force the expiration date to be a business day\n        expiration = bday.offset(expiration, 0)\n\n    if not interpolate and extrapolate:\n        raise ValueError(\"Extrapolation is not allowed without interpolation.\")\n    # Get the DI contract DataFrame\n    df = self.df\n\n    if df.empty:\n        return float(\"NaN\")\n\n    df_exp = df.query(\"ExpirationDate == @expiration\")\n\n    if df_exp.empty and not interpolate:\n        return float(\"NaN\")\n\n    if expiration in df_exp[\"ExpirationDate\"].values:\n        return float(df_exp[\"SettlementRate\"].iat[0])\n\n    if not interpolate:\n        return float(\"NaN\")\n\n    ff_interp = interpolator.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=df[\"BDaysToExp\"],\n        known_rates=df[\"SettlementRate\"],\n        extrapolate=extrapolate,\n    )\n    bd = bday.count(self._date, expiration)\n    return ff_interp(bd)\n</code></pre>"},{"location":"bc/","title":"BC Data","text":""},{"location":"bc/#pyield.bc.auctions","title":"<code>auctions(start=None, end=None, auction_type=None)</code>","text":"<p>Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.</p> <p>Consultas de Per\u00edodo: - Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>.   Exemplo: <code>auctions(start='2024-10-20', end='2024-10-27')</code> - Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir   da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel.   Exemplo: <code>auctions(start='2024-10-20')</code> - Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o desde a   data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>.   Exemplo: <code>auctions(end='2024-10-27')</code></p> <p>S\u00e9rie Hist\u00f3rica Completa: - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o   \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>.   Exemplo: <code>auctions()</code></p> <p>Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas, filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado. O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros <code>start</code> e <code>end</code> segue o padr\u00e3o da API do Banco Central: - Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim. - Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>. - Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</p> <p>Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\"). Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado. Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateScalar, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateScalar, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>auction_type</code> <code>(Literal['Sell', 'Buy'], opcional)</code> <p>O tipo de leil\u00e3o para filtrar diretamente na API. Padr\u00e3o \u00e9 <code>None</code> (retorna todos os tipos de leil\u00e3o).</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo especificados. Em caso de erro ao buscar os dados, um DataFrame vazio \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.</p> Notes <p>FR = First Round (Primeira Rodada) SR = Second Round (Segunda Rodada)</p> <p>O DataFrame possui as seguintes colunas:     - Date: Data do leil\u00e3o.     - Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.     - AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").     - Ordinance: Edital normativo associado ao leil\u00e3o.     - Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").     - BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").     - Maturity: Data de vencimento do t\u00edtulo.     - SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.     - Value: Valor total do leil\u00e3o em R$ (FR + SR).     - ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.     - ValueSR: Valor da segunda rodada (SR) em R$.     - OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).     - OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).     - OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).     - AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).     - AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).     - AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).     - AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.     - CutPrice: Pre\u00e7o de corte.     - AvgRate: Taxa de juros m\u00e9dia.     - CutRate: Taxa de corte.     - BDToMat: Dias \u00fateis at\u00e9 o vencimento.     - Duration: Duration (Dura\u00e7\u00e3o) do t\u00edtulo.     - DV01FR: Dollar Value of 1 bp change in yield - Primeira Rodada (FR) em R$.</p> Source code in <code>pyield/bc/auction.py</code> <pre><code>def auctions(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n    auction_type: Literal[\"Sell\", \"Buy\"] | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.\n\n    **Consultas de Per\u00edodo:**\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n      Exemplo: `auctions(start='2024-10-20', end='2024-10-27')`\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir\n      da data de `start` **at\u00e9 a data mais recente dispon\u00edvel**.\n      Exemplo: `auctions(start='2024-10-20')`\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o **desde a\n      data mais antiga dispon\u00edvel at\u00e9 a data de `end`**.\n      Exemplo: `auctions(end='2024-10-27')`\n\n    **S\u00e9rie Hist\u00f3rica Completa:**\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o\n      \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n      Exemplo: `auctions()`\n\n    Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas,\n    filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado.\n    O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros `start` e `end` segue o padr\u00e3o\n    da API do Banco Central:\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\").\n    Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado.\n    Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.\n\n    Args:\n        start (DateScalar, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateScalar, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        auction_type (Literal[\"Sell\", \"Buy\"], opcional): O tipo de leil\u00e3o para filtrar\n            diretamente na API. Padr\u00e3o \u00e9 `None` (retorna todos os tipos de leil\u00e3o).\n\n    Returns:\n        pd.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo\n            especificados. Em caso de erro ao buscar os dados, um DataFrame vazio\n            \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.\n\n    Notes:\n        FR = First Round (Primeira Rodada)\n        SR = Second Round (Segunda Rodada)\n\n        O DataFrame possui as seguintes colunas:\n            - Date: Data do leil\u00e3o.\n            - Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.\n            - AuctionType: Tipo de leil\u00e3o (ex: \"Sell\" ou \"Buy\").\n            - Ordinance: Edital normativo associado ao leil\u00e3o.\n            - Buyer: Categoria do comprador (ex: \"TodoMercado\", \"SomenteDealerApto\").\n            - BondType: Categoria do t\u00edtulo (ex: \"LTN\", \"LFT\", \"NTN-B\", \"NTN-F\").\n            - Maturity: Data de vencimento do t\u00edtulo.\n            - SelicCode: C\u00f3digo do t\u00edtulo no sistema Selic.\n            - Value: Valor total do leil\u00e3o em R$ (FR + SR).\n            - ValueFR: Valor da primeira rodada (FR) do leil\u00e3o em R$.\n            - ValueSR: Valor da segunda rodada (SR) em R$.\n            - OfferedQuantity: Quantidade total ofertada no leil\u00e3o (FR + SR).\n            - OfferedQuantityFR: Quantidade ofertada na primeira rodada (FR).\n            - OfferedQuantitySR: Quantidade ofertada na segunda rodada (SR).\n            - AcceptedQuantity: Quantidade total aceita no leil\u00e3o (FR + SR).\n            - AcceptedQuantityFR: Quantidade aceita na primeira rodada (FR).\n            - AcceptedQuantitySR: Quantidade aceita na segunda rodada (SR).\n            - AvgPrice: Pre\u00e7o m\u00e9dio no leil\u00e3o.\n            - CutPrice: Pre\u00e7o de corte.\n            - AvgRate: Taxa de juros m\u00e9dia.\n            - CutRate: Taxa de corte.\n            - BDToMat: Dias \u00fateis at\u00e9 o vencimento.\n            - Duration: Duration (Dura\u00e7\u00e3o) do t\u00edtulo.\n            - DV01FR: Dollar Value of 1 bp change in yield - Primeira Rodada (FR) em R$.\n    \"\"\"\n    url = BASE_API_URL\n    if start:\n        start = dc.convert_input_dates(start)\n        start_str = start.strftime(\"%Y-%m-%d\")\n        url += f\"@dataMovimentoInicio='{start_str}'\"\n\n    if end:\n        end = dc.convert_input_dates(end)\n        end_str = end.strftime(\"%Y-%m-%d\")\n        url += f\"&amp;@dataMovimentoFim='{end_str}'\"\n\n    # Mapeamento do auction_type para o valor esperado pela API\n    auction_type_mapping = {\"Sell\": \"Venda\", \"Buy\": \"Compra\"}\n    auction_type_api_value = auction_type_mapping.get(str(auction_type))\n    # Adiciona o par\u00e2metro tipoOferta \u00e0 URL se auction_type for fornecido\n    if auction_type_api_value:\n        url += f\"&amp;@tipoOferta='{auction_type_api_value}'\"\n\n    url += \"&amp;$format=text/csv\"  # Adiciona o formato CSV ao final\n\n    return _fetch_df_from_url(url)\n</code></pre>"},{"location":"bc/#pyield.bc.di_over","title":"<code>di_over(date, annualized=True)</code>","text":"<p>Fetches the DI Over rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the DI Over rate for.</p> required <code>annualized</code> <code>bool</code> <p>If True, returns the annualized rate (252 trading days per year), otherwise returns the daily rate.</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>The DI Over rate as a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n0.104\n</code></pre> <pre><code>&gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n0.00045513\n</code></pre> Source code in <code>pyield/bc/bcdata.py</code> <pre><code>def di_over(date: DateScalar, annualized: bool = True) -&gt; float:\n    \"\"\"\n    Fetches the DI Over rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the DI Over rate for.\n        annualized: If True, returns the annualized rate (252 trading\n            days per year), otherwise returns the daily rate.\n\n    Returns:\n        The DI Over rate as a float.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.di_over(\"31-05-2024\")\n        0.104\n\n        &gt;&gt;&gt; bc.di_over(\"28-01-2025\", annualized=False)\n        0.00045513\n    \"\"\"\n    df = di_over_series(date, date, annualized)\n    return float(df.at[0, \"Value\"])\n</code></pre>"},{"location":"bc/#pyield.bc.di_over_series","title":"<code>di_over_series(start=None, end=None, annualized=True)</code>","text":"<p>Fetches the DI (Interbank Deposit) rate from the Brazilian Central Bank.</p> <p>The DI rate represents the average interest rate of interbank loans.</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024 https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | None</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> <code>None</code> <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <code>annualized</code> <code>bool</code> <p>If True, returns the annualized rate (252 trading days per year), otherwise returns the daily rate.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the DI rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.di_over_series(\"29-01-2025\")\n        Date   Value\n0  2025-01-29  0.1215\n1  2025-01-30  0.1315\n2  2025-01-31  0.1315\n3  2025-02-03  0.1315\n...\n</code></pre> Source code in <code>pyield/bc/bcdata.py</code> <pre><code>def di_over_series(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n    annualized: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches the DI (Interbank Deposit) rate from the Brazilian Central Bank.\n\n    The DI rate represents the average interest rate of interbank loans.\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=csv&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n        annualized: If True, returns the annualized rate (252 trading\n            days per year), otherwise returns the daily rate.\n\n    Returns:\n        DataFrame containing Date and Value columns with the DI rate,\n        or empty DataFrame if data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.di_over_series(\"29-01-2025\")\n                Date   Value\n        0  2025-01-29  0.1215\n        1  2025-01-30  0.1315\n        2  2025-01-31  0.1315\n        3  2025-02-03  0.1315\n        ...\n\n    \"\"\"\n    df = _fetch_data_from_url(BCSerie.DI_OVER, start, end)\n    if annualized:\n        df[\"Value\"] = (df[\"Value\"] + 1) ** 252 - 1\n        df[\"Value\"] = df[\"Value\"].round(DECIMAL_PLACES_ANNUALIZED)\n    else:\n        df[\"Value\"] = df[\"Value\"].round(DECIMAL_PLACES_DAILY)\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.ptax_series","title":"<code>ptax_series(start=None, end=None)</code>","text":"<p>Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio) - Fonte: Banco Central do Brasil (BCB) - Frequ\u00eancia: Di\u00e1ria - Unidade: R$</p> <p>Documenta\u00e7\u00e3o da API do BCB:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n</code></pre> <p>Exemplo de chamada \u00e0 API:</p> <pre><code>https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n</code></pre> <p>Consultas de Per\u00edodo:</p> <ul> <li> <p>Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>. Exemplo:</p> <pre><code>`ptax_series(start='2024-10-20', end='2024-10-27')`\n</code></pre> </li> <li> <p>Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados a partir da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Exemplo:</p> <pre><code>`ptax_series(start='2024-10-20')`\n</code></pre> </li> <li> <p>Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Exemplo:</p> <p><code>ptax_series(end='2024-10-27')</code></p> </li> </ul> <p>S\u00e9rie Hist\u00f3rica Completa:</p> <ul> <li>Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984 at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>. Exemplo:<pre><code>`ptax_series()`\n</code></pre> </li> </ul> <p>Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:</p> <ul> <li>Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim.</li> <li>Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>.</li> <li>Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateScalar, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateScalar, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.</p> <code>DataFrame</code> <p>Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio</p> <code>DataFrame</code> <p>ser\u00e1 retornado.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; df = yd.bc.ptax_series(start=\"01-01-2025\", end=\"05-01-2025\")\n&gt;&gt;&gt; selected_columns = [\"Date\", \"BuyRate\", \"SellRate\", \"MidRate\"]\n&gt;&gt;&gt; df[selected_columns]\n        Date  BuyRate  SellRate  MidRate\n0 2025-01-02    6.208    6.2086   6.2083\n1 2025-01-03   6.1557    6.1563    6.156\n</code></pre> Notes <p>Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990 e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992, essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de 2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de 1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta; o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos boletins do dia.</p> <ul> <li>Primeira data dispon\u00edvel: 28.11.1984</li> <li>\u00daltima data dispon\u00edvel: data atual</li> </ul> <p>O DataFrame possui as seguintes colunas:</p> <ul> <li>Date: Data da cota\u00e7\u00e3o.</li> <li>Time: Hora da cota\u00e7\u00e3o.</li> <li>DateTime: Data e hora da cota\u00e7\u00e3o.</li> <li>BuyRate: Taxa de compra.</li> <li>SellRate: Taxa de venda.</li> <li>MidRate: Taxa m\u00e9dia entre a taxa de compra e venda.</li> </ul> Source code in <code>pyield/bc/ptax.py</code> <pre><code>def ptax_series(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Cota\u00e7\u00f5es de D\u00f3lar PTAX (taxa de c\u00e2mbio)\n    - Fonte: Banco Central do Brasil (BCB)\n    - Frequ\u00eancia: Di\u00e1ria\n    - Unidade: R$\n\n    Documenta\u00e7\u00e3o da API do BCB:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/documentacao\n\n    Exemplo de chamada \u00e0 API:\n\n        https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='08-01-2025'&amp;@dataFinalCotacao='08-05-2025'&amp;$format=text/csv\n\n    Consultas de Per\u00edodo:\n\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n    Exemplo:\n\n            `ptax_series(start='2024-10-20', end='2024-10-27')`\n\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados a partir\n    da data de `start` at\u00e9 a data mais recente dispon\u00edvel. Exemplo:\n\n            `ptax_series(start='2024-10-20')`\n\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados desde a data mais\n    antiga dispon\u00edvel at\u00e9 a data de `end`. Exemplo:\n\n        `ptax_series(end='2024-10-27')`\n\n    S\u00e9rie Hist\u00f3rica Completa:\n\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 28.11.1984\n    at\u00e9 o \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n    Exemplo:\n\n            `ptax_series()`\n\n    Busca dados de cota\u00e7\u00f5es de d\u00f3lar PTAX (taxa de c\u00e2mbio) para o per\u00edodo:\n\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Args:\n        start (DateScalar, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateScalar, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n\n    Returns:\n        pd.DataFrame: Um DataFrame contendo os dados de cota\u00e7\u00f5es de d\u00f3lar PTAX.\n        Se n\u00e3o houver dados dispon\u00edveis para o per\u00edodo especificado, um DataFrame vazio\n        ser\u00e1 retornado.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; df = yd.bc.ptax_series(start=\"01-01-2025\", end=\"05-01-2025\")\n        &gt;&gt;&gt; selected_columns = [\"Date\", \"BuyRate\", \"SellRate\", \"MidRate\"]\n        &gt;&gt;&gt; df[selected_columns]\n                Date  BuyRate  SellRate  MidRate\n        0 2025-01-02    6.208    6.2086   6.2083\n        1 2025-01-03   6.1557    6.1563    6.156\n\n    Notes:\n        Dispon\u00edvel desde 28.11.1984, refere-se \u00e0s taxas administradas at\u00e9 mar\u00e7o de 1990\n        e \u00e0s taxas livres a partir de ent\u00e3o (Resolu\u00e7\u00e3o 1690, de 18.3.1990). As taxas\n        administradas s\u00e3o aquelas fixadas pelo Banco Central; a partir de mar\u00e7o de 1992,\n        essa taxa recebeu a denomina\u00e7\u00e3o de taxa PTAX (fechamento). At\u00e9 30 de junho de\n        2011, as taxas livres correspondiam \u00e0 m\u00e9dia das taxas efetivas de opera\u00e7\u00f5es no\n        mercado interbanc\u00e1rio, ponderada pelo volume de transa\u00e7\u00f5es do dia. A partir de\n        1 de julho de 2011 (Circular 3506, de 23.9.2010), a Ptax passou a corresponder\n        \u00e0 m\u00e9dia aritm\u00e9tica das taxas obtidas em quatro consultas di\u00e1rias aos dealers de\n        c\u00e2mbio e refletem a taxa negociada no momento de abertura da janela de consulta;\n        o boletim de fechamento PTAX corresponde \u00e0 m\u00e9dia aritm\u00e9tica das taxas dos\n        boletins do dia.\n\n        - Primeira data dispon\u00edvel: 28.11.1984\n        - \u00daltima data dispon\u00edvel: data atual\n\n        O DataFrame possui as seguintes colunas:\n\n        - Date: Data da cota\u00e7\u00e3o.\n        - Time: Hora da cota\u00e7\u00e3o.\n        - DateTime: Data e hora da cota\u00e7\u00e3o.\n        - BuyRate: Taxa de compra.\n        - SellRate: Taxa de venda.\n        - MidRate: Taxa m\u00e9dia entre a taxa de compra e venda.\n\n\n    \"\"\"\n    if start:\n        start = dc.convert_input_dates(start)\n    else:\n        start = pd.Timestamp(\"1984-11-28\")\n\n    if end:\n        end = dc.convert_input_dates(end)\n    else:\n        end = dt.datetime.now(TIMEZONE_BZ).date()\n\n    start_str = start.strftime(\"%m-%d-%Y\")\n    end_str = end.strftime(\"%m-%d-%Y\")\n\n    # Monta a URL da API com as datas de in\u00edcio e fim\n    url = PTAX_API_URL\n    url += f\"@dataInicial='{start_str}'\"\n    url += f\"&amp;@dataFinalCotacao='{end_str}'\"\n    url += \"&amp;$format=text/csv\"  # Adiciona o formato CSV ao final\n\n    return _fetch_df_from_url(url)\n</code></pre>"},{"location":"bc/#pyield.bc.repos","title":"<code>repos(start=None, end=None)</code>","text":"<p>Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.</p> <p>Consultas de Per\u00edodo: - Para consultar dados de um intervalo, forne\u00e7a as datas de <code>start</code> e <code>end</code>.   Exemplo: <code>auctions(start='2024-10-20', end='2024-10-27')</code> - Se apenas <code>start</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir   da data de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel.   Exemplo: <code>auctions(start='2024-10-20')</code> - Se apenas <code>end</code> for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o desde a   data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>.   Exemplo: <code>auctions(end='2024-10-27')</code></p> <p>S\u00e9rie Hist\u00f3rica Completa: - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o   \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros <code>start</code> e <code>end</code>.   Exemplo: <code>auctions()</code></p> <p>Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas, filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado. O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros <code>start</code> e <code>end</code> segue o padr\u00e3o da API do Banco Central: - Se <code>start</code> for fornecido e <code>end</code> n\u00e3o, a fun\u00e7\u00e3o retorna dados de <code>start</code> at\u00e9 o fim. - Se <code>end</code> for fornecido e <code>start</code> n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 <code>end</code>. - Se ambos <code>start</code> e <code>end</code> forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.</p> <p>Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\"). Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado. Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(DateScalar, opcional)</code> <p>A data de in\u00edcio para a consulta dos leil\u00f5es. Se <code>start</code> for fornecido e <code>end</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o a partir de <code>start</code> at\u00e9 a data mais recente dispon\u00edvel. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <code>end</code> <code>(DateScalar, opcional)</code> <p>A data de fim para a consulta de dados de leil\u00e3o. Se <code>end</code> for fornecido e <code>start</code> for <code>None</code>, a API retornar\u00e1 dados de leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de <code>end</code>. Se <code>start</code> e <code>end</code> forem <code>None</code>, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada. Padr\u00e3o \u00e9 <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo especificados. Em caso de erro ao buscar os dados, um DataFrame vazio \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.</p> Notes <p>O DataFrame possui as seguintes colunas:     - Date: Data do leil\u00e3o.     - Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.     - Maturity: Data de retorno do leil\u00e3o.     - CDToMat: Prazo em dias corridos at\u00e9 o vencimento.     - BDtoMat: Prazo em dias \u00fateis at\u00e9 o vencimento.     - StartTime: Hora de in\u00edcio do leil\u00e3o.     - AllowedParticipants: Participantes permitidos no leil\u00e3o.     - CommunicationNumber: N\u00famero do comunicado.     - OfferType: Tipo de oferta do leil\u00e3o.     - AcceptedVolume: Volume aceito no leil\u00e3o (em R$).     - CutRate: Taxa de corte do leil\u00e3o.     - CutPct: Percentual de corte do leil\u00e3o.</p> Source code in <code>pyield/bc/repo.py</code> <pre><code>def repos(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recupera dados de leil\u00f5es para um determinado per\u00edodo e tipo de leil\u00e3o da API do BC.\n\n    **Consultas de Per\u00edodo:**\n    - Para consultar dados de um intervalo, forne\u00e7a as datas de `start` e `end`.\n      Exemplo: `auctions(start='2024-10-20', end='2024-10-27')`\n    - Se apenas `start` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o a partir\n      da data de `start` **at\u00e9 a data mais recente dispon\u00edvel**.\n      Exemplo: `auctions(start='2024-10-20')`\n    - Se apenas `end` for fornecido, a API do BC retornar\u00e1 dados de leil\u00e3o **desde a\n      data mais antiga dispon\u00edvel at\u00e9 a data de `end`**.\n      Exemplo: `auctions(end='2024-10-27')`\n\n    **S\u00e9rie Hist\u00f3rica Completa:**\n    - Para recuperar a s\u00e9rie hist\u00f3rica completa de leil\u00f5es (desde 12/11/2012 at\u00e9 o\n      \u00faltimo dia \u00fatil), chame a fun\u00e7\u00e3o sem fornecer os par\u00e2metros `start` e `end`.\n      Exemplo: `auctions()`\n\n    Busca dados de leil\u00f5es da API do BC para as datas de in\u00edcio e fim especificadas,\n    filtrando os resultados diretamente na API pelo tipo de leil\u00e3o, se especificado.\n    O comportamento da fun\u00e7\u00e3o em rela\u00e7\u00e3o aos par\u00e2metros `start` e `end` segue o padr\u00e3o\n    da API do Banco Central:\n    - Se `start` for fornecido e `end` n\u00e3o, a fun\u00e7\u00e3o retorna dados de `start` at\u00e9 o fim.\n    - Se `end` for fornecido e `start` n\u00e3o, a API retorna dados do in\u00edcio at\u00e9 `end`.\n    - Se ambos `start` e `end` forem omitidos, a API retorna a s\u00e9rie hist\u00f3rica completa.\n\n    Os dados podem ser filtrados pelo tipo de leil\u00e3o especificado (\"Sell\" ou \"Buy\").\n    Leil\u00f5es de \"Sell\" s\u00e3o aqueles em que o Tesouro Nacional vende t\u00edtulos ao mercado.\n    Leil\u00f5es de \"Buy\" s\u00e3o aqueles em que o Tesouro Nacional compra t\u00edtulos do mercado.\n\n    Args:\n        start (DateScalar, opcional): A data de in\u00edcio para a consulta dos leil\u00f5es.\n            Se `start` for fornecido e `end` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o a partir de `start` at\u00e9 a data mais recente dispon\u00edvel.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n        end (DateScalar, opcional): A data de fim para a consulta de dados de leil\u00e3o.\n            Se `end` for fornecido e `start` for `None`, a API retornar\u00e1 dados de\n            leil\u00e3o desde a data mais antiga dispon\u00edvel at\u00e9 a data de `end`.\n            Se `start` e `end` forem `None`, a s\u00e9rie hist\u00f3rica completa ser\u00e1 retornada.\n            Padr\u00e3o \u00e9 `None`.\n\n    Returns:\n        pd.DataFrame: Um DataFrame contendo dados de leil\u00f5es para o per\u00edodo e tipo\n            especificados. Em caso de erro ao buscar os dados, um DataFrame vazio\n            \u00e9 retornado e uma mensagem de erro \u00e9 registrada no log.\n\n    Notes:\n        O DataFrame possui as seguintes colunas:\n            - Date: Data do leil\u00e3o.\n            - Settlement: Data de liquida\u00e7\u00e3o do leil\u00e3o.\n            - Maturity: Data de retorno do leil\u00e3o.\n            - CDToMat: Prazo em dias corridos at\u00e9 o vencimento.\n            - BDtoMat: Prazo em dias \u00fateis at\u00e9 o vencimento.\n            - StartTime: Hora de in\u00edcio do leil\u00e3o.\n            - AllowedParticipants: Participantes permitidos no leil\u00e3o.\n            - CommunicationNumber: N\u00famero do comunicado.\n            - OfferType: Tipo de oferta do leil\u00e3o.\n            - AcceptedVolume: Volume aceito no leil\u00e3o (em R$).\n            - CutRate: Taxa de corte do leil\u00e3o.\n            - CutPct: Percentual de corte do leil\u00e3o.\n\n    \"\"\"\n    url = BASE_API_URL\n    if start:\n        start = dc.convert_input_dates(start)\n        start_str = start.strftime(\"%Y-%m-%d\")\n        url += f\"@dataLancamentoInicio='{start_str}'\"\n\n    if end:\n        end = dc.convert_input_dates(end)\n        end_str = end.strftime(\"%Y-%m-%d\")\n        url += f\"&amp;@dataLancamentoFim='{end_str}'\"\n\n    url += \"&amp;$format=text/csv\"  # Adiciona o formato CSV ao final\n\n    return _fetch_df_from_url(url)\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over","title":"<code>selic_over(date)</code>","text":"<p>Fetches the SELIC Over rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the SELIC Over rate for.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The SELIC Over rate as a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n0.104\n</code></pre> Source code in <code>pyield/bc/bcdata.py</code> <pre><code>def selic_over(date: DateScalar) -&gt; float:\n    \"\"\"\n    Fetches the SELIC Over rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the SELIC Over rate for.\n\n    Returns:\n        The SELIC Over rate as a float.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_over(\"31-05-2024\")\n        0.104\n    \"\"\"\n    df = selic_over_series(date, date)\n    return float(df.at[0, \"Value\"])\n</code></pre>"},{"location":"bc/#pyield.bc.selic_over_series","title":"<code>selic_over_series(start=None, end=None)</code>","text":"<p>Fetches the SELIC Over rate from the Brazilian Central Bank.</p> <p>The SELIC Over rate is the daily average interest rate effectively practiced between banks in the interbank market, using public securities as collateral.</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | None</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> <code>None</code> <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the SELIC Over rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_over_series(\"31-05-2024\", \"31-05-2024\")\n        Date  Value\n0 2024-05-31  0.104\n</code></pre> <pre><code>&gt;&gt;&gt; # No data on 26-01-2025 (sunday). Rate changed due to Copom meeting.\n&gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\")  # Returns all data since 26-01-2025\n        Date   Value\n0 2025-01-27  0.1215\n1 2025-01-28  0.1215\n2 2025-01-29  0.1215\n3 2025-01-30  0.1315\n4 2025-01-31  0.1315\n...\n</code></pre> Source code in <code>pyield/bc/bcdata.py</code> <pre><code>def selic_over_series(\n    start: DateScalar | None = None, end: DateScalar | None = None\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches the SELIC Over rate from the Brazilian Central Bank.\n\n    The SELIC Over rate is the daily average interest rate effectively practiced\n    between banks in the interbank market, using public securities as collateral.\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.1178/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n\n    Returns:\n        DataFrame containing Date and Value columns with the SELIC Over rate,\n        or empty DataFrame if data is not available.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_over_series(\"31-05-2024\", \"31-05-2024\")\n                Date  Value\n        0 2024-05-31  0.104\n\n        &gt;&gt;&gt; # No data on 26-01-2025 (sunday). Rate changed due to Copom meeting.\n        &gt;&gt;&gt; bc.selic_over_series(\"26-01-2025\")  # Returns all data since 26-01-2025\n                Date   Value\n        0 2025-01-27  0.1215\n        1 2025-01-28  0.1215\n        2 2025-01-29  0.1215\n        3 2025-01-30  0.1315\n        4 2025-01-31  0.1315\n        ...\n\n    \"\"\"\n    df = _fetch_data_from_url(BCSerie.SELIC_OVER, start, end)\n    df[\"Value\"] = df[\"Value\"].round(DECIMAL_PLACES_ANNUALIZED)\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target","title":"<code>selic_target(date)</code>","text":"<p>Fetches the SELIC Target rate value for a specific date.</p> <p>This is a convenience function that returns only the value (not the DataFrame) for the specified date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the SELIC Target rate for.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The SELIC Target rate as a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n0.105\n</code></pre> Source code in <code>pyield/bc/bcdata.py</code> <pre><code>def selic_target(date: DateScalar) -&gt; float:\n    \"\"\"\n    Fetches the SELIC Target rate value for a specific date.\n\n    This is a convenience function that returns only the value (not the DataFrame)\n    for the specified date.\n\n    Args:\n        date: The reference date to fetch the SELIC Target rate for.\n\n    Returns:\n        The SELIC Target rate as a float.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target(\"31-05-2024\")\n        0.105\n    \"\"\"\n    df = selic_target_series(date, date)\n    return float(df.at[0, \"Value\"])\n</code></pre>"},{"location":"bc/#pyield.bc.selic_target_series","title":"<code>selic_target_series(start=None, end=None)</code>","text":"<p>Fetches the SELIC Target rate from the Brazilian Central Bank.</p> <p>The SELIC Target rate is the official interest rate set by the Central Bank of Brazil's Monetary Policy Committee (COPOM).</p> API URL Example <p>https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | None</code> <p>The start date for the data to fetch. If None, returns data from   the earliest available date.</p> <code>None</code> <code>end</code> <code>DateScalar | None</code> <p>The end date for the data to fetch. If None, returns data up to  the latest available date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing Date and Value columns with the SELIC Target rate,</p> <code>DataFrame</code> <p>or empty DataFrame if data is not available</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\n        Date  Value\n0 2024-05-31  0.105\n</code></pre> Source code in <code>pyield/bc/bcdata.py</code> <pre><code>def selic_target_series(\n    start: DateScalar | None = None, end: DateScalar | None = None\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches the SELIC Target rate from the Brazilian Central Bank.\n\n    The SELIC Target rate is the official interest rate set by the\n    Central Bank of Brazil's Monetary Policy Committee (COPOM).\n\n    API URL Example:\n        https://api.bcb.gov.br/dados/serie/bcdata.sgs.432/dados?formato=json&amp;dataInicial=12/04/2024&amp;dataFinal=12/04/2024\n\n    Args:\n        start: The start date for the data to fetch. If None, returns data from\n              the earliest available date.\n        end: The end date for the data to fetch. If None, returns data up to\n             the latest available date.\n\n    Returns:\n        DataFrame containing Date and Value columns with the SELIC Target rate,\n        or empty DataFrame if data is not available\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.selic_target_series(\"31-05-2024\", \"31-05-2024\")\n                Date  Value\n        0 2024-05-31  0.105\n    \"\"\"\n    df = _fetch_data_from_url(BCSerie.SELIC_TARGET, start, end)\n    df[\"Value\"] = df[\"Value\"].round(DECIMAL_PLACES_ANNUALIZED)\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.tpf_trades","title":"<code>tpf_trades(target_date)</code>","text":"<p>Fetches monthly secondary trading data for the 't\u00edtulos p\u00fablicos federais' (TPF) registered in the Brazilian Central Bank (BCB) system.</p> <p>Downloads the monthly bond trading data from the Brazilian Central Bank (BCB) website for the month corresponding to the provided date. The data is downloaded as a ZIP file, extracted, and loaded into a Pandas DataFrame. The data contains all trades executed during the month, separated by each 'SettlementDate'.</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>DateScalar</code> <p>The date for which the monthly trading data will be fetched. This date can be a string, datetime, or pandas Timestamp object. It will be converted to a pandas Timestamp object. Only the year and month of this date will be used to download the corresponding monthly file.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the bond trading data for the specified month.</p> DataFrame columns <ul> <li>SettlementDate: Date when the trade settled</li> <li>BondType: Security type abbreviation</li> <li>SelicCode: Unique code in the SELIC system</li> <li>ISIN: International Securities Identification Number</li> <li>IssueDate: Date when the security was issued</li> <li>Maturity: Security's maturity date</li> <li>TradeCount: Number of trades executed</li> <li>TradeQuantity: Quantity traded</li> <li>TradeValue: Total value traded</li> <li>AvgPrice: Average price</li> <li>AvgRate: Average rate And additional trading metrics like min/max prices and rates.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; df = bc.tpf_trades(\"07-01-2025\")  # Returns all trades for January 2025\n</code></pre> Source code in <code>pyield/bc/trade.py</code> <pre><code>def tpf_trades(target_date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"Fetches monthly secondary trading data for the 't\u00edtulos p\u00fablicos federais' (TPF)\n    registered in the Brazilian Central Bank (BCB) system.\n\n    Downloads the monthly bond trading data from the Brazilian Central Bank (BCB)\n    website for the month corresponding to the provided date. The data is downloaded as\n    a ZIP file, extracted, and loaded into a Pandas DataFrame. The data contains all\n    trades executed during the month, separated by each 'SettlementDate'.\n\n    Args:\n        target_date (DateScalar): The date for which the monthly trading data will be\n            fetched. This date can be a string, datetime, or pandas Timestamp object.\n            It will be converted to a pandas Timestamp object. Only the year and month\n            of this date will be used to download the corresponding monthly file.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the bond trading data for the\n            specified month.\n\n    DataFrame columns:\n        - SettlementDate: Date when the trade settled\n        - BondType: Security type abbreviation\n        - SelicCode: Unique code in the SELIC system\n        - ISIN: International Securities Identification Number\n        - IssueDate: Date when the security was issued\n        - Maturity: Security's maturity date\n        - TradeCount: Number of trades executed\n        - TradeQuantity: Quantity traded\n        - TradeValue: Total value traded\n        - AvgPrice: Average price\n        - AvgRate: Average rate\n        And additional trading metrics like min/max prices and rates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; df = bc.tpf_trades(\"07-01-2025\")  # Returns all trades for January 2025\n    \"\"\"\n    url = _build_download_url(target_date)\n    df = _fetch_data_from_url(url)\n    df = df.rename(columns=COLUMN_MAPPING)\n    return df\n</code></pre>"},{"location":"bc/#pyield.bc.vna_lft","title":"<code>vna_lft(date)</code>","text":"<p>Retrieves the VNA (Valor Nominal Atualizado) from the BCB for a given date.</p> <p>This function fetches daily data from the BCB website, extracts the VNA value from a specific table within the downloaded content, and returns this value.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The date for which to retrieve the VNA value. This argument accepts various date formats, including string and datetime objects, which are then standardized using the <code>convert_input_dates</code> function.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The VNA (Valor Nominal Atualizado) value for the specified date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bc\n&gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n14903.01148\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the extracted VNA values from the BCB website are inconsistent (i.e., not all extracted values are identical), suggesting potential data discrepancies on the source website. The error message includes a link to the BCB website for manual verification.</p> <code>HTTPError</code> <p>If the HTTP request to the BCB website fails. This could be due to network issues, website unavailability, or the requested data not being found for the given date.</p> Source code in <code>pyield/bc/vna.py</code> <pre><code>def vna_lft(date: DateScalar) -&gt; float:\n    \"\"\"Retrieves the VNA (Valor Nominal Atualizado) from the BCB for a given date.\n\n    This function fetches daily data from the BCB website, extracts the\n    VNA value from a specific table within the downloaded content, and\n    returns this value.\n\n    Args:\n        date (DateScalar): The date for which to retrieve the VNA value.\n            This argument accepts various date formats, including string and\n            datetime objects, which are then standardized using the\n            `convert_input_dates` function.\n\n    Returns:\n        float: The VNA (Valor Nominal Atualizado) value for the specified date.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bc\n        &gt;&gt;&gt; bc.vna_lft(\"31-05-2024\")\n        14903.01148\n\n    Raises:\n        ValueError: If the extracted VNA values from the BCB website are\n            inconsistent (i.e., not all extracted values are identical),\n            suggesting potential data discrepancies on the source website.\n            The error message includes a link to the BCB website for manual\n            verification.\n        requests.exceptions.HTTPError: If the HTTP request to the BCB website\n            fails. This could be due to network issues, website unavailability,\n            or the requested data not being found for the given date.\n    \"\"\"\n    text = _get_text(date)\n    table_text = _extract_vna_table_text(text)\n    table_lines = _parse_vna_table_lines(table_text)\n    vnas = _extract_vna_values_from_lines(table_lines)\n    vna_value = _validate_vna_values(vnas)\n    return vna_value\n</code></pre>"},{"location":"bday/","title":"Business Day Tools","text":""},{"location":"bday/#pyield.bday.count","title":"<code>count(start, end)</code>","text":"<pre><code>count(start: DateScalar, end: DateScalar) -&gt; int\n</code></pre><pre><code>count(start: DateArray, end: DateScalar) -&gt; pd.Series\n</code></pre><pre><code>count(start: DateScalar, end: DateArray) -&gt; pd.Series\n</code></pre><pre><code>count(start: DateArray, end: DateArray) -&gt; pd.Series\n</code></pre> <p>Counts the number of business days between a <code>start</code> date (inclusive) and an <code>end</code> date (exclusive). The function can handle single dates, arrays of dates and mixed inputs, returning either a single integer or a series of integers depending on the inputs. It accounts for specified holidays, effectively excluding them from the business day count.</p> <p>Important Note: The <code>start</code> date is used to determine which list of holidays applies to the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | DateArray</code> <p>The start date(s) for counting. The holiday list is selected based on this date.</p> required <code>end</code> <code>DateScalar | DateArray</code> <p>The end date(s) for counting, which is excluded from the count themselves.</p> required <p>Returns:</p> Type Description <code>int | Series</code> <p>int | pd.Series: Returns an integer if <code>start</code> and <code>end</code> are single dates, or a Series if any of them is an array of dates.</p> Notes <ul> <li>This function is a wrapper around <code>numpy.busday_count</code>, adapted to work   directly with various Pandas and Numpy date formats.</li> <li>It supports flexible date inputs, including single dates, lists, Series, and   more, for both <code>start</code> and <code>end</code> parameters.</li> <li>The return type depends on the input types: single dates return an int, while   arrays of dates return a pd.Series with the count for each date range.</li> <li>The <code>start</code> date determines the holiday list, ensuring consistency with the   applicable calendar at the time.</li> <li>See <code>numpy.busday_count</code> documentation for more details on how holidays are   handled and how business day counts are calculated:   https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n</code></pre> <pre><code>&gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n10\n</code></pre>"},{"location":"bday/#pyield.bday.count--total-business-days-in-january-and-february-since-the-start-of-the-year","title":"Total business days in January and February since the start of the year","text":"<pre><code>&gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n0    22\n1    41\ndtype: Int64\n</code></pre>"},{"location":"bday/#pyield.bday.count--the-remaining-business-days-in-january-and-february-to-the-end-of-the-year","title":"The remaining business days in January and February to the end of the year","text":"<pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n0    253\n1    231\ndtype: Int64\n</code></pre>"},{"location":"bday/#pyield.bday.count--the-total-business-days-in-january-and-february-of-2024","title":"The total business days in January and February of 2024","text":"<pre><code>&gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n0    22\n1    19\ndtype: Int64\n</code></pre> Source code in <code>pyield/bday.py</code> <pre><code>def count(\n    start: DateScalar | DateArray,\n    end: DateScalar | DateArray,\n) -&gt; int | pd.Series:\n    \"\"\"\n    Counts the number of business days between a `start` date (inclusive) and an `end`\n    date (exclusive). The function can handle single dates, arrays of dates and\n    mixed inputs, returning either a single integer or a series of integers depending\n    on the inputs. It accounts for specified holidays, effectively excluding them from\n    the business day count.\n\n    **Important Note:** The `start` date is used to determine which list of holidays\n    applies to the calculation.\n\n    Args:\n        start (DateScalar | DateArray): The start date(s) for counting. The holiday list\n            is selected based on this date.\n        end (DateScalar | DateArray): The end date(s) for counting, which\n            is excluded from the count themselves.\n\n    Returns:\n        int | pd.Series: Returns an integer if `start` and `end` are single dates,\n            or a Series if any of them is an array of dates.\n\n    Notes:\n        - This function is a wrapper around `numpy.busday_count`, adapted to work\n          directly with various Pandas and Numpy date formats.\n        - It supports flexible date inputs, including single dates, lists, Series, and\n          more, for both `start` and `end` parameters.\n        - The return type depends on the input types: single dates return an int, while\n          arrays of dates return a pd.Series with the count for each date range.\n        - The `start` date determines the holiday list, ensuring consistency with the\n          applicable calendar at the time.\n        - See `numpy.busday_count` documentation for more details on how holidays are\n          handled and how business day counts are calculated:\n          https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n\n        &gt;&gt;&gt; bday.count(\"15-12-2023\", \"01-01-2024\")\n        10\n\n        # Total business days in January and February since the start of the year\n        &gt;&gt;&gt; bday.count(start=\"01-01-2024\", end=[\"01-02-2024\", \"01-03-2024\"])\n        0    22\n        1    41\n        dtype: Int64\n\n        # The remaining business days in January and February to the end of the year\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], \"01-01-2025\")\n        0    253\n        1    231\n        dtype: Int64\n\n        # The total business days in January and February of 2024\n        &gt;&gt;&gt; bday.count([\"01-01-2024\", \"01-02-2024\"], [\"01-02-2024\", \"01-03-2024\"])\n        0    22\n        1    19\n        dtype: Int64\n    \"\"\"\n    start_pd = dc.convert_input_dates(start)\n    end_pd = dc.convert_input_dates(end)\n\n    # If inputs are Series, check if they have different lengths\n    if isinstance(start_pd, pd.Series) and isinstance(end_pd, pd.Series):\n        if start_pd.size != end_pd.size:\n            raise ValueError(\"Input Series must have the same length.\")\n\n    # Only start is used to determine the holiday list\n    if isinstance(start_pd, pd.Series):\n        # Divide the input in order to apply the correct holiday list\n        start1 = start_pd[start_pd &lt; br_holidays.TRANSITION_DATE]\n        start2 = start_pd[start_pd &gt;= br_holidays.TRANSITION_DATE]\n        start3 = start_pd[start_pd.isna()]\n\n        # If end is a Series, it must be divided as well\n        if isinstance(end_pd, pd.Series):\n            end1 = end_pd[start1.index]\n            end2 = end_pd[start2.index]\n        else:\n            end1 = end_pd\n            end2 = end_pd\n\n        result1 = np.busday_count(\n            begindates=dc.to_numpy_date_type(start1),\n            enddates=dc.to_numpy_date_type(end1),\n            holidays=OLD_HOLIDAYS_ARRAY,\n        )\n        result2 = np.busday_count(\n            begindates=dc.to_numpy_date_type(start2),\n            enddates=dc.to_numpy_date_type(end2),\n            holidays=NEW_HOLIDAYS_ARRAY,\n        )\n\n        # Prepare results to be rejoined\n        result1 = pd.Series(result1, dtype=\"Int64\")\n        result2 = pd.Series(result2, dtype=\"Int64\")\n        # Convert the third result from NaT to NA\n        result3 = pd.Series(pd.NA, index=start3.index, dtype=\"Int64\")\n\n        # Old index is used to rejoin the results\n        result1.index = start1.index\n        result2.index = start2.index\n\n        # Reorder the result to match the original input order\n        result = pd.concat([result1, result2, result3]).sort_index()\n\n    else:  # Start is a single date\n        result = np.busday_count(\n            begindates=dc.to_numpy_date_type(start_pd),\n            enddates=dc.to_numpy_date_type(end_pd),\n            holidays=br_holidays.get_holiday_array(start_pd),\n        )\n        result = pd.Series(result, dtype=\"Int64\")\n\n    if result.size == 1:\n        return int(result[0])\n    return result\n</code></pre>"},{"location":"bday/#pyield.bday.generate","title":"<code>generate(start=None, end=None, inclusive='both', holiday_option='infer')</code>","text":"<p>Generates a Series of business days between a <code>start</code> and <code>end</code> date, considering the list of Brazilian holidays. It supports customization of holiday lists and inclusion options for start and end dates. It wraps <code>pandas.bdate_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar | None</code> <p>The start date for generating the dates.  If None, the current date is used. Defaults to None.</p> <code>None</code> <code>end</code> <code>DateScalar | None</code> <p>The end date for generating business days. If None, the current date is used. Defaults to None.</p> <code>None</code> <code>inclusive</code> <code>Literal['both', 'neither', 'left', 'right']</code> <p>Determines which of the start and end dates are included in the result. Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.</p> <code>'both'</code> <code>holiday_option</code> <code>Literal['old', 'new', 'infer']</code> <p>Specifies the list of holidays to consider. 'old' or 'new' refer to predefined lists, 'infer' selects the list based on the most recent date in the range. Defaults to \"infer\".</p> <code>'infer'</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series representing a range of business days between the specified start and end dates, considering the specified holidays.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n0   2023-12-22\n1   2023-12-26\n2   2023-12-27\n3   2023-12-28\n4   2023-12-29\n5   2024-01-02\ndtype: datetime64[ns]\n</code></pre> Note <p>For detailed information on parameters and error handling, refer to <code>pandas.bdate_range</code> documentation: https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.</p> Source code in <code>pyield/bday.py</code> <pre><code>def generate(\n    start: DateScalar | None = None,\n    end: DateScalar | None = None,\n    inclusive: Literal[\"both\", \"neither\", \"left\", \"right\"] = \"both\",\n    holiday_option: Literal[\"old\", \"new\", \"infer\"] = \"infer\",\n) -&gt; pd.Series:\n    \"\"\"\n    Generates a Series of business days between a `start` and `end` date, considering\n    the list of Brazilian holidays. It supports customization of holiday lists and\n    inclusion options for start and end dates. It wraps `pandas.bdate_range`.\n\n    Args:\n        start (DateScalar | None, optional): The start date for generating the dates.\n             If None, the current date is used. Defaults to None.\n        end (DateScalar | None, optional): The end date for generating business days.\n            If None, the current date is used. Defaults to None.\n        inclusive (Literal[\"both\", \"neither\", \"left\", \"right\"], optional):\n            Determines which of the start and end dates are included in the result.\n            Valid options are 'both', 'neither', 'left', 'right'. Defaults to 'both'.\n        holiday_option (Literal[\"old\", \"new\", \"infer\"], optional):\n            Specifies the list of holidays to consider. 'old' or 'new' refer to\n            predefined lists, 'infer' selects the list based on the most recent date in\n            the range. Defaults to \"infer\".\n\n    Returns:\n        pd.Series: A Series representing a range of business days between the specified\n            start and end dates, considering the specified holidays.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.generate(start=\"22-12-2023\", end=\"02-01-2024\")\n        0   2023-12-22\n        1   2023-12-26\n        2   2023-12-27\n        3   2023-12-28\n        4   2023-12-29\n        5   2024-01-02\n        dtype: datetime64[ns]\n\n    Note:\n        For detailed information on parameters and error handling, refer to\n        `pandas.bdate_range` documentation:\n        https://pandas.pydata.org/docs/reference/api/pandas.bdate_range.html.\n    \"\"\"\n    if start:\n        start_pd = dc.convert_input_dates(start)\n    else:\n        start_pd = pd.Timestamp.today()\n\n    if end:\n        end_pd = dc.convert_input_dates(end)\n    else:\n        end_pd = pd.Timestamp.today()\n\n    holidays_list = br_holidays.get_holiday_series(\n        dates=start_pd, holiday_option=holiday_option\n    ).to_list()\n\n    # Get the result as a DatetimeIndex (dti)\n    result_dti = pd.bdate_range(\n        start=start_pd,\n        end=end_pd,\n        freq=\"C\",\n        inclusive=inclusive,\n        holidays=holidays_list,\n    )\n    return pd.Series(result_dti.values)\n</code></pre>"},{"location":"bday/#pyield.bday.is_business_day","title":"<code>is_business_day(date)</code>","text":"<p>Checks if the input date is a business day.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The date to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the input date is a business day, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n&gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas\nFalse\n</code></pre> Source code in <code>pyield/bday.py</code> <pre><code>def is_business_day(date: DateScalar) -&gt; bool:\n    \"\"\"\n    Checks if the input date is a business day.\n\n    Args:\n        date (DateScalar): The date to check.\n\n    Returns:\n        bool: True if the input date is a business day, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n        &gt;&gt;&gt; bday.is_business_day(\"25-12-2023\")  # Christmas\n        False\n    \"\"\"\n    date_pd = dc.convert_input_dates(date)\n    shifted_date = offset(date_pd, 0)  # Shift the date if it is not a bus. day\n    return date_pd == shifted_date\n</code></pre>"},{"location":"bday/#pyield.bday.last_business_day","title":"<code>last_business_day()</code>","text":"<p>Returns the last business day in Brazil. If the current date is a business day, it returns the current date. If it is a weekend or holiday, it returns the last business day before the current date.</p> <p>Returns:</p> Type Description <code>Timestamp</code> <p>pd.Timestamp: The last business day in Brazil.</p> Source code in <code>pyield/bday.py</code> <pre><code>def last_business_day() -&gt; pd.Timestamp:\n    \"\"\"\n    Returns the last business day in Brazil. If the current date is a business day, it\n    returns the current date. If it is a weekend or holiday, it returns the last\n    business day before the current date.\n\n    Returns:\n        pd.Timestamp: The last business day in Brazil.\n\n    \"\"\"\n    # Get the current date in Brazil without timezone information\n    bz_today = pd.Timestamp.now(TIMEZONE_BZ).normalize().tz_localize(None)\n    return offset(bz_today, 0, roll=\"backward\")\n</code></pre>"},{"location":"bday/#pyield.bday.offset","title":"<code>offset(dates, offset, roll='forward')</code>","text":"<pre><code>offset(dates: DateScalar, offset: IntegerScalar, roll: Literal['forward', 'backward'] = ...) -&gt; pd.Timestamp\n</code></pre><pre><code>offset(dates: DateArray, offset: IntegerArray, roll: Literal['forward', 'backward'] = ...) -&gt; pd.Series\n</code></pre><pre><code>offset(dates: DateScalar, offset: IntegerArray, roll: Literal['forward', 'backward'] = ...) -&gt; pd.Series\n</code></pre><pre><code>offset(dates: DateArray, offset: IntegerScalar, roll: Literal['forward', 'backward'] = ...) -&gt; pd.Series\n</code></pre> <p>First adjusts the date to fall on a valid day according to the roll rule, then applies offsets to the given dates to the next or previous business day, considering brazilian holidays. This function supports both single dates and collections of dates. It is a wrapper for <code>numpy.busday_offset</code> adapted for Pandas data types and brazilian holidays.</p> <p>Important Note: The <code>dates</code> parameter is used to determine which list of holidays applies to the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar | DateArray</code> <p>The date(s) to offset. Can be a scalar date type or a collection of dates. The holiday list is determined based on this date.</p> required <code>offset</code> <code>int | Series | ndarray | list[int] | tuple[int]</code> <p>The number of business days to offset the dates. Positive for future dates, negative for past dates. Zero will return the same date if it's a business day, or the next business day otherwise.</p> required <code>roll</code> <code>Literal['forward', 'backward']</code> <p>Direction to roll the date if it falls on a holiday or weekend. 'forward' to the next business day, 'backward' to the previous. Defaults to 'forward'.</p> <code>'forward'</code> <p>Returns:</p> Type Description <code>Timestamp | Series</code> <p>pd.Timestamp | pd.Series: If a single date is provided, returns a single <code>Timestamp</code> of the offset date. If a series of dates is provided, returns a <code>Series</code> of offset dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import bday\n</code></pre> <p>Offset to the next business day if not a bday (offset=0 and roll=\"forward\")</p>"},{"location":"bday/#pyield.bday.offset--offset-saturday-before-christmas-to-the-next-b-day-tuesday-after-christmas","title":"Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\nTimestamp('2023-12-26 00:00:00')\n</code></pre>"},{"location":"bday/#pyield.bday.offset--offset-friday-before-christmas-no-offset-because-its-a-business-day","title":"Offset Friday before Christmas (no offset because it's a business day)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\nTimestamp('2023-12-22 00:00:00')\n</code></pre> <p>Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")</p>"},{"location":"bday/#pyield.bday.offset--no-offset-because-its-a-business-day","title":"No offset because it's a business day","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\nTimestamp('2023-12-22 00:00:00')\n</code></pre>"},{"location":"bday/#pyield.bday.offset--offset-to-the-first-business-day-before-23-12-2023","title":"Offset to the first business day before \"23-12-2023\"","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\nTimestamp('2023-12-22 00:00:00')\n</code></pre> <p>Jump to the next business day (1 offset and roll=\"forward\")</p>"},{"location":"bday/#pyield.bday.offset--offset-friday-to-the-next-business-day-friday-is-jumped-monday","title":"Offset Friday to the next business day (Friday is jumped -&gt; Monday)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\nTimestamp('2024-09-30 00:00:00')\n</code></pre>"},{"location":"bday/#pyield.bday.offset--offset-saturday-to-the-next-business-day-monday-is-jumped-tuesday","title":"Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\nTimestamp('2024-10-01 00:00:00')\n</code></pre> <p>Jump to the previous business day (-1 offset and roll=\"backward\")</p>"},{"location":"bday/#pyield.bday.offset--offset-friday-to-the-previous-business-day-friday-is-jumped-thursday","title":"Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\nTimestamp('2024-09-26 00:00:00')\n</code></pre>"},{"location":"bday/#pyield.bday.offset--offset-saturday-to-the-previous-business-day-friday-is-jumped-thursday","title":"Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)","text":"<pre><code>&gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\nTimestamp('2024-09-26 00:00:00')\n</code></pre> <p>List of dates and offsets</p> <pre><code>&gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)  # a list of dates\n0   2024-09-20\n1   2024-09-23\ndtype: datetime64[ns]\n</code></pre> <pre><code>&gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\n0   2024-09-20\n1   2024-09-23\ndtype: datetime64[ns]\n</code></pre> Note <p>This function uses <code>numpy.busday_offset</code> under the hood, which means it follows the same conventions and limitations for business day calculations. For detailed information on error handling and behavior, refer to the <code>numpy.busday_offset</code> documentation: https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html</p> Source code in <code>pyield/bday.py</code> <pre><code>def offset(\n    dates: DateScalar | DateArray,\n    offset: IntegerScalar | IntegerArray,\n    roll: Literal[\"forward\", \"backward\"] = \"forward\",\n) -&gt; pd.Timestamp | pd.Series:\n    \"\"\"\n    First adjusts the date to fall on a valid day according to the roll rule, then\n    applies offsets to the given dates to the next or previous business day, considering\n    brazilian holidays. This function supports both single dates and collections of\n    dates. It is a wrapper for `numpy.busday_offset` adapted for Pandas data types and\n    brazilian holidays.\n\n    **Important Note:** The `dates` parameter is used to determine which list of\n    holidays applies to the calculation.\n\n    Args:\n        dates (DateScalar | DateArray): The date(s) to offset. Can be a scalar date type\n            or a collection of dates. The holiday list is determined based on this date.\n        offset (int | Series | np.ndarray | list[int] | tuple[int], optional):\n            The number of business days to offset the dates. Positive for future dates,\n            negative for past dates. Zero will return the same date if it's a business\n            day, or the next business day otherwise.\n        roll (Literal[\"forward\", \"backward\"], optional): Direction to roll the date if\n            it falls on a holiday or weekend. 'forward' to the next business day,\n            'backward' to the previous. Defaults to 'forward'.\n\n    Returns:\n        pd.Timestamp | pd.Series: If a single date is provided, returns a single\n            `Timestamp` of the offset date. If a series of dates is provided, returns a\n            `Series` of offset dates.\n\n    Examples:\n        &gt;&gt;&gt; from pyield import bday\n\n        Offset to the next business day if not a bday (offset=0 and roll=\"forward\")\n\n        # Offset Saturday before Christmas to the next b. day (Tuesday after Christmas)\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0)\n        Timestamp('2023-12-26 00:00:00')\n\n        # Offset Friday before Christmas (no offset because it's a business day)\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0)\n        Timestamp('2023-12-22 00:00:00')\n\n        Offset to the previous business day if not a bday (offset=0 and roll=\"backward\")\n\n        # No offset because it's a business day\n        &gt;&gt;&gt; bday.offset(\"22-12-2023\", 0, roll=\"backward\")\n        Timestamp('2023-12-22 00:00:00')\n\n        # Offset to the first business day before \"23-12-2023\"\n        &gt;&gt;&gt; bday.offset(\"23-12-2023\", 0, roll=\"backward\")\n        Timestamp('2023-12-22 00:00:00')\n\n        Jump to the next business day (1 offset and roll=\"forward\")\n\n        # Offset Friday to the next business day (Friday is jumped -&gt; Monday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", 1)\n        Timestamp('2024-09-30 00:00:00')\n\n        # Offset Saturday to the next business day (Monday is jumped -&gt; Tuesday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", 1)\n        Timestamp('2024-10-01 00:00:00')\n\n        Jump to the previous business day (-1 offset and roll=\"backward\")\n\n        # Offset Friday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"27-09-2024\", -1, roll=\"backward\")\n        Timestamp('2024-09-26 00:00:00')\n\n        # Offset Saturday to the previous business day (Friday is jumped -&gt; Thursday)\n        &gt;&gt;&gt; bday.offset(\"28-09-2024\", -1, roll=\"backward\")\n        Timestamp('2024-09-26 00:00:00')\n\n        List of dates and offsets\n\n        &gt;&gt;&gt; bday.offset([\"19-09-2024\", \"20-09-2024\"], 1)  # a list of dates\n        0   2024-09-20\n        1   2024-09-23\n        dtype: datetime64[ns]\n\n        &gt;&gt;&gt; bday.offset(\"19-09-2024\", [1, 2])  # a list of offsets\n        0   2024-09-20\n        1   2024-09-23\n        dtype: datetime64[ns]\n\n    Note:\n        This function uses `numpy.busday_offset` under the hood, which means it follows\n        the same conventions and limitations for business day calculations. For detailed\n        information on error handling and behavior, refer to the `numpy.busday_offset`\n        documentation:\n        https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html\n    \"\"\"\n    dates_pd = dc.convert_input_dates(dates)\n\n    if isinstance(dates_pd, pd.Series):\n        # Divide the input in order to apply the correct holiday list\n        dates1 = dates_pd[dates_pd &lt; br_holidays.TRANSITION_DATE]\n        dates2 = dates_pd[dates_pd &gt;= br_holidays.TRANSITION_DATE]\n        dates3 = dates_pd[dates_pd.isna()]\n\n        offsetted_dates1 = np.busday_offset(\n            dc.to_numpy_date_type(dates1),\n            offsets=offset,\n            roll=roll,\n            holidays=OLD_HOLIDAYS_ARRAY,\n        )\n\n        offsetted_dates2 = np.busday_offset(\n            dc.to_numpy_date_type(dates2),\n            offsets=offset,\n            roll=roll,\n            holidays=NEW_HOLIDAYS_ARRAY,\n        )\n\n        # Convert from numpy.datetime64 to pandas.Timestamp\n        offsetted_dates1 = pd.to_datetime(offsetted_dates1)\n        offsetted_dates2 = pd.to_datetime(offsetted_dates2)\n\n        # 'pd.to_datetime' does not necessarily return datetime64[ns] Series\n        offsetted_dates1 = pd.Series(offsetted_dates1).astype(\"datetime64[ns]\")\n        offsetted_dates2 = pd.Series(offsetted_dates2).astype(\"datetime64[ns]\")\n\n        # Use old index to rejoin the results\n        offsetted_dates1.index = dates1.index\n        offsetted_dates2.index = dates2.index\n\n        offsetted_dates = pd.concat([offsetted_dates1, offsetted_dates2, dates3])\n\n        # Reorder the result to match the original input order\n        return offsetted_dates.sort_index()\n\n    elif isinstance(dates_pd, pd.Timestamp):\n        offsetted_dates_np = np.busday_offset(\n            dc.to_numpy_date_type(dates_pd),\n            offsets=offset,\n            roll=roll,\n            holidays=br_holidays.get_holiday_array(dates_pd),\n        )\n        if isinstance(offsetted_dates_np, np.datetime64):\n            return pd.Timestamp(offsetted_dates_np).as_unit(\"ns\")\n        else:\n            return pd.Series(offsetted_dates_np).astype(\"datetime64[ns]\")\n\n    else:\n        raise ValueError(\"Invalid input type for 'dates'.\")\n</code></pre>"},{"location":"di/","title":"DI Data","text":""},{"location":"di/#pyield.b3.di.DIFutures","title":"<code>DIFutures(date=None, month_start=False, pre_filter=False, all_columns=True)</code>","text":"<p>Class to retrieve and manipulate DI futures contract data.</p> <p>This class provides access to DI futures data for a specified trade date, and includes options to adjust expiration dates and apply filters based on LTN and NTN-F bond maturities.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar | None</code> <p>The trade date to retrieve the DI contract data. If None, an empty DataFrame is returned.</p> <code>None</code> <code>month_start</code> <code>bool</code> <p>If True, adjusts the expirations to the start of the month.</p> <code>False</code> <code>pre_filter</code> <code>bool</code> <p>If True, filters the DI contracts to match only expirations with existing prefixed TN bond maturities (LTN and NTN-F).</p> <code>False</code> <code>all_columns</code> <code>bool</code> <p>If True, returns all available columns in the DI dataset. If False, only the most common columns are returned.</p> <code>True</code> <p>Examples:</p> <p>To create a <code>DIFutures</code> instance and retrieve data:</p> <pre><code>&gt;&gt;&gt; dif = yd.DIFutures(date=\"16-10-2024\", month_start=True)\n&gt;&gt;&gt; df = dif.df  # Retrieve DI contract dataframe for the specified date\n&gt;&gt;&gt; df.iloc[:5, :5]  # Show the first five rows and columns\n   TradeDate ExpirationDate TickerSymbol  BDaysToExp  OpenContracts\n0 2024-10-16     2024-11-01       DI1X24          12        1744269\n1 2024-10-16     2024-12-01       DI1Z24          31        1429375\n2 2024-10-16     2025-01-01       DI1F25          52        5423969\n3 2024-10-16     2025-02-01       DI1G25          74         279491\n4 2024-10-16     2025-03-01       DI1H25          94         344056\n</code></pre> <p>You can also retrieve forward rates for the DI contracts:</p> <pre><code>&gt;&gt;&gt; dif.forwards.iloc[:5]  # Show the first five rows\n   TradeDate ExpirationDate  SettlementRate  ForwardRate\n0 2024-10-16     2024-11-01         0.10653      0.10653\n1 2024-10-16     2024-12-01          0.1091     0.110726\n2 2024-10-16     2025-01-01         0.11164       0.1154\n3 2024-10-16     2025-02-01         0.11362     0.118314\n4 2024-10-16     2025-03-01          0.1157      0.12343\n</code></pre> Note <p>The DI contract DataFrame is not loaded during initialization. It will be automatically loaded the first time the df() method is accessed.</p> Source code in <code>pyield/b3/di.py</code> <pre><code>def __init__(\n    self,\n    date: DateScalar | None = None,\n    month_start: bool = False,\n    pre_filter: bool = False,\n    all_columns: bool = True,\n):\n    \"\"\"\n    Initialize the DIFutures instance with the specified parameters.\n\n    Note:\n        The DI contract DataFrame is not loaded during initialization. It will be\n        automatically loaded the first time the df() method is accessed.\n    \"\"\"\n    self._df = pd.DataFrame()\n    self._dirty = True  # Attribute to track if the df needs updating\n\n    self.date = date\n    self.month_start = month_start\n    self.pre_filter = pre_filter\n    self.all_columns = all_columns\n</code></pre>"},{"location":"di/#pyield.b3.di.DIFutures.date","title":"<code>date</code>  <code>property</code> <code>writable</code>","text":"<p>The trade date to retrieve the DI contract data.</p> <p>This property can be both read and set. When setting a value, it automatically converts the input date format to a <code>pd.Timestamp</code>.</p> <p>Returns:</p> Type Description <code>Timestamp</code> <p>pd.Timestamp: The trade date set for this instance.</p>"},{"location":"di/#pyield.b3.di.DIFutures.df","title":"<code>df</code>  <code>property</code>","text":"<p>Returns a copy of the DI contract DataFrame for the initialized trade date.</p> <p>If the internal state is marked as 'dirty', the DataFrame will be (re)loaded before returning, ensuring that the returned data reflects the latest attribute values.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The DI contract data.</p>"},{"location":"di/#pyield.b3.di.DIFutures.forwards","title":"<code>forwards</code>  <code>property</code>","text":"<p>Calculate the DI forward rates for the initialized trade date.</p> <p>This property returns a DataFrame with both the SettlementRate and the calculated ForwardRate for DI contracts, based on the instance's trade date and applied filters.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the following columns: - ExpirationDate: The expiration dates of the DI contracts. - SettlementRate: The zero rate (interest rate) for each expiration. - ForwardRate: The fwd rate calculated between successive expirations.</p>"},{"location":"di/#pyield.b3.di.DIFutures.historical_dates","title":"<code>historical_dates = get_di_dataset().drop_duplicates(subset=['TradeDate'])['TradeDate'].sort_values(ascending=True).reset_index(drop=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>pd.Series: Sorted series of unique trade dates available in the DI dataset. It does not include the intraday date. It can be used to check for available historical data.</p>"},{"location":"di/#pyield.b3.di.DIFutures.month_start","title":"<code>month_start</code>  <code>property</code> <code>writable</code>","text":"<p>Adjusts the expiration dates to the start of the month.</p> <p>This property can be both read and set. When set to <code>True</code>, all expiration dates are adjusted to the first day of the month. For example, an expiration date of 02/01/2025 will be adjusted to 01/01/2025.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether expiration dates are adjusted to the start of the month.</p>"},{"location":"di/#pyield.b3.di.DIFutures.pre_filter","title":"<code>pre_filter</code>  <code>property</code> <code>writable</code>","text":"<p>Filters DI Futures to match prefixed TN bond maturities.</p> <p>This property can be both read and set. When set to <code>True</code>, only contracts that match the maturities of LTN and NTN-F bonds will be shown.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the contracts are filtered to match prefixed TN bond maturities from the ANBIMA dataset.</p>"},{"location":"di/#pyield.b3.di.DIFutures._update_df","title":"<code>_update_df()</code>","text":"<p>Retrieve DI contract DataFrame for the initialized trade date.</p> Source code in <code>pyield/b3/di.py</code> <pre><code>def _update_df(self) -&gt; pd.DataFrame:\n    \"\"\"Retrieve DI contract DataFrame for the initialized trade date.\"\"\"\n    if self._date is None:\n        logger.info(\"No date specified. Returning empty DataFrame.\")\n        return pd.DataFrame()\n    # Return an empty DataFrame if the trade date is a holiday\n    if not bday.is_business_day(self._date):\n        logger.warning(\"Specified date is not a business day.\")\n        logger.warning(\"Returning empty DataFrame.\")\n        return pd.DataFrame()\n\n    # Get historical data\n    df = get_di_dataset().query(\"TradeDate == @self._date\").reset_index(drop=True)\n\n    if df.empty:\n        logger.info(\"No historical data found. Trying real-time data.\")\n        df = b3.futures(contract_code=\"DI1\", date=self._date)\n\n    if df.empty:\n        logger.warning(\"No DI Futures data found for the specified date.\")\n        logger.warning(\"Returning empty DataFrame.\")\n        return pd.DataFrame()\n\n    if \"DaysToExpiration\" in df.columns:\n        df.drop(columns=[\"DaysToExpiration\"], inplace=True)\n\n    if self._pre_filter:\n        df_pre = (\n            get_anbima_dataset()\n            .query(\"BondType in ['LTN', 'NTN-F']\")\n            .query(\"ReferenceDate == @self._date\")[\n                [\"ReferenceDate\", \"MaturityDate\"]\n            ]\n            .drop_duplicates()\n            .reset_index(drop=True)\n        )\n        # Force the expiration date to be a business day as DI contracts\n        df_pre[\"MaturityDate\"] = bday.offset(df_pre[\"MaturityDate\"], 0)\n        df_pre = df_pre.rename(\n            columns={\n                \"ReferenceDate\": \"TradeDate\",\n                \"MaturityDate\": \"ExpirationDate\",\n            }\n        )\n\n        df = df.merge(df_pre, how=\"inner\")\n\n    if self._month_start:\n        df[\"ExpirationDate\"] = (\n            df[\"ExpirationDate\"].dt.to_period(\"M\").dt.to_timestamp()\n        )\n\n    if not self._all_columns:\n        cols = [\n            \"TradeDate\",\n            \"TickerSymbol\",\n            \"ExpirationDate\",\n            \"BDaysToExp\",\n            \"OpenContracts\",\n            \"TradeVolume\",\n            \"DV01\",\n            \"OpenRate\",\n            \"MinRate\",\n            \"MaxRate\",\n            \"CloseRate\",\n            \"SettlementRate\",\n            \"LastRate\",\n            \"SettlementPrice\",\n            \"LastPrice\",\n        ]\n        selected_cols = [col for col in cols if col in df.columns]\n        df = df[selected_cols].copy()\n\n    return df.sort_values(by=[\"TradeDate\", \"ExpirationDate\"]).reset_index(drop=True)\n</code></pre>"},{"location":"di/#pyield.b3.di.DIFutures.interpolate_rates","title":"<code>interpolate_rates(dates, expirations, extrapolate=True)</code>  <code>staticmethod</code>","text":"<p>Interpolates DI rates for specified trade dates and maturities. The method is recomended to be used in datasets calculations with multiple dates.</p> <p>This method calculates interpolated DI rates for a given set of trade dates and maturities using a flat-forward interpolation method. If no DI rates are available for a reference date, the interpolated rate is set to NaN.</p> <p>If dates is provided as a scalar and expirations as an array, the method assumes the scalar value is the same for all maturities. The same logic applies when the maturities are scalar and the trade dates are an array.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>DateScalar | DateArray</code> <p>The trade dates for the rates.</p> required <code>expirations</code> <code>DateScalar | DateArray</code> <p>The expirations corresponding to the trade dates.</p> required <code>extrapolate</code> <code>bool</code> <p>Whether to allow extrapolation beyond known DI rates.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the interpolated DI rates.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dates</code> and <code>maturities</code> have different lengths.</p> Source code in <code>pyield/b3/di.py</code> <pre><code>@staticmethod\ndef interpolate_rates(\n    dates: DateScalar | DateArray,\n    expirations: DateScalar | DateArray,\n    extrapolate: bool = True,\n) -&gt; pd.Series:\n    \"\"\"\n    Interpolates DI rates for specified trade dates and maturities. The method\n    is recomended to be used in datasets calculations with multiple dates.\n\n    This method calculates interpolated DI rates for a given set of trade\n    dates and maturities using a flat-forward interpolation method. If no DI\n    rates are available for a reference date, the interpolated rate is set to NaN.\n\n    If dates is provided as a scalar and expirations as an array, the\n    method assumes the scalar value is the same for all maturities. The same logic\n    applies when the maturities are scalar and the trade dates are an array.\n\n    Args:\n        dates (DateScalar | DateArray): The trade dates for the rates.\n        expirations (DateScalar | DateArray): The expirations corresponding to the\n            trade dates.\n        extrapolate (bool): Whether to allow extrapolation beyond known DI rates.\n\n    Returns:\n        pd.Series: A Series containing the interpolated DI rates.\n\n    Raises:\n        ValueError: If `dates` and `maturities` have different lengths.\n    \"\"\"\n    # Convert input dates to a consistent format\n    dates = dc.convert_input_dates(dates)\n    expirations = dc.convert_input_dates(expirations)\n\n    # Ensure the lengths of input arrays are consistent\n    match (dates, expirations):\n        case pd.Timestamp(), pd.Series():\n            dfi = pd.DataFrame({\"mat\": expirations})\n            dfi[\"tdate\"] = dates\n\n        case pd.Series(), pd.Timestamp():\n            dfi = pd.DataFrame({\"tdate\": dates})\n            dfi[\"mat\"] = expirations\n\n        case pd.Series(), pd.Series():\n            if len(dates) != len(expirations):\n                raise ValueError(\"Args. should have the same length.\")\n            dfi = pd.DataFrame({\"tdate\": dates, \"mat\": expirations})\n\n        case pd.Timestamp(), pd.Timestamp():\n            dfi = pd.DataFrame({\"tdate\": [dates], \"mat\": [expirations]})\n\n    # Compute business days between reference dates and maturities\n    dfi[\"bdays\"] = bday.count(dfi[\"tdate\"], dfi[\"mat\"])\n\n    # Initialize the interpolated rate column with NaN\n    dfi[\"irate\"] = pd.NA\n    dfi[\"irate\"] = dfi[\"irate\"].astype(\"Float64\")\n\n    # Load DI rates dataset filtered by the provided reference dates\n    dfr = (\n        get_di_dataset()\n        .query(\"TradeDate in @dfi['tdate'].unique()\")\n        .reset_index(drop=True)\n    )\n\n    # Return an empty DataFrame if no rates are found\n    if dfr.empty:\n        return pd.Series()\n\n    # Iterate over each unique reference date\n    for date in dfi[\"tdate\"].unique():\n        # Filter DI rates for the current reference date\n        dfr_subset = dfr.query(\"TradeDate == @date\").reset_index(drop=True)\n\n        # Skip processing if no rates are available for the current date\n        if dfr_subset.empty:\n            continue\n\n        # Initialize the interpolator with known rates and business days\n        interp = interpolator.Interpolator(\n            method=\"flat_forward\",\n            known_bdays=dfr_subset[\"BDaysToExp\"],\n            known_rates=dfr_subset[\"SettlementRate\"],\n            extrapolate=extrapolate,\n        )\n\n        # Apply interpolation to rows matching the current reference date\n        mask: pd.Series = dfi[\"tdate\"] == date\n        dfi.loc[mask, \"irate\"] = dfi.loc[mask, \"bdays\"].apply(interp)\n\n    # Return the Series with interpolated rates\n    s_irates = dfi[\"irate\"]\n    s_irates.name = \"InterpolatedRates\"\n    return s_irates\n</code></pre>"},{"location":"di/#pyield.b3.di.DIFutures.rate","title":"<code>rate(expiration, interpolate=True, extrapolate=False)</code>","text":"<p>Retrieve the DI rate for a specified expiration date.</p> Source code in <code>pyield/b3/di.py</code> <pre><code>def rate(\n    self,\n    expiration: DateScalar,\n    interpolate: bool = True,\n    extrapolate: bool = False,\n) -&gt; float:\n    \"\"\"Retrieve the DI rate for a specified expiration date.\"\"\"\n    expiration = dc.convert_input_dates(expiration)\n\n    if self._month_start:\n        # Force the expiration date to be the start of the month\n        expiration = expiration.to_period(\"M\").to_timestamp()\n    else:\n        # Force the expiration date to be a business day\n        expiration = bday.offset(expiration, 0)\n\n    if not interpolate and extrapolate:\n        raise ValueError(\"Extrapolation is not allowed without interpolation.\")\n    # Get the DI contract DataFrame\n    df = self.df\n\n    if df.empty:\n        return float(\"NaN\")\n\n    df_exp = df.query(\"ExpirationDate == @expiration\")\n\n    if df_exp.empty and not interpolate:\n        return float(\"NaN\")\n\n    if expiration in df_exp[\"ExpirationDate\"].values:\n        return float(df_exp[\"SettlementRate\"].iat[0])\n\n    if not interpolate:\n        return float(\"NaN\")\n\n    ff_interp = interpolator.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=df[\"BDaysToExp\"],\n        known_rates=df[\"SettlementRate\"],\n        extrapolate=extrapolate,\n    )\n    bd = bday.count(self._date, expiration)\n    return ff_interp(bd)\n</code></pre>"},{"location":"forwards/","title":"Forwards","text":""},{"location":"forwards/#pyield.forwards.forward_rates","title":"<code>forward_rates(business_days, zero_rates, groupby_dates=None)</code>","text":"<p>Calculates forward rates from zero rates.</p> <p>Parameters:</p> Name Type Description Default <code>business_days</code> <code>Series</code> <p>Number of business days for each zero rate.</p> required <code>zero_rates</code> <code>Series</code> <p>Zero rates corresponding to the business days.</p> required <code>groupby_dates</code> <code>Series | None</code> <p>Optional grouping criteria to segment calculations. If not provided, calculations will not be grouped.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series of calculated forward rates with the first rate set to the corresponding zero rate.</p> Source code in <code>pyield/forwards.py</code> <pre><code>def forward_rates(\n    business_days: pd.Series,\n    zero_rates: pd.Series,\n    groupby_dates: pd.Series | None = None,\n) -&gt; pd.Series:\n    \"\"\"Calculates forward rates from zero rates.\n\n    Args:\n        business_days (pd.Series): Number of business days for each zero rate.\n        zero_rates (pd.Series): Zero rates corresponding to the business days.\n        groupby_dates (pd.Series | None, optional): Optional grouping criteria to\n            segment calculations. If not provided, calculations will not be grouped.\n\n    Returns:\n        pd.Series: Series of calculated forward rates with the first rate set to the\n            corresponding zero rate.\n    \"\"\"\n    # Reset Series indexes to avoid misalignment issues during calculations\n    business_days = business_days.reset_index(drop=True)\n    zero_rates = zero_rates.reset_index(drop=True)\n    if groupby_dates is not None:\n        groupby_dates = groupby_dates.reset_index(drop=True)\n\n    # Create a DataFrame to work with the given series\n    df = pd.DataFrame({\"bd\": business_days, \"zero_rate\": zero_rates})\n\n    # If no groupby_dates is provided, create a dummy column to group the DataFrame\n    if groupby_dates is not None:\n        df[\"groupby_date\"] = groupby_dates\n    else:\n        df[\"groupby_date\"] = 0  # Dummy value to group the DataFrame\n\n    # Sort by the groupby_dates and bd columns to ensure proper chronological order\n    df.sort_values(by=[\"groupby_date\", \"bd\"], inplace=True)\n\n    # Calculate the next zero rate and business day for each group\n    df[\"next_rate\"] = df.groupby(\"groupby_date\")[\"zero_rate\"].shift(1)\n    df[\"next_bday\"] = df.groupby(\"groupby_date\")[\"bd\"].shift(1)\n\n    # Calculate the forward rates using the formula\n    factor1 = (1 + df[\"next_rate\"]) ** (df[\"next_bday\"] / 252)\n    factor2 = (1 + df[\"zero_rate\"]) ** (df[\"bd\"] / 252)\n    factor3 = 252 / (df[\"next_bday\"] - df[\"bd\"])\n    df[\"fwd_rate\"] = (factor1 / factor2) ** factor3 - 1\n\n    # Identifify the first index of each group of dates\n    first_indices = df.groupby(\"groupby_date\").head(1).index\n    # Set the first forward rate of each group to the zero rate\n    df.loc[first_indices, \"fwd_rate\"] = df.loc[first_indices, \"zero_rate\"]\n\n    df[\"fwd_rate\"] = df[\"fwd_rate\"].astype(\"Float64\")\n\n    return df[\"fwd_rate\"]\n</code></pre>"},{"location":"futures/","title":"Futures Data","text":""},{"location":"futures/#pyield.futures.futures","title":"<code>futures(contract_code, date)</code>","text":"<p>Fetches data for a specified futures contract based on type and reference date.</p> <p>Parameters:</p> Name Type Description Default <code>contract_code</code> <code>str</code> <p>The B3 futures contract code identifying the derivative. Supported contract codes are: - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3. - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3. - \"FRC\": Forward Rate Agreement (FRA) from B3. - \"DAP\": DI x IPCA Spread Futures. - \"DOL\": U.S. Dollar Futures from B3. - \"WDO\": Mini U.S. Dollar Futures from B3. - \"IND\": Ibovespa Futures from B3. - \"WIN\": Mini Ibovespa Futures from B3.</p> required <code>date</code> <code>DateScalar</code> <p>The date for which to fetch the data. If the reference date is a string, it should be in 'DD-MM-YYYY' format.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the fetched data for the specified futures contract.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the futures contract code is not recognized or supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n    TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n0  2024-05-31       DI1M24  ...      0.10404    0.10404\n1  2024-05-31       DI1N24  ...       0.1039    0.10386\n2  2024-05-31       DI1Q24  ...      0.10374    0.10374\n3  2024-05-31       DI1U24  ...      0.10365    0.10355\n...\n&gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n    TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n0  2024-05-31       DAPM24  ...         &lt;NA&gt;       &lt;NA&gt;\n1  2024-05-31       DAPN24  ...         &lt;NA&gt;       &lt;NA&gt;\n2  2024-05-31       DAPQ24  ...         &lt;NA&gt;     0.0885\n3  2024-05-31       DAPU24  ...         &lt;NA&gt;     0.0865\n...\n</code></pre> Source code in <code>pyield/b3/futures/__init__.py</code> <pre><code>def futures(\n    contract_code: ContractOptions | str,\n    date: DateScalar,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches data for a specified futures contract based on type and reference date.\n\n    Args:\n        contract_code (str): The B3 futures contract code identifying the derivative.\n            Supported contract codes are:\n            - \"DI1\": One-day Interbank Deposit Futures (Futuro de DI) from B3.\n            - \"DDI\": DI x U.S. Dollar Spread Futures (Futuro de Cupom Cambial) from B3.\n            - \"FRC\": Forward Rate Agreement (FRA) from B3.\n            - \"DAP\": DI x IPCA Spread Futures.\n            - \"DOL\": U.S. Dollar Futures from B3.\n            - \"WDO\": Mini U.S. Dollar Futures from B3.\n            - \"IND\": Ibovespa Futures from B3.\n            - \"WIN\": Mini Ibovespa Futures from B3.\n        date (DateScalar): The date for which to fetch the data.\n            If the reference date is a string, it should be in 'DD-MM-YYYY' format.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the fetched data for the specified futures\n            contract.\n\n    Raises:\n        ValueError: If the futures contract code is not recognized or supported.\n\n    Examples:\n        &gt;&gt;&gt; futures(\"DI1\", \"31-05-2024\")\n            TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n        0  2024-05-31       DI1M24  ...      0.10404    0.10404\n        1  2024-05-31       DI1N24  ...       0.1039    0.10386\n        2  2024-05-31       DI1Q24  ...      0.10374    0.10374\n        3  2024-05-31       DI1U24  ...      0.10365    0.10355\n        ...\n        &gt;&gt;&gt; futures(\"DAP\", \"31-05-2024\")\n            TradeDate TickerSymbol  ... CloseBidRate  CloseRate\n        0  2024-05-31       DAPM24  ...         &lt;NA&gt;       &lt;NA&gt;\n        1  2024-05-31       DAPN24  ...         &lt;NA&gt;       &lt;NA&gt;\n        2  2024-05-31       DAPQ24  ...         &lt;NA&gt;     0.0885\n        3  2024-05-31       DAPU24  ...         &lt;NA&gt;     0.0865\n        ...\n    \"\"\"\n    selected_contract = str(contract_code).upper()\n    converted_date = dc.convert_input_dates(date)\n\n    # First, try to fetch historical data for the specified date\n    df = fetch_historical_df(selected_contract, converted_date)\n\n    bz_today = dt.datetime.now(TIMEZONE_BZ).date()\n    # If there is no historical data available, try to fetch intraday data\n    if converted_date.date() == bz_today and df.empty:\n        df = fetch_intraday_df(selected_contract)\n\n    return df\n</code></pre>"},{"location":"ibge/","title":"IBGE Data","text":""},{"location":"ibge/#pyield.ibge.ipca_indexes","title":"<code>ipca_indexes(start, end)</code>","text":"<p>Retrieves the IPCA index values for a specified date range.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]</p> <p>Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date of the date range</p> required <code>end</code> <code>DateScalar</code> <p>The end date of the date range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ibge\n&gt;&gt;&gt; # Get the IPCA indexes for the first quarter of 2024\n&gt;&gt;&gt; df = ibge.ipca_indexes(\"01-01-2024\", \"31-03-2024\")\n</code></pre> Source code in <code>pyield/ibge/ipca.py</code> <pre><code>def ipca_indexes(start: DateScalar, end: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves the IPCA index values for a specified date range.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/2266?localidades=N1[all]\n\n    Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/2266?localidades=N1[all]\n\n    Args:\n        start (DateScalar): The start date of the date range\n        end (DateScalar): The end date of the date range\n\n    Returns:\n        pd.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ibge\n        &gt;&gt;&gt; # Get the IPCA indexes for the first quarter of 2024\n        &gt;&gt;&gt; df = ibge.ipca_indexes(\"01-01-2024\", \"31-03-2024\")\n    \"\"\"\n    start = convert_input_dates(start)\n    end = convert_input_dates(end)\n\n    start_date = start.strftime(\"%Y%m\")\n    end_date = end.strftime(\"%Y%m\")\n    api_url = f\"{IPCA_URL}{start_date}-{end_date}/variaveis/2266?localidades=N1[all]\"\n    data_dict = _fetch_series_data(api_url)\n\n    return _process_ipca_dataframe(data_dict)\n</code></pre>"},{"location":"ibge/#pyield.ibge.ipca_last_indexes","title":"<code>ipca_last_indexes(num_months=1)</code>","text":"<p>Retrieves the last IPCA index values for a specified number of months.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]</p> <p>Example: For the last 2 months, the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>Number of months to retrieve. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If num_months is 0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ibge\n&gt;&gt;&gt; # Get the last month's IPCA index\n&gt;&gt;&gt; df = ibge.ipca_last_indexes(1)\n&gt;&gt;&gt; # Get the last 3 months' IPCA indexes\n&gt;&gt;&gt; df = ibge.ipca_last_indexes(3)\n</code></pre> Source code in <code>pyield/ibge/ipca.py</code> <pre><code>def ipca_last_indexes(num_months: int = 1) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves the last IPCA index values for a specified number of months.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/2266?localidades=N1[all]\n\n    Example: For the last 2 months, the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/2266?localidades=N1[all]\n\n    Args:\n        num_months (int, optional): Number of months to retrieve. Defaults to 1.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Raises:\n        ValueError: If num_months is 0\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ibge\n        &gt;&gt;&gt; # Get the last month's IPCA index\n        &gt;&gt;&gt; df = ibge.ipca_last_indexes(1)\n        &gt;&gt;&gt; # Get the last 3 months' IPCA indexes\n        &gt;&gt;&gt; df = ibge.ipca_last_indexes(3)\n    \"\"\"\n    num_months = abs(num_months)\n    if num_months == 0:\n        raise ValueError(\"The number of months must be greater than 0.\")\n\n    api_url = f\"{IPCA_URL}-{num_months}/variaveis/2266?localidades=N1[all]\"\n    data_dict = _fetch_series_data(api_url)\n\n    return _process_ipca_dataframe(data_dict)\n</code></pre>"},{"location":"ibge/#pyield.ibge.ipca_last_rates","title":"<code>ipca_last_rates(num_months=1)</code>","text":"<p>Retrieves the last IPCA monthly rates for a specified number of months.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]</p> <p>Example: For the last 2 months, the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>num_months</code> <code>int</code> <p>Number of months to retrieve. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns 'Period' and 'Value'</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If num_months is 0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ibge\n&gt;&gt;&gt; # Get the last month's IPCA rate\n&gt;&gt;&gt; df = ibge.ipca_last_rates(1)\n&gt;&gt;&gt; # Get the last 3 months' IPCA rates\n&gt;&gt;&gt; df = ibge.ipca_last_rates(3)\n</code></pre> Source code in <code>pyield/ibge/ipca.py</code> <pre><code>def ipca_last_rates(num_months: int = 1) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves the last IPCA monthly rates for a specified number of months.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-N/variaveis/63?localidades=N1[all]\n\n    Example: For the last 2 months, the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/-2/variaveis/63?localidades=N1[all]\n\n    Args:\n        num_months (int, optional): Number of months to retrieve. Defaults to 1.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns 'Period' and 'Value'\n\n    Raises:\n        ValueError: If num_months is 0\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ibge\n        &gt;&gt;&gt; # Get the last month's IPCA rate\n        &gt;&gt;&gt; df = ibge.ipca_last_rates(1)\n        &gt;&gt;&gt; # Get the last 3 months' IPCA rates\n        &gt;&gt;&gt; df = ibge.ipca_last_rates(3)\n    \"\"\"\n    num_months = abs(num_months)\n    if num_months == 0:\n        raise ValueError(\"The number of months must be greater than 0.\")\n\n    api_url = f\"{IPCA_URL}-{num_months}/variaveis/63?localidades=N1[all]\"\n    data_dict = _fetch_series_data(api_url)\n\n    return _process_ipca_dataframe(data_dict, is_in_pct=True)\n</code></pre>"},{"location":"ibge/#pyield.ibge.ipca_rates","title":"<code>ipca_rates(start, end)</code>","text":"<p>Retrieves the IPCA monthly rates for a specified date range.</p> <p>Makes an API call to the IBGE's data portal using the format: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]</p> <p>Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be: https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date of the date range</p> required <code>end</code> <code>DateScalar</code> <p>The end date of the date range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns 'Period' and 'Rate'</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import ibge\n&gt;&gt;&gt; # Get the IPCA rates for the first quarter of 2024\n&gt;&gt;&gt; df = ibge.ipca_rates(\"01-01-2024\", \"31-03-2024\")\n</code></pre> Source code in <code>pyield/ibge/ipca.py</code> <pre><code>def ipca_rates(start: DateScalar, end: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves the IPCA monthly rates for a specified date range.\n\n    Makes an API call to the IBGE's data portal using the format:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/YYYYMM-YYYYMM/variaveis/63?localidades=N1[all]\n\n    Example: For the date range \"01-01-2024\" to \"31-03-2024\", the API URL will be:\n    https://servicodados.ibge.gov.br/api/v3/agregados/6691/periodos/202401-202403/variaveis/63?localidades=N1[all]\n\n    Args:\n        start (DateScalar): The start date of the date range\n        end (DateScalar): The end date of the date range\n\n    Returns:\n        pd.DataFrame: DataFrame with columns 'Period' and 'Rate'\n\n    Examples:\n        &gt;&gt;&gt; from pyield import ibge\n        &gt;&gt;&gt; # Get the IPCA rates for the first quarter of 2024\n        &gt;&gt;&gt; df = ibge.ipca_rates(\"01-01-2024\", \"31-03-2024\")\n    \"\"\"\n    start = convert_input_dates(start)\n    end = convert_input_dates(end)\n\n    start_date = start.strftime(\"%Y%m\")\n    end_date = end.strftime(\"%Y%m\")\n    api_url = f\"{IPCA_URL}{start_date}-{end_date}/variaveis/63?localidades=N1[all]\"\n    data_dict = _fetch_series_data(api_url)\n\n    return _process_ipca_dataframe(data_dict, is_in_pct=True)\n</code></pre>"},{"location":"interpolator/","title":"Interpolator","text":""},{"location":"interpolator/#pyield.interpolator.Interpolator","title":"<code>Interpolator(method, known_bdays, known_rates, extrapolate=False)</code>","text":"<p>Interpolator class for interest rate interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['flat_forward', 'linear']</code> <p>The interpolation method to use.</p> required <code>known_bdays</code> <code>Series | list[int]</code> <p>The known business days sequence.</p> required <code>known_rates</code> <code>Series | list[float]</code> <p>The known interest rates sequence.</p> required <code>extrapolate</code> <code>bool</code> <p>If True, extrapolates beyond known business days using the last available rate. Defaults to False, returning NaN for out-of-range values.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If known_bdays and known_rates do not have the same length.</p> <code>ValueError</code> <p>If the interpolation method is not recognized</p> Note <ul> <li>This class uses a 252 business days per year convention.</li> <li>Instances of this class are immutable. To modify the interpolation   settings, create a new instance.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyield import Interpolator\n&gt;&gt;&gt; known_bdays = [30, 60, 90]\n&gt;&gt;&gt; known_rates = [0.045, 0.05, 0.055]\n</code></pre> <p>Linear interpolation example:</p> <pre><code>&gt;&gt;&gt; lin_interp = Interpolator(\"linear\", known_bdays, known_rates)\n&gt;&gt;&gt; lin_interp(45)\n0.0475\n</code></pre> <p>Flat forward interpolation example:</p> <pre><code>&gt;&gt;&gt; ffo_interp = Interpolator(\"flat_forward\", known_bdays, known_rates)\n&gt;&gt;&gt; ffo_interp(45)\n0.04833068080970859\n</code></pre> Source code in <code>pyield/interpolator.py</code> <pre><code>def __init__(\n    self,\n    method: Literal[\"flat_forward\", \"linear\"],\n    known_bdays: pd.Series | np.ndarray | tuple[int] | list[int],\n    known_rates: pd.Series | np.ndarray | tuple[float] | list[float],\n    extrapolate: bool = False,\n):\n    df = (\n        pd.DataFrame({\"bday\": known_bdays, \"rate\": known_rates})\n        .dropna()\n        .drop_duplicates(subset=\"bday\")\n        .sort_values(\"bday\", ignore_index=True)\n    )\n    self._df = df\n    self._method = str(method)\n    self._known_bdays = tuple(df[\"bday\"])\n    self._known_rates = tuple(df[\"rate\"])\n    self._extrapolate = bool(extrapolate)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__call__","title":"<code>__call__(bday)</code>","text":"<p>Allows the instance to be called as a function to perform interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interest rate interpolated by the specified method for the given number of business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __call__(self, bday: int) -&gt; float:\n    \"\"\"\n    Allows the instance to be called as a function to perform interpolation.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for the given\n            number of business days.\n    \"\"\"\n    return self.interpolate(bday)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of known business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the number of known business days.\"\"\"\n    return len(self._df)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.__repr__","title":"<code>__repr__()</code>","text":"<p>Textual representation, used in terminal or scripts.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Textual representation, used in terminal or scripts.\"\"\"\n\n    return repr(self._df)\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator._flat_forward","title":"<code>_flat_forward(bday, i)</code>","text":"<p>Performs the interest rate interpolation using the flat forward method.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def _flat_forward(self, bday: int, i: int) -&gt; float:\n    \"\"\"Performs the interest rate interpolation using the flat forward method.\"\"\"\n    prev_rate = self._known_rates[i - 1]\n    prev_bday = self._known_bdays[i - 1]\n    next_rate = self._known_rates[i]\n    next_bday = self._known_bdays[i]\n\n    # Perform flat forward interpolation\n    a = (1 + prev_rate) ** (prev_bday / 252)\n    b = (1 + next_rate) ** (next_bday / 252)\n    c = (bday - prev_bday) / (next_bday - prev_bday)\n    return (a * (b / a) ** c) ** (252 / bday) - 1\n</code></pre>"},{"location":"interpolator/#pyield.interpolator.Interpolator.interpolate","title":"<code>interpolate(bday)</code>","text":"<p>Finds the appropriate interpolation point and returns the interest rate interpolated by the specified method from that point.</p> <p>Parameters:</p> Name Type Description Default <code>bday</code> <code>int</code> <p>Number of business days for which the interest rate is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The interest rate interpolated by the specified method for the given number of business days.</p> Source code in <code>pyield/interpolator.py</code> <pre><code>def interpolate(self, bday: int) -&gt; float:\n    \"\"\"\n    Finds the appropriate interpolation point and returns the interest rate\n    interpolated by the specified method from that point.\n\n    Args:\n        bday (int): Number of business days for which the interest rate is to be\n            calculated.\n\n    Returns:\n        float: The interest rate interpolated by the specified method for the given\n            number of business days.\n    \"\"\"\n    # Create local references to facilitate code readability\n    known_bdays = self._known_bdays\n    known_rates = self._known_rates\n    extrapolate = self._extrapolate\n    method = self._method\n\n    # Lower bound extrapolation is always the first known rate\n    if bday &lt; known_bdays[0]:\n        return known_rates[0]\n    # Upper bound extrapolation depends on the extrapolate flag\n    elif bday &gt; known_bdays[-1]:\n        return known_rates[-1] if extrapolate else float(\"NaN\")\n\n    # Early return for linear interpolation\n    if method == \"linear\":\n        return float(np.interp(bday, known_bdays, known_rates))\n\n    # Find i such that known_bdays[i-1] &lt; bday &lt; known_bdays[i]\n    idx = bisect.bisect_left(known_bdays, bday)\n\n    # Check if the interpolation point is known\n    if idx &lt; len(known_bdays) and known_bdays[idx] == bday:\n        return known_rates[idx]\n\n    # Perform flat forward interpolation\n    return self._flat_forward(bday, idx)\n</code></pre>"},{"location":"lft/","title":"LFT","text":""},{"location":"lft/#pyield.tpf.lft.data","title":"<code>data(date)</code>","text":"<p>Fetch the LFT indicative rates for the given reference date from ANBIMA.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the following columns: - ReferenceDate: The reference date for the data. - BondType: The type of bond. - MaturityDate: The maturity date of the LFT bond. - IndicativeRate: The Anbima indicative rate for the LFT bond. - Price: The price of the LFT bond.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.lft.data(\"23-08-2024\")\n   ReferenceDate BondType MaturityDate  IndicativeRate         Price\n0     2024-08-23      LFT   2024-09-01        0.000272  15252.158852\n1     2024-08-23      LFT   2025-03-01       -0.000418  15255.605864\n2     2024-08-23      LFT   2025-09-01        -0.00023  15255.819395\n3     2024-08-23      LFT   2026-03-01        0.000075  15250.526859\n4     2024-08-23      LFT   2026-09-01        0.000114  15248.757596\n5     2024-08-23      LFT   2027-03-01        0.000669  15226.824838\n6     2024-08-23      LFT   2027-09-01        0.000948  15208.842417\n7     2024-08-23      LFT   2028-03-01        0.001172  15189.853347\n8     2024-08-23      LFT   2028-09-01        0.001328  15171.352348\n9     2024-08-23      LFT   2029-03-01        0.001491  15150.700781\n10    2024-08-23      LFT   2029-09-01        0.001587  15131.894737\n11    2024-08-23      LFT   2030-03-01        0.001591  15119.952213\n12    2024-08-23      LFT   2030-06-01        0.001641  15109.717943\n13    2024-08-23      LFT   2030-09-01        0.001687  15099.285393\n</code></pre> Source code in <code>pyield/tpf/lft.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the LFT indicative rates for the given reference date from ANBIMA.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the following columns:\n            - ReferenceDate: The reference date for the data.\n            - BondType: The type of bond.\n            - MaturityDate: The maturity date of the LFT bond.\n            - IndicativeRate: The Anbima indicative rate for the LFT bond.\n            - Price: The price of the LFT bond.\n\n    Examples:\n\n        &gt;&gt;&gt; yd.lft.data(\"23-08-2024\")\n           ReferenceDate BondType MaturityDate  IndicativeRate         Price\n        0     2024-08-23      LFT   2024-09-01        0.000272  15252.158852\n        1     2024-08-23      LFT   2025-03-01       -0.000418  15255.605864\n        2     2024-08-23      LFT   2025-09-01        -0.00023  15255.819395\n        3     2024-08-23      LFT   2026-03-01        0.000075  15250.526859\n        4     2024-08-23      LFT   2026-09-01        0.000114  15248.757596\n        5     2024-08-23      LFT   2027-03-01        0.000669  15226.824838\n        6     2024-08-23      LFT   2027-09-01        0.000948  15208.842417\n        7     2024-08-23      LFT   2028-03-01        0.001172  15189.853347\n        8     2024-08-23      LFT   2028-09-01        0.001328  15171.352348\n        9     2024-08-23      LFT   2029-03-01        0.001491  15150.700781\n        10    2024-08-23      LFT   2029-09-01        0.001587  15131.894737\n        11    2024-08-23      LFT   2030-03-01        0.001591  15119.952213\n        12    2024-08-23      LFT   2030-06-01        0.001641  15109.717943\n        13    2024-08-23      LFT   2030-09-01        0.001687  15099.285393\n    \"\"\"\n    return anbima.tpf_data(date, \"LFT\")\n</code></pre>"},{"location":"lft/#pyield.tpf.lft.premium","title":"<code>premium(lft_rate, selic_over)</code>","text":"<p>Calculate the premium of the LFT bond over the Selic rate (overnight). Obs: The Selic rate (overnight) is not the same as the Selic target rate</p> <p>Parameters:</p> Name Type Description Default <code>lft_rate</code> <code>float</code> <p>The LFT rate for the bond.</p> required <code>selic_over</code> <code>float</code> <p>The Selic overnight rate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LFT bond over the Selic rate.</p> <p>Examples:</p> <p>Calculate the premium of a LFT bond with a 0.02 yield rate over the Selic rate:</p> <pre><code>&gt;&gt;&gt; lft_rate = 0.1695 / 100  # 0.1695%\n&gt;&gt;&gt; selic_over = 10.40 / 100  # 10.40%\n&gt;&gt;&gt; yd.lft.premium(lft_rate, selic_over)\n1.017120519283759\n</code></pre> Source code in <code>pyield/tpf/lft.py</code> <pre><code>def premium(lft_rate: float, selic_over: float) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LFT bond over the Selic rate (overnight).\n    Obs: The Selic rate (overnight) is not the same as the Selic target rate\n\n    Args:\n        lft_rate (float): The LFT rate for the bond.\n        selic_over (float): The Selic overnight rate.\n\n    Returns:\n        float: The premium of the LFT bond over the Selic rate.\n\n    Examples:\n        Calculate the premium of a LFT bond with a 0.02 yield rate over the Selic rate:\n        &gt;&gt;&gt; lft_rate = 0.1695 / 100  # 0.1695%\n        &gt;&gt;&gt; selic_over = 10.40 / 100  # 10.40%\n        &gt;&gt;&gt; yd.lft.premium(lft_rate, selic_over)\n        1.017120519283759\n    \"\"\"\n    adjusted_lft_rate = (lft_rate + 1) * (selic_over + 1) - 1\n    f1 = (adjusted_lft_rate + 1) ** (1 / 252) - 1\n    f2 = (selic_over + 1) ** (1 / 252) - 1\n    return f1 / f2\n</code></pre>"},{"location":"lft/#pyield.tpf.lft.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the quotation of a LFT bond using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the bond.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The annualized yield rate of the bond</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The quotation of the bond.</p> <p>Examples:</p> <p>Calculate the quotation of a LFT bond with a 0.02 yield rate:</p> <pre><code>&gt;&gt;&gt; yd.lft.quotation(\n...     settlement=\"24-07-2024\",\n...     maturity=\"01-09-2030\",\n...     rate=0.001717,  # 0.1717%\n... )\n98.9645\n</code></pre> Source code in <code>pyield/tpf/lft.py</code> <pre><code>def quotation(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the quotation of a LFT bond using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date of the bond.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The annualized yield rate of the bond\n\n    Returns:\n        float: The quotation of the bond.\n\n    Examples:\n        Calculate the quotation of a LFT bond with a 0.02 yield rate:\n        &gt;&gt;&gt; yd.lft.quotation(\n        ...     settlement=\"24-07-2024\",\n        ...     maturity=\"01-09-2030\",\n        ...     rate=0.001717,  # 0.1717%\n        ... )\n        98.9645\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # The number of bdays between settlement (inclusive) and the maturity (exclusive)\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = tt.truncate(bdays / 252, 14)\n\n    discount_factor = 1 / (1 + rate) ** num_of_years\n\n    return tt.truncate(100 * discount_factor, 4)\n</code></pre>"},{"location":"ltn/","title":"LTN","text":""},{"location":"ltn/#pyield.tpf.ltn.data","title":"<code>data(date)</code>","text":"<p>Fetch the LTN Anbima indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ltn.data(\"23-08-2024\")\n   ReferenceDate BondType MaturityDate  IndicativeRate       Price\n0     2024-08-23      LTN   2024-10-01        0.104416  989.415342\n1     2024-08-23      LTN   2025-01-01        0.107171  964.293046\n2     2024-08-23      LTN   2025-04-01        0.110866  938.943013\n3     2024-08-23      LTN   2025-07-01        0.113032  913.849158\n4     2024-08-23      LTN   2025-10-01        0.114374  887.394285\n5     2024-08-23      LTN   2026-01-01        0.114654  863.026594\n6     2024-08-23      LTN   2026-04-01        0.114997  840.232741\n7     2024-08-23      LTN   2026-07-01        0.115265  818.020491\n8     2024-08-23      LTN   2026-10-01        0.115357  795.185488\n9     2024-08-23      LTN   2027-07-01        0.115335  733.981131\n10    2024-08-23      LTN   2028-01-01        0.115694  693.647778\n11    2024-08-23      LTN   2028-07-01        0.116417    655.6398\n12    2024-08-23      LTN   2030-01-01        0.117436  554.331151\n</code></pre> Source code in <code>pyield/tpf/ltn.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the LTN Anbima indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; yd.ltn.data(\"23-08-2024\")\n           ReferenceDate BondType MaturityDate  IndicativeRate       Price\n        0     2024-08-23      LTN   2024-10-01        0.104416  989.415342\n        1     2024-08-23      LTN   2025-01-01        0.107171  964.293046\n        2     2024-08-23      LTN   2025-04-01        0.110866  938.943013\n        3     2024-08-23      LTN   2025-07-01        0.113032  913.849158\n        4     2024-08-23      LTN   2025-10-01        0.114374  887.394285\n        5     2024-08-23      LTN   2026-01-01        0.114654  863.026594\n        6     2024-08-23      LTN   2026-04-01        0.114997  840.232741\n        7     2024-08-23      LTN   2026-07-01        0.115265  818.020491\n        8     2024-08-23      LTN   2026-10-01        0.115357  795.185488\n        9     2024-08-23      LTN   2027-07-01        0.115335  733.981131\n        10    2024-08-23      LTN   2028-01-01        0.115694  693.647778\n        11    2024-08-23      LTN   2028-07-01        0.116417    655.6398\n        12    2024-08-23      LTN   2030-01-01        0.117436  554.331151\n\n    \"\"\"\n    return anbima.tpf_data(date, \"LTN\")\n</code></pre>"},{"location":"ltn/#pyield.tpf.ltn.di_spreads","title":"<code>di_spreads(date)</code>","text":"<p>Calculates the DI spread for the LTN based on ANBIMA's indicative rates.</p> <p>This function fetches the indicative rates for the NTN-F bonds and the DI futures rates and calculates the spread between these rates in basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for the spread calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with the columns \"MaturityDate\" and \"DISpread\" (in bps).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ltn.di_spreads(\"22-08-2024\")\n   MaturityDate  DISpread\n0    2024-10-01     -3.06\n1    2025-01-01     -9.95\n2    2025-04-01     -8.28\n3    2025-07-01      -6.1\n4    2025-10-01     -2.57\n5    2026-01-01     -1.57\n6    2026-04-01     -0.86\n7    2026-07-01      2.83\n8    2026-10-01      4.17\n9    2027-07-01      3.72\n10   2028-01-01      6.19\n11   2028-07-01      8.68\n12   2030-01-01     14.96\n</code></pre> Source code in <code>pyield/tpf/ltn.py</code> <pre><code>def di_spreads(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the DI spread for the LTN based on ANBIMA's indicative rates.\n\n    This function fetches the indicative rates for the NTN-F bonds and the DI futures\n    rates and calculates the spread between these rates in basis points.\n\n    Parameters:\n        date (DateScalar, optional): The reference date for the\n            spread calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame with the columns \"MaturityDate\" and \"DISpread\" (in bps).\n\n    Examples:\n        &gt;&gt;&gt; yd.ltn.di_spreads(\"22-08-2024\")\n           MaturityDate  DISpread\n        0    2024-10-01     -3.06\n        1    2025-01-01     -9.95\n        2    2025-04-01     -8.28\n        3    2025-07-01      -6.1\n        4    2025-10-01     -2.57\n        5    2026-01-01     -1.57\n        6    2026-04-01     -0.86\n        7    2026-07-01      2.83\n        8    2026-10-01      4.17\n        9    2027-07-01      3.72\n        10   2028-01-01      6.19\n        11   2028-07-01      8.68\n        12   2030-01-01     14.96\n    \"\"\"\n    # Fetch DI Spreads for the reference date\n    df = tt.pre_spreads(date)\n    df.query(\"BondType == 'LTN'\", inplace=True)\n    df.sort_values([\"MaturityDate\"], ignore_index=True, inplace=True)\n    return df[[\"MaturityDate\", \"DISpread\"]]\n</code></pre>"},{"location":"ltn/#pyield.tpf.ltn.historical_premium","title":"<code>historical_premium(date, maturity)</code>","text":"<p>Calculate the premium of the LTN bond over the DI Future rate for a given date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date to fetch the rates.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the LTN bond.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LTN bond over the DI Future rate for the given date.    If the data is not available, returns NaN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ltn.historical_premium(\"22-08-2024\", \"01-01-2030\")\n1.0120718007994287\n</code></pre> Source code in <code>pyield/tpf/ltn.py</code> <pre><code>def historical_premium(\n    date: DateScalar,\n    maturity: DateScalar,\n) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LTN bond over the DI Future rate for a given date.\n\n    Args:\n        date (DateScalar): The reference date to fetch the rates.\n        maturity (DateScalar): The maturity date of the LTN bond.\n\n    Returns:\n        float: The premium of the LTN bond over the DI Future rate for the given date.\n               If the data is not available, returns NaN.\n\n    Examples:\n        &gt;&gt;&gt; yd.ltn.historical_premium(\"22-08-2024\", \"01-01-2030\")\n        1.0120718007994287\n\n    \"\"\"\n    # Convert input dates to a consistent format\n    date = dc.convert_input_dates(date)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Retrieve LTN rates for the reference date\n    df_anbima = data(date)\n    if df_anbima.empty:\n        return float(\"NaN\")\n\n    # Extract the LTN rate for the specified maturity date\n    ltn_rates = df_anbima.query(\"MaturityDate == @maturity\")[\"IndicativeRate\"]\n    if ltn_rates.empty:\n        return float(\"NaN\")\n    ltn_rate = float(ltn_rates.iloc[0])\n\n    # Retrieve DI rate for the reference date and maturity\n    dif = di.DIFutures(date=date)\n    di_rate = dif.rate(expiration=maturity, interpolate=True, extrapolate=False)\n    if pd.isnull(di_rate):  # Check if the DI rate is NaN\n        return float(\"NaN\")\n\n    # Calculate and return the premium using the extracted rates\n    return premium(ltn_rate, di_rate)\n</code></pre>"},{"location":"ltn/#pyield.tpf.ltn.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ltn.maturities(\"22-08-2024\")\n0    2024-10-01\n1    2025-01-01\n2    2025-04-01\n3    2025-07-01\n4    2025-10-01\n5    2026-01-01\n6    2026-04-01\n7    2026-07-01\n8    2026-10-01\n9    2027-07-01\n10   2028-01-01\n11   2028-07-01\n12   2030-01-01\ndtype: datetime64[ns]\n</code></pre> Source code in <code>pyield/tpf/ltn.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pd.Series:\n    \"\"\"\n    Fetch the bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series of bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; yd.ltn.maturities(\"22-08-2024\")\n        0    2024-10-01\n        1    2025-01-01\n        2    2025-04-01\n        3    2025-07-01\n        4    2025-10-01\n        5    2026-01-01\n        6    2026-04-01\n        7    2026-07-01\n        8    2026-10-01\n        9    2027-07-01\n        10   2028-01-01\n        11   2028-07-01\n        12   2030-01-01\n        dtype: datetime64[ns]\n\n    \"\"\"\n    df_rates = data(date)\n    s_maturities = df_rates[\"MaturityDate\"]\n    s_maturities.name = None\n    return s_maturities\n</code></pre>"},{"location":"ltn/#pyield.tpf.ltn.premium","title":"<code>premium(ltn_rate, di_rate)</code>","text":"<p>Calculate the premium of the LTN bond over the DI Future rate using provided rates.</p> <p>Parameters:</p> Name Type Description Default <code>ltn_rate</code> <code>float</code> <p>The annualized LTN rate.</p> required <code>di_rate</code> <code>float</code> <p>The annualized DI Future rate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the LTN bond over the DI Future rate.</p> <p>Examples:</p> <p>Reference date: 22-08-2024 LTN rate for 01-01-2030: 0.118746 DI (JAN30) Settlement rate: 0.11725</p> <pre><code>&gt;&gt;&gt; yd.ltn.premium(0.118746, 0.11725)\n1.0120718007994287\n</code></pre> Source code in <code>pyield/tpf/ltn.py</code> <pre><code>def premium(ltn_rate: float, di_rate: float) -&gt; float:\n    \"\"\"\n    Calculate the premium of the LTN bond over the DI Future rate using provided rates.\n\n    Args:\n        ltn_rate (float): The annualized LTN rate.\n        di_rate (float): The annualized DI Future rate.\n\n    Returns:\n        float: The premium of the LTN bond over the DI Future rate.\n\n    Examples:\n        Reference date: 22-08-2024\n        LTN rate for 01-01-2030: 0.118746\n        DI (JAN30) Settlement rate: 0.11725\n        &gt;&gt;&gt; yd.ltn.premium(0.118746, 0.11725)\n        1.0120718007994287\n    \"\"\"\n    # C\u00e1lculo das taxas di\u00e1rias\n    ltn_factor = (1 + ltn_rate) ** (1 / 252)\n    di_factor = (1 + di_rate) ** (1 / 252)\n\n    # Retorno do c\u00e1lculo do pr\u00eamio\n    return (ltn_factor - 1) / (di_factor - 1)\n</code></pre>"},{"location":"ltn/#pyield.tpf.ltn.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the LTN price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date in 'DD-MM-YYYY' format or a pandas Timestamp.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-F.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The LTN price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n535.279902\n</code></pre> Source code in <code>pyield/tpf/ltn.py</code> <pre><code>def price(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the LTN price using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date in 'DD-MM-YYYY' format\n            or a pandas Timestamp.\n        maturity (DateScalar): The maturity date in 'DD-MM-YYYY' format or\n            a pandas Timestamp.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-F.\n\n    Returns:\n        float: The LTN price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; yd.ltn.price(\"05-07-2024\", \"01-01-2030\", 0.12145)\n        535.279902\n    \"\"\"\n\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, maturity)\n\n    # Calculate the number of periods truncated as per Anbima rule\n    num_of_years = tt.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Truncate the price to 6 decimal places as per Anbima rules\n    return tt.truncate(FACE_VALUE / discount_factor, 6)\n</code></pre>"},{"location":"ntnb/","title":"NTN-B","text":""},{"location":"ntnb/#pyield.tpf.ntnb._generate_all_coupon_dates","title":"<code>_generate_all_coupon_dates(start, end)</code>","text":"<p>Generate a map of all possible coupon dates between the start and end dates. The dates are inclusive. Coupon payments are made on the 15th of February, May, August, and November (15-02, 15-05, 15-08, and 15-11 of each year).</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>DateScalar</code> <p>The start date.</p> required <code>end</code> <code>DateScalar</code> <p>The end date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series of coupon dates within the specified range.</p> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def _generate_all_coupon_dates(\n    start: DateScalar,\n    end: DateScalar,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate a map of all possible coupon dates between the start and end dates.\n    The dates are inclusive. Coupon payments are made on the 15th of February, May,\n    August, and November (15-02, 15-05, 15-08, and 15-11 of each year).\n\n    Args:\n        start (DateScalar): The start date.\n        end (DateScalar): The end date.\n\n    Returns:\n        pd.Series: Series of coupon dates within the specified range.\n    \"\"\"\n    # Validate and normalize dates\n    start = dc.convert_input_dates(start)\n    end = dc.convert_input_dates(end)\n\n    # Initialize the first coupon date based on the reference date\n    reference_year = start.year\n    first_coupon_date = pd.Timestamp(f\"{reference_year}-02-01\")\n\n    # Generate coupon dates\n    coupon_dates = pd.date_range(start=first_coupon_date, end=end, freq=\"3MS\")\n\n    # Offset dates by 14 in order to have day 15 of the month\n    coupon_dates += pd.Timedelta(days=14)\n\n    # First coupon date must be after the reference date, otherwise, it can lead to\n    # division by zero where BDays == 0 (bootstrap method for instance)\n    coupon_dates = coupon_dates[coupon_dates &gt; start]\n\n    return pd.Series(coupon_dates).reset_index(drop=True)\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.bei_rates","title":"<code>bei_rates(settlement, ntnb_maturities, ntnb_rates, nominal_maturities, nominal_rates)</code>","text":"<p>Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real interest rates. The BEI represents the inflation rate that equalizes the real and nominal yields. The calculation is based on the spot rates for NTN-B bonds.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>str or Timestamp</code> <p>The settlement date of the operation.</p> required <code>ntnb_maturities</code> <code>Series</code> <p>The maturity dates for the NTN-B bonds.</p> required <code>ntnb_rates</code> <code>Series</code> <p>The real interest rates (Yield to Maturity - YTM) corresponding to the given NTN-B maturities.</p> required <code>nominal_maturities</code> <code>Series</code> <p>The maturity dates to be used as reference for nominal reates.</p> required <code>nominal_rates</code> <code>Series</code> <p>The nominal interest rates (e.g. DI Futures or  zero prefixed bonds rates) used as reference for the calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the calculated breakeven inflation rates.</p> Returned columns <ul> <li>MaturityDate: The maturity date of the bonds.</li> <li>BDToMat: The number of business days from the settlement to the maturity.</li> <li>RIR: The calculated Real Interest Rates based on the spot rates.</li> <li>NIR: The Nominal Interest Rates interpolated for the maturity date.</li> <li>BEI: The calculated Breakeven Inflation Rates.</li> </ul> Notes <p>The BEI is calculated by comparing the nominal and real interest rates, indicating the market's inflation expectations over the period from the settlement date to the bond's maturity.</p> <p>Examples:</p> <p>Get the NTN-B rates for a specific reference date. These are YTM rates and the spot rates are calculated based on them</p> <pre><code>&gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n</code></pre> <p>Get the DI Futures settlement rates for the same reference date to be used as reference for the nominal rates:</p> <pre><code>&gt;&gt;&gt; di = yd.DIFutures(\"05-09-2024\")\n&gt;&gt;&gt; df_di = di.df\n</code></pre> <p>Calculate the BEI rates considering the settlement at the reference date:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.bei_rates(\n...     settlement=\"05-09-2024\",\n...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n...     nominal_maturities=df_di[\"ExpirationDate\"],\n...     nominal_rates=df_di[\"SettlementRate\"],\n... )\n   MaturityDate  BDToMat       RIR       NIR       BEI\n0    2025-05-15      171  0.061749  0.113836  0.049058\n1    2026-08-15      488  0.066133  0.117126   0.04783\n2    2027-05-15      673  0.063816  0.117169  0.050152\n3    2028-08-15      988  0.063635   0.11828  0.051376\n4    2029-05-15     1172  0.062532   0.11838  0.052561\n5    2030-08-15     1486  0.061809  0.118499   0.05339\n6    2032-08-15     1990  0.062135  0.118084  0.052676\n7    2033-05-15     2177  0.061897   0.11787   0.05271\n8    2035-05-15     2676  0.061711  0.117713  0.052747\n9    2040-08-15     3995  0.060468   0.11759  0.053865\n10   2045-05-15     5182    0.0625   0.11759   0.05185\n11   2050-08-15     6497  0.063016   0.11759  0.051339\n12   2055-05-15     7686  0.062252   0.11759  0.052095\n13   2060-08-15     9003  0.063001   0.11759  0.051354\n</code></pre> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def bei_rates(\n    settlement: DateScalar,\n    ntnb_maturities: pd.Series,\n    ntnb_rates: pd.Series,\n    nominal_maturities: pd.Series,\n    nominal_rates: pd.Series,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the Breakeven Inflation (BEI) for NTN-B bonds based on nominal and real\n    interest rates. The BEI represents the inflation rate that equalizes the real and\n    nominal yields. The calculation is based on the spot rates for NTN-B bonds.\n\n    Args:\n        settlement (str or pd.Timestamp): The settlement date of the operation.\n        ntnb_maturities (pd.Series): The maturity dates for the NTN-B bonds.\n        ntnb_rates (pd.Series): The real interest rates (Yield to Maturity - YTM)\n            corresponding to the given NTN-B maturities.\n        nominal_maturities (pd.Series): The maturity dates to be used as reference for\n            nominal reates.\n        nominal_rates (pd.Series): The nominal interest rates (e.g. DI Futures or\n             zero prefixed bonds rates) used as reference for the calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the calculated breakeven inflation rates.\n\n    Returned columns:\n        - MaturityDate: The maturity date of the bonds.\n        - BDToMat: The number of business days from the settlement to the maturity.\n        - RIR: The calculated Real Interest Rates based on the spot rates.\n        - NIR: The Nominal Interest Rates interpolated for the maturity date.\n        - BEI: The calculated Breakeven Inflation Rates.\n\n    Notes:\n        The BEI is calculated by comparing the nominal and real interest rates,\n        indicating the market's inflation expectations over the period from the\n        settlement date to the bond's maturity.\n\n    Examples:\n        Get the NTN-B rates for a specific reference date.\n        These are YTM rates and the spot rates are calculated based on them\n        &gt;&gt;&gt; df_ntnb = yd.ntnb.data(\"05-09-2024\")\n\n        Get the DI Futures settlement rates for the same reference date to be used as\n        reference for the nominal rates:\n        &gt;&gt;&gt; di = yd.DIFutures(\"05-09-2024\")\n        &gt;&gt;&gt; df_di = di.df\n\n        Calculate the BEI rates considering the settlement at the reference date:\n        &gt;&gt;&gt; yd.ntnb.bei_rates(\n        ...     settlement=\"05-09-2024\",\n        ...     ntnb_maturities=df_ntnb[\"MaturityDate\"],\n        ...     ntnb_rates=df_ntnb[\"IndicativeRate\"],\n        ...     nominal_maturities=df_di[\"ExpirationDate\"],\n        ...     nominal_rates=df_di[\"SettlementRate\"],\n        ... )\n           MaturityDate  BDToMat       RIR       NIR       BEI\n        0    2025-05-15      171  0.061749  0.113836  0.049058\n        1    2026-08-15      488  0.066133  0.117126   0.04783\n        2    2027-05-15      673  0.063816  0.117169  0.050152\n        3    2028-08-15      988  0.063635   0.11828  0.051376\n        4    2029-05-15     1172  0.062532   0.11838  0.052561\n        5    2030-08-15     1486  0.061809  0.118499   0.05339\n        6    2032-08-15     1990  0.062135  0.118084  0.052676\n        7    2033-05-15     2177  0.061897   0.11787   0.05271\n        8    2035-05-15     2676  0.061711  0.117713  0.052747\n        9    2040-08-15     3995  0.060468   0.11759  0.053865\n        10   2045-05-15     5182    0.0625   0.11759   0.05185\n        11   2050-08-15     6497  0.063016   0.11759  0.051339\n        12   2055-05-15     7686  0.062252   0.11759  0.052095\n        13   2060-08-15     9003  0.063001   0.11759  0.051354\n\n    \"\"\"\n    # Normalize input dates\n    settlement = dc.convert_input_dates(settlement)\n    ntnb_maturities = pd.to_datetime(ntnb_maturities, errors=\"coerce\", dayfirst=True)\n\n    # Calculate Real Interest Rate (RIR)\n    df = spot_rates(settlement, ntnb_maturities, ntnb_rates)\n    df[\"BDToMat\"] = bday.count(settlement, df[\"MaturityDate\"])\n    df = df.rename(columns={\"SpotRate\": \"RIR\"})\n\n    nir_interplator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, nominal_maturities),\n        known_rates=nominal_rates,\n        extrapolate=True,\n    )\n\n    df[\"NIR\"] = df[\"BDToMat\"].apply(nir_interplator).astype(\"Float64\")\n    # Calculate Breakeven Inflation Rate (BEI)\n    df[\"BEI\"] = ((df[\"NIR\"] + 1) / (df[\"RIR\"] + 1)) - 1\n\n    cols_reordered = [\n        \"MaturityDate\",\n        \"BDToMat\",\n        \"RIR\",\n        \"NIR\",\n        \"BEI\",\n    ]\n    return df[cols_reordered].copy()\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.cash_flows","title":"<code>cash_flows(settlement, maturity)</code>","text":"<p>Generate the cash flows for NTN-B bonds between the settlement and maturity dates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exclusive) to start generating the cash flows.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> Returned columns <ul> <li>PaymentDate: The payment date of the cash flow</li> <li>CashFlow: Cash flow value for the bond</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n  PaymentDate    CashFlow\n0  2024-05-15    2.956301\n1  2024-11-15    2.956301\n2  2025-05-15  102.956301\n</code></pre> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def cash_flows(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate the cash flows for NTN-B bonds between the settlement and maturity dates.\n\n    Args:\n        settlement (DateScalar): The settlement date (exclusive) to start generating\n            the cash flows.\n        maturity (DateScalar): The maturity date of the bond.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Returned columns:\n        - PaymentDate: The payment date of the cash flow\n        - CashFlow: Cash flow value for the bond\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.cash_flows(\"10-05-2024\", \"15-05-2025\")\n          PaymentDate    CashFlow\n        0  2024-05-15    2.956301\n        1  2024-11-15    2.956301\n        2  2025-05-15  102.956301\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Get the coupon dates between the settlement and maturity dates\n    p_dates = payment_dates(settlement, maturity)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cfs = np.where(p_dates == maturity, FINAL_PMT, COUPON_PMT).tolist()\n\n    # Return a dataframe with the payment dates and cash flows\n    return pd.DataFrame(data={\"PaymentDate\": p_dates, \"CashFlow\": cfs})\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.data","title":"<code>data(date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> Returned columns <ul> <li>MaturityDate: The maturity date of the bond.</li> <li>IndicativeRate: The indicative rate for the bond.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.data(\"23-08-2024\")\n   ReferenceDate BondType MaturityDate  IndicativeRate        Price\n0     2024-08-23    NTN-B   2025-05-15        0.063804  4377.008543\n1     2024-08-23    NTN-B   2026-08-15        0.065795  4278.316344\n2     2024-08-23    NTN-B   2027-05-15        0.063794   4350.54878\n3     2024-08-23    NTN-B   2028-08-15        0.063094  4281.186307\n4     2024-08-23    NTN-B   2029-05-15          0.0621  4358.101314\n5     2024-08-23    NTN-B   2030-08-15        0.060298  4324.468801\n6     2024-08-23    NTN-B   2032-08-15          0.0604  4320.153067\n7     2024-08-23    NTN-B   2033-05-15        0.060403  4384.189924\n8     2024-08-23    NTN-B   2035-05-15        0.060375  4386.002533\n9     2024-08-23    NTN-B   2040-08-15        0.059797  4345.119587\n10    2024-08-23    NTN-B   2045-05-15        0.060923  4358.235102\n11    2024-08-23    NTN-B   2050-08-15         0.06114  4279.434119\n12    2024-08-23    NTN-B   2055-05-15        0.060892  4355.145036\n13    2024-08-23    NTN-B   2060-08-15        0.061005  4282.308398\n</code></pre> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Returned columns:\n        - MaturityDate: The maturity date of the bond.\n        - IndicativeRate: The indicative rate for the bond.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.data(\"23-08-2024\")\n           ReferenceDate BondType MaturityDate  IndicativeRate        Price\n        0     2024-08-23    NTN-B   2025-05-15        0.063804  4377.008543\n        1     2024-08-23    NTN-B   2026-08-15        0.065795  4278.316344\n        2     2024-08-23    NTN-B   2027-05-15        0.063794   4350.54878\n        3     2024-08-23    NTN-B   2028-08-15        0.063094  4281.186307\n        4     2024-08-23    NTN-B   2029-05-15          0.0621  4358.101314\n        5     2024-08-23    NTN-B   2030-08-15        0.060298  4324.468801\n        6     2024-08-23    NTN-B   2032-08-15          0.0604  4320.153067\n        7     2024-08-23    NTN-B   2033-05-15        0.060403  4384.189924\n        8     2024-08-23    NTN-B   2035-05-15        0.060375  4386.002533\n        9     2024-08-23    NTN-B   2040-08-15        0.059797  4345.119587\n        10    2024-08-23    NTN-B   2045-05-15        0.060923  4358.235102\n        11    2024-08-23    NTN-B   2050-08-15         0.06114  4279.434119\n        12    2024-08-23    NTN-B   2055-05-15        0.060892  4355.145036\n        13    2024-08-23    NTN-B   2060-08-15        0.061005  4282.308398\n\n    \"\"\"\n    return anbima.tpf_data(date, \"NTN-B\")\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.maturities","title":"<code>maturities(date)</code>","text":"<p>Get the bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series containing the maturity dates for the NTN-B bonds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.maturities(\"16-08-2024\")\n0    2025-05-15\n1    2026-08-15\n2    2027-05-15\n3    2028-08-15\n4    2029-05-15\n5    2030-08-15\n6    2032-08-15\n7    2033-05-15\n8    2035-05-15\n9    2040-08-15\n10   2045-05-15\n11   2050-08-15\n12   2055-05-15\n13   2060-08-15\ndtype: datetime64[ns]\n</code></pre> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pd.Series:\n    \"\"\"\n    Get the bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: Series containing the maturity dates for the NTN-B bonds.\n\n    Examples:\n\n        &gt;&gt;&gt; yd.ntnb.maturities(\"16-08-2024\")\n        0    2025-05-15\n        1    2026-08-15\n        2    2027-05-15\n        3    2028-08-15\n        4    2029-05-15\n        5    2030-08-15\n        6    2032-08-15\n        7    2033-05-15\n        8    2035-05-15\n        9    2040-08-15\n        10   2045-05-15\n        11   2050-08-15\n        12   2055-05-15\n        13   2060-08-15\n        dtype: datetime64[ns]\n\n    \"\"\"\n    df_rates = data(date)\n    s_maturities = df_rates[\"MaturityDate\"]\n    s_maturities.name = None\n    return s_maturities\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a given date and the maturity date. The dates are inclusive. Coupon payments are made on the 15th of February, May, August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date (exlusive) to start generating the coupon dates.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series of coupon dates within the specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n0   2024-05-15\n1   2024-11-15\n2   2025-05-15\ndtype: datetime64[ns]\n</code></pre> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def payment_dates(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a given date and the maturity date.\n    The dates are inclusive. Coupon payments are made on the 15th of February, May,\n    August, and November (15-02, 15-05, 15-08, and 15-11 of each year). The NTN-B\n    bond is determined by its maturity date.\n\n    Args:\n        settlement (DateScalar): The settlement date (exlusive) to start generating\n            the coupon dates.\n        maturity (DateScalar): The maturity date.\n\n    Returns:\n        pd.Series: Series of coupon dates within the specified range.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.payment_dates(\"10-05-2024\", \"15-05-2025\")\n        0   2024-05-15\n        1   2024-11-15\n        2   2025-05-15\n        dtype: datetime64[ns]\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt; settlement:\n        raise ValueError(\"Maturity date must be after the start date.\")\n\n    # Initialize loop variables\n    coupon_dates = maturity\n    cp_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_dates &gt; settlement:\n        cp_dates.append(coupon_dates)\n        # Move the coupon date back 6 months\n        coupon_dates -= pd.DateOffset(months=6)\n\n    return pd.Series(cp_dates).sort_values(ignore_index=True)\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.price","title":"<code>price(vna, quotation)</code>","text":"<p>Calculate the NTN-B price using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>vna</code> <code>float</code> <p>The nominal value of the NTN-B bond.</p> required <code>quotation</code> <code>float</code> <p>The NTN-B quotation in base 100.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B price truncated to 6 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.price(4299.160173, 99.3651)\n4271.864805\n&gt;&gt;&gt; yd.ntnb.price(4315.498383, 100.6409)\n4343.156412\n</code></pre> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def price(\n    vna: float,\n    quotation: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B price using Anbima rules.\n\n    Args:\n        vna (float): The nominal value of the NTN-B bond.\n        quotation (float): The NTN-B quotation in base 100.\n\n    Returns:\n        float: The NTN-B price truncated to 6 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.price(4299.160173, 99.3651)\n        4271.864805\n        &gt;&gt;&gt; yd.ntnb.price(4315.498383, 100.6409)\n        4343.156412\n    \"\"\"\n    return bt.truncate(vna * quotation / 100, 6)\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.quotation","title":"<code>quotation(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-B quotation in base 100 using Anbima rules.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date of the operation.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-B bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate used to calculate the present value of the cash flows, which is the yield to maturity (YTM) of the NTN-B.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-B quotation truncated to 4 decimal places.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 2.956301, which represents a 6% annual   coupon rate compounded semi-annually and rounded to 6 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n99.3651\n&gt;&gt;&gt; yd.ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n99.5341\n&gt;&gt;&gt; yd.ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n100.6409\n</code></pre> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def quotation(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-B quotation in base 100 using Anbima rules.\n\n    Args:\n        settlement (DateScalar): The settlement date of the operation.\n        maturity (DateScalar): The maturity date of the NTN-B bond.\n        rate (float): The discount rate used to calculate the present value of\n            the cash flows, which is the yield to maturity (YTM) of the NTN-B.\n\n    Returns:\n        float: The NTN-B quotation truncated to 4 decimal places.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 2.956301, which represents a 6% annual\n          coupon rate compounded semi-annually and rounded to 6 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnb.quotation(\"31-05-2024\", \"15-05-2035\", 0.061490)\n        99.3651\n        &gt;&gt;&gt; yd.ntnb.quotation(\"31-05-2024\", \"15-08-2060\", 0.061878)\n        99.5341\n        &gt;&gt;&gt; yd.ntnb.quotation(\"15-08-2024\", \"15-08-2032\", 0.05929)\n        100.6409\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    cf_df = cash_flows(settlement, maturity)\n    cf_dates = cf_df[\"PaymentDate\"]\n    cf_values = cf_df[\"CashFlow\"]\n\n    # Calculate the number of business days between settlement and cash flow dates\n    bdays = bday.count(settlement, cf_dates)\n\n    # Calculate the number of periods truncated as per Anbima rules\n    num_of_years = bt.truncate(bdays / 252, 14)\n\n    discount_factor = (1 + rate) ** num_of_years\n\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    cf_present_value = (cf_values / discount_factor).round(10)\n\n    # Return the quotation (the dcf sum) truncated as per Anbima rules\n    return bt.truncate(cf_present_value.sum(), 4)\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.spot_rates","title":"<code>spot_rates(settlement, maturities, rates, show_coupons=False)</code>","text":"<p>Calculate the spot rates for NTN-B bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The reference date for settlement.</p> required <code>maturities</code> <code>Series</code> <p>Series of maturity dates for the bonds.</p> required <code>rates</code> <code>Series</code> <p>Series of yield to maturity rates.</p> required <code>show_coupons</code> <code>bool</code> <p>If True, the result will include the intermediate coupon dates. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".</p> <p>Examples:</p>"},{"location":"ntnb/#pyield.tpf.ntnb.spot_rates--get-the-ntn-b-rates-for-a-specific-reference-date","title":"Get the NTN-B rates for a specific reference date","text":"<pre><code>&gt;&gt;&gt; df = yd.ntnb.data(\"16-08-2024\")\n</code></pre>"},{"location":"ntnb/#pyield.tpf.ntnb.spot_rates--calculate-the-spot-rates-considering-the-settlement-at-the-reference-date","title":"Calculate the spot rates considering the settlement at the reference date","text":"<pre><code>&gt;&gt;&gt; yd.ntnb.spot_rates(\n...     settlement=\"16-08-2024\",\n...     maturities=df[\"MaturityDate\"],\n...     rates=df[\"IndicativeRate\"],\n... )\n   MaturityDate  BDToMat  SpotRate\n0    2025-05-15      185  0.063894\n1    2026-08-15      502  0.066141\n2    2027-05-15      687  0.064087\n3    2028-08-15     1002  0.063057\n4    2029-05-15     1186  0.061458\n5    2030-08-15     1500  0.059491\n6    2032-08-15     2004  0.059652\n7    2033-05-15     2191  0.059497\n8    2035-05-15     2690  0.059151\n9    2040-08-15     4009  0.058326\n10   2045-05-15     5196  0.060371\n11   2050-08-15     6511  0.060772\n12   2055-05-15     7700  0.059909\n13   2060-08-15     9017  0.060652\n</code></pre> Notes <p>The calculation of the spot rates for NTN-B bonds considers the following steps:     - Map all all possible payment dates up to the longest maturity date.     - Interpolate the YTM rates in the intermediate payment dates.     - Calculate the NTN-B quotation for each maturity date.     - Calculate the real spot rates for each maturity date.     - Columns in the returned DataFrame:         - MaturityDate: The maturity date of the bond.         - BDToMat: The number of business days from settlement to maturities.         - SpotRate: The real spot rate for the bond.</p> Source code in <code>pyield/tpf/ntnb.py</code> <pre><code>def spot_rates(\n    settlement: DateScalar,\n    maturities: pd.Series,\n    rates: pd.Series,\n    show_coupons: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the spot rates for NTN-B bonds using the bootstrap method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price.\n\n    Args:\n        settlement (DateScalar): The reference date for settlement.\n        maturities (pd.Series): Series of maturity dates for the bonds.\n        rates (pd.Series): Series of yield to maturity rates.\n        show_coupons (bool, optional): If True, the result will include the\n            intermediate coupon dates. Defaults to False.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\", \"SpotRate\".\n\n    Examples:\n        # Get the NTN-B rates for a specific reference date\n        &gt;&gt;&gt; df = yd.ntnb.data(\"16-08-2024\")\n\n        # Calculate the spot rates considering the settlement at the reference date\n        &gt;&gt;&gt; yd.ntnb.spot_rates(\n        ...     settlement=\"16-08-2024\",\n        ...     maturities=df[\"MaturityDate\"],\n        ...     rates=df[\"IndicativeRate\"],\n        ... )\n           MaturityDate  BDToMat  SpotRate\n        0    2025-05-15      185  0.063894\n        1    2026-08-15      502  0.066141\n        2    2027-05-15      687  0.064087\n        3    2028-08-15     1002  0.063057\n        4    2029-05-15     1186  0.061458\n        5    2030-08-15     1500  0.059491\n        6    2032-08-15     2004  0.059652\n        7    2033-05-15     2191  0.059497\n        8    2035-05-15     2690  0.059151\n        9    2040-08-15     4009  0.058326\n        10   2045-05-15     5196  0.060371\n        11   2050-08-15     6511  0.060772\n        12   2055-05-15     7700  0.059909\n        13   2060-08-15     9017  0.060652\n\n    Notes:\n        The calculation of the spot rates for NTN-B bonds considers the following steps:\n            - Map all all possible payment dates up to the longest maturity date.\n            - Interpolate the YTM rates in the intermediate payment dates.\n            - Calculate the NTN-B quotation for each maturity date.\n            - Calculate the real spot rates for each maturity date.\n            - Columns in the returned DataFrame:\n                - MaturityDate: The maturity date of the bond.\n                - BDToMat: The number of business days from settlement to maturities.\n                - SpotRate: The real spot rate for the bond.\n    \"\"\"\n    # Process and validate the input data\n    settlement = dc.convert_input_dates(settlement)\n    maturities = pd.to_datetime(maturities, errors=\"raise\", dayfirst=True)\n\n    # Create the interpolator to calculate the YTM rates for intermediate dates\n    ff_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, maturities),\n        known_rates=rates,\n    )\n\n    # Generate coupon dates up to the longest maturity date\n    all_coupon_dates = _generate_all_coupon_dates(\n        start=settlement, end=maturities.max()\n    )\n\n    # Create a DataFrame with all coupon dates and the corresponding YTM\n    df = pd.DataFrame(data=all_coupon_dates, columns=[\"MaturityDate\"])\n    df[\"BDToMat\"] = bday.count(settlement, df[\"MaturityDate\"])\n    df[\"BYears\"] = df[\"BDToMat\"] / 252\n    df[\"YTM\"] = df[\"BDToMat\"].apply(ff_interpolator)\n    df[\"Coupon\"] = COUPON_PMT\n    df[\"SpotRate\"] = np.nan\n\n    # The Bootstrap loop to calculate spot rates\n    for index, row in df.iterrows():\n        # Get the cash flow dates for the bond\n        cf_dates = payment_dates(settlement, row[\"MaturityDate\"])\n\n        # If there is only one cash flow date, it means the bond is a single payment\n        # bond, so the spot rate is equal to the YTM rate\n        if len(cf_dates) == 1:\n            df.at[index, \"SpotRate\"] = row[\"YTM\"]\n            continue\n\n        # Calculate the present value of the cash flows without last payment\n        cf_dates = cf_dates[:-1]\n        cf_df = df.query(\"MaturityDate in @cf_dates\").reset_index(drop=True)\n        cf_present_value = bt.calculate_present_value(\n            cash_flows=cf_df[\"Coupon\"],\n            rates=cf_df[\"SpotRate\"],\n            periods=cf_df[\"BYears\"],\n        )\n\n        # Calculate the Spot Rate for the bond\n        bond_price = quotation(settlement, row[\"MaturityDate\"], row[\"YTM\"])\n        price_factor = FINAL_PMT / (bond_price - cf_present_value)\n        df.at[index, \"SpotRate\"] = price_factor ** (1 / row[\"BYears\"]) - 1\n\n    df = df[[\"MaturityDate\", \"BDToMat\", \"SpotRate\"]].copy()\n    # Force Float64 type in float columns to standardize the output\n    df[\"SpotRate\"] = df[\"SpotRate\"].astype(\"Float64\")\n\n    # Filter the result without the intermediate coupon dates (virtual bonds)\n    if not show_coupons:\n        df = df.query(\"MaturityDate in @maturities\").reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"ntnf/","title":"NTN-F","text":""},{"location":"ntnf/#pyield.tpf.ntnf._check_maturity_date","title":"<code>_check_maturity_date(maturity)</code>","text":"<p>Check if the maturity date is a valid NTN-F maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>maturity</code> <code>Timestamp</code> <p>The maturity date to be checked.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the maturity date is not the 1st of January.</p> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def _check_maturity_date(maturity: pd.Timestamp) -&gt; None:\n    \"\"\"\n    Check if the maturity date is a valid NTN-F maturity date.\n\n    Args:\n        maturity (pd.Timestamp): The maturity date to be checked.\n\n    Raises:\n        ValueError: If the maturity date is not the 1st of January.\n    \"\"\"\n    if maturity.day != 1 or maturity.month not in COUPON_MONTHS:\n        raise ValueError(\"NTN-F maturity date must be the 1st of January.\")\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf._solve_spread","title":"<code>_solve_spread(price_difference_func, initial_guess=None)</code>","text":"<p>Solve for the spread that zeroes the price difference using a bisection method.</p> <p>Parameters:</p> Name Type Description Default <code>price_difference_func</code> <code>callable</code> <p>The function that computes the difference between the bond's market price and its discounted cash flows.</p> required <code>initial_guess</code> <code>float</code> <p>An initial guess for the spread.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The solution for the spread in bps or NaN if no solution is found.</p> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def _solve_spread(\n    price_difference_func: Callable,\n    initial_guess: float | None = None,\n) -&gt; float:\n    \"\"\"\n    Solve for the spread that zeroes the price difference using a bisection method.\n\n    Args:\n        price_difference_func (callable): The function that computes the difference\n            between the bond's market price and its discounted cash flows.\n        initial_guess (float, optional): An initial guess for the spread.\n\n    Returns:\n        float: The solution for the spread in bps or NaN if no solution is found.\n    \"\"\"\n    try:\n        if initial_guess is not None:\n            # range_width_bps below the initial guess\n            a = initial_guess - 0.005  # 50 bps\n            # range_width_bps above the initial guess\n            b = initial_guess + 0.005  # 50 bps\n        else:\n            a = -0.01  # Initial guess of -100 bps\n            b = 0.01  # Initial guess of 100 bps\n\n        # Find the spread (p) that zeroes the price difference\n        p_solution = _bisection_method(price_difference_func, a, b)\n    except ValueError:\n        # If no solution is found, return NaN\n        p_solution = float(\"NaN\")\n\n    return p_solution\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.cash_flows","title":"<code>cash_flows(settlement, maturity, adj_payment_dates=False)</code>","text":"<p>Generate the cash flows for the NTN-F bond between the settlement (exclusive) and maturity dates (inclusive). The cash flows are the coupon payments and the final payment at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The date (exclusive) for starting the cash flows.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>adj_payment_dates</code> <code>bool</code> <p>If True, adjust the payment dates to the next business day.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.cash_flows(\"15-05-2024\", \"01-01-2025\")\n  PaymentDate    CashFlow\n0  2024-07-01    48.80885\n1  2025-01-01  1048.80885\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def cash_flows(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    adj_payment_dates: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate the cash flows for the NTN-F bond between the settlement (exclusive) and\n    maturity dates (inclusive). The cash flows are the coupon payments and the final\n    payment at maturity.\n\n    Args:\n        settlement (DateScalar): The date (exclusive) for starting the cash flows.\n        maturity (DateScalar): The maturity date of the bond.\n        adj_payment_dates (bool): If True, adjust the payment dates to the next\n            business day.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"PaymentDate\" and \"CashFlow\".\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnf.cash_flows(\"15-05-2024\", \"01-01-2025\")\n          PaymentDate    CashFlow\n        0  2024-07-01    48.80885\n        1  2025-01-01  1048.80885\n    \"\"\"\n    # Validate input dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n    _check_maturity_date(maturity)\n\n    # Get the coupon payment dates between the settlement and maturity dates\n    pay_dates = payment_dates(settlement, maturity)\n\n    # Set the cash flow at maturity to FINAL_PMT and the others to COUPON_PMT\n    cf_values = np.where(pay_dates == maturity, FINAL_PMT, COUPON_PMT)\n\n    df = pd.DataFrame(data={\"PaymentDate\": pay_dates, \"CashFlow\": cf_values})\n\n    if adj_payment_dates:\n        df[\"PaymentDate\"] = bday.offset(df[\"PaymentDate\"], 0)\n\n    return df\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.data","title":"<code>data(date)</code>","text":"<p>Fetch the bond indicative rates for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.data(\"23-08-2024\")\n  ReferenceDate BondType MaturityDate  IndicativeRate        Price\n0    2024-08-23    NTN-F   2025-01-01        0.107692  1011.189166\n1    2024-08-23    NTN-F   2027-01-01        0.115109   985.834842\n2    2024-08-23    NTN-F   2029-01-01        0.116337   964.126325\n3    2024-08-23    NTN-F   2031-01-01        0.117008   945.416939\n4    2024-08-23    NTN-F   2033-01-01        0.116307   934.776692\n5    2024-08-23    NTN-F   2035-01-01        0.116586   923.239406\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def data(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch the bond indicative rates for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\" and \"IndicativeRate\".\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnf.data(\"23-08-2024\")\n          ReferenceDate BondType MaturityDate  IndicativeRate        Price\n        0    2024-08-23    NTN-F   2025-01-01        0.107692  1011.189166\n        1    2024-08-23    NTN-F   2027-01-01        0.115109   985.834842\n        2    2024-08-23    NTN-F   2029-01-01        0.116337   964.126325\n        3    2024-08-23    NTN-F   2031-01-01        0.117008   945.416939\n        4    2024-08-23    NTN-F   2033-01-01        0.116307   934.776692\n        5    2024-08-23    NTN-F   2035-01-01        0.116586   923.239406\n    \"\"\"\n    return anbima.tpf_data(date, \"NTN-F\")\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.di_net_spread","title":"<code>di_net_spread(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates, initial_guess=None)</code>","text":"<p>Calculate the net DI spread for a bond given the YTM and the DI rates.</p> <p>This function determines the spread over the DI curve that equates the present value of the bond's cash flows to its market price. It interpolates the DI rates to match the bond's cash flow payment dates and uses the Brent method to find the spread (in bps) that zeroes the difference between the bond's market price and its discounted cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the spread.</p> required <code>ntnf_maturity</code> <code>DateScalar</code> <p>The bond maturity date.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the bond.</p> required <code>di_rates</code> <code>Series</code> <p>A Series of DI rates.</p> required <code>di_expirations</code> <code>Series</code> <p>A list or Series of DI expiration dates.</p> required <code>initial_guess</code> <code>float</code> <p>An initial guess for the spread. Defaults to None. A good initial guess is the DI gross spread for the bond.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The net DI spread in basis points.</p> <p>Examples:</p>"},{"location":"ntnf/#pyield.tpf.ntnf.di_net_spread--obs-only-some-of-the-di-rates-will-be-used-in-the-example","title":"Obs: only some of the DI rates will be used in the example.","text":"<pre><code>&gt;&gt;&gt; exp_dates = pd.to_datetime([\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"])\n&gt;&gt;&gt; di_rates = pd.Series([0.10823, 0.11594, 0.11531])\n&gt;&gt;&gt; di_net_spread(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n12.13\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def di_net_spread(  # noqa\n    settlement: DateScalar,\n    ntnf_maturity: DateScalar,\n    ntnf_rate: float,\n    di_expirations: pd.Series,\n    di_rates: pd.Series,\n    initial_guess: float | None = None,\n) -&gt; float:\n    \"\"\"\n    Calculate the net DI spread for a bond given the YTM and the DI rates.\n\n    This function determines the spread over the DI curve that equates the present value\n    of the bond's cash flows to its market price. It interpolates the DI rates to match\n    the bond's cash flow payment dates and uses the Brent method to find the spread\n    (in bps) that zeroes the difference between the bond's market price and its\n    discounted cash flows.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the spread.\n        ntnf_maturity (DateScalar): The bond maturity date.\n        ntnf_rate (float): The yield to maturity (YTM) of the bond.\n        di_rates (pd.Series): A Series of DI rates.\n        di_expirations (pd.Series): A list or Series of DI expiration dates.\n        initial_guess (float, optional): An initial guess for the spread. Defaults to\n            None. A good initial guess is the DI gross spread for the bond.\n\n    Returns:\n        float: The net DI spread in basis points.\n\n    Examples:\n        # Obs: only some of the DI rates will be used in the example.\n        &gt;&gt;&gt; exp_dates = pd.to_datetime([\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"])\n        &gt;&gt;&gt; di_rates = pd.Series([0.10823, 0.11594, 0.11531])\n        &gt;&gt;&gt; di_net_spread(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        12.13\n    \"\"\"\n    # Create an interpolator for the DI rates using the flat-forward method\n    settlement = dc.convert_input_dates(settlement)\n    ntnf_maturity = dc.convert_input_dates(ntnf_maturity)\n\n    ff_interpolator = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    # Ensure the DI data is valid\n    if len(di_rates) != len(di_expirations):\n        raise ValueError(\"di_rates and di_expirations must have the same length.\")\n    if len(di_rates) == 0:\n        return float(\"NaN\")\n\n    # Calculate cash flows and business days between settlement and payment dates\n    df = cash_flows(settlement, ntnf_maturity).reset_index()\n    df[\"BDToMat\"] = bday.count(settlement, df[\"PaymentDate\"])\n\n    byears = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    di_interp = df[\"BDToMat\"].apply(ff_interpolator)\n    bond_price = price(settlement, ntnf_maturity, ntnf_rate)\n    bond_cash_flows = df[\"CashFlow\"]\n\n    def price_difference(p):\n        # Difference between the bond's price and its discounted cash flows\n        return (bond_cash_flows / (1 + di_interp + p) ** byears).sum() - bond_price\n\n    # Solve for the spread that zeroes the price difference using the bisection method\n    p_solution = _solve_spread(price_difference, initial_guess)\n    # Convert the solution to basis points (bps) and round to two decimal places\n    return round((p_solution * 10_000), 2)\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.di_spreads","title":"<code>di_spreads(date)</code>","text":"<p>Calculates the DI spread for the NTN-F based on ANBIMA's indicative rates.</p> <p>This function fetches the indicative rates for the NTN-F bonds and the DI futures rates and calculates the spread between these rates in basis points.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for the spread calculation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"MaturityDate\", \"DISpread\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.di_spreads(\"23-08-2024\")\n  MaturityDate  DISpread\n0   2025-01-01     -5.38\n1   2027-01-01      4.39\n2   2029-01-01      7.37\n3   2031-01-01     12.58\n4   2033-01-01      7.67\n5   2035-01-01     12.76\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def di_spreads(date: DateScalar) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the DI spread for the NTN-F based on ANBIMA's indicative rates.\n\n    This function fetches the indicative rates for the NTN-F bonds and the DI futures\n    rates and calculates the spread between these rates in basis points.\n\n    Parameters:\n        date (DateScalar): The reference date for the spread calculation.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"MaturityDate\", \"DISpread\".\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnf.di_spreads(\"23-08-2024\")\n          MaturityDate  DISpread\n        0   2025-01-01     -5.38\n        1   2027-01-01      4.39\n        2   2029-01-01      7.37\n        3   2031-01-01     12.58\n        4   2033-01-01      7.67\n        5   2035-01-01     12.76\n\n    \"\"\"\n    # Fetch DI Spreads for the reference date\n    df = tt.pre_spreads(date)\n    df = (\n        df.query(\"BondType == 'NTN-F'\")\n        .sort_values([\"MaturityDate\"])\n        .reset_index(drop=True)\n    )\n    return df[[\"MaturityDate\", \"DISpread\"]]\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.duration","title":"<code>duration(settlement, maturity, rate)</code>","text":"<p>Calculate the Macaulay duration for an NTN-F bond.</p> <p>The Macaulay duration is a weighted average of the times until each payment is received, with the weights proportional to the present value of the cash flows. It measures the bond's sensitivity to interest rate changes.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the duration.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The yield to maturity (YTM) used to discount the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Macaulay duration in years.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n6.32854218039796\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def duration(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the Macaulay duration for an NTN-F bond.\n\n    The Macaulay duration is a weighted average of the times until each payment is\n    received, with the weights proportional to the present value of the cash flows.\n    It measures the bond's sensitivity to interest rate changes.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the duration.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The yield to maturity (YTM) used to discount the cash flows.\n\n    Returns:\n        float: The Macaulay duration in years.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnf.duration(\"02-09-2024\", \"01-01-2035\", 0.121785)\n        6.32854218039796\n    \"\"\"\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    df = cash_flows(settlement, maturity)\n    df[\"BY\"] = bday.count(settlement, df[\"PaymentDate\"]) / 252\n    df[\"DCF\"] = df[\"CashFlow\"] / (1 + rate) ** df[\"BY\"]\n    np_duration = (df[\"DCF\"] * df[\"BY\"]).sum() / df[\"DCF\"].sum()\n    return float(np_duration)\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.maturities","title":"<code>maturities(date)</code>","text":"<p>Fetch the NTN-F bond maturities available for the given reference date.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>DateScalar</code> <p>The reference date for fetching the data.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series of NTN-F bond maturities available for the reference date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.maturities(\"23-08-2024\")\n0   2025-01-01\n1   2027-01-01\n2   2029-01-01\n3   2031-01-01\n4   2033-01-01\n5   2035-01-01\ndtype: datetime64[ns]\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def maturities(date: DateScalar) -&gt; pd.Series:\n    \"\"\"\n    Fetch the NTN-F bond maturities available for the given reference date.\n\n    Args:\n        date (DateScalar): The reference date for fetching the data.\n\n    Returns:\n        pd.Series: A Series of NTN-F bond maturities available for the reference date.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnf.maturities(\"23-08-2024\")\n        0   2025-01-01\n        1   2027-01-01\n        2   2029-01-01\n        3   2031-01-01\n        4   2033-01-01\n        5   2035-01-01\n        dtype: datetime64[ns]\n\n    \"\"\"\n    df_rates = data(date)\n    s_maturities = df_rates[\"MaturityDate\"]\n    s_maturities.name = None\n    return s_maturities\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.payment_dates","title":"<code>payment_dates(settlement, maturity)</code>","text":"<p>Generate all remaining coupon dates between a settlement date and a maturity date. The dates are exclusive for the settlement date and inclusive for the maturity date. Coupon payments are made on the 1st of January and July. The NTN-F bond is determined by its maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: A Series containing the coupon dates between the settlement (exclusive) and maturity (inclusive) dates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.payment_dates(\"15-05-2024\", \"01-01-2025\")\n0   2024-07-01\n1   2025-01-01\ndtype: datetime64[ns]\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def payment_dates(\n    settlement: DateScalar,\n    maturity: DateScalar,\n) -&gt; pd.Series:\n    \"\"\"\n    Generate all remaining coupon dates between a settlement date and a maturity date.\n    The dates are exclusive for the settlement date and inclusive for the maturity date.\n    Coupon payments are made on the 1st of January and July.\n    The NTN-F bond is determined by its maturity date.\n\n    Args:\n        settlement (DateScalar): The settlement date.\n        maturity (DateScalar): The maturity date.\n\n    Returns:\n        pd.Series: A Series containing the coupon dates between the settlement\n            (exclusive) and maturity (inclusive) dates.\n\n    Examples:\n\n        &gt;&gt;&gt; yd.ntnf.payment_dates(\"15-05-2024\", \"01-01-2025\")\n        0   2024-07-01\n        1   2025-01-01\n        dtype: datetime64[ns]\n    \"\"\"\n    # Validate and normalize dates\n    settlement = dc.convert_input_dates(settlement)\n    maturity = dc.convert_input_dates(maturity)\n\n    # Check if the maturity date is valid\n    _check_maturity_date(maturity)\n\n    # Check if maturity date is after the start date\n    if maturity &lt;= settlement:\n        raise ValueError(\"Maturity date must be after the settlement date.\")\n\n    # Initialize loop variables\n    coupon_date = maturity\n    coupon_dates = []\n\n    # Iterate backwards from the maturity date to the settlement date\n    while coupon_date &gt; settlement:\n        coupon_dates.append(coupon_date)\n        # Move the coupon date back 6 months\n        coupon_date -= pd.DateOffset(months=6)\n\n    # Return the coupon dates as a sorted Series\n    return pd.Series(coupon_dates).sort_values(ignore_index=True)\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.premium","title":"<code>premium(settlement, ntnf_maturity, ntnf_rate, di_expirations, di_rates)</code>","text":"<p>Calculate the premium of an NTN-F bond over DI rates.</p> <p>This function computes the premium of an NTN-F bond by comparing its implied discount factor with that of the DI curve. It determines the net premium based on the difference between the discount factors of the bond's yield-to-maturity (YTM) and the interpolated DI rates.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the premium.</p> required <code>ntnf_maturity</code> <code>DateScalar</code> <p>The maturity date of the NTN-F bond.</p> required <code>ntnf_rate</code> <code>float</code> <p>The yield to maturity (YTM) of the NTN-F bond.</p> required <code>di_expirations</code> <code>Series</code> <p>Series containing the expiration dates for DI rates.</p> required <code>di_rates</code> <code>Series</code> <p>Series containing the DI rates corresponding to the expiration dates.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The premium of the NTN-F bond over the DI curve, expressed as a</p> <code>float</code> <p>factor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Obs: only some of the DI rates will be used in the example.\n&gt;&gt;&gt; exp_dates = pd.to_datetime([\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"])\n&gt;&gt;&gt; di_rates = pd.Series([0.10823, 0.11594, 0.11531])\n&gt;&gt;&gt; premium(\n...     settlement=\"23-08-2024\",\n...     ntnf_maturity=\"01-01-2035\",\n...     ntnf_rate=0.116586,\n...     di_expirations=exp_dates,\n...     di_rates=di_rates,\n... )\n1.0099602136954626\n</code></pre> Notes <ul> <li>The function adjusts coupon payment dates to business days and calculates   the present value of cash flows for the NTN-F bond using DI rates.</li> </ul> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def premium(\n    settlement: DateScalar,\n    ntnf_maturity: DateScalar,\n    ntnf_rate: float,\n    di_expirations: pd.Series,\n    di_rates: pd.Series,\n) -&gt; float:\n    \"\"\"\n    Calculate the premium of an NTN-F bond over DI rates.\n\n    This function computes the premium of an NTN-F bond by comparing its implied\n    discount factor with that of the DI curve. It determines the net premium based\n    on the difference between the discount factors of the bond's yield-to-maturity\n    (YTM) and the interpolated DI rates.\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the premium.\n        ntnf_maturity (DateScalar): The maturity date of the NTN-F bond.\n        ntnf_rate (float): The yield to maturity (YTM) of the NTN-F bond.\n        di_expirations (pd.Series): Series containing the expiration dates for DI rates.\n        di_rates (pd.Series): Series containing the DI rates corresponding to\n            the expiration dates.\n\n    Returns:\n        float: The premium of the NTN-F bond over the DI curve, expressed as a\n        factor.\n\n    Examples:\n        &gt;&gt;&gt; # Obs: only some of the DI rates will be used in the example.\n        &gt;&gt;&gt; exp_dates = pd.to_datetime([\"2025-01-01\", \"2030-01-01\", \"2035-01-01\"])\n        &gt;&gt;&gt; di_rates = pd.Series([0.10823, 0.11594, 0.11531])\n        &gt;&gt;&gt; premium(\n        ...     settlement=\"23-08-2024\",\n        ...     ntnf_maturity=\"01-01-2035\",\n        ...     ntnf_rate=0.116586,\n        ...     di_expirations=exp_dates,\n        ...     di_rates=di_rates,\n        ... )\n        1.0099602136954626\n\n    Notes:\n        - The function adjusts coupon payment dates to business days and calculates\n          the present value of cash flows for the NTN-F bond using DI rates.\n\n    \"\"\"\n    ntnf_maturity = dc.convert_input_dates(ntnf_maturity)\n    settlement = dc.convert_input_dates(settlement)\n\n    df = cash_flows(settlement, ntnf_maturity, adj_payment_dates=True)\n    df[\"BDToMat\"] = bday.count(settlement, df[\"PaymentDate\"])\n    df[\"BYears\"] = df[\"BDToMat\"] / 252\n\n    ff_interpolator = ip.Interpolator(\n        \"flat_forward\",\n        bday.count(settlement, di_expirations),\n        di_rates,\n    )\n\n    df[\"DIRate\"] = df[\"BDToMat\"].apply(ff_interpolator)\n\n    # Calculate the present value of the cash flows using the DI rate\n    bond_price = tt.calculate_present_value(\n        cash_flows=df[\"CashFlow\"],\n        rates=df[\"DIRate\"],\n        periods=df[\"BDToMat\"] / 252,\n    )\n\n    # Calculate the rate corresponding to this price\n    def price_difference(ytm):\n        # The ytm that zeroes the price difference\n        return (df[\"CashFlow\"] / (1 + ytm) ** df[\"BYears\"]).sum() - bond_price\n\n    # Solve for the YTM that zeroes the price difference\n    di_ytm = _solve_spread(price_difference, ntnf_rate)\n\n    factor_ntnf = (1 + ntnf_rate) ** (1 / 252)\n    factor_di = (1 + di_ytm) ** (1 / 252)\n    premium_np = (factor_ntnf - 1) / (factor_di - 1)\n    return float(premium_np)\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.price","title":"<code>price(settlement, maturity, rate)</code>","text":"<p>Calculate the NTN-F price using Anbima rules, which corresponds to the present     value of the cash flows discounted at the given yield to maturity rate (YTM).</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date to calculate the price.</p> required <code>maturity</code> <code>DateScalar</code> <p>The maturity date of the bond.</p> required <code>rate</code> <code>float</code> <p>The discount rate (yield to maturity) used to calculate the present value of the cash flows.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The NTN-F price using Anbima rules.</p> References <ul> <li>https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf</li> <li>The semi-annual coupon is set to 48.81, which represents a 10% annual   coupon rate compounded semi-annually and rounded to 5 decimal places as per   Anbima rules.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; yd.ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n895.359254\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def price(\n    settlement: DateScalar,\n    maturity: DateScalar,\n    rate: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the NTN-F price using Anbima rules, which corresponds to the present\n        value of the cash flows discounted at the given yield to maturity rate (YTM).\n\n    Args:\n        settlement (DateScalar): The settlement date to calculate the price.\n        maturity (DateScalar): The maturity date of the bond.\n        rate (float): The discount rate (yield to maturity) used to calculate the\n            present value of the cash flows.\n\n    Returns:\n        float: The NTN-F price using Anbima rules.\n\n    References:\n        - https://www.anbima.com.br/data/files/A0/02/CC/70/8FEFC8104606BDC8B82BA2A8/Metodologias%20ANBIMA%20de%20Precificacao%20Titulos%20Publicos.pdf\n        - The semi-annual coupon is set to 48.81, which represents a 10% annual\n          coupon rate compounded semi-annually and rounded to 5 decimal places as per\n          Anbima rules.\n\n    Examples:\n        &gt;&gt;&gt; yd.ntnf.price(\"05-07-2024\", \"01-01-2035\", 0.11921)\n        895.359254\n    \"\"\"\n    cf_df = cash_flows(settlement, maturity)\n    cf_values = cf_df[\"CashFlow\"]\n    bdays = bday.count(settlement, cf_df[\"PaymentDate\"])\n    byears = tt.truncate(bdays / 252, 14)\n    discount_factors = (1 + rate) ** byears\n    # Calculate the present value of each cash flow (DCF) rounded as per Anbima rules\n    dcf = (cf_values / discount_factors).round(9)\n    # Return the sum of the discounted cash flows truncated as per Anbima rules\n    return tt.truncate(dcf.sum(), 6)\n</code></pre>"},{"location":"ntnf/#pyield.tpf.ntnf.spot_rates","title":"<code>spot_rates(settlement, ltn_maturities, ltn_rates, ntnf_maturities, ntnf_rates, show_coupons=False)</code>","text":"<p>Calculate the spot rates (zero coupon rates) for NTN-F bonds using the bootstrap method.</p> <p>The bootstrap method is a process used to determine spot rates from the yields of a series of bonds. It involves iteratively solving for the spot rates that discount each bond's cash flows to its current price. It uses the LTN rates, which are zero coupon bonds, up to the last LTN maturity available. For maturities after the last LTN maturity, it calculates the spot rates using the bootstrap method.</p> <p>Parameters:</p> Name Type Description Default <code>settlement</code> <code>DateScalar</code> <p>The settlement date for the spot rates calculation.</p> required <code>ltn_maturities</code> <code>Series</code> <p>The LTN known maturities.</p> required <code>ltn_rates</code> <code>Series</code> <p>The LTN known rates.</p> required <code>ntnf_maturities</code> <code>Series</code> <p>The NTN-F known maturities.</p> required <code>ntnf_rates</code> <code>Series</code> <p>The NTN-F known rates.</p> required <code>show_coupons</code> <code>bool</code> <p>If True, show also July rates corresponding to the coupon payments. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with columns \"BDToMat\", \"MaturityDate\" and \"SpotRate\". \"BDToMat\" is the business days from the settlement date to the maturities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df_ltn = yd.ltn.data(\"03-09-2024\")\n&gt;&gt;&gt; df_ntnf = yd.ntnf.data(\"03-09-2024\")\n&gt;&gt;&gt; yd.ntnf.spot_rates(\n...     settlement=\"03-09-2024\",\n...     ltn_maturities=df_ltn[\"MaturityDate\"],\n...     ltn_rates=df_ltn[\"IndicativeRate\"],\n...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n... )\n  MaturityDate  BDToMat  SpotRate\n0   2025-01-01       83  0.108837\n1   2027-01-01      584  0.119981\n2   2029-01-01     1083  0.122113\n3   2031-01-01     1584  0.122231\n4   2033-01-01     2088  0.121355\n5   2035-01-01     2587  0.121398\n</code></pre> Source code in <code>pyield/tpf/ntnf.py</code> <pre><code>def spot_rates(  # noqa\n    settlement: DateScalar,\n    ltn_maturities: pd.Series,\n    ltn_rates: pd.Series,\n    ntnf_maturities: pd.Series,\n    ntnf_rates: pd.Series,\n    show_coupons: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate the spot rates (zero coupon rates) for NTN-F bonds using the bootstrap\n    method.\n\n    The bootstrap method is a process used to determine spot rates from\n    the yields of a series of bonds. It involves iteratively solving for\n    the spot rates that discount each bond's cash flows to its current\n    price. It uses the LTN rates, which are zero coupon bonds, up to the\n    last LTN maturity available. For maturities after the last LTN maturity,\n    it calculates the spot rates using the bootstrap method.\n\n\n    Args:\n        settlement (DateScalar): The settlement date for the spot rates calculation.\n        ltn_maturities (pd.Series): The LTN known maturities.\n        ltn_rates (pd.Series): The LTN known rates.\n        ntnf_maturities (pd.Series): The NTN-F known maturities.\n        ntnf_rates (pd.Series): The NTN-F known rates.\n        show_coupons (bool): If True, show also July rates corresponding to the\n            coupon payments. Defaults to False.\n\n    Returns:\n        pd.DataFrame: DataFrame with columns \"BDToMat\", \"MaturityDate\" and \"SpotRate\".\n            \"BDToMat\" is the business days from the settlement date to the maturities.\n\n    Examples:\n        &gt;&gt;&gt; df_ltn = yd.ltn.data(\"03-09-2024\")\n        &gt;&gt;&gt; df_ntnf = yd.ntnf.data(\"03-09-2024\")\n        &gt;&gt;&gt; yd.ntnf.spot_rates(\n        ...     settlement=\"03-09-2024\",\n        ...     ltn_maturities=df_ltn[\"MaturityDate\"],\n        ...     ltn_rates=df_ltn[\"IndicativeRate\"],\n        ...     ntnf_maturities=df_ntnf[\"MaturityDate\"],\n        ...     ntnf_rates=df_ntnf[\"IndicativeRate\"],\n        ... )\n          MaturityDate  BDToMat  SpotRate\n        0   2025-01-01       83  0.108837\n        1   2027-01-01      584  0.119981\n        2   2029-01-01     1083  0.122113\n        3   2031-01-01     1584  0.122231\n        4   2033-01-01     2088  0.121355\n        5   2035-01-01     2587  0.121398\n    \"\"\"\n    # Process and validate the input data\n    settlement = dc.convert_input_dates(settlement)\n\n    # Create flat forward interpolators for LTN and NTN-F rates\n    ltn_rate_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ltn_maturities),\n        known_rates=ltn_rates,\n    )\n    ntnf_rate_interpolator = ip.Interpolator(\n        method=\"flat_forward\",\n        known_bdays=bday.count(settlement, ntnf_maturities),\n        known_rates=ntnf_rates,\n    )\n\n    # Generate all coupon dates up to the last NTN-F maturity date\n    all_coupon_dates = payment_dates(settlement, ntnf_maturities.max())\n\n    # Create a DataFrame with all coupon dates and the corresponding YTM\n    df = pd.DataFrame(data=all_coupon_dates, columns=[\"MaturityDate\"])\n    df[\"BDToMat\"] = bday.count(start=settlement, end=df[\"MaturityDate\"])\n    df[\"BYears\"] = df[\"BDToMat\"] / 252\n    df[\"Coupon\"] = COUPON_PMT\n    df[\"YTM\"] = df[\"BDToMat\"].apply(ntnf_rate_interpolator)\n\n    # The Bootstrap loop to calculate spot rates\n    for index, row in df.iterrows():\n        if row[\"MaturityDate\"] &lt;= ltn_maturities.max():\n            # Use LTN rates for maturities before the last LTN maturity date\n            df.at[index, \"SpotRate\"] = ltn_rate_interpolator(row[\"BDToMat\"])\n            continue\n\n        # Calculate the present value of the coupon payments\n        cf_dates = payment_dates(settlement, row[\"MaturityDate\"])[:-1]  # noqa\n        cf_df = df.query(\"MaturityDate in @cf_dates\").reset_index(drop=True)\n        cf_present_value = tt.calculate_present_value(\n            cash_flows=cf_df[\"Coupon\"],\n            rates=cf_df[\"SpotRate\"],\n            periods=cf_df[\"BDToMat\"] / 252,\n        )\n\n        bond_price = price(settlement, row[\"MaturityDate\"], row[\"YTM\"])\n        price_factor = FINAL_PMT / (bond_price - cf_present_value)\n        df.at[index, \"SpotRate\"] = price_factor ** (1 / row[\"BYears\"]) - 1\n\n    df = df[[\"MaturityDate\", \"BDToMat\", \"SpotRate\"]].copy()\n    df[\"SpotRate\"] = df[\"SpotRate\"].astype(\"Float64\")\n\n    if not show_coupons:\n        df = df.query(\"MaturityDate in @ntnf_maturities\").reset_index(drop=True)\n\n    return df\n</code></pre>"},{"location":"articles/pyield_intro/","title":"Introdu\u00e7\u00e3o a PYield","text":""},{"location":"articles/pyield_intro/#uma-biblioteca-em-python-para-obtecao-de-dados-de-instrumentos-de-renda-fixa-brasileira","title":"Uma biblioteca em Python para obte\u00e7\u00e3o de dados de instrumentos de Renda Fixa brasileira","text":"<p>Se voc\u00ea \u00e9 um entusiasta de VBA e Excel, pode pular esse artigo que aqui n\u00e3o \u00e9 lugar para voc\u00ea! Brincadeira, voc\u00ea \u00e9 bem-vindo tamb\u00e9m. Afinal, essa pode ser uma \u00f3tima desculpa para voc\u00ea finalmente aprender Python \ud83d\ude02</p> <p>Brincadeiras \u00e0 parte, qualquer um que trabalhe com an\u00e1lise de renda fixa no sabe que a obten\u00e7\u00e3o de dados de fontes como ANBIMA e B3 pode ser uma tarefa complicada. Outro ponto refere-se ao tratamento dos feriados e dias \u00fateis, um verdadeiro pesadelo para quem precisa calcular prazos e vencimentos, ainda mais depois que criaram um novo feriado nacional no final do ano passado. Sim, agora temos que considerar duas listas de feriados nacionais, uma para dados ateriores a 26-12-2023 e outra para depois.</p> <p>Claro que para os afortunados com acesso a servi\u00e7os pagos como Bloomberg, a obten\u00e7\u00e3o desse tipo de dados j\u00e1 \u00e9 bem f\u00e1cil. Mas para a maioria dos analistas financeiros, pesquisadores e entusiastas do mercado, a obten\u00e7\u00e3o e processamento desses dados pode ser um desafio. Afinal, voc\u00ea ter\u00e1 que lidar com chamadas para diversas APIs como a do IBGE, do BACEN, da ANBIMA, da B3, e por a\u00ed vai. Em alguns casos, o dado tem que ser extra\u00eddo diretamente de sites, o que pode ser ainda mais complicado.</p>"},{"location":"articles/pyield_intro/#o-que-e-pyield","title":"O que \u00e9 PYield?","text":"<p>A biblioteca Python foi projetada especificamente para a obten\u00e7\u00e3o e tratamento de dados de instrumentos de renda fixa. Ou seja, \u00e9 uma tentativa de  simplificar a obten\u00e7\u00e3o e processamento de dados de fontes prim\u00e1rias como ANBIMA e B3, fornecendo uma API de f\u00e1cil utiliza\u00e7\u00e3o.</p> <p>Utilizando a robustez de bibliotecas populares de Python, como Pandas, Requests e Numpy, PYield pode ser usada como backend de aplica\u00e7\u00f5es mais complexas, removendo a parte pesada relacionada a obten\u00e7\u00e3o e processamento de dados de fontes e formatos diversos.</p>"},{"location":"articles/pyield_intro/#caracteristicas-principais","title":"Caracter\u00edsticas Principais","text":"<ul> <li>Coleta de Dados: Obtenha dados diretamente de fontes prim\u00e1rias como ANBIMA e B3 de forma simples e r\u00e1pida.</li> <li>Processamento de Dados: Os dados s\u00e3o processados e entregues em formatos f\u00e1ceis de usar, como DataFrames do Pandas.</li> <li>Ferramentas de An\u00e1lise: Acesse fun\u00e7\u00f5es para tarefas comuns de an\u00e1lise do mercado de renda fixa, como c\u00e1lculos de dias \u00fateis e feriados.</li> </ul>"},{"location":"articles/pyield_intro/#como-instalar-o-pyield","title":"Como Instalar o PYield","text":"<p>A instala\u00e7\u00e3o do PYield \u00e9 r\u00e1pida e f\u00e1cil atrav\u00e9s do pip, o gerenciador de pacotes do Python. Basta abrir o terminal e executar o seguinte comando no seu ambiente virtual:</p> <p><pre><code>pip install pyield\n</code></pre> Este comando instala a \u00faltima vers\u00e3o do PYield, deixando voc\u00ea pronto para come\u00e7ar a utilizar a biblioteca em seus projetos.</p> <p>Exemplos Pr\u00e1ticos de Uso:</p>"},{"location":"articles/pyield_intro/#ferramentas-de-dias-uteis-feriados-brasileiros-sao-automaticamente-considerados","title":"Ferramentas de Dias \u00dateis (Feriados brasileiros s\u00e3o automaticamente considerados)","text":"<pre><code>&gt;&gt;&gt; import pyield as yd\n\n# Contar o n\u00famero de dias \u00fateis entre duas datas.\n# A data de in\u00edcio \u00e9 inclusiva, a data de t\u00e9rmino \u00e9 exclusiva.\n&gt;&gt;&gt; yd.bday.count(start='29-12-2023', end='02-01-2024')\n1\n\n# Obtenha o pr\u00f3ximo dia \u00fatil ap\u00f3s uma determinada data (offset=1).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=1)\nTimestamp('2024-01-02 00:00:00')\n\n# Obtenha o pr\u00f3ximo dia \u00fatil se n\u00e3o for um dia \u00fatil (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"30-12-2023\", offset=0)\nTimestamp('2024-01-02 00:00:00')\n\n# Como 2023-12-29 j\u00e1 \u00e9 um dia \u00fatil, a fun\u00e7\u00e3o retorna a mesma data (offset=0).\n&gt;&gt;&gt; yd.bday.offset(dates=\"29-12-2023\", offset=0)\nTimestamp('2023-12-29 00:00:00')\n\n# Gerar uma s\u00e9rie de dias \u00fateis entre duas datas.\n&gt;&gt;&gt; yd.bday.generate(start='2023-12-29', end='2024-01-03')\n0   2023-12-29\n1   2024-01-02\n2   2024-01-03\ndtype: datetime64[ns]\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-futuro-de-di","title":"Dados de Futuro de DI","text":"<pre><code># Obtenha um DataFrame com os dados dos Futuros de DI da B3 de uma data espec\u00edfica.\n&gt;&gt;&gt; yd.futures(contract_code=\"DI1\", date='2024-03-08')\n\nTradeDate  ExpirationCode ExpirationDate BDaysToExp  ... LastRate LastAskRate LastBidRate SettlementRate\n2024-03-08 J24            2024-04-01     15              ... 10.952   10.952      10.956      10.956\n2024-03-08 K24            2024-05-02     37              ... 10.776   10.774      10.780      10.777\n2024-03-08 M24            2024-06-03     58              ... 10.604   10.602      10.604      10.608\n...        ...            ...            ...             ... ...      ...         ...         ...\n2024-03-08 F37            2037-01-02     3213            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F38            2038-01-04     3462            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.859\n2024-03-08 F39            2039-01-03     3713            ... &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;        10.85\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-titulos-do-tesouro","title":"Dados de T\u00edtulos do Tesouro","text":"<pre><code># Obtenha um DataFrame com os dados dos t\u00edtulos NTN-B da ANBIMA.\n# Os dados da Anbima est\u00e3o dispon\u00edveis para os \u00faltimos 5 dias \u00fateis.\n# Obs: Para quem \u00e9 membro da Anbima, o acesso ao hist\u00f3rico \u00e9 liberado automaticamente pela biblioteca.\n&gt;&gt;&gt; yd.anbima(bond_type=\"NTN-B\", date='2024-04-12')\n\nBondType ReferenceDate MaturityDate BidRate AskRate IndicativeRate Price\nNTN-B    2024-04-12    2024-08-15   0.07540 0.07504 0.07523        4,271.43565\nNTN-B    2024-04-12    2025-05-15   0.05945 0.05913 0.05930        4,361.34391\nNTN-B    2024-04-12    2026-08-15   0.05927 0.05897 0.05910        4,301.40082\n...      ...           ...          ...     ...     ...            ...\nNTN-B    2024-04-12    2050-08-15   0.06039 0.06006 0.06023        4,299.28233\nNTN-B    2024-04-12    2055-05-15   0.06035 0.05998 0.06017        4,367.13360\nNTN-B    2024-04-12    2060-08-15   0.06057 0.06016 0.06036        4,292.26323\n</code></pre>"},{"location":"articles/pyield_intro/#calculo-de-spreads","title":"C\u00e1lculo de spreads","text":"<pre><code># Calcule o spread entre o futuro de DI e os t\u00edtulos pr\u00e9-fixados do Tesouro.\n&gt;&gt;&gt; yd.spreads(spread_type=\"DI_PRE\", date=\"2024-4-11\")\n\nBondType ReferenceDate MaturityDate  DISpread\nLTN      2024-04-11    2024-07-01    -20.28\nLTN      2024-04-11    2024-10-01    -10.19\nLTN      2024-04-11    2025-01-01    -15.05\n...      ...           ...           ...\nNTN-F    2024-04-11    2031-01-01    -0.66\nNTN-F    2024-04-11    2033-01-01    -5.69\nNTN-F    2024-04-11    2035-01-01    -1.27\n</code></pre>"},{"location":"articles/pyield_intro/#dados-de-indicadores","title":"Dados de Indicadores","text":"<pre><code># Obtenha a taxa SELIC meta do BCB em um determinado dia.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"SELIC\", date='2024-04-12')\n0.1075  # 10.75%\n\n# Obtenha a taxa mensal (Monthly Rate) do IPCA do IBGE com base no m\u00eas de refer\u00eancia da data.\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", date='2024-03-18')\n0.0016  # 0.16%\n\n# Se o indicador n\u00e3o estiver dispon\u00edvel para a data de refer\u00eancia, o retorno ser\u00e1 nulo (None).\n&gt;&gt;&gt; yd.indicator(indicator_code=\"IPCA_MR\", date='2030-04-10')\nNone\n</code></pre>"},{"location":"articles/pyield_intro/#conclusao","title":"Conclus\u00e3o","text":"<p>Se voc\u00ea precisa obter e tratar dados de renda fixa, PYield pode ser uma ferramenta valiosa nesse processo. Com uma API simples, o seu c\u00f3digo pode se tornar mais limpo e eficiente, permitindo que voc\u00ea se concentre na an\u00e1lise dos dados em vez de se preocupar com a obten\u00e7\u00e3o e processamento deles.</p> <p>O c\u00f3digo da biblioteca pode ser acessado em: PYield</p> <p>Quem quiser contribuir com o desenvolvimento da ferramenta entre em contato comigo: cr.cj@outlook.com</p>"}]}